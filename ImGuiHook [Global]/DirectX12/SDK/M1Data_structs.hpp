#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: M1Data

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Enum M1Data.EM1AuthResults
// NumValues: 0x0007
enum class EM1AuthResults : uint32
{
	Fail                                     = 0,
	Success                                  = 1,
	Reenter                                  = 2,
	ParticipateWithSuccess                   = 3,
	ParticipateWithFail                      = 4,
	ParticipateWithCrossPlayFail             = 5,
	EM1AuthResults_MAX                       = 6,
};

// Enum M1Data.EM1BlockUpdateType
// NumValues: 0x0004
enum class EM1BlockUpdateType : uint32
{
	Load                                     = 0,
	Add                                      = 1,
	Remove                                   = 2,
	EM1BlockUpdateType_MAX                   = 3,
};

// Enum M1Data.EM1FriendUpdateType
// NumValues: 0x0005
enum class EM1FriendUpdateType : uint32
{
	Load                                     = 0,
	Add                                      = 1,
	Remove                                   = 2,
	Update                                   = 3,
	EM1FriendUpdateType_MAX                  = 4,
};

// Enum M1Data.EM1InGameSocialOptionType
// NumValues: 0x0004
enum class EM1InGameSocialOptionType : uint32
{
	On                                       = 0,
	OnlyFriend                               = 1,
	Off                                      = 2,
	EM1InGameSocialOptionType_MAX            = 3,
};

// Enum M1Data.EM1AutomationTestAttr
// NumValues: 0x0006
enum class EM1AutomationTestAttr : uint32
{
	Str                                      = 0,
	Wis                                      = 1,
	Int                                      = 3,
	Dex                                      = 4,
	Con                                      = 5,
	EM1AutomationTestAttr_MAX                = 6,
};

// Enum M1Data.EM1DropContainerType
// NumValues: 0x0005
enum class EM1DropContainerType : uint8
{
	None                                     = 0,
	Item                                     = 1,
	MissionCollectibles                      = 2,
	MissionSupplies                          = 3,
	Max                                      = 4,
};

// Enum M1Data.EM1StatUIRecordType
// NumValues: 0x0006
enum class EM1StatUIRecordType : uint8
{
	Plus                                     = 0,
	Percent                                  = 1,
	Multiply                                 = 2,
	Meter                                    = 3,
	Second                                   = 4,
	EM1StatUIRecordType_MAX                  = 5,
};

// Enum M1Data.EM1SearchKeywordType
// NumValues: 0x0006
enum class EM1SearchKeywordType : uint8
{
	CharacterModule                          = 0,
	WeaponModule                             = 1,
	ResearchCharacter                        = 10,
	ResearchWeapon                           = 11,
	ResearchEnhance                          = 12,
	EM1SearchKeywordType_MAX                 = 13,
};

// Enum M1Data.EM1ProjectileAlignmentType
// NumValues: 0x0006
enum class EM1ProjectileAlignmentType : uint8
{
	None                                     = 0,
	Horizontal                               = 1,
	Vertical                                 = 2,
	Random                                   = 3,
	Range                                    = 4,
	EM1ProjectileAlignmentType_MAX           = 5,
};

// Enum M1Data.EM1EMonsterTagRateType
// NumValues: 0x0003
enum class EM1EMonsterTagRateType : uint8
{
	Ratio                                    = 0,
	Percent                                  = 1,
	EM1EMonsterTagRateType_MAX               = 2,
};

// Enum M1Data.EM1AITargetingType
// NumValues: 0x0005
enum class EM1AITargetingType : uint32
{
	CharacterFirst                           = 0,
	CharacterOnly                            = 1,
	ObjectFirst                              = 2,
	ObjectOnly                               = 3,
	EM1AITargetingType_MAX                   = 4,
};

// Enum M1Data.EM1AITargetingPriority
// NumValues: 0x0004
enum class EM1AITargetingPriority : uint32
{
	Closest                                  = 0,
	Farthest                                 = 1,
	Random                                   = 2,
	EM1AITargetingPriority_MAX               = 3,
};

// Enum M1Data.EM1MonsterAIPattern
// NumValues: 0x0003
enum class EM1MonsterAIPattern : uint8
{
	Normal                                   = 0,
	Named                                    = 1,
	EM1MonsterAIPattern_MAX                  = 2,
};

// Enum M1Data.EM1MonsterAIDataOverrideType
// NumValues: 0x0002
enum class EM1MonsterAIDataOverrideType : uint32
{
	VulgusPost                               = 0,
	EM1MonsterAIDataOverrideType_MAX         = 1,
};

// Enum M1Data.EM1ActionTargetType
// NumValues: 0x0004
enum class EM1ActionTargetType : uint8
{
	Primary                                  = 0,
	Secondary                                = 1,
	SubOrPrimary                             = 2,
	EM1ActionTargetType_MAX                  = 3,
};

// Enum M1Data.EM1ActionArmType
// NumValues: 0x0005
enum class EM1ActionArmType : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	Both                                     = 3,
	EM1ActionArmType_MAX                     = 4,
};

// Enum M1Data.EM1MonsterActionType
// NumValues: 0x0004
enum class EM1MonsterActionType : uint8
{
	None                                     = 0,
	Barrage                                  = 1,
	Single                                   = 2,
	EM1MonsterActionType_MAX                 = 3,
};

// Enum M1Data.EM1AreaType
// NumValues: 0x0005
enum class EM1AreaType : uint8
{
	Sphere                                   = 0,
	Cone                                     = 1,
	Box                                      = 2,
	Cylinder                                 = 3,
	EM1AreaType_MAX                          = 4,
};

// Enum M1Data.EM1NpcSpawnType
// NumValues: 0x0004
enum class EM1NpcSpawnType : uint8
{
	AlwaysSpawn                              = 0,
	QuestSpecificSpawn                       = 1,
	Replacement                              = 2,
	EM1NpcSpawnType_MAX                      = 3,
};

// Enum M1Data.EM1NpcServiceType
// NumValues: 0x0029
enum class EM1NpcServiceType : uint8
{
	None                                     = 0,
	BuyItem                                  = 1,
	SellItem                                 = 2,
	ChangeRuneSocketColor                    = 3,
	ChangeRuneSocketLink                     = 4,
	CustomizeItem                            = 5,
	UpgradeItem                              = 6,
	OpenWorldMap                             = 7,
	OpenLocalMap                             = 8,
	Mission                                  = 9,
	Research                                 = 10,
	Quest                                    = 11,
	CharacterReset                           = 12,
	RuneEnchant                              = 13,
	RuneDecompose                            = 14,
	MasteryRankUp                            = 15,
	RuneCompose                              = 16,
	Mail                                     = 17,
	VoidBattleNormal                         = 18,
	VoidBattleHard                           = 19,
	WorldMission                             = 20,
	ItemLevelUpgrade                         = 21,
	Warehouse                                = 22,
	PerkEnchant                              = 23,
	ReactorEnchant                           = 24,
	RangedWeaponRandomOptionChange           = 25,
	ReactorRandomOptionChange                = 26,
	RecordObject                             = 27,
	Laboratory                               = 28,
	LaboratoryOption                         = 29,
	LaboratoryMonsterAllClear                = 30,
	InstanceDungeon                          = 31,
	InstanceDungeonNormal                    = 32,
	InstanceDungeonHard                      = 33,
	MultiSupply                              = 34,
	OpenPopup                                = 35,
	EnterInstanceDungeon                     = 36,
	PaintExtract                             = 37,
	InvasionDungeon                          = 38,
	PlayCinematic                            = 39,
	EM1NpcServiceType_MAX                    = 40,
};

// Enum M1Data.EM1NpcSpawnConditionType
// NumValues: 0x0004
enum class EM1NpcSpawnConditionType : uint8
{
	None                                     = 0,
	QuestStart                               = 1,
	QuestComplete                            = 2,
	EM1NpcSpawnConditionType_MAX             = 3,
};

// Enum M1Data.EM1NpcServiceUnlockConditionType
// NumValues: 0x0005
enum class EM1NpcServiceUnlockConditionType : uint8
{
	None                                     = 0,
	CompleteQuest                            = 1,
	OwnQuest                                 = 2,
	EquipCharacter                           = 3,
	EM1NpcServiceUnlockConditionType_MAX     = 4,
};

// Enum M1Data.EM1DialogueType
// NumValues: 0x0005
enum class EM1DialogueType : uint8
{
	None                                     = 0,
	Mission                                  = 1,
	Quest                                    = 2,
	NpcDialogueScene                         = 3,
	EM1DialogueType_MAX                      = 4,
};

// Enum M1Data.EM1StatRefType
// NumValues: 0x0006
enum class EM1StatRefType : uint8
{
	None                                     = 0,
	SourceSnapshot                           = 1,
	SourceLinked                             = 2,
	TargetSnapshot                           = 3,
	TargetLinked                             = 4,
	EM1StatRefType_MAX                       = 5,
};

// Enum M1Data.EM1AbilityCreatedObjectRemovalPolicy
// NumValues: 0x0004
enum class EM1AbilityCreatedObjectRemovalPolicy : uint8
{
	DoNothing                                = 0,
	RemoveWithThisAbility                    = 1,
	RemoveWhenInstigatorIsInvalid            = 2,
	EM1AbilityCreatedObjectRemovalPolicy_MAX = 3,
};

// Enum M1Data.EM1StatusEffectStackDecreasePolicy
// NumValues: 0x0004
enum class EM1StatusEffectStackDecreasePolicy : uint8
{
	DoNothing                                = 0,
	WhenRemoveOtherSE                        = 1,
	WhenEndDuration                          = 2,
	EM1StatusEffectStackDecreasePolicy_MAX   = 3,
};

// Enum M1Data.EM1SkillType
// NumValues: 0x0004
enum class EM1SkillType : uint8
{
	None                                     = 0,
	Active                                   = 1,
	Passive                                  = 2,
	Max                                      = 3,
};

// Enum M1Data.EM1SkillArcheType
// NumValues: 0x0006
enum class EM1SkillArcheType : uint8
{
	None                                     = 0,
	Fusion                                   = 1,
	Singular                                 = 2,
	Dimension                                = 3,
	Tech                                     = 4,
	Max                                      = 5,
};

// Enum M1Data.EM1SkillInfoBenefitType
// NumValues: 0x0004
enum class EM1SkillInfoBenefitType : uint8
{
	None                                     = 0,
	Increase                                 = 1,
	Decrease                                 = 2,
	Max                                      = 3,
};

// Enum M1Data.EM1SkillInfoTextFormatType
// NumValues: 0x0004
enum class EM1SkillInfoTextFormatType : uint8
{
	None                                     = 0,
	Title                                    = 1,
	Annotation                               = 2,
	EM1SkillInfoTextFormatType_MAX           = 3,
};

// Enum M1Data.EM1StatusEffectAmassType
// NumValues: 0x0005
enum class EM1StatusEffectAmassType : uint8
{
	Replace                                  = 0,
	Preserve                                 = 1,
	StackReplace                             = 2,
	StackPreserve                            = 3,
	EM1StatusEffectAmassType_MAX             = 4,
};

// Enum M1Data.EM1ChattingTab
// NumValues: 0x0003
enum class EM1ChattingTab : uint8
{
	Tab_Normal                               = 0,
	Tab_World                                = 1,
	Tab_MAX                                  = 2,
};

// Enum M1Data.EM1ChattingBlockRule
// NumValues: 0x0004
enum class EM1ChattingBlockRule : uint8
{
	SystemDefault                            = 0,
	ChatDefault                              = 1,
	SocialMotion                             = 2,
	EM1ChattingBlockRule_MAX                 = 3,
};

// Enum M1Data.EM1CreditType
// NumValues: 0x0007
enum class EM1CreditType : uint8
{
	Title                                    = 0,
	Staff                                    = 1,
	Staff_Center                             = 2,
	Image                                    = 3,
	FreeText                                 = 4,
	Space                                    = 5,
	EM1CreditType_MAX                        = 6,
};

// Enum M1Data.EM1MissionTargetType
// NumValues: 0x000F
enum class EM1MissionTargetType : uint8
{
	None                                     = 255,
	Destruction                              = 0,
	Defense                                  = 1,
	Supply                                   = 2,
	Explosion                                = 3,
	DataCollection                           = 4,
	Escort                                   = 5,
	MultiCollection                          = 6,
	MultiAssassination                       = 7,
	Interaction                              = 8,
	DestructionIronHeart                     = 9,
	VoidFragment                             = 10,
	CompetitiveOccupation                    = 11,
	InstantDeathBarrier                      = 12,
	EM1MissionTargetType_MAX                 = 256,
};

// Enum M1Data.EM1InvasionArcheSymbolType
// NumValues: 0x0008
enum class EM1InvasionArcheSymbolType : uint8
{
	None                                     = 0,
	InvasionArche_1                          = 1,
	InvasionArche_2                          = 2,
	InvasionArche_3                          = 3,
	InvasionArche_4                          = 4,
	InvasionArche_5                          = 5,
	InvasionArche_6                          = 6,
	EM1InvasionArcheSymbolType_MAX           = 7,
};

// Enum M1Data.EM1ContentsPlatformType
// NumValues: 0x0005
enum class EM1ContentsPlatformType : uint8
{
	PS4                                      = 0,
	PS5                                      = 1,
	Xbox                                     = 2,
	Steam                                    = 3,
	Max                                      = 4,
};

// Enum M1Data.EM1RelationsCheckType
// NumValues: 0x0004
enum class EM1RelationsCheckType : uint8
{
	Both                                     = 0,
	OnlyEnemy                                = 1,
	OnlyAlly                                 = 2,
	EM1RelationsCheckType_MAX                = 3,
};

// Enum M1Data.EM1EquipmentCategoryType
// NumValues: 0x0009
enum class EM1EquipmentCategoryType : uint8
{
	None                                     = 0,
	RangedWeapon                             = 1,
	MeleeWeapon_Deleted                      = 2,
	Reactor                                  = 3,
	Necklace                                 = 4,
	Earrings                                 = 5,
	Ring                                     = 6,
	Bracelet                                 = 7,
	Max                                      = 8,
};

// Enum M1Data.EM1EquipItemClassType
// NumValues: 0x0014
enum class EM1EquipItemClassType : uint8
{
	None                                     = 0,
	WeaponHandGun                            = 1,
	WeaponHandCannon                         = 2,
	WeaponShotGun                            = 3,
	WeaponSubMachineGun                      = 4,
	WeaponMachineGun                         = 5,
	WeaponAssaultRifle                       = 6,
	WeaponTacticalRifle                      = 7,
	WeaponScoutRifle                         = 8,
	WeaponSniperRifle                        = 9,
	WeaponLauncher                           = 10,
	WeaponBow                                = 11,
	WeaponBeamRifle                          = 12,
	WeaponMelee_Deleted                      = 13,
	ArmorCloth                               = 14,
	ArmorLeather                             = 15,
	ArmorMetal                               = 16,
	WeaponSword                              = 17,
	WeaponBattleAxe                          = 18,
	EM1EquipItemClassType_MAX                = 19,
};

// Enum M1Data.EM1ItemTierType
// NumValues: 0x0006
enum class EM1ItemTierType : uint8
{
	None                                     = 0,
	Tier1                                    = 1,
	Tier2                                    = 2,
	Tier3                                    = 3,
	Tier4                                    = 4,
	Max                                      = 5,
};

// Enum M1Data.EM1ConsumableItemCategoryType
// NumValues: 0x000E
enum class EM1ConsumableItemCategoryType : uint8
{
	None                                     = 0,
	AmmoRecovery                             = 1,
	BuffItem                                 = 2,
	Material                                 = 3,
	CharacterTicket                          = 4,
	VoidVault                                = 5,
	MiniGameKey                              = 6,
	VoidPiece                                = 7,
	EnhancementItem                          = 8,
	VoidVaultStabilizer                      = 9,
	Bunch                                    = 10,
	PaintExtractMaterial                     = 11,
	KeyMaterial                              = 12,
	Max                                      = 13,
};

// Enum M1Data.EM1ConsumableItemHowToUse
// NumValues: 0x0005
enum class EM1ConsumableItemHowToUse : uint8
{
	None                                     = 0,
	Instantly                                = 1,
	ByInventory                              = 2,
	UseImmediately                           = 3,
	EM1ConsumableItemHowToUse_MAX            = 4,
};

// Enum M1Data.EM1ItemAcquireType
// NumValues: 0x0004
enum class EM1ItemAcquireType : uint8
{
	None                                     = 0,
	InGame                                   = 1,
	LimitedTime                              = 2,
	EM1ItemAcquireType_MAX                   = 3,
};

// Enum M1Data.EM1CurrencyType
// NumValues: 0x000A
enum class EM1CurrencyType : uint8
{
	None                                     = 0,
	Gold                                     = 1,
	BlueCash                                 = 2,
	BlackMana                                = 3,
	Qulipothium                              = 4,
	RedCash                                  = 5,
	BattleCoin                               = 6,
	PlatinumCoin                             = 7,
	BonusCoin                                = 8,
	Max                                      = 9,
};

// Enum M1Data.EM1RedeemType
// NumValues: 0x0004
enum class EM1RedeemType : uint8
{
	None                                     = 0,
	Decomposition                            = 1,
	Package                                  = 2,
	EM1RedeemType_MAX                        = 3,
};

// Enum M1Data.EM1BuffItemType
// NumValues: 0x0004
enum class EM1BuffItemType : uint8
{
	None                                     = 0,
	Boost                                    = 1,
	SlotExpansion                            = 2,
	EM1BuffItemType_MAX                      = 3,
};

// Enum M1Data.EM1CustomizingConditionType
// NumValues: 0x0005
enum class EM1CustomizingConditionType : uint8
{
	None                                     = 0,
	Character                                = 1,
	Weapon                                   = 2,
	All                                      = 3,
	EM1CustomizingConditionType_MAX          = 4,
};

// Enum M1Data.EM1CustomizingConditionSubType
// NumValues: 0x0006
enum class EM1CustomizingConditionSubType : uint8
{
	None                                     = 0,
	All                                      = 1,
	All_Male                                 = 2,
	All_Female                               = 3,
	Group                                    = 4,
	EM1CustomizingConditionSubType_MAX       = 5,
};

// Enum M1Data.EM1CustomizingCharacterSkinType
// NumValues: 0x0008
enum class EM1CustomizingCharacterSkinType : uint8
{
	None                                     = 0,
	Head                                     = 1,
	Body                                     = 2,
	BackAttachment                           = 3,
	ChestAttachment                          = 4,
	Makeup                                   = 5,
	Spawn                                    = 6,
	EM1CustomizingCharacterSkinType_MAX      = 7,
};

// Enum M1Data.EM1CustomizingBoundType
// NumValues: 0x0004
enum class EM1CustomizingBoundType : uint32
{
	None                                     = 0,
	Acquire                                  = 1,
	Equip                                    = 2,
	EM1CustomizingBoundType_MAX              = 3,
};

// Enum M1Data.EM1CharacterSize
// NumValues: 0x0007
enum class EM1CharacterSize : uint8
{
	Small                                    = 0,
	Medium                                   = 1,
	Big                                      = 2,
	Special                                  = 3,
	Special2                                 = 4,
	Special3                                 = 5,
	EM1CharacterSize_MAX                     = 6,
};

// Enum M1Data.EM1ItemOptionType
// NumValues: 0x0003
enum class EM1ItemOptionType : uint8
{
	None                                     = 0,
	Random                                   = 1,
	EM1ItemOptionType_MAX                    = 2,
};

// Enum M1Data.EM1JunkFilterCategory
// NumValues: 0x0004
enum class EM1JunkFilterCategory : uint8
{
	None                                     = 0,
	Reactor                                  = 1,
	Accessory                                = 2,
	EM1JunkFilterCategory_MAX                = 3,
};

// Enum M1Data.EM1CharacterGender
// NumValues: 0x0004
enum class EM1CharacterGender : uint8
{
	None                                     = 0,
	Female                                   = 1,
	Male                                     = 2,
	EM1CharacterGender_MAX                   = 3,
};

// Enum M1Data.EM1CharacterGrade
// NumValues: 0x0003
enum class EM1CharacterGrade : uint8
{
	Normal                                   = 0,
	Ultimate                                 = 1,
	EM1CharacterGrade_MAX                    = 2,
};

// Enum M1Data.EM1DropGroupType
// NumValues: 0x0008
enum class EM1DropGroupType : uint8
{
	None                                     = 0,
	Equipment                                = 1,
	Rune                                     = 2,
	Consumable                               = 3,
	Gold                                     = 4,
	Qulipothium                              = 5,
	Instant                                  = 6,
	EM1DropGroupType_MAX                     = 7,
};

// Enum M1Data.EM1WeaponInstanceType
// NumValues: 0x0004
enum class EM1WeaponInstanceType : uint8
{
	ItemWeapon                               = 0,
	AltWeapon                                = 1,
	PickupWeapon                             = 2,
	EM1WeaponInstanceType_MAX                = 3,
};

// Enum M1Data.EM1RoundsType
// NumValues: 0x0006
enum class EM1RoundsType : uint8
{
	None                                     = 0,
	GeneralRounds                            = 1,
	EnhancedRounds                           = 2,
	ImpactRounds                             = 3,
	HighpowerRounds                          = 4,
	EM1RoundsType_MAX                        = 5,
};

// Enum M1Data.EM1ReloadType
// NumValues: 0x0003
enum class EM1ReloadType : uint8
{
	Magazine                                 = 0,
	Rounds                                   = 1,
	EM1ReloadType_MAX                        = 2,
};

// Enum M1Data.EM1SpreadType
// NumValues: 0x0005
enum class EM1SpreadType : uint8
{
	None                                     = 0,
	Random                                   = 1,
	Division                                 = 2,
	CenterAndDivision                        = 3,
	EM1SpreadType_MAX                        = 4,
};

// Enum M1Data.EM1MonsterCategory
// NumValues: 0x0006
enum class EM1MonsterCategory : uint8
{
	Normal                                   = 0,
	Champion                                 = 1,
	Named                                    = 2,
	Boss                                     = 3,
	MissionTarget                            = 4,
	Max                                      = 5,
};

// Enum M1Data.EM1MonsterSpecialty
// NumValues: 0x0008
enum class EM1MonsterSpecialty : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Assault                                  = 2,
	Cower                                    = 3,
	Speeder                                  = 4,
	Defender                                 = 5,
	Hider                                    = 6,
	EM1MonsterSpecialty_MAX                  = 7,
};

// Enum M1Data.EM1LegionCategory
// NumValues: 0x0005
enum class EM1LegionCategory : uint8
{
	None                                     = 0,
	Darkness                                 = 1,
	Truth                                    = 2,
	Immortal                                 = 3,
	Max                                      = 4,
};

// Enum M1Data.EM1ItemOptionTierType
// NumValues: 0x0005
enum class EM1ItemOptionTierType : uint8
{
	None                                     = 0,
	Tier1                                    = 1,
	Tier2                                    = 2,
	Tier3                                    = 3,
	Max                                      = 4,
};

// Enum M1Data.EM1MonsterSubType
// NumValues: 0x0004
enum class EM1MonsterSubType : uint8
{
	Normal                                   = 0,
	Elite                                    = 1,
	Guide                                    = 2,
	EM1MonsterSubType_MAX                    = 3,
};

// Enum M1Data.EM1FieldObjectType
// NumValues: 0x0004
enum class EM1FieldObjectType : uint8
{
	None                                     = 0,
	Interaction                              = 1,
	Hit                                      = 2,
	EM1FieldObjectType_MAX                   = 3,
};

// Enum M1Data.EM1FieldObjectActivateType
// NumValues: 0x0005
enum class EM1FieldObjectActivateType : uint8
{
	None                                     = 0,
	DropItem                                 = 1,
	Explosion                                = 2,
	MiniGame                                 = 3,
	EM1FieldObjectActivateType_MAX           = 4,
};

// Enum M1Data.EM1EciveActionType
// NumValues: 0x0005
enum class EM1EciveActionType : uint8
{
	None                                     = 0,
	Marker                                   = 1,
	Sound                                    = 2,
	Monster                                  = 3,
	EM1EciveActionType_MAX                   = 4,
};

// Enum M1Data.EM1FieldObjectActivateConditionType
// NumValues: 0x0003
enum class EM1FieldObjectActivateConditionType : uint8
{
	None                                     = 0,
	Consumable                               = 1,
	EM1FieldObjectActivateConditionType_MAX  = 2,
};

// Enum M1Data.EM1DamageAdvantageType
// NumValues: 0x0005
enum class EM1DamageAdvantageType : uint8
{
	None                                     = 0,
	Burst                                    = 1,
	Crush                                    = 2,
	Piercing                                 = 3,
	EM1DamageAdvantageType_MAX               = 4,
};

// Enum M1Data.EM1ElementalDamageChannel
// NumValues: 0x0007
enum class EM1ElementalDamageChannel : uint8
{
	None                                     = 0,
	Plain                                    = 1,
	Blazer                                   = 2,
	Glacier                                  = 3,
	Electricity                              = 4,
	Demonic                                  = 5,
	Max                                      = 6,
};

// Enum M1Data.EM1ElementalDegreeType
// NumValues: 0x0007
enum class EM1ElementalDegreeType : uint8
{
	None                                     = 0,
	VeryWeak                                 = 1,
	Weak                                     = 2,
	Normal                                   = 3,
	Strong                                   = 4,
	VeryStrong                               = 5,
	EM1ElementalDegreeType_MAX               = 6,
};

// Enum M1Data.EM1MapType
// NumValues: 0x0007
enum class EM1MapType : uint8
{
	City                                     = 0,
	Field                                    = 1,
	Prologue                                 = 2,
	VoidBattle                               = 3,
	InstanceDungeon                          = 4,
	Laboratory                               = 5,
	EM1MapType_MAX                           = 6,
};

// Enum M1Data.EM1EntryPointUnlockType
// NumValues: 0x0004
enum class EM1EntryPointUnlockType : uint8
{
	None                                     = 0,
	BattleZone                               = 1,
	Overlap                                  = 2,
	EM1EntryPointUnlockType_MAX              = 3,
};

// Enum M1Data.EM1MapBattleZoneOpenConditionType
// NumValues: 0x0005
enum class EM1MapBattleZoneOpenConditionType : uint8
{
	Quest                                    = 0,
	Mission                                  = 1,
	FieldOpen                                = 2,
	BattleZone                               = 3,
	EM1MapBattleZoneOpenConditionType_MAX    = 4,
};

// Enum M1Data.EM1MapTargetType
// NumValues: 0x0004
enum class EM1MapTargetType : uint8
{
	Quest                                    = 0,
	Mission                                  = 1,
	VoidBattle                               = 2,
	EM1MapTargetType_MAX                     = 3,
};

// Enum M1Data.EM1MapGoalType
// NumValues: 0x0003
enum class EM1MapGoalType : uint8
{
	Battle                                   = 0,
	Field                                    = 1,
	EM1MapGoalType_MAX                       = 2,
};

// Enum M1Data.EM1ProductType
// NumValues: 0x0004
enum class EM1ProductType : uint8
{
	Common                                   = 0,
	Paid                                     = 1,
	Bundle                                   = 2,
	EM1ProductType_MAX                       = 3,
};

// Enum M1Data.EM1ShopCategoryType
// NumValues: 0x0010
enum class EM1ShopCategoryType : uint8
{
	None                                     = 0,
	Popular                                  = 1,
	BattlePass                               = 2,
	Character                                = 3,
	UltimateCharacter                        = 4,
	LimitedSkin                              = 5,
	PremiumSkin                              = 6,
	CharacterSkin                            = 7,
	CharacterMakeup                          = 8,
	CommonSkin                               = 9,
	Paint                                    = 10,
	Growth                                   = 11,
	Boost                                    = 12,
	Cash                                     = 13,
	Veiled                                   = 14,
	MAX                                      = 14,
};

// Enum M1Data.EM1ShopResetType
// NumValues: 0x0005
enum class EM1ShopResetType : uint8
{
	None                                     = 0,
	Daily                                    = 1,
	Weekly                                   = 2,
	Monthly                                  = 3,
	EM1ShopResetType_MAX                     = 4,
};

// Enum M1Data.EM1ShopType
// NumValues: 0x0003
enum class EM1ShopType : uint8
{
	Common                                   = 0,
	Paid                                     = 1,
	EM1ShopType_MAX                          = 2,
};

// Enum M1Data.EM1ImportanceType
// NumValues: 0x0005
enum class EM1ImportanceType : uint8
{
	None                                     = 0,
	Low                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	EM1ImportanceType_MAX                    = 4,
};

// Enum M1Data.EM1ResearchType
// NumValues: 0x0007
enum class EM1ResearchType : uint8
{
	None                                     = 0,
	Character                                = 1,
	Equipment                                = 2,
	CharacterMaterial                        = 3,
	EquipmentMaterial                        = 4,
	UpgradeMaterial                          = 5,
	Max                                      = 6,
};

// Enum M1Data.EM1PrerequisiteType
// NumValues: 0x0003
enum class EM1PrerequisiteType : uint8
{
	Field                                    = 0,
	BattleZone                               = 1,
	EM1PrerequisiteType_MAX                  = 2,
};

// Enum M1Data.EM1MissionRequiredActivateConditionType
// NumValues: 0x0004
enum class EM1MissionRequiredActivateConditionType : uint8
{
	None                                     = 0,
	VoidFragment                             = 1,
	VoidFusion                               = 2,
	EM1MissionRequiredActivateConditionType_MAX = 3,
};

// Enum M1Data.EM1MissionRewardsEvaluateConditionType
// NumValues: 0x0005
enum class EM1MissionRewardsEvaluateConditionType : uint8
{
	None                                     = 0,
	VoidFragment                             = 1,
	VoidFusion                               = 2,
	DestructionVulgusPost                    = 3,
	EM1MissionRewardsEvaluateConditionType_MAX = 4,
};

// Enum M1Data.EM1MissionCategory
// NumValues: 0x000E
enum class EM1MissionCategory : uint8
{
	None                                     = 0,
	Prologue                                 = 1,
	BaseMission                              = 2,
	DungeonField                             = 3,
	RouteMission                             = 4,
	BlockWorld                               = 5,
	DefenseWorld                             = 6,
	ResearchWorld                            = 7,
	VoidFragmentField                        = 8,
	VoidFusionField                          = 9,
	RepeatMission6                           = 10,
	VulgusPostField                          = 11,
	Invasion                                 = 12,
	EM1MissionCategory_MAX                   = 13,
};

// Enum M1Data.EM1QuestStartPointType
// NumValues: 0x0004
enum class EM1QuestStartPointType : uint8
{
	None                                     = 0,
	EnterField                               = 1,
	InteractNpc                              = 2,
	EM1QuestStartPointType_MAX               = 3,
};

// Enum M1Data.EM1QuestStartConditionType
// NumValues: 0x0016
enum class EM1QuestStartConditionType : uint8
{
	None                                     = 0,
	CompleteQuest                            = 1,
	OwnRangedWeapon                          = 2,
	OwnAccessory                             = 3,
	OwnConsumable                            = 4,
	OwnCurrency                              = 5,
	OwnRune                                  = 6,
	EquipRangedWeapon                        = 7,
	EquipAccessory                           = 8,
	EquipRune                                = 9,
	CharacterLevel                           = 10,
	MasteryRank                              = 11,
	BattleZoneProgressValue                  = 12,
	OwnReactor                               = 13,
	EquipReactor                             = 14,
	CanMasteryRankUp                         = 15,
	EquipCustomizing                         = 16,
	OwnRecord                                = 17,
	OwnPlayer                                = 18,
	EquipCharacter                           = 19,
	InSeason                                 = 20,
	EM1QuestStartConditionType_MAX           = 21,
};

// Enum M1Data.EM1CompleteConditionType
// NumValues: 0x0078
enum class EM1CompleteConditionType : uint8
{
	None                                     = 0,
	CompleteQuest                            = 1,
	SucceedMission                           = 2,
	KillMonster                              = 3,
	InteractNpc                              = 4,
	EnterField                               = 5,
	MasteryRank                              = 6,
	GetRangedWeapon                          = 7,
	GetAccessory                             = 8,
	GetConsumable                            = 9,
	GetCurrency                              = 10,
	GetRune                                  = 11,
	OwnRangedWeapon                          = 12,
	OwnAccessory                             = 13,
	OwnConsumable                            = 14,
	OwnCurrency                              = 15,
	OwnRune                                  = 16,
	BuyRangedWeapon                          = 17,
	BuyAccessory                             = 18,
	BuyConsumable                            = 19,
	BuyRune                                  = 20,
	SellRangedWeapon                         = 21,
	SellAccessory                            = 22,
	SellConsumable                           = 23,
	SellRune                                 = 24,
	EquipRangedWeapon                        = 25,
	EquipAccessory                           = 26,
	EquipRune                                = 27,
	UseConsumable                            = 28,
	UseCurrency                              = 29,
	EnchantRune                              = 30,
	EnchantRuneLevel                         = 31,
	ComposeRune                              = 32,
	DecomposeRune                            = 33,
	RuneCapacityIncrease                     = 34,
	RuneSocketGrant                          = 35,
	RaidPlay                                 = 36,
	RaidSucceed                              = 37,
	DoParty                                  = 38,
	PartyMissionSucceed                      = 39,
	PartyRaidPlay                            = 40,
	PartyRaidSucceed                         = 41,
	ResearchComplete                         = 42,
	ResearchShorten                          = 43,
	CharacterLevel                           = 44,
	ChangeCharacter                          = 45,
	AllClearBattleZone                       = 46,
	RangedWeaponLevelUpgrade                 = 47,
	RangedWeaponPerkEnchant                  = 48,
	DecomposeRangedWeapon                    = 49,
	EpicMonsterDeboneSuccess                 = 50,
	OwnPlayer                                = 51,
	EnchantReactor                           = 52,
	GetReactor                               = 53,
	OwnReactor                               = 54,
	BuyReactor                               = 55,
	SellReactor                              = 56,
	EquipReactor                             = 57,
	DecomposeAccessory                       = 58,
	DecomposeReactor                         = 59,
	SucceedMissionWave                       = 60,
	PartySucceedMissionWave                  = 61,
	BattleZoneProgressValue                  = 62,
	MultiKillMonsterByWeapon                 = 63,
	MultiKillMonsterBySKill                  = 64,
	KillMonsterBySkill                       = 65,
	NotDamagedSucceedMission                 = 66,
	NotDamagedSucceedRaid                    = 67,
	TimeLimitRaidSucceed                     = 68,
	TimeLimitMissionSucceed                  = 69,
	EquipCharacter                           = 70,
	EquipCustomizing                         = 71,
	GiveSingleDamage                         = 72,
	GiveTotalDamage                          = 73,
	KillMonsterByWeapon                      = 74,
	KillMonsterByMelee                       = 75,
	KillMonsterByWeakness                    = 76,
	HitMonsterWeakness                       = 77,
	GiveTotalWeaponDamage                    = 78,
	GiveTotalSkillDamage                     = 79,
	GiveTotalMeleeDamage                     = 80,
	GiveTotalWeaknessDamage                  = 81,
	GiveTotalCriticalDamage                  = 82,
	TakeSingleDamage                         = 83,
	TakeTotalDamage                          = 84,
	RescuePlayer                             = 85,
	RescuedByPlayer                          = 86,
	PlayerDeath                              = 87,
	DestoryEpicMonsterParts                  = 88,
	GiveStatusEffect                         = 89,
	TakeStatusEffect                         = 90,
	GiveTotalHeal                            = 91,
	TakeTotalHeal                            = 92,
	CheckRecord                              = 93,
	RangedWeaponRandomOptionChange           = 94,
	AttackVoidFragment                       = 95,
	SucceedMiniGame                          = 96,
	RangedWeaponPerkEnchantTier              = 97,
	GainTotalCommonGauge                     = 98,
	StartDialog                              = 99,
	EndDialog                                = 100,
	OwnRecord                                = 101,
	SeasonLevel                              = 102,
	SucceedInvasionStop                      = 103,
	UnlockSeasonAbility                      = 104,
	InteractFieldObject                      = 105,
	HitFieldObject                           = 106,
	InteractNpcServiceType                   = 107,
	RangedWeaponIDProficiencyLevel           = 108,
	RangedWeaponsProficiencyLevel            = 109,
	GetCharacterExp                          = 110,
	UseSocialMotion                          = 111,
	KillMonsterByObject                      = 112,
	NoDBNOSucceedMission                     = 113,
	NoDBNOSucceedRaid                        = 114,
	TakeBarrierDamage                        = 115,
	MultiCharacterMaxLevel                   = 116,
	RangedWeaponIDPerkEnchantLevel           = 117,
	RangedWeaponsPerkEnchantLevel            = 118,
	EM1CompleteConditionType_MAX             = 119,
};

// Enum M1Data.EM1QuestSubConditionType
// NumValues: 0x000F
enum class EM1QuestSubConditionType : uint8
{
	None                                     = 0,
	EquipRangedWeaponClassType               = 1,
	EquipRangedWeaponId                      = 2,
	EquipRangedWeaponRoundsType              = 3,
	EquipRuneId                              = 4,
	EquipPlayerId                            = 5,
	ContentType                              = 6,
	MapId                                    = 7,
	InParty                                  = 8,
	EquipCustomizingId                       = 9,
	EquipCustomizingTierType                 = 10,
	BattleZoneId                             = 11,
	MissionId                                = 12,
	Difficulty                               = 13,
	EM1QuestSubConditionType_MAX             = 14,
};

// Enum M1Data.EM1QuestDirectionType
// NumValues: 0x0005
enum class EM1QuestDirectionType : uint8
{
	None                                     = 0,
	OperatorDialog                           = 1,
	NpcDialog                                = 2,
	Sequence                                 = 3,
	EM1QuestDirectionType_MAX                = 4,
};

// Enum M1Data.EM1QuestCompleteConditionGroupType
// NumValues: 0x0004
enum class EM1QuestCompleteConditionGroupType : uint8
{
	None                                     = 0,
	Always                                   = 1,
	TrackerOnly                              = 2,
	EM1QuestCompleteConditionGroupType_MAX   = 3,
};

// Enum M1Data.EM1QuestParamType
// NumValues: 0x0019
enum class EM1QuestParamType : uint8
{
	Invalid                                  = 0,
	PlayerData                               = 1,
	MonsterData                              = 2,
	NpcData                                  = 3,
	MapData                                  = 4,
	FieldObjectData                          = 5,
	QuestData                                = 6,
	MissionData                              = 7,
	MissionWaveData                          = 8,
	VoidBattleData                           = 9,
	SkillData                                = 10,
	StatusEffectData                         = 11,
	MonsterPartsData                         = 12,
	ResearchData                             = 13,
	CurrencyData                             = 14,
	RangedWeaponData                         = 15,
	ReactorData                              = 16,
	AccessoryData                            = 17,
	ConsumableItemData                       = 18,
	ConsumableItemCategoryType               = 19,
	RuneData                                 = 20,
	RuneClassType                            = 21,
	CustomizingItemData                      = 22,
	SeasonReinforceGroupType                 = 23,
	EM1QuestParamType_MAX                    = 24,
};

// Enum M1Data.EM1AbilityParamType
// NumValues: 0x000C
enum class EM1AbilityParamType : uint8
{
	Invalid                                  = 0,
	Bool                                     = 1,
	Int                                      = 2,
	Float                                    = 3,
	Name                                     = 4,
	Enum                                     = 5,
	Vector                                   = 6,
	Object                                   = 7,
	Class                                    = 8,
	Tag                                      = 9,
	TraitTags                                = 10,
	EM1AbilityParamType_MAX                  = 11,
};

// Enum M1Data.EM1StatModifierOp
// NumValues: 0x0004
enum class EM1StatModifierOp : uint8
{
	Add                                      = 0,
	Multiply                                 = 1,
	Override                                 = 2,
	Max                                      = 3,
};

// Enum M1Data.EM1RuneClassType
// NumValues: 0x0009
enum class EM1RuneClassType : uint8
{
	Invalid                                  = 0,
	Character                                = 1,
	WeaponRange_01                           = 2,
	WeaponRange_02                           = 3,
	WeaponRange_03                           = 4,
	WeaponRange_04                           = 5,
	WeaponRange_05                           = 6,
	AccountMelee                             = 20,
	EM1RuneClassType_MAX                     = 21,
};

// Enum M1Data.EM1RuneSocketType
// NumValues: 0x0008
enum class EM1RuneSocketType : uint8
{
	None                                     = 0,
	Neutral                                  = 1,
	Blue                                     = 2,
	Red                                      = 3,
	Green                                    = 4,
	Yellow                                   = 5,
	Purple                                   = 6,
	EM1RuneSocketType_MAX                    = 7,
};

// Enum M1Data.EM1PlatformAchievementObjectiveCondition
// NumValues: 0x0002
enum class EM1PlatformAchievementObjectiveCondition : uint8
{
	QuestComplete                            = 0,
	EM1PlatformAchievementObjectiveCondition_MAX = 1,
};

// Enum M1Data.EM1ReactorOptimizedConditionType
// NumValues: 0x0006
enum class EM1ReactorOptimizedConditionType : uint8
{
	EquipWeaponClassCurrentSlot              = 0,
	EquipWeaponClassAnySlot                  = 1,
	EquipWeaponCurrentSlot                   = 2,
	EquipWeaponAnySlot                       = 3,
	EquipCharacter                           = 4,
	EM1ReactorOptimizedConditionType_MAX     = 5,
};

// Enum M1Data.EM1VoidBattleDifficulty
// NumValues: 0x0004
enum class EM1VoidBattleDifficulty : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Hard                                     = 2,
	EM1VoidBattleDifficulty_MAX              = 3,
};

// Enum M1Data.EM1VoidBattleUnlockConditionType
// NumValues: 0x0004
enum class EM1VoidBattleUnlockConditionType : uint8
{
	CompleteQuest                            = 0,
	SucceedMission                           = 1,
	AchieveMasteryLevel                      = 2,
	EM1VoidBattleUnlockConditionType_MAX     = 3,
};

// Enum M1Data.EM1VoidBattleStartConditionType
// NumValues: 0x0002
enum class EM1VoidBattleStartConditionType : uint8
{
	TimeSlot                                 = 0,
	EM1VoidBattleStartConditionType_MAX      = 1,
};

// Enum M1Data.EM1InstanceDungeonDifficulty
// NumValues: 0x0004
enum class EM1InstanceDungeonDifficulty : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Hard                                     = 2,
	EM1InstanceDungeonDifficulty_MAX         = 3,
};

// Enum M1Data.EM1MotionType
// NumValues: 0x0003
enum class EM1MotionType : uint8
{
	Solo                                     = 0,
	Group                                    = 1,
	EM1MotionType_MAX                        = 2,
};

// Enum M1Data.EM1EventType
// NumValues: 0x0003
enum class EM1EventType : uint8
{
	Challenge                                = 0,
	Boosting                                 = 1,
	EM1EventType_MAX                         = 2,
};

// Enum M1Data.EM1EventResetType
// NumValues: 0x0005
enum class EM1EventResetType : uint8
{
	Permanent                                = 0,
	Daily                                    = 1,
	Weekly                                   = 2,
	Monthly                                  = 3,
	EM1EventResetType_MAX                    = 4,
};

// Enum M1Data.EM1EventBoostContentType
// NumValues: 0x000A
enum class EM1EventBoostContentType : uint8
{
	None                                     = 0,
	KillMonster                              = 1,
	KillBossMonster                          = 2,
	MissionSucceed                           = 3,
	RaidSucceed                              = 4,
	MissionWaveSucceed                       = 5,
	KillMissionTaskMonster                   = 6,
	KillMissionWaveMonster                   = 7,
	FieldObject                              = 8,
	EM1EventBoostContentType_MAX             = 9,
};

// Enum M1Data.EM1DayOfWeek
// NumValues: 0x0008
enum class EM1DayOfWeek : uint8
{
	Sunday                                   = 0,
	Monday                                   = 1,
	Tuesday                                  = 2,
	Wednesday                                = 3,
	Thursday                                 = 4,
	Friday                                   = 5,
	Saturday                                 = 6,
	EM1DayOfWeek_MAX                         = 7,
};

// Enum M1Data.EM1DecomposeTargetType
// NumValues: 0x000A
enum class EM1DecomposeTargetType : uint8
{
	None                                     = 0,
	RangedWeapon                             = 1,
	Reactor                                  = 2,
	Necklace                                 = 3,
	Earrings                                 = 4,
	Ring                                     = 5,
	Bracelet                                 = 6,
	Perk                                     = 7,
	Rune                                     = 8,
	EM1DecomposeTargetType_MAX               = 9,
};

// Enum M1Data.EM1TitleType
// NumValues: 0x0003
enum class EM1TitleType : uint8
{
	Prefix                                   = 0,
	Suffix                                   = 1,
	EM1TitleType_MAX                         = 2,
};

// Enum M1Data.EM1ChallengeDataType
// NumValues: 0x0004
enum class EM1ChallengeDataType : uint8
{
	None                                     = 0,
	PassChallengeDaily                       = 1,
	PassChallengeWeekly                      = 2,
	EM1ChallengeDataType_MAX                 = 3,
};

// Enum M1Data.EM1BattlePassType
// NumValues: 0x0006
enum class EM1BattlePassType : uint8
{
	None                                     = 0,
	General                                  = 1,
	Platinum                                 = 2,
	Bonus                                    = 3,
	Event                                    = 4,
	EM1BattlePassType_MAX                    = 5,
};

// Enum M1Data.EM1RecordType
// NumValues: 0x0004
enum class EM1RecordType : uint8
{
	None                                     = 0,
	Voice                                    = 1,
	Document                                 = 2,
	EM1RecordType_MAX                        = 3,
};

// Enum M1Data.EM1StatValueOrder
// NumValues: 0x0003
enum class EM1StatValueOrder : uint32
{
	Default                                  = 0,
	Reverse                                  = 1,
	EM1StatValueOrder_MAX                    = 2,
};

// Enum M1Data.EM1EventBoostType
// NumValues: 0x0006
enum class EM1EventBoostType : uint8
{
	ItemRateBoost                            = 0,
	ItemAmountBoost                          = 1,
	CharExpBoost                             = 2,
	MasterExpBoost                           = 3,
	WeaponExpBoost                           = 4,
	EM1EventBoostType_MAX                    = 5,
};

// Enum M1Data.EM1MiniGameType
// NumValues: 0x0003
enum class EM1MiniGameType : uint8
{
	None                                     = 0,
	TimingRing                               = 1,
	EM1MiniGameType_MAX                      = 2,
};

// Enum M1Data.EM1SeasonReinforceGroupType
// NumValues: 0x0007
enum class EM1SeasonReinforceGroupType : uint8
{
	None                                     = 0,
	Hunting                                  = 1,
	Elemental                                = 2,
	Recovery                                 = 3,
	Survival                                 = 4,
	Season                                   = 5,
	EM1SeasonReinforceGroupType_MAX          = 6,
};

// Enum M1Data.EM1LoginPlatformTypes
// NumValues: 0x0007
enum class EM1LoginPlatformTypes : uint8
{
	Unknown                                  = 0,
	Xbox                                     = 1,
	PS                                       = 2,
	Steam                                    = 3,
	Nexon                                    = 4,
	Dev                                      = 5,
	EM1LoginPlatformTypes_MAX                = 6,
};

// Enum M1Data.EM1EquipmentSlotType
// NumValues: 0x000D
enum class EM1EquipmentSlotType : uint8
{
	Ranged_0                                 = 0,
	Ranged_1                                 = 1,
	Ranged_2                                 = 2,
	Reactor                                  = 9,
	Necklace                                 = 10,
	Earring                                  = 11,
	Ring                                     = 12,
	Bracelet                                 = 13,
	Face                                     = 20,
	Hair                                     = 21,
	AltWeapon                                = 90,
	PickupWeapon                             = 91,
	Max                                      = 99,
};

// Enum M1Data.EM1PresetSlotType
// NumValues: 0x000E
enum class EM1PresetSlotType : uint8
{
	Ranged_0                                 = 0,
	Ranged_1                                 = 1,
	Ranged_2                                 = 2,
	Reactor                                  = 9,
	Necklace                                 = 10,
	Earring                                  = 11,
	Ring                                     = 12,
	Bracelet                                 = 13,
	Face                                     = 20,
	Hair                                     = 21,
	PlayerCharacter                          = 80,
	AltWeapon                                = 90,
	PickupWeapon                             = 91,
	Max                                      = 99,
};

// Enum M1Data.EM1ItemType
// NumValues: 0x000D
enum class EM1ItemType : uint8
{
	None                                     = 0,
	Currency                                 = 1,
	Equipment                                = 2,
	Consumable                               = 3,
	Rune                                     = 4,
	Character                                = 5,
	InstantUse                               = 6,
	Customizing                              = 7,
	Title                                    = 8,
	Record                                   = 9,
	CurrencyInternal                         = 10,
	ItemSelector                             = 11,
	Max                                      = 12,
};

// Enum M1Data.EM1CustomizingItemCategoryType
// NumValues: 0x0012
enum class EM1CustomizingItemCategoryType : uint8
{
	None                                     = 0,
	CharacterHeadSkin                        = 1,
	CharacterBodySkin                        = 2,
	CharacterBackAttachment                  = 3,
	CharacterChestAttachment                 = 4,
	CharacterMakeupSkin                      = 5,
	CharacterSpawnSkin                       = 6,
	WeaponSkin                               = 100,
	Paint                                    = 110,
	GrapplingHookSkin                        = 200,
	SpawnSkin                                = 201,
	UITheme                                  = 202,
	UINameCard                               = 203,
	LobbyMotion                              = 204,
	Ecive                                    = 205,
	EmotionSocialMotion                      = 206,
	EmotionSpray                             = 207,
	EM1CustomizingItemCategoryType_MAX       = 208,
};

// Enum M1Data.EM1CurrencyInternalType
// NumValues: 0x000C
enum class EM1CurrencyInternalType : uint16
{
	None                                     = 0,
	Gold                                     = 1,
	BlackMana                                = 3,
	Qulipothium                              = 4,
	BattleCoin                               = 6,
	PlatinumCoin                             = 7,
	BonusCoin                                = 8,
	BlueCash_Paid                            = 111,
	BlueCash_Free                            = 112,
	RedCash_Paid                             = 121,
	RedCash_Free                             = 122,
	Max                                      = 131,
};

// Enum M1Data.EM1BuffSubItemType
// NumValues: 0x000C
enum class EM1BuffSubItemType : uint8
{
	None                                     = 0,
	CharacterExpBoost                        = 1,
	WeaponProficiencyBoost                   = 2,
	GoldBoost                                = 3,
	QulipothiumBoost                         = 4,
	InventoryExpansion                       = 5,
	CharcterInvenExpansion                   = 6,
	ConsumableInvenExpansion                 = 7,
	WareHouseInvenExpansion                  = 8,
	PresetSlotExpansion                      = 9,
	SeasonExpBoost                           = 10,
	EM1BuffSubItemType_MAX                   = 11,
};

// Enum M1Data.EM1StatType
// NumValues: 0x00E6
enum class EM1StatType : uint8
{
	Stat_MaxHp                               = 0,
	Stat_KnockbackSpeed                      = 1,
	Stat_KnockbackTime                       = 2,
	Stat_KnockdownTime                       = 3,
	Stat_RangeMax                            = 4,
	Stat_SpreadSize_Deprecated               = 5,
	Stat_CrosshairSizeMax                    = 6,
	Stat_Impulse                             = 7,
	Stat_AimOnDelay                          = 8,
	Stat_AimOffDelay                         = 9,
	Stat_JumpZVelocity                       = 10,
	Stat_CurrentEnergyShield                 = 11,
	Stat_InteractionRevive                   = 12,
	Stat_RunSpeed                            = 13,
	Stat_SprintSpeed                         = 14,
	Stat_ZoomMoveSpeed                       = 15,
	Stat_RoundsPerMagazine                   = 16,
	Stat_ReloadRounds                        = 17,
	Stat_FireInterval                        = 18,
	Stat_MaxMp                               = 19,
	Stat_MaxEnergyShield                     = 20,
	Stat_ATK                                 = 21,
	Stat_ATKMin                              = 22,
	Stat_ATKMax                              = 23,
	Stat_DEF                                 = 24,
	Stat_CriticalChance                      = 25,
	Stat_CriticalATKIncrease                 = 26,
	Stat_ShellCount                          = 27,
	Stat_RoundsConsume                       = 28,
	Stat_AimMoveSpeed                        = 29,
	Stat_WeaknessDamageIncrease              = 30,
	Stat_SpreadZoomSize_Deprecated           = 31,
	Stat_CrosshairMoveSizeModifier           = 32,
	Stat_CrosshairFireSizeModifier           = 33,
	Stat_CrosshairZoomFireSizeModifier       = 34,
	Stat_CrosshairRecoverySpeed              = 35,
	Stat_CrosshairChangeSpeed                = 36,
	Stat_ClimbSpeed                          = 37,
	Stat_StressMaxRate_Deprecated            = 38,
	Stat_StressDamageRate                    = 39,
	Stat_StressDecreaseRate                  = 40,
	Stat_NonCombatEntryTime_Deprecated       = 41,
	Stat_StressDecreaseStartTime             = 42,
	Stat_WalkSpeed                           = 43,
	Stat_MoveDestructivePower                = 44,
	Stat_WeaponProjHitRadiusRate             = 45,
	Stat_EvadeTime                           = 46,
	Stat_EvadeRecoveryTime                   = 47,
	Stat_Domination                          = 48,
	Stat_Manipulation                        = 49,
	Stat_Fortitude                           = 50,
	Stat_CrosshairSizeMin                    = 51,
	Stat_ReloadSpeed                         = 52,
	Stat_ReloadCompleteDelay                 = 53,
	Stat_ReduceRangeStart                    = 54,
	Stat_ReduceRangeEnd                      = 55,
	Stat_ATKReductionByRange                 = 56,
	Stat_ATKExplosion                        = 57,
	Stat_ATKBlazer                           = 58,
	Stat_ATKGlacier                          = 59,
	Stat_ATKElectricity                      = 60,
	Stat_ATKDemonic                          = 61,
	Stat_DEFBlazer                           = 62,
	Stat_DEFGlacier                          = 63,
	Stat_DEFElectricity                      = 64,
	Stat_DEFDemonic                          = 65,
	Stat_RESCriticalChance                   = 66,
	Stat_ReloadTime                          = 67,
	Stat_Burst                               = 68,
	Stat_Crush                               = 69,
	Stat_Piercing                            = 70,
	Stat_FireBurstInterval                   = 71,
	Stat_ATKReductionByExplosionRange        = 72,
	Stat_ZoomOutDelay                        = 73,
	Stat_Penetration                         = 74,
	Stat_PenetrationDefence                  = 75,
	Stat_WeaponDestructivePower              = 76,
	Stat_SkillDestructivePower               = 77,
	Stat_FireIncreaseSpread_Deprecated       = 78,
	Stat_LifeTime_Deprecated                 = 79,
	Stat_BonusLifeTime_Deprecated            = 80,
	Stat_RangeMin_Deprecated                 = 81,
	Stat_WireCooltimeCoefficient             = 82,
	Stat_WireChargingTimeCoefficient         = 83,
	Stat_KnockbackAttackRate                 = 84,
	Stat_KnockbackDefenceResistance          = 85,
	Stat_KnockbackTimeResistance             = 86,
	Stat_KnockbackSpeedResistance            = 87,
	Stat_KnockdownAttackRate                 = 88,
	Stat_KnockdownXSpeed                     = 89,
	Stat_KnockdownZSpeed                     = 90,
	Stat_KnockdownDefenceResistance          = 91,
	Stat_KnockdownXSpeedResistance           = 92,
	Stat_KnockdownZSpeedResistance           = 93,
	Stat_KnockdownTimeResistance             = 94,
	Stat_MeleeSpecialAttackReduceCoolTime_Deprecated = 95,
	Stat_HitStopAttackPoint                  = 96,
	Stat_HitStopDefencePoint                 = 97,
	Stat_BerserkMoveSpeed                    = 98,
	Stat_BerserkMaxRate                      = 99,
	Stat_BerserkDamageRate                   = 100,
	Stat_BerserkDecreaseStartTime            = 101,
	Stat_BerserkDecreaseRate                 = 102,
	Stat_BerserkMaintenanceTime              = 103,
	Stat_NaturalRecoveryTickTimeHp           = 104,
	Stat_NaturalRecoveryTickTimeMp           = 105,
	Stat_NaturalRecoveryTickTimeEnergyShield = 106,
	Stat_NaturalRecoveryHp                   = 107,
	Stat_NaturalRecoveryMp                   = 108,
	Stat_NaturalRecoveryEnergyShield         = 109,
	Stat_InBattleNaturalRecoveryHp           = 110,
	Stat_InBattleNaturalRecoveryMp           = 111,
	Stat_InBattleNaturalRecoveryEnergyShield = 112,
	Stat_CurrentHp                           = 113,
	Stat_CurrentMp                           = 114,
	Stat_MaxCommonGauge                      = 115,
	Stat_CurrentCommonGauge                  = 116,
	Stat_DEFInflection_VarX1_Deprecated      = 117,
	Stat_DEFInflection_VarX2_Deprecated      = 118,
	Stat_DEFInflection_VarX3_Deprecated      = 119,
	Stat_WireStackCountIncrease              = 120,
	Stat_RecoilCoefficient                   = 121,
	Stat_SkillCooltimeCoefficient            = 122,
	Stat_SkillCostCoefficient                = 123,
	Stat_SkillATKCoefficient                 = 124,
	Stat_FinalDamageCoefficient_Deprecated   = 125,
	Stat_HpOrbRecoveryCoefficient_Deprecated = 126,
	Stat_MpOrbRecoveryCoefficient_Deprecated = 127,
	Stat_EmptyRoundsReloadTimeSpeed          = 128,
	Stat_SkillDurationIncrease               = 129,
	Stat_SkillDurationDecrease               = 130,
	Stat_SkillScaleCoefficient               = 131,
	Stat_WeaponChangingSpeed                 = 132,
	Stat_MaxGeneralRoundsCoefficient         = 133,
	Stat_MaxEnhancedRoundsCoefficient        = 134,
	Stat_MaxImpactRoundsCoefficient          = 135,
	Stat_MaxHighpowerRoundsCoefficient       = 136,
	Stat_NaturalRecoveryTickPR_Deprecated    = 137,
	Stat_InBattleNaturalRecoveryPR_Deprecated = 138,
	Stat_NaturalRecoveryPR_Deprecated        = 139,
	Stat_CrosshairJumpSizeModifier           = 140,
	Stat_PhysicalATK                         = 141,
	Stat_NatureATK                           = 142,
	Stat_GiveHpRecoveryCoefficient           = 143,
	Stat_TakeHpRecoveryCoefficient           = 144,
	Stat_GiveMpRecoveryCoefficient           = 145,
	Stat_TakeMpRecoveryCoefficient           = 146,
	Stat_RWATKCoefficient                    = 147,
	Stat_GiveFinalDamageCoefficient          = 148,
	Stat_TakeFinalDamageCoefficient          = 149,
	Stat_LevelFactor                         = 150,
	Stat_SkillATKCorrection                  = 151,
	Stat_ItemLevelCorrection                 = 152,
	Stat_MaxStressGauge                      = 153,
	Stat_CurrentStressGauge                  = 154,
	Stat_MaxBerserkGauge                     = 155,
	Stat_CurrentBerserkGauge                 = 156,
	Stat_SkillATKPower                       = 157,
	Stat_SkillPowerCoefficient               = 158,
	Stat_SkillPlainPowerCoefficient          = 159,
	Stat_SkillBlazerPowerCoefficient         = 160,
	Stat_SkillGlacierPowerCoefficient        = 161,
	Stat_SkillElectricityPowerCoefficient    = 162,
	Stat_SkillDemonicPowerCoefficient        = 163,
	Stat_SkillFusionPowerCoefficient         = 164,
	Stat_SkillSingularPowerCoefficient       = 165,
	Stat_SkillDimensionPowerCoefficient      = 166,
	Stat_SkillTechPowerCoefficient           = 167,
	Stat_SkillPlainATKCoefficient            = 168,
	Stat_SkillBlazerATKCoefficient           = 169,
	Stat_SkillGlacierATKCoefficient          = 170,
	Stat_SkillElectricityATKCoefficient      = 171,
	Stat_SkillDemonicATKCoefficient          = 172,
	Stat_SkillFusionATKCoefficient           = 173,
	Stat_SkillSingularATKCoefficient         = 174,
	Stat_SkillDimensionATKCoefficient        = 175,
	Stat_SkillTechATKCoefficient             = 176,
	Stat_SkillCriticalChance                 = 178,
	Stat_SkillCriticalATKIncrease            = 179,
	Stat_SkillRESCriticalChance              = 180,
	Stat_DEFSkill                            = 181,
	Stat_DEFPlain                            = 182,
	Stat_Accuracy                            = 183,
	Stat_ZoomAccuracy                        = 184,
	Stat_InvokeChanceElementalSE             = 185,
	Stat_GiveShieldRecoveryCoefficient       = 186,
	Stat_TakeShieldRecoveryCoefficient       = 187,
	Stat_MaxSprintSpeed                      = 188,
	Stat_WeaponProjHitRadius                 = 189,
	Stat_DBNORescueTime                      = 190,
	Stat_RuneDropCoefficient                 = 191,
	Stat_EquipmentDropCoefficient            = 192,
	Stat_ConsumableDropCoefficient           = 193,
	Stat_GoldDropCoefficient                 = 194,
	Stat_QulipothiumDropCoefficient          = 195,
	Stat_CharEXPCoefficient                  = 196,
	Stat_ProficiencyCoefficient              = 197,
	Stat_TypeBossATKBonus                    = 198,
	Stat_TypeDarknessATKBonus                = 199,
	Stat_TypeTruthATKBonus                   = 200,
	Stat_TypeImmortalATKBonus                = 201,
	Stat_DBNODurationCoefficient             = 202,
	Stat_LootDistanceCoefficient             = 203,
	Stat_DoubleJumpZVelocity                 = 204,
	Stat_EciveSearchDistanceCoefficient      = 205,
	Stat_EciveSearchRemainTimeCoefficient    = 206,
	Stat_SubSkillATKPower                    = 207,
	Stat_SubSkillATKCoefficient              = 208,
	Stat_TakeWeaknessDamageCoefficient_Deprecated = 209,
	Stat_RWChargeRateCoefficient             = 210,
	Stat_RWDischargeRateCoefficient          = 211,
	Stat_TypeBossSkillATKBonus               = 212,
	Stat_TypeDarknessSkillATKBonus           = 213,
	Stat_TypeTruthSkillATKBonus              = 214,
	Stat_TypeImmortalSkillATKBonus           = 215,
	Stat_BurstDelay                          = 216,
	Stat_DefaultStressStopDuration           = 217,
	Stat_FieldTimingRing_LimitTimeRatio      = 218,
	Stat_FieldTimingRing_NeedleRotationTimeRatio = 219,
	Stat_FieldTimingRing_ReduceSuccessCount  = 220,
	Stat_FieldTimingRing_IncreaseTimingAngleMax = 221,
	Stat_FieldTimingRing_FailTimeRatio       = 222,
	Stat_SkillVelocityAndRangeCoefficient    = 223,
	Stat_StressMaxHpRandMinRate              = 224,
	Stat_StressMaxHpRandMaxRate              = 225,
	Stat_StressMaxHpCurrentRate              = 226,
	Stat_ActionSpeedCoeffcient               = 227,
	Stat_ProjectilePenetration               = 228,
	Stat_ProjectilePenetrationDefence        = 229,
	MAX                                      = 230,
};

// Enum M1Data.EM1InventoryType
// NumValues: 0x0008
enum class EM1InventoryType : uint8
{
	None                                     = 0,
	Equipment                                = 1,
	WareHouse                                = 2,
	Character                                = 3,
	Consumable                               = 4,
	Rune                                     = 5,
	PresetSlot                               = 6,
	Max                                      = 7,
};

// Enum M1Data.EM1MapSubType
// NumValues: 0x0006
enum class EM1MapSubType : uint8
{
	None                                     = 0,
	VoidBattle                               = 1,
	WorldMission                             = 2,
	InstanceDungeon                          = 3,
	InvasionDungeon                          = 4,
	EM1MapSubType_MAX                        = 5,
};

// Enum M1Data.EM1MapDifficulty
// NumValues: 0x0004
enum class EM1MapDifficulty : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Hard                                     = 2,
	EM1MapDifficulty_MAX                     = 3,
};

// Enum M1Data.EM1QuestType
// NumValues: 0x000E
enum class EM1QuestType : uint8
{
	Main                                     = 0,
	Field                                    = 1,
	Event                                    = 2,
	Sub                                      = 3,
	Platform                                 = 4,
	PassChallengeDaily                       = 5,
	PassChallengeWeekly                      = 6,
	ContentsUnlock                           = 7,
	Achievement                              = 8,
	Evolution                                = 9,
	CharacterStory                           = 10,
	Season                                   = 11,
	All                                      = 100,
	EM1QuestType_MAX                         = 101,
};

// Enum M1Data.EM1RuneSubClassType
// NumValues: 0x0004
enum class EM1RuneSubClassType : uint8
{
	Main                                     = 0,
	CharacterSub                             = 1,
	SkillRune                                = 2,
	EM1RuneSubClassType_MAX                  = 3,
};

// Enum M1Data.EM1MailType
// NumValues: 0x0007
enum class EM1MailType : uint8
{
	All                                      = 0,
	PostMail                                 = 1,
	LostMail                                 = 2,
	NarrativeMail                            = 3,
	EventMail                                = 4,
	PaidMail                                 = 5,
	EM1MailType_MAX                          = 6,
};

// Enum M1Data.EM1ChattingType
// NumValues: 0x0007
enum class EM1ChattingType : uint8
{
	World                                    = 0,
	DirectMessage                            = 1,
	System                                   = 2,
	Normal                                   = 3,
	Party                                    = 4,
	Notice                                   = 5,
	EM1ChattingType_MAX                      = 6,
};

// Enum M1Data.EM1MoveDedicatedServerReason
// NumValues: 0x0009
enum class EM1MoveDedicatedServerReason : uint32
{
	Cheat                                    = 18446744073709551615,
	ToThePartyMaster                         = 0,
	ToThePartyMember                         = 1,
	PartyMove                                = 2,
	MaxCity                                  = 3,
	Matching                                 = 4,
	Support                                  = 5,
	Disallow                                 = 6,
	EM1MoveDedicatedServerReason_MAX         = 7,
};

// Enum M1Data.EM1MatchingCancelReason
// NumValues: 0x0008
enum class EM1MatchingCancelReason : uint32
{
	Canceled                                 = 0,
	TimeOut                                  = 1,
	MemberLogout                             = 2,
	MatchingSucceeded                        = 3,
	ReserveGameFailed                        = 4,
	FailAlreadyPrivateMatched                = 18,
	FailAlreadyMatchingFound                 = 19,
	EM1MatchingCancelReason_MAX              = 20,
};

// Enum M1Data.EM1ExternalLinkerType
// NumValues: 0x0004
enum class EM1ExternalLinkerType : uint8
{
	Dev                                      = 0,
	DevTOY                                   = 1,
	TOY                                      = 2,
	EM1ExternalLinkerType_MAX                = 3,
};

// Enum M1Data.EM1Locale
// NumValues: 0x000E
enum class EM1Locale : uint8
{
	None                                     = 0,
	KO                                       = 1,
	EN                                       = 2,
	DE                                       = 3,
	FR                                       = 4,
	JA                                       = 5,
	ZH_Hans                                  = 6,
	ZH_Hant                                  = 7,
	IT                                       = 8,
	PL                                       = 9,
	PT                                       = 10,
	RU                                       = 11,
	ES                                       = 12,
	Max                                      = 13,
};

// Enum M1Data.EM1MatchRegion
// NumValues: 0x000B
enum class EM1MatchRegion : uint8
{
	None                                     = 0,
	Koreacentral                             = 1,
	Eastus                                   = 2,
	Northcentralus                           = 3,
	brazilsouth                              = 4,
	Westus                                   = 5,
	Germanywestcentral                       = 6,
	Eastasia                                 = 7,
	Polandcentral                            = 8,
	Southeastasia                            = 10,
	EM1MatchRegion_MAX                       = 11,
};

// Enum M1Data.EM1ForceRebuild
// NumValues: 0x0003
enum class EM1ForceRebuild : uint8
{
	None                                     = 0,
	RollingVersion                           = 1,
	EM1ForceRebuild_MAX                      = 2,
};

// Enum M1Data.EM1PerkReason
// NumValues: 0x0009
enum class EM1PerkReason : uint32
{
	Unknown                                  = 0,
	Success                                  = 1,
	InvalidWeapon                            = 2,
	InvalidPerk                              = 3,
	AlreadyMaxLevel                          = 4,
	ChangeResourceFail                       = 5,
	DestroyResourceItemFail                  = 6,
	AccountNotExists                         = 7,
	EM1PerkReason_MAX                        = 8,
};

// Enum M1Data.EM1ItemTagStatus
// NumValues: 0x000B
enum class EM1ItemTagStatus : uint8
{
	None                                     = 0,
	Junk                                     = 1,
	BookMark_0                               = 2,
	BookMark_1                               = 3,
	BookMark_2                               = 4,
	BookMark_3                               = 5,
	BookMark_4                               = 6,
	BookMark_5                               = 7,
	BookMark_6                               = 8,
	BookMark_7                               = 9,
	EM1ItemTagStatus_MAX                     = 10,
};

// Enum M1Data.EM1TitleReason
// NumValues: 0x0006
enum class EM1TitleReason : uint32
{
	Unknown                                  = 0,
	Success                                  = 1,
	InvalidData                              = 2,
	InvalidValue                             = 3,
	AccountNotExists                         = 4,
	EM1TitleReason_MAX                       = 5,
};

// Enum M1Data.EM1BoostType
// NumValues: 0x0004
enum class EM1BoostType : uint8
{
	Event                                    = 0,
	Stat                                     = 1,
	Item                                     = 2,
	Max                                      = 3,
};

// Enum M1Data.EM1CommonShopResultType
// NumValues: 0x0022
enum class EM1CommonShopResultType : uint32
{
	Unknown                                  = 0,
	Success                                  = 1,
	CantSellCurrency                         = 2,
	ItemInvalid                              = 3,
	ItemTypeInvalid                          = 4,
	ItemTemplateIdInvalid                    = 5,
	CantChangeConsumable                     = 6,
	CantSellItem                             = 7,
	CantChangeCurrency                       = 8,
	CantBuyCurrency                          = 9,
	InvalidShopId                            = 10,
	CantBuyItem                              = 11,
	InvalidAccount                           = 12,
	NotEnoughResource                        = 13,
	InvalidCount                             = 14,
	ProductInvalid                           = 15,
	CantBuyPaidProduct                       = 16,
	NoPrice                                  = 17,
	OverBuyableCount                         = 18,
	InvalidBattlePassSeason                  = 19,
	NotEnoughBattlePassLevel                 = 20,
	InvalidData                              = 21,
	DoesNotBuyRequiredPageItem               = 22,
	CantBuyMultipleItem                      = 23,
	CantBuyPremiumBattlePassItem             = 24,
	DuplicateItem                            = 25,
	NotInSaleTime                            = 26,
	CantBuyMultipleNonStackable              = 27,
	SoldButInMail                            = 28,
	NotEnoughMasteryLevel                    = 29,
	CantBuyBattlePassPremiumItem             = 30,
	CantBuyResearchItem                      = 31,
	ProductProhibited                        = 32,
	EM1CommonShopResultType_MAX              = 33,
};

// Enum M1Data.EM1CheatCreateCharacterResultType
// NumValues: 0x0008
enum class EM1CheatCreateCharacterResultType : uint32
{
	Unknown                                  = 0,
	Success                                  = 1,
	CharacterTypeDuplicated                  = 2,
	LackOfCharacterSlots                     = 3,
	InvalidAccountUid                        = 4,
	InvalidTemplateId                        = 5,
	CantCreateCharacter                      = 6,
	EM1CheatCreateCharacterResultType_MAX    = 7,
};

// Enum M1Data.EM1ResearchStatus
// NumValues: 0x0005
enum class EM1ResearchStatus : uint8
{
	None                                     = 0,
	Proceed                                  = 1,
	Complete                                 = 2,
	Recipiency                               = 3,
	Max                                      = 4,
};

// Enum M1Data.EM1ResearchReason
// NumValues: 0x0017
enum class EM1ResearchReason : uint32
{
	Unknown                                  = 0,
	Success                                  = 1,
	ResearchAlreadyDone                      = 2,
	ResearchDataNotExist                     = 3,
	ResearchCurrencyNotEnough                = 4,
	ResearchResourceNotEnough                = 5,
	ResearchDidntStart                       = 6,
	ResearchAlreadyReceive                   = 7,
	ResearchCurrencyFailBack                 = 8,
	ResearchResourceFailBack                 = 9,
	ResearchBoostCurrencyNotEnough           = 10,
	ResearchDidntComplete                    = 11,
	ResearchOwnCharacter                     = 13,
	ResearchOverMaxCount                     = 15,
	ResearchResultCountOver                  = 16,
	ResearchMasteryLevelRow                  = 18,
	ResearchInvalidAccount                   = 19,
	ResearchUnkownReason                     = 20,
	ResearchCantSetBookmarkAlreadyStarted    = 21,
	ResearchInventoryLimitOver               = 22,
	ResearchBookmarkTargetInvalid            = 23,
	ResearchInvalidRepeatCount               = 24,
	EM1ResearchReason_MAX                    = 25,
};

// Enum M1Data.EM1MissionEndType
// NumValues: 0x0003
enum class EM1MissionEndType : uint32
{
	Cancel                                   = 0,
	Fail                                     = 1,
	EM1MissionEndType_MAX                    = 2,
};

// Enum M1Data.EM1RuneReason
// NumValues: 0x0033
enum class EM1RuneReason : uint32
{
	Unknown                                  = 0,
	Success                                  = 1,
	RuneAlreadyAttach                        = 2,
	RuneSameKindRuneAttach                   = 3,
	RuneCharacterNotExist                    = 4,
	RuneItemNotExist                         = 5,
	RuneNotAttached                          = 6,
	RuneAccountNotExist                      = 7,
	RuneMasteryLevelInvalid                  = 8,
	RuneLevelInvalid                         = 9,
	RuneCapacityOver                         = 10,
	RuneSlotCountOver                        = 11,
	RuneInvalid                              = 12,
	RuneSlotDataInvalid                      = 13,
	RuneInvalidData                          = 15,
	RuneCapcityIncreaseItemNotEnough         = 16,
	RuneCapacityMax                          = 17,
	RuneEnchantResouceNotEnough              = 18,
	RuneCantDecomposeAttachItem              = 19,
	RuneInvalidResource                      = 20,
	RuneDecomposable                         = 21,
	RuneEnchantable                          = 22,
	RuneEnchantMasteryLevel                  = 23,
	RuneSocketTypeAlreadyGrant               = 24,
	RuneSocketGrantResourceNotEnough         = 25,
	RuneSocketTypeAlreadySelected            = 26,
	RuneSocketCantSelect                     = 27,
	RuneInvalidComposeCount                  = 28,
	RuneComposeResourceNotEnough             = 29,
	RuneUnknownError                         = 30,
	RuneInventoryNotEnough                   = 31,
	RuneSubSocketInvalid                     = 32,
	RuneItemCantCompose                      = 33,
	RuneResourceNotEnough                    = 34,
	RuneCantAttachInvalidClassType           = 35,
	RuneCantAttachSameGroup                  = 36,
	RuneNothingChanged                       = 37,
	RuneCantAttachInvalidCharacter           = 38,
	RuneDuplicatedPosition                   = 39,
	RuneWeaponResetFail                      = 40,
	RuneCharacterResetFail                   = 41,
	RuneInvalidType                          = 42,
	RuneLoadoutSlotNotExist                  = 43,
	RuneLoadoutSlotEquipsNotLoaded           = 44,
	RuneLoadoutSlotNameSlang                 = 45,
	RuneLoadoutSlotNameTooLong               = 45,
	RuneLoadoutSlotMaxCount                  = 46,
	RuneInventoryRevisionMismatch            = 47,
	RuneInventoryCountMismatch               = 48,
	RuneSocketTypeNotExist                   = 49,
	EM1RuneReason_MAX                        = 50,
};

// Enum M1Data.EM1FieldUnlockResults
// NumValues: 0x000C
enum class EM1FieldUnlockResults : uint8
{
	Unknown                                  = 0,
	Success                                  = 1,
	AlreadyUnlocked                          = 2,
	InvalidMapId                             = 3,
	NotFieldMap                              = 4,
	InvalidMapSubData                        = 5,
	InvalidCampId                            = 6,
	FieldNotUnlocked                         = 7,
	InvalidAccountUid                        = 8,
	InvalidDediOid                           = 9,
	InvalidBattleZone                        = 10,
	EM1FieldUnlockResults_MAX                = 11,
};

// Enum M1Data.EM1LastBattleZoneSetReason
// NumValues: 0x0007
enum class EM1LastBattleZoneSetReason : uint32
{
	Unknown                                  = 0,
	InvalidMapId                             = 1,
	InvalidBattleZoneId                      = 2,
	AlreadySet                               = 3,
	NotUnlock                                = 4,
	Success                                  = 5,
	EM1LastBattleZoneSetReason_MAX           = 6,
};

// Enum M1Data.EM1QuestCompleteState
// NumValues: 0x0004
enum class EM1QuestCompleteState : uint32
{
	NotComplete                              = 0,
	SuccessBeforeReward                      = 1,
	SuccessComplete                          = 2,
	EM1QuestCompleteState_MAX                = 3,
};

// Enum M1Data.EM1IncQuestProgressReason
// NumValues: 0x0008
enum class EM1IncQuestProgressReason : uint32
{
	Null                                     = 0,
	Success                                  = 1,
	Fail_QuestNotFound                       = 2,
	Fail_AlreadyCompleted                    = 3,
	Fail_InvalidQuestId                      = 4,
	Fail_InvalidQuestType                    = 5,
	Fail_QuestExpired                        = 6,
	EM1IncQuestProgressReason_MAX            = 7,
};

// Enum M1Data.EM1CharacterResetReason
// NumValues: 0x0009
enum class EM1CharacterResetReason : uint8
{
	UnknownReason                            = 0,
	Success                                  = 1,
	InvalidAccountUid                        = 2,
	CharacterNotMaxLevel                     = 3,
	InvalidData                              = 4,
	CharacterResetItemNotEnuough             = 5,
	ResetRewardTooMuch                       = 6,
	ResourceNotEnough                        = 7,
	EM1CharacterResetReason_MAX              = 8,
};

// Enum M1Data.EM1CharacterFavoriteReason
// NumValues: 0x0006
enum class EM1CharacterFavoriteReason : uint32
{
	None                                     = 0,
	Success                                  = 1,
	InvalidAccountUid                        = 2,
	InvalidCharacterUid                      = 3,
	NotChanges                               = 4,
	EM1CharacterFavoriteReason_MAX           = 5,
};

// Enum M1Data.EM1MasteryLevelCheckBenefit
// NumValues: 0x0008
enum class EM1MasteryLevelCheckBenefit : uint8
{
	Equipment                                = 0,
	EquipInventorySlot                       = 1,
	WeaponRune                               = 2,
	CharacterRune                            = 3,
	Trade                                    = 4,
	CharacterSubRune                         = 5,
	CharacterSkillRune                       = 6,
	EM1MasteryLevelCheckBenefit_MAX          = 7,
};

// Enum M1Data.EM1MasteryUnlockType
// NumValues: 0x000E
enum class EM1MasteryUnlockType : uint8
{
	RuneWeaponCapacity                       = 0,
	RuneCharacterCapacity                    = 1,
	RuneAccountSlot                          = 2,
	RuneCharacterSlot                        = 3,
	EquipInventorySlot                       = 4,
	WeaponSlot                               = 5,
	AccessoryReactor                         = 6,
	AccessoryNeckSlot                        = 7,
	AccessoryEarringsSlot                    = 8,
	AccessoryRingSlot                        = 9,
	AccessoryBraceletSlot                    = 10,
	TradeCount                               = 11,
	None                                     = 12,
	EM1MasteryUnlockType_MAX                 = 13,
};

// Enum M1Data.EM1ItemReason
// NumValues: 0x0015
enum class EM1ItemReason : uint32
{
	UnknownError                             = 0,
	Success                                  = 1,
	CurrencyNotEnough                        = 2,
	InvalidType                              = 3,
	InvalidData                              = 4,
	InvalidValue                             = 5,
	CantSatisfyMasterLevelCondition          = 6,
	InventoryLimitOver                       = 7,
	ItemNotEnough                            = 8,
	CantMoveWareHouseToWareHouse             = 9,
	CantMoveWearingItemToWareHouse           = 10,
	SlotIncrementLimitOver                   = 11,
	HowToUseInvalid                          = 12,
	SlotCountOver                            = 13,
	DuplicateItem                            = 14,
	CantSubRealCurrencyDirect                = 15,
	AccountNotExists                         = 16,
	InvalidRevision                          = 17,
	WearingItem                              = 18,
	InvalidItemCount                         = 19,
	EM1ItemReason_MAX                        = 20,
};

// Enum M1Data.EM1MatchingReason
// NumValues: 0x001E
enum class EM1MatchingReason : uint32
{
	Unknown                                  = 0,
	Success                                  = 1,
	FailNoEntrance                           = 2,
	FailNoTicket                             = 3,
	FailInvalidRequest                       = 4,
	FailPartyMemberNoEntrance                = 5,
	FailAlreadyRequested                     = 6,
	FailServerNotReady                       = 7,
	FailEtc                                  = 8,
	FailNotRegistered                        = 9,
	FailAlreadyMatched                       = 10,
	FailNotStartTime                         = 11,
	FailNotMaster                            = 12,
	FailAccountNotFound                      = 13,
	FailSystemNotInitialized                 = 14,
	FailWaitMember                           = 15,
	FailRedisDataNotFound                    = 16,
	FailSingleOnly                           = 17,
	FailAlreadyPrivateMatched                = 18,
	FailAlreadyMatchingFound                 = 19,
	FailMinMembers                           = 20,
	MMErrUnavailable                         = 21,
	MMErrFailed                              = 100,
	MMErrInvalidParam                        = 201,
	MMErrNotFound                            = 301,
	MMErrIncorrectToken                      = 302,
	MMErrStateNotApplicable                  = 303,
	MMErrPartiallyFailed                     = 304,
	MMErrNotImplemented                      = 901,
	EM1MatchingReason_MAX                    = 902,
};

// Enum M1Data.EM1InstanceDungeonCompleteReason
// NumValues: 0x0004
enum class EM1InstanceDungeonCompleteReason : uint32
{
	Fail                                     = 0,
	InvalidData                              = 1,
	Success                                  = 2,
	EM1InstanceDungeonCompleteReason_MAX     = 3,
};

// Enum M1Data.EM1MatchedGameEndType
// NumValues: 0x0006
enum class EM1MatchedGameEndType : uint32
{
	Unknown                                  = 0,
	Success                                  = 1,
	Fail_Annihilated                         = 2,
	Fail_TimeOut                             = 3,
	Fail_Etc                                 = 4,
	EM1MatchedGameEndType_MAX                = 5,
};

// Enum M1Data.EM1MailReason
// NumValues: 0x000F
enum class EM1MailReason : uint32
{
	UnknownError                             = 0,
	Success                                  = 1,
	InvalidMailType                          = 2,
	AccountNotExists                         = 3,
	AlreadyRead                              = 4,
	InvalidData                              = 5,
	ValueNonExist                            = 6,
	OutofAttachmentIndex                     = 7,
	InvalidItemType                          = 8,
	InventoryLimitOver                       = 9,
	CantDeleteItemAttachedMail               = 10,
	MailDeletePartlySuccess                  = 11,
	MailAttachItemAlreadyReceived            = 12,
	MailAttachmentCountOver                  = 13,
	EM1MailReason_MAX                        = 14,
};

// Enum M1Data.EM1CustomizeReason
// NumValues: 0x000C
enum class EM1CustomizeReason : uint32
{
	Failed                                   = 0,
	Success                                  = 1,
	InvalidData                              = 2,
	Duplicate                                = 3,
	AccountNotExists                         = 4,
	NotFound                                 = 5,
	OverPaintIndex                           = 6,
	NeedEvolution                            = 7,
	NotEnoughCondition                       = 8,
	NotAbleEvolution                         = 9,
	OverEvolution                            = 10,
	EM1CustomizeReason_MAX                   = 11,
};

// Enum M1Data.EM1PackageItemReason
// NumValues: 0x000A
enum class EM1PackageItemReason : uint32
{
	Unknown                                  = 0,
	Success                                  = 1,
	InvalidData                              = 2,
	ConsumeItemFail                          = 3,
	CreateItemFail                           = 4,
	WorkingDBNotFound                        = 5,
	UseKeyFail                               = 6,
	LinkedKeyNotFound                        = 7,
	SelectItemFail                           = 8,
	EM1PackageItemReason_MAX                 = 9,
};

// Enum M1Data.EM1EventRewardDateType
// NumValues: 0x0005
enum class EM1EventRewardDateType : uint8
{
	Permanent                                = 0,
	Daily                                    = 1,
	Weekly                                   = 2,
	Monthly                                  = 3,
	EM1EventRewardDateType_MAX               = 4,
};

// Enum M1Data.EM1ReactorReason
// NumValues: 0x000C
enum class EM1ReactorReason : uint32
{
	Unknown                                  = 0,
	Success                                  = 1,
	InvalidData                              = 2,
	MaxEnchantLevel                          = 3,
	ResourceFail                             = 4,
	NotEnchantable                           = 5,
	CurrencyNotConditiion                    = 6,
	ConsumableNotConditiion                  = 7,
	EquipmentNotConditiion                   = 8,
	CharacterNotConditiion                   = 9,
	AccountNotExists                         = 10,
	EM1ReactorReason_MAX                     = 11,
};

// Enum M1Data.EM1BattlePassLevelReason
// NumValues: 0x0004
enum class EM1BattlePassLevelReason : uint32
{
	NormalExpUp                              = 0,
	LevelUpBuy                               = 1,
	PremiumExclusiveRepeal                   = 2,
	EM1BattlePassLevelReason_MAX             = 3,
};

// Enum M1Data.EM1BattlePassReason
// NumValues: 0x0010
enum class EM1BattlePassReason : uint32
{
	Fail                                     = 0,
	Success                                  = 1,
	InvalidSeason                            = 2,
	AlreadyGetPremium                        = 3,
	UnknownError                             = 4,
	InvalidData                              = 5,
	NotEnoughResource                        = 6,
	InvalidCurrency                          = 7,
	TryLevelUpOver                           = 8,
	AlreadyBuyBundle                         = 9,
	OldSeasonNotCompleted                    = 10,
	CantBuyLevelCauseOver                    = 11,
	AlreadyGetPremiumExlusiveReward          = 12,
	CantGetReward                            = 13,
	AdjustmentPeriod                         = 14,
	EM1BattlePassReason_MAX                  = 15,
};

// Enum M1Data.EM1CodexTrackingType
// NumValues: 0x0006
enum class EM1CodexTrackingType : uint8
{
	None                                     = 0,
	Research                                 = 1,
	Consumable                               = 2,
	Rune                                     = 3,
	Equipment                                = 4,
	EM1CodexTrackingType_MAX                 = 5,
};

// Enum M1Data.EM1RequestSupportReason
// NumValues: 0x0009
enum class EM1RequestSupportReason : uint32
{
	Unknown                                  = 0,
	Success                                  = 1,
	NoDedi                                   = 2,
	NoUser                                   = 3,
	Fail_RequesterNotFound                   = 4,
	Fail_RequesterDediNotFound               = 5,
	Fail_Exception                           = 6,
	Fail_InvalidMapType                      = 7,
	EM1RequestSupportReason_MAX              = 8,
};

// Enum M1Data.EM1PresetReason
// NumValues: 0x000D
enum class EM1PresetReason : uint32
{
	Unknown                                  = 0,
	Success                                  = 1,
	NameTooLong                              = 2,
	NameSlang                                = 3,
	AccountNotExist                          = 4,
	PresetSlotInsufficient                   = 5,
	PresetIndexInvalid                       = 6,
	PresetNotExist                           = 7,
	PlayerDataInvalid                        = 8,
	PlayerChangeFailed                       = 9,
	PlayerNotExist                           = 10,
	InventoryLimitOver                       = 11,
	EM1PresetReason_MAX                      = 12,
};

// Enum M1Data.EM1LoginResultType
// NumValues: 0x0015
enum class EM1LoginResultType : uint32
{
	Fail                                     = 0,
	Success                                  = 1,
	VersionMismatched                        = 2,
	UserNameIsInvalid                        = 3,
	UserNameIsDuplicated                     = 4,
	UserIsAlreadyLoggedIn                    = 5,
	InvalidLinkData                          = 6,
	InvalidAuthValue                         = 7,
	InvalidToken                             = 8,
	ExpiredToken                             = 9,
	HackedUser                               = 10,
	UserBanned                               = 11,
	GameServerCountZero                      = 12,
	GameServerNotFound                       = 13,
	DuplicateLogin                           = 14,
	PSDataShareOff                           = 15,
	GameServerChecksumMismatched             = 16,
	WaitInitialize                           = 17,
	WaitLoginQueue                           = 18,
	NoAvailableShard                         = 19,
	EM1LoginResultType_MAX                   = 20,
};

// Enum M1Data.EM1SystemMessageType
// NumValues: 0x0006
enum class EM1SystemMessageType : uint32
{
	WillRelocateDedicateServer               = 0,
	InDeprecateServer                        = 1,
	InDeprecateServerLimitContents           = 2,
	TargetDeprecateServer                    = 3,
	KickAllUer                               = 4,
	EM1SystemMessageType_MAX                 = 5,
};

// Enum M1Data.EM1DediPlatformTag
// NumValues: 0x0004
enum class EM1DediPlatformTag : uint8
{
	ALL                                      = 0,
	PS                                       = 1,
	XBOX                                     = 2,
	EM1DediPlatformTag_MAX                   = 3,
};

// Enum M1Data.EM1OsTypes
// NumValues: 0x000A
enum class EM1OsTypes : uint32
{
	Unknown                                  = 0,
	IOS                                      = 1,
	Android                                  = 2,
	Windows                                  = 3,
	Xbox                                     = 4,
	PS                                       = 5,
	Switch                                   = 6,
	Mac                                      = 7,
	Linux                                    = 8,
	EM1OsTypes_MAX                           = 9,
};

// Enum M1Data.EM1DedicatedServerType
// NumValues: 0x0004
enum class EM1DedicatedServerType : uint8
{
	None                                     = 0,
	City                                     = 1,
	Field                                    = 2,
	EM1DedicatedServerType_MAX               = 3,
};

// Enum M1Data.EM1JoinDedicatedServerReason
// NumValues: 0x0013
enum class EM1JoinDedicatedServerReason : uint32
{
	Unknown                                  = 0,
	Success                                  = 1,
	DediNotReady                             = 2,
	HasParty                                 = 3,
	InvalidMapData                           = 4,
	NotUnlockedMap                           = 5,
	InvalidDediOid                           = 6,
	ReserveFail                              = 7,
	TestReserveFail                          = 8,
	InvalidOid                               = 9,
	WorkingDbNotFound                        = 10,
	CheckUpFieldOptionFail                   = 11,
	NowMatching                              = 12,
	GameServerMove                           = 13,
	InstanceDungeonEntranceFail              = 14,
	NgsInitialize                            = 15,
	RelocateFail                             = 16,
	FinishedPrevious                         = 17,
	EM1JoinDedicatedServerReason_MAX         = 18,
};

// Enum M1Data.EM1XBOXInnerOptionType
// NumValues: 0x0004
enum class EM1XBOXInnerOptionType : uint32
{
	Everyone                                 = 0,
	XboxFriends                              = 1,
	Blocked                                  = 2,
	EM1XBOXInnerOptionType_MAX               = 3,
};

// Enum M1Data.EM1XBOXOuterOptionType
// NumValues: 0x0004
enum class EM1XBOXOuterOptionType : uint32
{
	Everyone                                 = 0,
	InGameFriends                            = 1,
	Blocked                                  = 2,
	EM1XBOXOuterOptionType_MAX               = 3,
};

// Enum M1Data.EM1SearchType
// NumValues: 0x0009
enum class EM1SearchType : uint8
{
	Base                                     = 0,
	PlatformFriendList                       = 1,
	InviteFriend                             = 2,
	InviteParty                              = 3,
	SocialUserList                           = 4,
	SocialRecentList                         = 5,
	SocialInGameFriendList                   = 6,
	SocialBlockList                          = 7,
	EM1SearchType_MAX                        = 8,
};

// Enum M1Data.EM1SearchErrorCode
// NumValues: 0x0009
enum class EM1SearchErrorCode : uint8
{
	Unknown                                  = 0,
	Success                                  = 1,
	EmptyName                                = 2,
	SelfSearch                               = 3,
	NotFound                                 = 4,
	Offline                                  = 5,
	ServerDown                               = 6,
	Busy                                     = 7,
	EM1SearchErrorCode_MAX                   = 8,
};

// Enum M1Data.EM1PartyContentsType
// NumValues: 0x0006
enum class EM1PartyContentsType : uint32
{
	Request                                  = 0,
	Accept                                   = 1,
	MemberChange                             = 2,
	Join                                     = 3,
	Move                                     = 4,
	EM1PartyContentsType_MAX                 = 5,
};

// Enum M1Data.EM1PartyErrorCode
// NumValues: 0x002B
enum class EM1PartyErrorCode : uint32
{
	Unknown                                  = 0,
	ServerDown                               = 1,
	NotFound                                 = 2,
	Success                                  = 3,
	FullParty                                = 4,
	AlreadyParty                             = 5,
	RequestFull                              = 6,
	RequestAlready                           = 7,
	RequestAccept                            = 8,
	RequestReject                            = 9,
	RequestAutoReject                        = 10,
	RequestTimeOut                           = 11,
	MasterOnly                               = 12,
	CityOnly                                 = 13,
	NeedUnlock                               = 14,
	Join                                     = 15,
	Leave                                    = 16,
	Exile                                    = 17,
	MasterChange                             = 18,
	Break                                    = 19,
	MoveFailed                               = 20,
	SameField                                = 21,
	WaitPartyMember                          = 22,
	FieldUnlockPartyMember                   = 23,
	Matching                                 = 24,
	Wait                                     = 25,
	FieldOptionCheckFail                     = 26,
	Block                                    = 27,
	TargetBlock                              = 28,
	CrossPlayOff                             = 29,
	MyCrossPlayOff                           = 30,
	TargetCrossPlayOff                       = 31,
	SocialOff                                = 32,
	FailEntrantCondition                     = 33,
	FailEntrantConditionPartyMember          = 34,
	Laboratory                               = 35,
	NotMatchedVersion                        = 36,
	TargetNotMatchedVersion                  = 37,
	MustPrologue                             = 37,
	LobbyOnly                                = 38,
	SelfRequest                              = 39,
	FullSession                              = 40,
	EM1PartyErrorCode_MAX                    = 41,
};

// Enum M1Data.EM1FriendContentsType
// NumValues: 0x0006
enum class EM1FriendContentsType : uint32
{
	Request                                  = 0,
	Accept                                   = 1,
	Delete                                   = 2,
	Bookmark                                 = 3,
	Reject                                   = 4,
	EM1FriendContentsType_MAX                = 5,
};

// Enum M1Data.EM1FriendErrorCode
// NumValues: 0x0014
enum class EM1FriendErrorCode : uint32
{
	Fail                                     = 0,
	NotFoundUser                             = 1,
	NotFoundFriend                           = 2,
	NotFoundRequest                          = 3,
	Self                                     = 4,
	MyBlock                                  = 5,
	TargetBlock                              = 6,
	AlreadyRequested                         = 7,
	AlreadyFriend                            = 8,
	DuplicateBookmark                        = 9,
	MyFriendFull                             = 10,
	TargetFriendFull                         = 11,
	TargetRequestFull                        = 12,
	Success                                  = 13,
	Proxy                                    = 14,
	CrossPlayOff                             = 15,
	MyCrossPlayOff                           = 16,
	TargetCrossPlayOff                       = 17,
	SocialOff                                = 18,
	EM1FriendErrorCode_MAX                   = 19,
};

// Enum M1Data.EM1BlockErrorCode
// NumValues: 0x0009
enum class EM1BlockErrorCode : uint32
{
	Fail                                     = 0,
	Regist                                   = 1,
	Unregist                                 = 2,
	Duplicate                                = 3,
	Busy                                     = 4,
	Full                                     = 5,
	Self                                     = 6,
	ServerDown                               = 7,
	EM1BlockErrorCode_MAX                    = 8,
};

// Enum M1Data.EM1ChattingErrorCode
// NumValues: 0x0014
enum class EM1ChattingErrorCode : uint32
{
	ServerDown                               = 18446744073709551615,
	Unknown                                  = 0,
	Success                                  = 1,
	Reject                                   = 2,
	NotFound                                 = 3,
	Self                                     = 4,
	MessageEmpty                             = 5,
	Slang                                    = 6,
	Busy                                     = 7,
	NotParty                                 = 8,
	OverLength                               = 9,
	Offline                                  = 10,
	Block                                    = 11,
	CrossPlayOff                             = 12,
	MyCrossPlayOff                           = 13,
	TargetCrossPlayOff                       = 14,
	SocialOff                                = 15,
	Ban                                      = 16,
	Wait                                     = 17,
	EM1ChattingErrorCode_MAX                 = 18,
};

// Enum M1Data.EM1SupportReason
// NumValues: 0x0005
enum class EM1SupportReason : uint32
{
	Fail                                     = 0,
	Success                                  = 1,
	NotMatchedVersion                        = 2,
	TargetNotMatchedVersion                  = 3,
	EM1SupportReason_MAX                     = 4,
};

// Enum M1Data.EM1UserState
// NumValues: 0x0006
enum class EM1UserState : uint8
{
	Reserved                                 = 0,
	Moved                                    = 1,
	InGame                                   = 2,
	Kicked                                   = 3,
	ReconnectWait                            = 4,
	EM1UserState_MAX                         = 5,
};

// Enum M1Data.EM1KickType
// NumValues: 0x0007
enum class EM1KickType : uint32
{
	SystemError                              = 0,
	SystemBan                                = 1,
	DuplicateLogin                           = 2,
	DedicateServerError                      = 3,
	NgsInitialize                            = 4,
	NeedUpdate                               = 5,
	EM1KickType_MAX                          = 6,
};

// Enum M1Data.EM1BanType
// NumValues: 0x0003
enum class EM1BanType : uint8
{
	Account                                  = 0,
	Chat                                     = 1,
	EM1BanType_MAX                           = 2,
};

// Enum M1Data.EM1ReportReasonType
// NumValues: 0x000A
enum class EM1ReportReasonType : uint32
{
	Unknown                                  = 0,
	Abuse                                    = 1,
	Advertisement                            = 2,
	NickName                                 = 3,
	BadManner                                = 4,
	Illegal                                  = 5,
	Bug                                      = 6,
	Etc                                      = 7,
	Afk                                      = 8,
	EM1ReportReasonType_MAX                  = 9,
};

// Enum M1Data.EM1ReportErrorCode
// NumValues: 0x0006
enum class EM1ReportErrorCode : uint32
{
	Unknown                                  = 0,
	Success                                  = 1,
	InvalidAccountId                         = 2,
	ServerDown                               = 3,
	AlreadyReported                          = 4,
	EM1ReportErrorCode_MAX                   = 5,
};

// Enum M1Data.EM1InputMethod
// NumValues: 0x0004
enum class EM1InputMethod : uint8
{
	MouseAndKeyboard                         = 0,
	GamepadXBOX                              = 1,
	GamepadPS                                = 2,
	EM1InputMethod_MAX                       = 3,
};

// Enum M1Data.EM1AnnouncementType
// NumValues: 0x0004
enum class EM1AnnouncementType : uint32
{
	Chat                                     = 0,
	Information                              = 1,
	Emergency                                = 2,
	EM1AnnouncementType_MAX                  = 3,
};

// ScriptStruct M1Data.DataLinkBase
// 0x0028 (0x0028 - 0x0000)
struct FDataLinkBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UM1DataTable*                           Table;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x18];                                      // 0x0010(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDataLinkBase) == 0x000008, "Wrong alignment on FDataLinkBase");
static_assert(sizeof(FDataLinkBase) == 0x000028, "Wrong size on FDataLinkBase");
static_assert(offsetof(FDataLinkBase, Table) == 0x000008, "Member 'FDataLinkBase::Table' has a wrong offset!");

// ScriptStruct M1Data.DataLink
// 0x0008 (0x0030 - 0x0028)
struct FDataLink : public FDataLinkBase
{
public:
	class FName                                   RowName;                                           // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDataLink) == 0x000008, "Wrong alignment on FDataLink");
static_assert(sizeof(FDataLink) == 0x000030, "Wrong size on FDataLink");
static_assert(offsetof(FDataLink, RowName) == 0x000028, "Member 'FDataLink::RowName' has a wrong offset!");

// ScriptStruct M1Data.M1RuneClassTypeDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1RuneClassTypeDataLink final : public FDataLink
{
};
static_assert(alignof(FM1RuneClassTypeDataLink) == 0x000008, "Wrong alignment on FM1RuneClassTypeDataLink");
static_assert(sizeof(FM1RuneClassTypeDataLink) == 0x000030, "Wrong size on FM1RuneClassTypeDataLink");

// ScriptStruct M1Data.M1TemplateId
// 0x0004 (0x0004 - 0x0000)
struct FM1TemplateId final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, SimpleDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1TemplateId) == 0x000004, "Wrong alignment on FM1TemplateId");
static_assert(sizeof(FM1TemplateId) == 0x000004, "Wrong size on FM1TemplateId");
static_assert(offsetof(FM1TemplateId, ID) == 0x000000, "Member 'FM1TemplateId::ID' has a wrong offset!");

// ScriptStruct M1Data.M1InstanceDungeonStartAttribute
// 0x0010 (0x0010 - 0x0000)
struct FM1InstanceDungeonStartAttribute final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          InstanceDungeonRewardTid;                          // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1InstanceDungeonStartAttribute) == 0x000008, "Wrong alignment on FM1InstanceDungeonStartAttribute");
static_assert(sizeof(FM1InstanceDungeonStartAttribute) == 0x000010, "Wrong size on FM1InstanceDungeonStartAttribute");
static_assert(offsetof(FM1InstanceDungeonStartAttribute, AccountUid) == 0x000000, "Member 'FM1InstanceDungeonStartAttribute::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonStartAttribute, InstanceDungeonRewardTid) == 0x000008, "Member 'FM1InstanceDungeonStartAttribute::InstanceDungeonRewardTid' has a wrong offset!");

// ScriptStruct M1Data.M1RunePosition
// 0x0010 (0x0010 - 0x0000)
struct FM1RunePosition final
{
public:
	int64                                         RuneUid;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RuneSubClassType                           RuneSubClassType;                                  // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SocketIndex;                                       // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RunePosition) == 0x000008, "Wrong alignment on FM1RunePosition");
static_assert(sizeof(FM1RunePosition) == 0x000010, "Wrong size on FM1RunePosition");
static_assert(offsetof(FM1RunePosition, RuneUid) == 0x000000, "Member 'FM1RunePosition::RuneUid' has a wrong offset!");
static_assert(offsetof(FM1RunePosition, RuneSubClassType) == 0x000008, "Member 'FM1RunePosition::RuneSubClassType' has a wrong offset!");
static_assert(offsetof(FM1RunePosition, SocketIndex) == 0x000009, "Member 'FM1RunePosition::SocketIndex' has a wrong offset!");

// ScriptStruct M1Data.M1ItemInfoBox
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FM1ItemInfoBox final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ItemInfoBox) == 0x000008, "Wrong alignment on FM1ItemInfoBox");
static_assert(sizeof(FM1ItemInfoBox) == 0x000030, "Wrong size on FM1ItemInfoBox");

// ScriptStruct M1Data.M1BoostExpData
// 0x0010 (0x0010 - 0x0000)
struct FM1BoostExpData final
{
public:
	EM1BoostType                                  Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         BoostExp;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BoostExpData) == 0x000008, "Wrong alignment on FM1BoostExpData");
static_assert(sizeof(FM1BoostExpData) == 0x000010, "Wrong size on FM1BoostExpData");
static_assert(offsetof(FM1BoostExpData, Type) == 0x000000, "Member 'FM1BoostExpData::Type' has a wrong offset!");
static_assert(offsetof(FM1BoostExpData, BoostExp) == 0x000008, "Member 'FM1BoostExpData::BoostExp' has a wrong offset!");

// ScriptStruct M1Data.M1CharacterAddExpNoti
// 0x0030 (0x0030 - 0x0000)
struct FM1CharacterAddExpNoti final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          PlayerTid;                                         // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Exp;                                               // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         BoostExp;                                          // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1BoostExpData>                BoostDataList;                                     // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CharacterAddExpNoti) == 0x000008, "Wrong alignment on FM1CharacterAddExpNoti");
static_assert(sizeof(FM1CharacterAddExpNoti) == 0x000030, "Wrong size on FM1CharacterAddExpNoti");
static_assert(offsetof(FM1CharacterAddExpNoti, AccountUid) == 0x000000, "Member 'FM1CharacterAddExpNoti::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1CharacterAddExpNoti, PlayerTid) == 0x000008, "Member 'FM1CharacterAddExpNoti::PlayerTid' has a wrong offset!");
static_assert(offsetof(FM1CharacterAddExpNoti, Exp) == 0x000010, "Member 'FM1CharacterAddExpNoti::Exp' has a wrong offset!");
static_assert(offsetof(FM1CharacterAddExpNoti, BoostExp) == 0x000018, "Member 'FM1CharacterAddExpNoti::BoostExp' has a wrong offset!");
static_assert(offsetof(FM1CharacterAddExpNoti, BoostDataList) == 0x000020, "Member 'FM1CharacterAddExpNoti::BoostDataList' has a wrong offset!");

// ScriptStruct M1Data.M1ItemUIData
// 0x0060 (0x0060 - 0x0000)
struct FM1ItemUIData final
{
public:
	struct FSoftObjectPath                        IconPath;                                          // 0x0000(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconBigPath;                                       // 0x0020(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconSmallPath;                                     // 0x0040(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemUIData) == 0x000008, "Wrong alignment on FM1ItemUIData");
static_assert(sizeof(FM1ItemUIData) == 0x000060, "Wrong size on FM1ItemUIData");
static_assert(offsetof(FM1ItemUIData, IconPath) == 0x000000, "Member 'FM1ItemUIData::IconPath' has a wrong offset!");
static_assert(offsetof(FM1ItemUIData, IconBigPath) == 0x000020, "Member 'FM1ItemUIData::IconBigPath' has a wrong offset!");
static_assert(offsetof(FM1ItemUIData, IconSmallPath) == 0x000040, "Member 'FM1ItemUIData::IconSmallPath' has a wrong offset!");

// ScriptStruct M1Data.M1ItemTidBox
// 0x0008 (0x0008 - 0x0000)
struct FM1ItemTidBox final
{
public:
	EM1ItemType                                   Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TemplateId;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemTidBox) == 0x000004, "Wrong alignment on FM1ItemTidBox");
static_assert(sizeof(FM1ItemTidBox) == 0x000008, "Wrong size on FM1ItemTidBox");
static_assert(offsetof(FM1ItemTidBox, Type) == 0x000000, "Member 'FM1ItemTidBox::Type' has a wrong offset!");
static_assert(offsetof(FM1ItemTidBox, TemplateId) == 0x000004, "Member 'FM1ItemTidBox::TemplateId' has a wrong offset!");

// ScriptStruct M1Data.M1PresetWearingInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1PresetWearingInfo final
{
public:
	EM1PresetSlotType                             SlotIndex;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ItemUid;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemTidBox                          ItemTid;                                           // 0x0010(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LoadoutSlotIndex;                                  // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PresetWearingInfo) == 0x000008, "Wrong alignment on FM1PresetWearingInfo");
static_assert(sizeof(FM1PresetWearingInfo) == 0x000020, "Wrong size on FM1PresetWearingInfo");
static_assert(offsetof(FM1PresetWearingInfo, SlotIndex) == 0x000000, "Member 'FM1PresetWearingInfo::SlotIndex' has a wrong offset!");
static_assert(offsetof(FM1PresetWearingInfo, ItemUid) == 0x000008, "Member 'FM1PresetWearingInfo::ItemUid' has a wrong offset!");
static_assert(offsetof(FM1PresetWearingInfo, ItemTid) == 0x000010, "Member 'FM1PresetWearingInfo::ItemTid' has a wrong offset!");
static_assert(offsetof(FM1PresetWearingInfo, Level) == 0x000018, "Member 'FM1PresetWearingInfo::Level' has a wrong offset!");
static_assert(offsetof(FM1PresetWearingInfo, LoadoutSlotIndex) == 0x00001C, "Member 'FM1PresetWearingInfo::LoadoutSlotIndex' has a wrong offset!");

// ScriptStruct M1Data.M1PresetInfo
// 0x0030 (0x0030 - 0x0000)
struct FM1PresetInfo final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PresetIndex;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PresetName;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1PresetWearingInfo>           WearingList;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PresetInfo) == 0x000008, "Wrong alignment on FM1PresetInfo");
static_assert(sizeof(FM1PresetInfo) == 0x000030, "Wrong size on FM1PresetInfo");
static_assert(offsetof(FM1PresetInfo, AccountUid) == 0x000000, "Member 'FM1PresetInfo::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1PresetInfo, PresetIndex) == 0x000008, "Member 'FM1PresetInfo::PresetIndex' has a wrong offset!");
static_assert(offsetof(FM1PresetInfo, PresetName) == 0x000010, "Member 'FM1PresetInfo::PresetName' has a wrong offset!");
static_assert(offsetof(FM1PresetInfo, WearingList) == 0x000020, "Member 'FM1PresetInfo::WearingList' has a wrong offset!");

// ScriptStruct M1Data.M1ApplyPresetRes
// 0x0038 (0x0038 - 0x0000)
struct FM1ApplyPresetRes final
{
public:
	EM1PresetReason                               Reason;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1PresetInfo                          PresetInfo;                                        // 0x0008(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ApplyPresetRes) == 0x000008, "Wrong alignment on FM1ApplyPresetRes");
static_assert(sizeof(FM1ApplyPresetRes) == 0x000038, "Wrong size on FM1ApplyPresetRes");
static_assert(offsetof(FM1ApplyPresetRes, Reason) == 0x000000, "Member 'FM1ApplyPresetRes::Reason' has a wrong offset!");
static_assert(offsetof(FM1ApplyPresetRes, PresetInfo) == 0x000008, "Member 'FM1ApplyPresetRes::PresetInfo' has a wrong offset!");

// ScriptStruct M1Data.M1CharacterInfo
// 0x0028 (0x0028 - 0x0000)
struct FM1CharacterInfo final
{
public:
	int64                                         Uid;                                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          Tid;                                               // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Exp;                                               // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLevel;                                          // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResetCount;                                        // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CharacterInfo) == 0x000008, "Wrong alignment on FM1CharacterInfo");
static_assert(sizeof(FM1CharacterInfo) == 0x000028, "Wrong size on FM1CharacterInfo");
static_assert(offsetof(FM1CharacterInfo, Uid) == 0x000000, "Member 'FM1CharacterInfo::Uid' has a wrong offset!");
static_assert(offsetof(FM1CharacterInfo, Tid) == 0x000008, "Member 'FM1CharacterInfo::Tid' has a wrong offset!");
static_assert(offsetof(FM1CharacterInfo, Exp) == 0x000010, "Member 'FM1CharacterInfo::Exp' has a wrong offset!");
static_assert(offsetof(FM1CharacterInfo, Level) == 0x000018, "Member 'FM1CharacterInfo::Level' has a wrong offset!");
static_assert(offsetof(FM1CharacterInfo, MaxLevel) == 0x00001C, "Member 'FM1CharacterInfo::MaxLevel' has a wrong offset!");
static_assert(offsetof(FM1CharacterInfo, ResetCount) == 0x000020, "Member 'FM1CharacterInfo::ResetCount' has a wrong offset!");

// ScriptStruct M1Data.M1PartyRequestInfo
// 0x0070 (0x0070 - 0x0000)
struct FM1PartyRequestInfo final
{
public:
	class FString                                 SeqId;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         AccountUid;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccountName;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MasteryLevel;                                      // 0x0028(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         AuthValue;                                         // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          CharacterTid;                                      // 0x0038(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         CharacterLevel;                                    // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ElapsedTimeSec;                                    // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlatformId;                                        // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         PlatfromUid;                                       // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         PlatformType;                                      // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CrossPlayOn;                                       // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PartyRequestInfo) == 0x000008, "Wrong alignment on FM1PartyRequestInfo");
static_assert(sizeof(FM1PartyRequestInfo) == 0x000070, "Wrong size on FM1PartyRequestInfo");
static_assert(offsetof(FM1PartyRequestInfo, SeqId) == 0x000000, "Member 'FM1PartyRequestInfo::SeqId' has a wrong offset!");
static_assert(offsetof(FM1PartyRequestInfo, AccountUid) == 0x000010, "Member 'FM1PartyRequestInfo::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1PartyRequestInfo, AccountName) == 0x000018, "Member 'FM1PartyRequestInfo::AccountName' has a wrong offset!");
static_assert(offsetof(FM1PartyRequestInfo, MasteryLevel) == 0x000028, "Member 'FM1PartyRequestInfo::MasteryLevel' has a wrong offset!");
static_assert(offsetof(FM1PartyRequestInfo, AuthValue) == 0x000030, "Member 'FM1PartyRequestInfo::AuthValue' has a wrong offset!");
static_assert(offsetof(FM1PartyRequestInfo, CharacterTid) == 0x000038, "Member 'FM1PartyRequestInfo::CharacterTid' has a wrong offset!");
static_assert(offsetof(FM1PartyRequestInfo, CharacterLevel) == 0x000040, "Member 'FM1PartyRequestInfo::CharacterLevel' has a wrong offset!");
static_assert(offsetof(FM1PartyRequestInfo, ElapsedTimeSec) == 0x000048, "Member 'FM1PartyRequestInfo::ElapsedTimeSec' has a wrong offset!");
static_assert(offsetof(FM1PartyRequestInfo, PlatformId) == 0x000050, "Member 'FM1PartyRequestInfo::PlatformId' has a wrong offset!");
static_assert(offsetof(FM1PartyRequestInfo, PlatfromUid) == 0x000060, "Member 'FM1PartyRequestInfo::PlatfromUid' has a wrong offset!");
static_assert(offsetof(FM1PartyRequestInfo, PlatformType) == 0x000068, "Member 'FM1PartyRequestInfo::PlatformType' has a wrong offset!");
static_assert(offsetof(FM1PartyRequestInfo, CrossPlayOn) == 0x000069, "Member 'FM1PartyRequestInfo::CrossPlayOn' has a wrong offset!");

// ScriptStruct M1Data.M1PartyRequestChangeNoti
// 0x0018 (0x0018 - 0x0000)
struct FM1PartyRequestChangeNoti final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1PartyRequestInfo>            Requests;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PartyRequestChangeNoti) == 0x000008, "Wrong alignment on FM1PartyRequestChangeNoti");
static_assert(sizeof(FM1PartyRequestChangeNoti) == 0x000018, "Wrong size on FM1PartyRequestChangeNoti");
static_assert(offsetof(FM1PartyRequestChangeNoti, AccountUid) == 0x000000, "Member 'FM1PartyRequestChangeNoti::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1PartyRequestChangeNoti, Requests) == 0x000008, "Member 'FM1PartyRequestChangeNoti::Requests' has a wrong offset!");

// ScriptStruct M1Data.M1PaintExtractMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1PaintExtractMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1PaintExtractMiscDataLink) == 0x000008, "Wrong alignment on FM1PaintExtractMiscDataLink");
static_assert(sizeof(FM1PaintExtractMiscDataLink) == 0x000030, "Wrong size on FM1PaintExtractMiscDataLink");

// ScriptStruct M1Data.M1RuneLoadoutSlotName
// 0x0018 (0x0018 - 0x0000)
struct FM1RuneLoadoutSlotName final
{
public:
	uint8                                         LoadoutSlotIndex;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneLoadoutSlotName) == 0x000008, "Wrong alignment on FM1RuneLoadoutSlotName");
static_assert(sizeof(FM1RuneLoadoutSlotName) == 0x000018, "Wrong size on FM1RuneLoadoutSlotName");
static_assert(offsetof(FM1RuneLoadoutSlotName, LoadoutSlotIndex) == 0x000000, "Member 'FM1RuneLoadoutSlotName::LoadoutSlotIndex' has a wrong offset!");
static_assert(offsetof(FM1RuneLoadoutSlotName, Name) == 0x000008, "Member 'FM1RuneLoadoutSlotName::Name' has a wrong offset!");

// ScriptStruct M1Data.M1RuneEquipInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1RuneEquipInfo final
{
public:
	EM1RuneSubClassType                           SubClassType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SocketIndex;                                       // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         RuneUid;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RuneCost;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RuneEquipInfo) == 0x000008, "Wrong alignment on FM1RuneEquipInfo");
static_assert(sizeof(FM1RuneEquipInfo) == 0x000018, "Wrong size on FM1RuneEquipInfo");
static_assert(offsetof(FM1RuneEquipInfo, SubClassType) == 0x000000, "Member 'FM1RuneEquipInfo::SubClassType' has a wrong offset!");
static_assert(offsetof(FM1RuneEquipInfo, SocketIndex) == 0x000001, "Member 'FM1RuneEquipInfo::SocketIndex' has a wrong offset!");
static_assert(offsetof(FM1RuneEquipInfo, RuneUid) == 0x000008, "Member 'FM1RuneEquipInfo::RuneUid' has a wrong offset!");
static_assert(offsetof(FM1RuneEquipInfo, RuneCost) == 0x000010, "Member 'FM1RuneEquipInfo::RuneCost' has a wrong offset!");

// ScriptStruct M1Data.M1RuneSocketInfo
// 0x0003 (0x0003 - 0x0000)
struct FM1RuneSocketInfo final
{
public:
	EM1RuneSubClassType                           SubClassType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SocketIndex;                                       // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RuneSocketType                             RuneSocketType;                                    // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneSocketInfo) == 0x000001, "Wrong alignment on FM1RuneSocketInfo");
static_assert(sizeof(FM1RuneSocketInfo) == 0x000003, "Wrong size on FM1RuneSocketInfo");
static_assert(offsetof(FM1RuneSocketInfo, SubClassType) == 0x000000, "Member 'FM1RuneSocketInfo::SubClassType' has a wrong offset!");
static_assert(offsetof(FM1RuneSocketInfo, SocketIndex) == 0x000001, "Member 'FM1RuneSocketInfo::SocketIndex' has a wrong offset!");
static_assert(offsetof(FM1RuneSocketInfo, RuneSocketType) == 0x000002, "Member 'FM1RuneSocketInfo::RuneSocketType' has a wrong offset!");

// ScriptStruct M1Data.M1RuneLoadoutSlotInfo
// 0x0028 (0x0028 - 0x0000)
struct FM1RuneLoadoutSlotInfo final
{
public:
	uint8                                         LoadoutSlotIndex;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Version;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1RuneEquipInfo>               RuneEquips;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1RuneSocketInfo>              SelectedRuneSockets;                               // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneLoadoutSlotInfo) == 0x000008, "Wrong alignment on FM1RuneLoadoutSlotInfo");
static_assert(sizeof(FM1RuneLoadoutSlotInfo) == 0x000028, "Wrong size on FM1RuneLoadoutSlotInfo");
static_assert(offsetof(FM1RuneLoadoutSlotInfo, LoadoutSlotIndex) == 0x000000, "Member 'FM1RuneLoadoutSlotInfo::LoadoutSlotIndex' has a wrong offset!");
static_assert(offsetof(FM1RuneLoadoutSlotInfo, Version) == 0x000004, "Member 'FM1RuneLoadoutSlotInfo::Version' has a wrong offset!");
static_assert(offsetof(FM1RuneLoadoutSlotInfo, RuneEquips) == 0x000008, "Member 'FM1RuneLoadoutSlotInfo::RuneEquips' has a wrong offset!");
static_assert(offsetof(FM1RuneLoadoutSlotInfo, SelectedRuneSockets) == 0x000018, "Member 'FM1RuneLoadoutSlotInfo::SelectedRuneSockets' has a wrong offset!");

// ScriptStruct M1Data.M1RuneLoadoutInfo
// 0x0050 (0x0050 - 0x0000)
struct FM1RuneLoadoutInfo final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemTidBox                          OwnerTid;                                          // 0x0008(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         SelectedLoadoutSlotIndex;                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCapacityBase;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasAdditionalCapacity;                             // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1RuneLoadoutSlotName>         LoadoutSlotNames;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1RuneLoadoutSlotInfo>         LoadoutSlots;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1RuneSocketInfo>              RuneSockets;                                       // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneLoadoutInfo) == 0x000008, "Wrong alignment on FM1RuneLoadoutInfo");
static_assert(sizeof(FM1RuneLoadoutInfo) == 0x000050, "Wrong size on FM1RuneLoadoutInfo");
static_assert(offsetof(FM1RuneLoadoutInfo, AccountUid) == 0x000000, "Member 'FM1RuneLoadoutInfo::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1RuneLoadoutInfo, OwnerTid) == 0x000008, "Member 'FM1RuneLoadoutInfo::OwnerTid' has a wrong offset!");
static_assert(offsetof(FM1RuneLoadoutInfo, SelectedLoadoutSlotIndex) == 0x000010, "Member 'FM1RuneLoadoutInfo::SelectedLoadoutSlotIndex' has a wrong offset!");
static_assert(offsetof(FM1RuneLoadoutInfo, MaxCapacityBase) == 0x000014, "Member 'FM1RuneLoadoutInfo::MaxCapacityBase' has a wrong offset!");
static_assert(offsetof(FM1RuneLoadoutInfo, HasAdditionalCapacity) == 0x000018, "Member 'FM1RuneLoadoutInfo::HasAdditionalCapacity' has a wrong offset!");
static_assert(offsetof(FM1RuneLoadoutInfo, LoadoutSlotNames) == 0x000020, "Member 'FM1RuneLoadoutInfo::LoadoutSlotNames' has a wrong offset!");
static_assert(offsetof(FM1RuneLoadoutInfo, LoadoutSlots) == 0x000030, "Member 'FM1RuneLoadoutInfo::LoadoutSlots' has a wrong offset!");
static_assert(offsetof(FM1RuneLoadoutInfo, RuneSockets) == 0x000040, "Member 'FM1RuneLoadoutInfo::RuneSockets' has a wrong offset!");

// ScriptStruct M1Data.M1NpcServiceUnlockCondition
// 0x0018 (0x0018 - 0x0000)
struct FM1NpcServiceUnlockCondition final
{
public:
	EM1NpcServiceUnlockConditionType              Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Values;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NpcServiceUnlockCondition) == 0x000008, "Wrong alignment on FM1NpcServiceUnlockCondition");
static_assert(sizeof(FM1NpcServiceUnlockCondition) == 0x000018, "Wrong size on FM1NpcServiceUnlockCondition");
static_assert(offsetof(FM1NpcServiceUnlockCondition, Type) == 0x000000, "Member 'FM1NpcServiceUnlockCondition::Type' has a wrong offset!");
static_assert(offsetof(FM1NpcServiceUnlockCondition, Values) == 0x000008, "Member 'FM1NpcServiceUnlockCondition::Values' has a wrong offset!");

// ScriptStruct M1Data.M1NpcService
// 0x0050 (0x0050 - 0x0000)
struct FM1NpcService final
{
public:
	class FName                                   StringId;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1NpcServiceType                             ServiceType;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServiceValue;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         WidgetClass;                                       // 0x0020(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1NpcServiceUnlockCondition>   UnlockConditions;                                  // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NpcService) == 0x000008, "Wrong alignment on FM1NpcService");
static_assert(sizeof(FM1NpcService) == 0x000050, "Wrong size on FM1NpcService");
static_assert(offsetof(FM1NpcService, StringId) == 0x000000, "Member 'FM1NpcService::StringId' has a wrong offset!");
static_assert(offsetof(FM1NpcService, ServiceType) == 0x000008, "Member 'FM1NpcService::ServiceType' has a wrong offset!");
static_assert(offsetof(FM1NpcService, ServiceValue) == 0x000010, "Member 'FM1NpcService::ServiceValue' has a wrong offset!");
static_assert(offsetof(FM1NpcService, WidgetClass) == 0x000020, "Member 'FM1NpcService::WidgetClass' has a wrong offset!");
static_assert(offsetof(FM1NpcService, UnlockConditions) == 0x000040, "Member 'FM1NpcService::UnlockConditions' has a wrong offset!");

// ScriptStruct M1Data.M1NpcSpawnParam
// 0x000C (0x000C - 0x0000)
struct FM1NpcSpawnParam final
{
public:
	EM1NpcSpawnConditionType                      ConditionType;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ConditionValue;                                    // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NpcSpawnParam) == 0x000004, "Wrong alignment on FM1NpcSpawnParam");
static_assert(sizeof(FM1NpcSpawnParam) == 0x00000C, "Wrong size on FM1NpcSpawnParam");
static_assert(offsetof(FM1NpcSpawnParam, ConditionType) == 0x000000, "Member 'FM1NpcSpawnParam::ConditionType' has a wrong offset!");
static_assert(offsetof(FM1NpcSpawnParam, ConditionValue) == 0x000004, "Member 'FM1NpcSpawnParam::ConditionValue' has a wrong offset!");

// ScriptStruct M1Data.M1NpcDespawnParam
// 0x0014 (0x0014 - 0x0000)
struct FM1NpcDespawnParam final
{
public:
	EM1NpcSpawnConditionType                      ConditionType;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ConditionValue;                                    // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReplacementNpcName;                                // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NpcDespawnParam) == 0x000004, "Wrong alignment on FM1NpcDespawnParam");
static_assert(sizeof(FM1NpcDespawnParam) == 0x000014, "Wrong size on FM1NpcDespawnParam");
static_assert(offsetof(FM1NpcDespawnParam, ConditionType) == 0x000000, "Member 'FM1NpcDespawnParam::ConditionType' has a wrong offset!");
static_assert(offsetof(FM1NpcDespawnParam, ConditionValue) == 0x000004, "Member 'FM1NpcDespawnParam::ConditionValue' has a wrong offset!");
static_assert(offsetof(FM1NpcDespawnParam, ReplacementNpcName) == 0x00000C, "Member 'FM1NpcDespawnParam::ReplacementNpcName' has a wrong offset!");

// ScriptStruct M1Data.M1NpcSpawnPeriod
// 0x0010 (0x0010 - 0x0000)
struct FM1NpcSpawnPeriod final
{
public:
	class FName                                   Start;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   End;                                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NpcSpawnPeriod) == 0x000004, "Wrong alignment on FM1NpcSpawnPeriod");
static_assert(sizeof(FM1NpcSpawnPeriod) == 0x000010, "Wrong size on FM1NpcSpawnPeriod");
static_assert(offsetof(FM1NpcSpawnPeriod, Start) == 0x000000, "Member 'FM1NpcSpawnPeriod::Start' has a wrong offset!");
static_assert(offsetof(FM1NpcSpawnPeriod, End) == 0x000008, "Member 'FM1NpcSpawnPeriod::End' has a wrong offset!");

// ScriptStruct M1Data.M1NpcDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1NpcDataLink final : public FDataLink
{
};
static_assert(alignof(FM1NpcDataLink) == 0x000008, "Wrong alignment on FM1NpcDataLink");
static_assert(sizeof(FM1NpcDataLink) == 0x000030, "Wrong size on FM1NpcDataLink");

// ScriptStruct M1Data.M1NpcSpawnInfo
// 0x0040 (0x0040 - 0x0000)
struct FM1NpcSpawnInfo final
{
public:
	TArray<struct FM1NpcSpawnPeriod>              SpawnPeriods;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1NpcDataLink                         ReplacementNpc;                                    // 0x0010(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NpcSpawnInfo) == 0x000008, "Wrong alignment on FM1NpcSpawnInfo");
static_assert(sizeof(FM1NpcSpawnInfo) == 0x000040, "Wrong size on FM1NpcSpawnInfo");
static_assert(offsetof(FM1NpcSpawnInfo, SpawnPeriods) == 0x000000, "Member 'FM1NpcSpawnInfo::SpawnPeriods' has a wrong offset!");
static_assert(offsetof(FM1NpcSpawnInfo, ReplacementNpc) == 0x000010, "Member 'FM1NpcSpawnInfo::ReplacementNpc' has a wrong offset!");

// ScriptStruct M1Data.M1NpcData
// 0x0100 (0x0108 - 0x0008)
struct FM1NpcData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringIdName;                                      // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringIdButtonName;                                // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         BlueprintClass;                                    // 0x0020(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1NpcSpawnType                               SpawnType;                                         // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NameTagOffset;                                     // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        HudIcon;                                           // 0x0048(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MapIcon;                                           // 0x0068(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowMapIcon;                                       // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkipNpcMenu;                                       // 0x0089(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1NpcService>                  Services;                                          // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1NpcSpawnParam>               SpawnParams;                                       // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1NpcDespawnParam>             DespawnParams;                                     // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Collision;                                         // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1NpcSpawnInfo                        SpawnInfo;                                         // 0x00C8(0x0040)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NpcData) == 0x000008, "Wrong alignment on FM1NpcData");
static_assert(sizeof(FM1NpcData) == 0x000108, "Wrong size on FM1NpcData");
static_assert(offsetof(FM1NpcData, TemplateId) == 0x000008, "Member 'FM1NpcData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1NpcData, StringIdName) == 0x00000C, "Member 'FM1NpcData::StringIdName' has a wrong offset!");
static_assert(offsetof(FM1NpcData, StringIdButtonName) == 0x000014, "Member 'FM1NpcData::StringIdButtonName' has a wrong offset!");
static_assert(offsetof(FM1NpcData, BlueprintClass) == 0x000020, "Member 'FM1NpcData::BlueprintClass' has a wrong offset!");
static_assert(offsetof(FM1NpcData, SpawnType) == 0x000040, "Member 'FM1NpcData::SpawnType' has a wrong offset!");
static_assert(offsetof(FM1NpcData, NameTagOffset) == 0x000044, "Member 'FM1NpcData::NameTagOffset' has a wrong offset!");
static_assert(offsetof(FM1NpcData, HudIcon) == 0x000048, "Member 'FM1NpcData::HudIcon' has a wrong offset!");
static_assert(offsetof(FM1NpcData, MapIcon) == 0x000068, "Member 'FM1NpcData::MapIcon' has a wrong offset!");
static_assert(offsetof(FM1NpcData, ShowMapIcon) == 0x000088, "Member 'FM1NpcData::ShowMapIcon' has a wrong offset!");
static_assert(offsetof(FM1NpcData, SkipNpcMenu) == 0x000089, "Member 'FM1NpcData::SkipNpcMenu' has a wrong offset!");
static_assert(offsetof(FM1NpcData, Services) == 0x000090, "Member 'FM1NpcData::Services' has a wrong offset!");
static_assert(offsetof(FM1NpcData, SpawnParams) == 0x0000A0, "Member 'FM1NpcData::SpawnParams' has a wrong offset!");
static_assert(offsetof(FM1NpcData, DespawnParams) == 0x0000B0, "Member 'FM1NpcData::DespawnParams' has a wrong offset!");
static_assert(offsetof(FM1NpcData, Collision) == 0x0000C0, "Member 'FM1NpcData::Collision' has a wrong offset!");
static_assert(offsetof(FM1NpcData, SpawnInfo) == 0x0000C8, "Member 'FM1NpcData::SpawnInfo' has a wrong offset!");

// ScriptStruct M1Data.M1PlatformBlockUser
// 0x0008 (0x0008 - 0x0000)
struct FM1PlatformBlockUser final
{
public:
	int64                                         PlatformUid;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PlatformBlockUser) == 0x000008, "Wrong alignment on FM1PlatformBlockUser");
static_assert(sizeof(FM1PlatformBlockUser) == 0x000008, "Wrong size on FM1PlatformBlockUser");
static_assert(offsetof(FM1PlatformBlockUser, PlatformUid) == 0x000000, "Member 'FM1PlatformBlockUser::PlatformUid' has a wrong offset!");

// ScriptStruct M1Data.M1PlatformBlockList
// 0x0010 (0x0010 - 0x0000)
struct FM1PlatformBlockList final
{
public:
	TArray<struct FM1PlatformBlockUser>           Users;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PlatformBlockList) == 0x000008, "Wrong alignment on FM1PlatformBlockList");
static_assert(sizeof(FM1PlatformBlockList) == 0x000010, "Wrong size on FM1PlatformBlockList");
static_assert(offsetof(FM1PlatformBlockList, Users) == 0x000000, "Member 'FM1PlatformBlockList::Users' has a wrong offset!");

// ScriptStruct M1Data.M1AbilityParamData
// 0x0020 (0x0020 - 0x0000)
struct FM1AbilityParamData final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1AbilityParamType                           Type;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Value;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityParamData) == 0x000008, "Wrong alignment on FM1AbilityParamData");
static_assert(sizeof(FM1AbilityParamData) == 0x000020, "Wrong size on FM1AbilityParamData");
static_assert(offsetof(FM1AbilityParamData, Name) == 0x000000, "Member 'FM1AbilityParamData::Name' has a wrong offset!");
static_assert(offsetof(FM1AbilityParamData, Type) == 0x000008, "Member 'FM1AbilityParamData::Type' has a wrong offset!");
static_assert(offsetof(FM1AbilityParamData, Value) == 0x000010, "Member 'FM1AbilityParamData::Value' has a wrong offset!");

// ScriptStruct M1Data.M1DropItemLink
// 0x0000 (0x0030 - 0x0030)
struct FM1DropItemLink final : public FDataLink
{
};
static_assert(alignof(FM1DropItemLink) == 0x000008, "Wrong alignment on FM1DropItemLink");
static_assert(sizeof(FM1DropItemLink) == 0x000030, "Wrong size on FM1DropItemLink");

// ScriptStruct M1Data.M1PartsDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1PartsDataLink final : public FDataLink
{
};
static_assert(alignof(FM1PartsDataLink) == 0x000008, "Wrong alignment on FM1PartsDataLink");
static_assert(sizeof(FM1PartsDataLink) == 0x000030, "Wrong size on FM1PartsDataLink");

// ScriptStruct M1Data.M1PartsDropElement
// 0x0090 (0x0090 - 0x0000)
struct FM1PartsDropElement final
{
public:
	struct FM1PartsDataLink                       PartsDataId;                                       // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FM1DropItemLink                        DropItemDebone;                                    // 0x0030(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FM1DropItemLink                        DropItemDestruction;                               // 0x0060(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PartsDropElement) == 0x000008, "Wrong alignment on FM1PartsDropElement");
static_assert(sizeof(FM1PartsDropElement) == 0x000090, "Wrong size on FM1PartsDropElement");
static_assert(offsetof(FM1PartsDropElement, PartsDataId) == 0x000000, "Member 'FM1PartsDropElement::PartsDataId' has a wrong offset!");
static_assert(offsetof(FM1PartsDropElement, DropItemDebone) == 0x000030, "Member 'FM1PartsDropElement::DropItemDebone' has a wrong offset!");
static_assert(offsetof(FM1PartsDropElement, DropItemDestruction) == 0x000060, "Member 'FM1PartsDropElement::DropItemDestruction' has a wrong offset!");

// ScriptStruct M1Data.M1BossLvDropElement
// 0x0050 (0x0050 - 0x0000)
struct FM1BossLvDropElement final
{
public:
	struct FM1DropItemLink                        DropItemIdBossKill;                                // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1PartsDropElement>            PartsDrop;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         DropEquipLevelRangeMin;                            // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropEquipLevelRangeMax;                            // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StandardLv;                                        // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1BossLvDropElement) == 0x000008, "Wrong alignment on FM1BossLvDropElement");
static_assert(sizeof(FM1BossLvDropElement) == 0x000050, "Wrong size on FM1BossLvDropElement");
static_assert(offsetof(FM1BossLvDropElement, DropItemIdBossKill) == 0x000000, "Member 'FM1BossLvDropElement::DropItemIdBossKill' has a wrong offset!");
static_assert(offsetof(FM1BossLvDropElement, PartsDrop) == 0x000030, "Member 'FM1BossLvDropElement::PartsDrop' has a wrong offset!");
static_assert(offsetof(FM1BossLvDropElement, DropEquipLevelRangeMin) == 0x000040, "Member 'FM1BossLvDropElement::DropEquipLevelRangeMin' has a wrong offset!");
static_assert(offsetof(FM1BossLvDropElement, DropEquipLevelRangeMax) == 0x000044, "Member 'FM1BossLvDropElement::DropEquipLevelRangeMax' has a wrong offset!");
static_assert(offsetof(FM1BossLvDropElement, StandardLv) == 0x000048, "Member 'FM1BossLvDropElement::StandardLv' has a wrong offset!");

// ScriptStruct M1Data.M1MonsterAIDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1MonsterAIDataLink final : public FDataLink
{
};
static_assert(alignof(FM1MonsterAIDataLink) == 0x000008, "Wrong alignment on FM1MonsterAIDataLink");
static_assert(sizeof(FM1MonsterAIDataLink) == 0x000030, "Wrong size on FM1MonsterAIDataLink");

// ScriptStruct M1Data.M1MonsterUIData
// 0x0020 (0x0020 - 0x0000)
struct FM1MonsterUIData final
{
public:
	struct FSoftObjectPath                        IconPath;                                          // 0x0000(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterUIData) == 0x000008, "Wrong alignment on FM1MonsterUIData");
static_assert(sizeof(FM1MonsterUIData) == 0x000020, "Wrong size on FM1MonsterUIData");
static_assert(offsetof(FM1MonsterUIData, IconPath) == 0x000000, "Member 'FM1MonsterUIData::IconPath' has a wrong offset!");

// ScriptStruct M1Data.M1StatValuePair
// 0x0010 (0x0010 - 0x0000)
struct FM1StatValuePair final
{
public:
	EM1StatType                                   StatTypeEnum;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        StatValue;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StatValuePair) == 0x000008, "Wrong alignment on FM1StatValuePair");
static_assert(sizeof(FM1StatValuePair) == 0x000010, "Wrong size on FM1StatValuePair");
static_assert(offsetof(FM1StatValuePair, StatTypeEnum) == 0x000000, "Member 'FM1StatValuePair::StatTypeEnum' has a wrong offset!");
static_assert(offsetof(FM1StatValuePair, StatValue) == 0x000008, "Member 'FM1StatValuePair::StatValue' has a wrong offset!");

// ScriptStruct M1Data.M1CharacterLevelInfo
// 0x0050 (0x0050 - 0x0000)
struct FM1CharacterLevelInfo final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1StatValuePair>               VariableStats;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int64                                         RewardCharacterExp;                                // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         RewardProficiencyExp;                              // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         RewardBattlePassExp;                               // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 PassiveSkillLevels;                                // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 ActiveSkillLevels;                                 // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CharacterLevelInfo) == 0x000008, "Wrong alignment on FM1CharacterLevelInfo");
static_assert(sizeof(FM1CharacterLevelInfo) == 0x000050, "Wrong size on FM1CharacterLevelInfo");
static_assert(offsetof(FM1CharacterLevelInfo, Level) == 0x000000, "Member 'FM1CharacterLevelInfo::Level' has a wrong offset!");
static_assert(offsetof(FM1CharacterLevelInfo, VariableStats) == 0x000008, "Member 'FM1CharacterLevelInfo::VariableStats' has a wrong offset!");
static_assert(offsetof(FM1CharacterLevelInfo, RewardCharacterExp) == 0x000018, "Member 'FM1CharacterLevelInfo::RewardCharacterExp' has a wrong offset!");
static_assert(offsetof(FM1CharacterLevelInfo, RewardProficiencyExp) == 0x000020, "Member 'FM1CharacterLevelInfo::RewardProficiencyExp' has a wrong offset!");
static_assert(offsetof(FM1CharacterLevelInfo, RewardBattlePassExp) == 0x000028, "Member 'FM1CharacterLevelInfo::RewardBattlePassExp' has a wrong offset!");
static_assert(offsetof(FM1CharacterLevelInfo, PassiveSkillLevels) == 0x000030, "Member 'FM1CharacterLevelInfo::PassiveSkillLevels' has a wrong offset!");
static_assert(offsetof(FM1CharacterLevelInfo, ActiveSkillLevels) == 0x000040, "Member 'FM1CharacterLevelInfo::ActiveSkillLevels' has a wrong offset!");

// ScriptStruct M1Data.M1SkillDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1SkillDataLink final : public FDataLink
{
};
static_assert(alignof(FM1SkillDataLink) == 0x000008, "Wrong alignment on FM1SkillDataLink");
static_assert(sizeof(FM1SkillDataLink) == 0x000030, "Wrong size on FM1SkillDataLink");

// ScriptStruct M1Data.M1CharacterData
// 0x00D0 (0x00D8 - 0x0008)
struct FM1CharacterData : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringId;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1DamageAdvantageType                        AdvantageType;                                     // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HitPoint;                                          // 0x0024(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         BlueprintClass;                                    // 0x0030(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LegacyDataAsset;                                   // 0x0050(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1CharacterLevelInfo>          Lv;                                                // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EM1StatType>                           UnusedGaugeStats;                                  // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1StatValuePair>               Stats;                                             // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1StatValuePair>               BareHandStats;                                     // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1SkillDataLink>               PassiveSkills;                                     // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1SkillDataLink>               ActiveSkills;                                      // 0x00C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EM1CharacterSize                              CharacterSize;                                     // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CharacterData) == 0x000008, "Wrong alignment on FM1CharacterData");
static_assert(sizeof(FM1CharacterData) == 0x0000D8, "Wrong size on FM1CharacterData");
static_assert(offsetof(FM1CharacterData, TemplateId) == 0x000008, "Member 'FM1CharacterData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1CharacterData, StringId) == 0x000010, "Member 'FM1CharacterData::StringId' has a wrong offset!");
static_assert(offsetof(FM1CharacterData, AdvantageType) == 0x000020, "Member 'FM1CharacterData::AdvantageType' has a wrong offset!");
static_assert(offsetof(FM1CharacterData, HitPoint) == 0x000024, "Member 'FM1CharacterData::HitPoint' has a wrong offset!");
static_assert(offsetof(FM1CharacterData, BlueprintClass) == 0x000030, "Member 'FM1CharacterData::BlueprintClass' has a wrong offset!");
static_assert(offsetof(FM1CharacterData, LegacyDataAsset) == 0x000050, "Member 'FM1CharacterData::LegacyDataAsset' has a wrong offset!");
static_assert(offsetof(FM1CharacterData, Lv) == 0x000070, "Member 'FM1CharacterData::Lv' has a wrong offset!");
static_assert(offsetof(FM1CharacterData, UnusedGaugeStats) == 0x000080, "Member 'FM1CharacterData::UnusedGaugeStats' has a wrong offset!");
static_assert(offsetof(FM1CharacterData, Stats) == 0x000090, "Member 'FM1CharacterData::Stats' has a wrong offset!");
static_assert(offsetof(FM1CharacterData, BareHandStats) == 0x0000A0, "Member 'FM1CharacterData::BareHandStats' has a wrong offset!");
static_assert(offsetof(FM1CharacterData, PassiveSkills) == 0x0000B0, "Member 'FM1CharacterData::PassiveSkills' has a wrong offset!");
static_assert(offsetof(FM1CharacterData, ActiveSkills) == 0x0000C0, "Member 'FM1CharacterData::ActiveSkills' has a wrong offset!");
static_assert(offsetof(FM1CharacterData, CharacterSize) == 0x0000D0, "Member 'FM1CharacterData::CharacterSize' has a wrong offset!");

// ScriptStruct M1Data.M1MonsterData
// 0x00A8 (0x0180 - 0x00D8)
struct FM1MonsterData : public FM1CharacterData
{
public:
	EM1MonsterCategory                            MonsterCategory;                                   // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LegionCategory                             LegionCategory;                                    // 0x00D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x6];                                       // 0x00DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1MonsterAIDataLink                   AI;                                                // 0x00E0(0x0030)(Edit, NativeAccessSpecifierPublic)
	class FString                                 ActionGroupId;                                     // 0x0110(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PartsGroupId;                                      // 0x0120(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseControllerRotationYaw;                          // 0x0130(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableInstantDropItem;                            // 0x0131(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_132[0x2];                                      // 0x0132(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackAccuracyRate;                                // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         SpawnMonsterId;                                    // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Tags;                                              // 0x0140(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1MonsterUIData                       UIData;                                            // 0x0150(0x0020)(Edit, NativeAccessSpecifierPublic)
	bool                                          ShowMapIcon;                                       // 0x0170(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GrantEliteWeight;                                  // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MonsterSpecialty                           Specialty;                                         // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MonsterData) == 0x000008, "Wrong alignment on FM1MonsterData");
static_assert(sizeof(FM1MonsterData) == 0x000180, "Wrong size on FM1MonsterData");
static_assert(offsetof(FM1MonsterData, MonsterCategory) == 0x0000D8, "Member 'FM1MonsterData::MonsterCategory' has a wrong offset!");
static_assert(offsetof(FM1MonsterData, LegionCategory) == 0x0000D9, "Member 'FM1MonsterData::LegionCategory' has a wrong offset!");
static_assert(offsetof(FM1MonsterData, AI) == 0x0000E0, "Member 'FM1MonsterData::AI' has a wrong offset!");
static_assert(offsetof(FM1MonsterData, ActionGroupId) == 0x000110, "Member 'FM1MonsterData::ActionGroupId' has a wrong offset!");
static_assert(offsetof(FM1MonsterData, PartsGroupId) == 0x000120, "Member 'FM1MonsterData::PartsGroupId' has a wrong offset!");
static_assert(offsetof(FM1MonsterData, UseControllerRotationYaw) == 0x000130, "Member 'FM1MonsterData::UseControllerRotationYaw' has a wrong offset!");
static_assert(offsetof(FM1MonsterData, DisableInstantDropItem) == 0x000131, "Member 'FM1MonsterData::DisableInstantDropItem' has a wrong offset!");
static_assert(offsetof(FM1MonsterData, AttackAccuracyRate) == 0x000134, "Member 'FM1MonsterData::AttackAccuracyRate' has a wrong offset!");
static_assert(offsetof(FM1MonsterData, SpawnMonsterId) == 0x000138, "Member 'FM1MonsterData::SpawnMonsterId' has a wrong offset!");
static_assert(offsetof(FM1MonsterData, Tags) == 0x000140, "Member 'FM1MonsterData::Tags' has a wrong offset!");
static_assert(offsetof(FM1MonsterData, UIData) == 0x000150, "Member 'FM1MonsterData::UIData' has a wrong offset!");
static_assert(offsetof(FM1MonsterData, ShowMapIcon) == 0x000170, "Member 'FM1MonsterData::ShowMapIcon' has a wrong offset!");
static_assert(offsetof(FM1MonsterData, GrantEliteWeight) == 0x000174, "Member 'FM1MonsterData::GrantEliteWeight' has a wrong offset!");
static_assert(offsetof(FM1MonsterData, Specialty) == 0x000178, "Member 'FM1MonsterData::Specialty' has a wrong offset!");

// ScriptStruct M1Data.M1BossMonsterData
// 0x0058 (0x01D8 - 0x0180)
struct FM1BossMonsterData final : public FM1MonsterData
{
public:
	float                                         ForwardMoveScale;                                  // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SideMoveScale;                                     // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackwardMoveScale;                                 // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1BossLvDropElement>           LvDrop;                                            // 0x0190(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1DropItemLink                        DropItemIdMinion;                                  // 0x01A0(0x0030)(Edit, NativeAccessSpecifierPublic)
	bool                                          HasLifeTime;                                       // 0x01D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1BossMonsterData) == 0x000008, "Wrong alignment on FM1BossMonsterData");
static_assert(sizeof(FM1BossMonsterData) == 0x0001D8, "Wrong size on FM1BossMonsterData");
static_assert(offsetof(FM1BossMonsterData, ForwardMoveScale) == 0x000180, "Member 'FM1BossMonsterData::ForwardMoveScale' has a wrong offset!");
static_assert(offsetof(FM1BossMonsterData, SideMoveScale) == 0x000184, "Member 'FM1BossMonsterData::SideMoveScale' has a wrong offset!");
static_assert(offsetof(FM1BossMonsterData, BackwardMoveScale) == 0x000188, "Member 'FM1BossMonsterData::BackwardMoveScale' has a wrong offset!");
static_assert(offsetof(FM1BossMonsterData, LvDrop) == 0x000190, "Member 'FM1BossMonsterData::LvDrop' has a wrong offset!");
static_assert(offsetof(FM1BossMonsterData, DropItemIdMinion) == 0x0001A0, "Member 'FM1BossMonsterData::DropItemIdMinion' has a wrong offset!");
static_assert(offsetof(FM1BossMonsterData, HasLifeTime) == 0x0001D0, "Member 'FM1BossMonsterData::HasLifeTime' has a wrong offset!");

// ScriptStruct M1Data.M1ItemUidBox
// 0x0010 (0x0010 - 0x0000)
struct FM1ItemUidBox final
{
public:
	EM1ItemType                                   Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Uid;                                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemUidBox) == 0x000008, "Wrong alignment on FM1ItemUidBox");
static_assert(sizeof(FM1ItemUidBox) == 0x000010, "Wrong size on FM1ItemUidBox");
static_assert(offsetof(FM1ItemUidBox, Type) == 0x000000, "Member 'FM1ItemUidBox::Type' has a wrong offset!");
static_assert(offsetof(FM1ItemUidBox, Uid) == 0x000008, "Member 'FM1ItemUidBox::Uid' has a wrong offset!");

// ScriptStruct M1Data.M1ProductMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1ProductMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1ProductMiscDataLink) == 0x000008, "Wrong alignment on FM1ProductMiscDataLink");
static_assert(sizeof(FM1ProductMiscDataLink) == 0x000030, "Wrong size on FM1ProductMiscDataLink");

// ScriptStruct M1Data.M1EncountDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1EncountDataLink final : public FDataLink
{
};
static_assert(alignof(FM1EncountDataLink) == 0x000008, "Wrong alignment on FM1EncountDataLink");
static_assert(sizeof(FM1EncountDataLink) == 0x000030, "Wrong size on FM1EncountDataLink");

// ScriptStruct M1Data.M1ScaledInteger
// 0x0008 (0x0008 - 0x0000)
struct FM1ScaledInteger final
{
public:
	int64                                         Value;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1ScaledInteger) == 0x000008, "Wrong alignment on FM1ScaledInteger");
static_assert(sizeof(FM1ScaledInteger) == 0x000008, "Wrong size on FM1ScaledInteger");
static_assert(offsetof(FM1ScaledInteger, Value) == 0x000000, "Member 'FM1ScaledInteger::Value' has a wrong offset!");

// ScriptStruct M1Data.M1RuneComposeCostData
// 0x0010 (0x0010 - 0x0000)
struct FM1RuneComposeCostData final
{
public:
	EM1ItemTierType                               Tier;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1CurrencyType                               CurrencyType;                                      // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Amount;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneComposeCostData) == 0x000008, "Wrong alignment on FM1RuneComposeCostData");
static_assert(sizeof(FM1RuneComposeCostData) == 0x000010, "Wrong size on FM1RuneComposeCostData");
static_assert(offsetof(FM1RuneComposeCostData, Tier) == 0x000000, "Member 'FM1RuneComposeCostData::Tier' has a wrong offset!");
static_assert(offsetof(FM1RuneComposeCostData, CurrencyType) == 0x000001, "Member 'FM1RuneComposeCostData::CurrencyType' has a wrong offset!");
static_assert(offsetof(FM1RuneComposeCostData, Amount) == 0x000008, "Member 'FM1RuneComposeCostData::Amount' has a wrong offset!");

// ScriptStruct M1Data.M1RuneComposeMiscData
// 0x0020 (0x0028 - 0x0008)
struct FM1RuneComposeMiscData final : public FTableRowBase
{
public:
	int32                                         ComposeTargetCount;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalRewardWeightByClass;                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalRewardWeightBySocket;                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1RuneComposeCostData>         CostDataList;                                      // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneComposeMiscData) == 0x000008, "Wrong alignment on FM1RuneComposeMiscData");
static_assert(sizeof(FM1RuneComposeMiscData) == 0x000028, "Wrong size on FM1RuneComposeMiscData");
static_assert(offsetof(FM1RuneComposeMiscData, ComposeTargetCount) == 0x000008, "Member 'FM1RuneComposeMiscData::ComposeTargetCount' has a wrong offset!");
static_assert(offsetof(FM1RuneComposeMiscData, AdditionalRewardWeightByClass) == 0x00000C, "Member 'FM1RuneComposeMiscData::AdditionalRewardWeightByClass' has a wrong offset!");
static_assert(offsetof(FM1RuneComposeMiscData, AdditionalRewardWeightBySocket) == 0x000010, "Member 'FM1RuneComposeMiscData::AdditionalRewardWeightBySocket' has a wrong offset!");
static_assert(offsetof(FM1RuneComposeMiscData, CostDataList) == 0x000018, "Member 'FM1RuneComposeMiscData::CostDataList' has a wrong offset!");

// ScriptStruct M1Data.M1FieldObjectSpawnGroupDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1FieldObjectSpawnGroupDataLink final : public FDataLink
{
};
static_assert(alignof(FM1FieldObjectSpawnGroupDataLink) == 0x000008, "Wrong alignment on FM1FieldObjectSpawnGroupDataLink");
static_assert(sizeof(FM1FieldObjectSpawnGroupDataLink) == 0x000030, "Wrong size on FM1FieldObjectSpawnGroupDataLink");

// ScriptStruct M1Data.M1PackageItemElementInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1PackageItemElementInfo final
{
public:
	struct FM1ItemTidBox                          ItemTid;                                           // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PackageItemElementInfo) == 0x000004, "Wrong alignment on FM1PackageItemElementInfo");
static_assert(sizeof(FM1PackageItemElementInfo) == 0x000010, "Wrong size on FM1PackageItemElementInfo");
static_assert(offsetof(FM1PackageItemElementInfo, ItemTid) == 0x000000, "Member 'FM1PackageItemElementInfo::ItemTid' has a wrong offset!");
static_assert(offsetof(FM1PackageItemElementInfo, Count) == 0x000008, "Member 'FM1PackageItemElementInfo::Count' has a wrong offset!");
static_assert(offsetof(FM1PackageItemElementInfo, Level) == 0x00000C, "Member 'FM1PackageItemElementInfo::Level' has a wrong offset!");

// ScriptStruct M1Data.M1PackageItemOpenResult
// 0x0014 (0x0014 - 0x0000)
struct FM1PackageItemOpenResult final
{
public:
	EM1PackageItemReason                          Reason;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1PackageItemElementInfo              Item;                                              // 0x0004(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PackageItemOpenResult) == 0x000004, "Wrong alignment on FM1PackageItemOpenResult");
static_assert(sizeof(FM1PackageItemOpenResult) == 0x000014, "Wrong size on FM1PackageItemOpenResult");
static_assert(offsetof(FM1PackageItemOpenResult, Reason) == 0x000000, "Member 'FM1PackageItemOpenResult::Reason' has a wrong offset!");
static_assert(offsetof(FM1PackageItemOpenResult, Item) == 0x000004, "Member 'FM1PackageItemOpenResult::Item' has a wrong offset!");

// ScriptStruct M1Data.M1AbilityOperationStatModifierData
// 0x0018 (0x0018 - 0x0000)
struct FM1AbilityOperationStatModifierData final
{
public:
	EM1StatRefType                                StatRefType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1StatType                                   StatType;                                          // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1StatModifierOp                             ModOp;                                             // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Value;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityOperationStatModifierData) == 0x000008, "Wrong alignment on FM1AbilityOperationStatModifierData");
static_assert(sizeof(FM1AbilityOperationStatModifierData) == 0x000018, "Wrong size on FM1AbilityOperationStatModifierData");
static_assert(offsetof(FM1AbilityOperationStatModifierData, StatRefType) == 0x000000, "Member 'FM1AbilityOperationStatModifierData::StatRefType' has a wrong offset!");
static_assert(offsetof(FM1AbilityOperationStatModifierData, StatType) == 0x000001, "Member 'FM1AbilityOperationStatModifierData::StatType' has a wrong offset!");
static_assert(offsetof(FM1AbilityOperationStatModifierData, ModOp) == 0x000002, "Member 'FM1AbilityOperationStatModifierData::ModOp' has a wrong offset!");
static_assert(offsetof(FM1AbilityOperationStatModifierData, Value) == 0x000008, "Member 'FM1AbilityOperationStatModifierData::Value' has a wrong offset!");

// ScriptStruct M1Data.M1AbilityOperationData
// 0x0050 (0x0050 - 0x0000)
struct FM1AbilityOperationData final
{
public:
	struct FSoftClassPath                         CalcClass;                                         // 0x0000(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1AbilityParamData>            Params;                                            // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1AbilityOperationStatModifierData> Modifiers;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   QueryTags;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityOperationData) == 0x000008, "Wrong alignment on FM1AbilityOperationData");
static_assert(sizeof(FM1AbilityOperationData) == 0x000050, "Wrong size on FM1AbilityOperationData");
static_assert(offsetof(FM1AbilityOperationData, CalcClass) == 0x000000, "Member 'FM1AbilityOperationData::CalcClass' has a wrong offset!");
static_assert(offsetof(FM1AbilityOperationData, Params) == 0x000020, "Member 'FM1AbilityOperationData::Params' has a wrong offset!");
static_assert(offsetof(FM1AbilityOperationData, Modifiers) == 0x000030, "Member 'FM1AbilityOperationData::Modifiers' has a wrong offset!");
static_assert(offsetof(FM1AbilityOperationData, QueryTags) == 0x000040, "Member 'FM1AbilityOperationData::QueryTags' has a wrong offset!");

// ScriptStruct M1Data.M1TaggedAbilityOperationData
// 0x0058 (0x0058 - 0x0000)
struct FM1TaggedAbilityOperationData final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1AbilityOperationData                Operation;                                         // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TaggedAbilityOperationData) == 0x000008, "Wrong alignment on FM1TaggedAbilityOperationData");
static_assert(sizeof(FM1TaggedAbilityOperationData) == 0x000058, "Wrong size on FM1TaggedAbilityOperationData");
static_assert(offsetof(FM1TaggedAbilityOperationData, Tag) == 0x000000, "Member 'FM1TaggedAbilityOperationData::Tag' has a wrong offset!");
static_assert(offsetof(FM1TaggedAbilityOperationData, Operation) == 0x000008, "Member 'FM1TaggedAbilityOperationData::Operation' has a wrong offset!");

// ScriptStruct M1Data.M1AbilityActorDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1AbilityActorDataLink final : public FDataLink
{
};
static_assert(alignof(FM1AbilityActorDataLink) == 0x000008, "Wrong alignment on FM1AbilityActorDataLink");
static_assert(sizeof(FM1AbilityActorDataLink) == 0x000030, "Wrong size on FM1AbilityActorDataLink");

// ScriptStruct M1Data.M1SpawnAbilityActorData
// 0x0048 (0x0048 - 0x0000)
struct FM1SpawnAbilityActorData final
{
public:
	struct FM1AbilityActorDataLink                AbilityActor;                                      // 0x0000(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EM1AbilityCreatedObjectRemovalPolicy          RemovalPolicy;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1AbilityParamData>            Params;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SpawnAbilityActorData) == 0x000008, "Wrong alignment on FM1SpawnAbilityActorData");
static_assert(sizeof(FM1SpawnAbilityActorData) == 0x000048, "Wrong size on FM1SpawnAbilityActorData");
static_assert(offsetof(FM1SpawnAbilityActorData, AbilityActor) == 0x000000, "Member 'FM1SpawnAbilityActorData::AbilityActor' has a wrong offset!");
static_assert(offsetof(FM1SpawnAbilityActorData, RemovalPolicy) == 0x000030, "Member 'FM1SpawnAbilityActorData::RemovalPolicy' has a wrong offset!");
static_assert(offsetof(FM1SpawnAbilityActorData, Params) == 0x000038, "Member 'FM1SpawnAbilityActorData::Params' has a wrong offset!");

// ScriptStruct M1Data.M1TaggedSpawnAbilityActorData
// 0x0050 (0x0050 - 0x0000)
struct FM1TaggedSpawnAbilityActorData final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1SpawnAbilityActorData               SpawnAbilityActor;                                 // 0x0008(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TaggedSpawnAbilityActorData) == 0x000008, "Wrong alignment on FM1TaggedSpawnAbilityActorData");
static_assert(sizeof(FM1TaggedSpawnAbilityActorData) == 0x000050, "Wrong size on FM1TaggedSpawnAbilityActorData");
static_assert(offsetof(FM1TaggedSpawnAbilityActorData, Tag) == 0x000000, "Member 'FM1TaggedSpawnAbilityActorData::Tag' has a wrong offset!");
static_assert(offsetof(FM1TaggedSpawnAbilityActorData, SpawnAbilityActor) == 0x000008, "Member 'FM1TaggedSpawnAbilityActorData::SpawnAbilityActor' has a wrong offset!");

// ScriptStruct M1Data.M1StatusEffectDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1StatusEffectDataLink final : public FDataLink
{
};
static_assert(alignof(FM1StatusEffectDataLink) == 0x000008, "Wrong alignment on FM1StatusEffectDataLink");
static_assert(sizeof(FM1StatusEffectDataLink) == 0x000030, "Wrong size on FM1StatusEffectDataLink");

// ScriptStruct M1Data.M1InvokeStatusEffectData
// 0x0048 (0x0048 - 0x0000)
struct FM1InvokeStatusEffectData final
{
public:
	struct FM1StatusEffectDataLink                StatusEffect;                                      // 0x0000(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EM1AbilityCreatedObjectRemovalPolicy          RemovalPolicy;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1AbilityParamData>            Params;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InvokeStatusEffectData) == 0x000008, "Wrong alignment on FM1InvokeStatusEffectData");
static_assert(sizeof(FM1InvokeStatusEffectData) == 0x000048, "Wrong size on FM1InvokeStatusEffectData");
static_assert(offsetof(FM1InvokeStatusEffectData, StatusEffect) == 0x000000, "Member 'FM1InvokeStatusEffectData::StatusEffect' has a wrong offset!");
static_assert(offsetof(FM1InvokeStatusEffectData, RemovalPolicy) == 0x000030, "Member 'FM1InvokeStatusEffectData::RemovalPolicy' has a wrong offset!");
static_assert(offsetof(FM1InvokeStatusEffectData, Params) == 0x000038, "Member 'FM1InvokeStatusEffectData::Params' has a wrong offset!");

// ScriptStruct M1Data.M1TaggedInvokeStatusEffectData
// 0x0050 (0x0050 - 0x0000)
struct FM1TaggedInvokeStatusEffectData final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1InvokeStatusEffectData              InvokeStatusEffect;                                // 0x0008(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TaggedInvokeStatusEffectData) == 0x000008, "Wrong alignment on FM1TaggedInvokeStatusEffectData");
static_assert(sizeof(FM1TaggedInvokeStatusEffectData) == 0x000050, "Wrong size on FM1TaggedInvokeStatusEffectData");
static_assert(offsetof(FM1TaggedInvokeStatusEffectData, Tag) == 0x000000, "Member 'FM1TaggedInvokeStatusEffectData::Tag' has a wrong offset!");
static_assert(offsetof(FM1TaggedInvokeStatusEffectData, InvokeStatusEffect) == 0x000008, "Member 'FM1TaggedInvokeStatusEffectData::InvokeStatusEffect' has a wrong offset!");

// ScriptStruct M1Data.M1AbilityActorData
// 0x0060 (0x0068 - 0x0008)
struct FM1AbilityActorData final : public FTableRowBase
{
public:
	struct FSoftClassPath                         AbilityActorClass;                                 // 0x0008(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1TaggedAbilityOperationData>  Operations;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1TaggedInvokeStatusEffectData> InvokeStatusEffects;                               // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1TaggedSpawnAbilityActorData> SpawnAbilityActors;                                // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1AbilityParamData>            Params;                                            // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityActorData) == 0x000008, "Wrong alignment on FM1AbilityActorData");
static_assert(sizeof(FM1AbilityActorData) == 0x000068, "Wrong size on FM1AbilityActorData");
static_assert(offsetof(FM1AbilityActorData, AbilityActorClass) == 0x000008, "Member 'FM1AbilityActorData::AbilityActorClass' has a wrong offset!");
static_assert(offsetof(FM1AbilityActorData, Operations) == 0x000028, "Member 'FM1AbilityActorData::Operations' has a wrong offset!");
static_assert(offsetof(FM1AbilityActorData, InvokeStatusEffects) == 0x000038, "Member 'FM1AbilityActorData::InvokeStatusEffects' has a wrong offset!");
static_assert(offsetof(FM1AbilityActorData, SpawnAbilityActors) == 0x000048, "Member 'FM1AbilityActorData::SpawnAbilityActors' has a wrong offset!");
static_assert(offsetof(FM1AbilityActorData, Params) == 0x000058, "Member 'FM1AbilityActorData::Params' has a wrong offset!");

// ScriptStruct M1Data.M1CustomizingItemDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1CustomizingItemDataLink final : public FDataLink
{
};
static_assert(alignof(FM1CustomizingItemDataLink) == 0x000008, "Wrong alignment on FM1CustomizingItemDataLink");
static_assert(sizeof(FM1CustomizingItemDataLink) == 0x000030, "Wrong size on FM1CustomizingItemDataLink");

// ScriptStruct M1Data.M1BaseCustomizeItemElement
// 0x0038 (0x0038 - 0x0000)
struct FM1BaseCustomizeItemElement final
{
public:
	struct FM1CustomizingItemDataLink             ID;                                                // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	bool                                          bEquip;                                            // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1BaseCustomizeItemElement) == 0x000008, "Wrong alignment on FM1BaseCustomizeItemElement");
static_assert(sizeof(FM1BaseCustomizeItemElement) == 0x000038, "Wrong size on FM1BaseCustomizeItemElement");
static_assert(offsetof(FM1BaseCustomizeItemElement, ID) == 0x000000, "Member 'FM1BaseCustomizeItemElement::ID' has a wrong offset!");
static_assert(offsetof(FM1BaseCustomizeItemElement, bEquip) == 0x000030, "Member 'FM1BaseCustomizeItemElement::bEquip' has a wrong offset!");

// ScriptStruct M1Data.M1CashShopCategoryClickRecord
// 0x0008 (0x0008 - 0x0000)
struct FM1CashShopCategoryClickRecord final
{
public:
	EM1ShopCategoryType                           CategoryType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ClickCount;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CashShopCategoryClickRecord) == 0x000004, "Wrong alignment on FM1CashShopCategoryClickRecord");
static_assert(sizeof(FM1CashShopCategoryClickRecord) == 0x000008, "Wrong size on FM1CashShopCategoryClickRecord");
static_assert(offsetof(FM1CashShopCategoryClickRecord, CategoryType) == 0x000000, "Member 'FM1CashShopCategoryClickRecord::CategoryType' has a wrong offset!");
static_assert(offsetof(FM1CashShopCategoryClickRecord, ClickCount) == 0x000004, "Member 'FM1CashShopCategoryClickRecord::ClickCount' has a wrong offset!");

// ScriptStruct M1Data.M1ClientChecksum
// 0x0030 (0x0030 - 0x0000)
struct FM1ClientChecksum final
{
public:
	class FString                                 ChecksumClientService;                             // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChecksumGameService;                               // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChecksumDediService;                               // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ClientChecksum) == 0x000008, "Wrong alignment on FM1ClientChecksum");
static_assert(sizeof(FM1ClientChecksum) == 0x000030, "Wrong size on FM1ClientChecksum");
static_assert(offsetof(FM1ClientChecksum, ChecksumClientService) == 0x000000, "Member 'FM1ClientChecksum::ChecksumClientService' has a wrong offset!");
static_assert(offsetof(FM1ClientChecksum, ChecksumGameService) == 0x000010, "Member 'FM1ClientChecksum::ChecksumGameService' has a wrong offset!");
static_assert(offsetof(FM1ClientChecksum, ChecksumDediService) == 0x000020, "Member 'FM1ClientChecksum::ChecksumDediService' has a wrong offset!");

// ScriptStruct M1Data.M1MapSubData
// 0x0010 (0x0010 - 0x0000)
struct FM1MapSubData final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MapSubType                                 Type;                                              // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FieldDifficulty;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattleZoneId;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MapSubData) == 0x000004, "Wrong alignment on FM1MapSubData");
static_assert(sizeof(FM1MapSubData) == 0x000010, "Wrong size on FM1MapSubData");
static_assert(offsetof(FM1MapSubData, ID) == 0x000000, "Member 'FM1MapSubData::ID' has a wrong offset!");
static_assert(offsetof(FM1MapSubData, Type) == 0x000004, "Member 'FM1MapSubData::Type' has a wrong offset!");
static_assert(offsetof(FM1MapSubData, FieldDifficulty) == 0x000008, "Member 'FM1MapSubData::FieldDifficulty' has a wrong offset!");
static_assert(offsetof(FM1MapSubData, BattleZoneId) == 0x00000C, "Member 'FM1MapSubData::BattleZoneId' has a wrong offset!");

// ScriptStruct M1Data.M1DedicatedServerInfo
// 0x00A0 (0x00A0 - 0x0000)
struct FM1DedicatedServerInfo final
{
public:
	class FString                                 IpAddr;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Port;                                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServerName;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserName;                                          // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NetworkVersion;                                    // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapName;                                           // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Oid;                                               // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MapTemplateId;                                     // 0x0058(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1MapSubData                          MapSubData;                                        // 0x005C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Private;                                           // 0x006C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ClientChecksum                      Checksum;                                          // 0x0070(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DedicatedServerInfo) == 0x000008, "Wrong alignment on FM1DedicatedServerInfo");
static_assert(sizeof(FM1DedicatedServerInfo) == 0x0000A0, "Wrong size on FM1DedicatedServerInfo");
static_assert(offsetof(FM1DedicatedServerInfo, IpAddr) == 0x000000, "Member 'FM1DedicatedServerInfo::IpAddr' has a wrong offset!");
static_assert(offsetof(FM1DedicatedServerInfo, Port) == 0x000010, "Member 'FM1DedicatedServerInfo::Port' has a wrong offset!");
static_assert(offsetof(FM1DedicatedServerInfo, ServerName) == 0x000018, "Member 'FM1DedicatedServerInfo::ServerName' has a wrong offset!");
static_assert(offsetof(FM1DedicatedServerInfo, UserName) == 0x000028, "Member 'FM1DedicatedServerInfo::UserName' has a wrong offset!");
static_assert(offsetof(FM1DedicatedServerInfo, NetworkVersion) == 0x000038, "Member 'FM1DedicatedServerInfo::NetworkVersion' has a wrong offset!");
static_assert(offsetof(FM1DedicatedServerInfo, MapName) == 0x000040, "Member 'FM1DedicatedServerInfo::MapName' has a wrong offset!");
static_assert(offsetof(FM1DedicatedServerInfo, Oid) == 0x000050, "Member 'FM1DedicatedServerInfo::Oid' has a wrong offset!");
static_assert(offsetof(FM1DedicatedServerInfo, MapTemplateId) == 0x000058, "Member 'FM1DedicatedServerInfo::MapTemplateId' has a wrong offset!");
static_assert(offsetof(FM1DedicatedServerInfo, MapSubData) == 0x00005C, "Member 'FM1DedicatedServerInfo::MapSubData' has a wrong offset!");
static_assert(offsetof(FM1DedicatedServerInfo, Private) == 0x00006C, "Member 'FM1DedicatedServerInfo::Private' has a wrong offset!");
static_assert(offsetof(FM1DedicatedServerInfo, Checksum) == 0x000070, "Member 'FM1DedicatedServerInfo::Checksum' has a wrong offset!");

// ScriptStruct M1Data.M1PartyMoveRes
// 0x00B8 (0x00B8 - 0x0000)
struct FM1PartyMoveRes final
{
public:
	EM1PartyErrorCode                             ErrorCode;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 AccountUids;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1DedicatedServerInfo                 ServerInfo;                                        // 0x0018(0x00A0)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PartyMoveRes) == 0x000008, "Wrong alignment on FM1PartyMoveRes");
static_assert(sizeof(FM1PartyMoveRes) == 0x0000B8, "Wrong size on FM1PartyMoveRes");
static_assert(offsetof(FM1PartyMoveRes, ErrorCode) == 0x000000, "Member 'FM1PartyMoveRes::ErrorCode' has a wrong offset!");
static_assert(offsetof(FM1PartyMoveRes, AccountUids) == 0x000008, "Member 'FM1PartyMoveRes::AccountUids' has a wrong offset!");
static_assert(offsetof(FM1PartyMoveRes, ServerInfo) == 0x000018, "Member 'FM1PartyMoveRes::ServerInfo' has a wrong offset!");

// ScriptStruct M1Data.M1RangedFloat
// 0x0008 (0x0008 - 0x0000)
struct FM1RangedFloat final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RangedFloat) == 0x000004, "Wrong alignment on FM1RangedFloat");
static_assert(sizeof(FM1RangedFloat) == 0x000008, "Wrong size on FM1RangedFloat");
static_assert(offsetof(FM1RangedFloat, Min) == 0x000000, "Member 'FM1RangedFloat::Min' has a wrong offset!");
static_assert(offsetof(FM1RangedFloat, Max) == 0x000004, "Member 'FM1RangedFloat::Max' has a wrong offset!");

// ScriptStruct M1Data.M1StatModifierClampInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1StatModifierClampInfo final
{
public:
	struct FM1RangedFloat                         Total;                                             // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1RangedFloat                         Add;                                               // 0x0008(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1RangedFloat                         Multiply;                                          // 0x0010(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StatModifierClampInfo) == 0x000004, "Wrong alignment on FM1StatModifierClampInfo");
static_assert(sizeof(FM1StatModifierClampInfo) == 0x000018, "Wrong size on FM1StatModifierClampInfo");
static_assert(offsetof(FM1StatModifierClampInfo, Total) == 0x000000, "Member 'FM1StatModifierClampInfo::Total' has a wrong offset!");
static_assert(offsetof(FM1StatModifierClampInfo, Add) == 0x000008, "Member 'FM1StatModifierClampInfo::Add' has a wrong offset!");
static_assert(offsetof(FM1StatModifierClampInfo, Multiply) == 0x000010, "Member 'FM1StatModifierClampInfo::Multiply' has a wrong offset!");

// ScriptStruct M1Data.M1MapBattleZoneOpenCondition
// 0x0018 (0x0018 - 0x0000)
struct FM1MapBattleZoneOpenCondition final
{
public:
	EM1MapBattleZoneOpenConditionType             Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Params;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MapBattleZoneOpenCondition) == 0x000008, "Wrong alignment on FM1MapBattleZoneOpenCondition");
static_assert(sizeof(FM1MapBattleZoneOpenCondition) == 0x000018, "Wrong size on FM1MapBattleZoneOpenCondition");
static_assert(offsetof(FM1MapBattleZoneOpenCondition, Type) == 0x000000, "Member 'FM1MapBattleZoneOpenCondition::Type' has a wrong offset!");
static_assert(offsetof(FM1MapBattleZoneOpenCondition, Params) == 0x000008, "Member 'FM1MapBattleZoneOpenCondition::Params' has a wrong offset!");

// ScriptStruct M1Data.M1RuneAbilityDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1RuneAbilityDataLink final : public FDataLink
{
};
static_assert(alignof(FM1RuneAbilityDataLink) == 0x000008, "Wrong alignment on FM1RuneAbilityDataLink");
static_assert(sizeof(FM1RuneAbilityDataLink) == 0x000030, "Wrong size on FM1RuneAbilityDataLink");

// ScriptStruct M1Data.M1NGSPacket
// 0x0010 (0x0010 - 0x0000)
struct FM1NGSPacket final
{
public:
	TArray<uint8>                                 Data;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NGSPacket) == 0x000008, "Wrong alignment on FM1NGSPacket");
static_assert(sizeof(FM1NGSPacket) == 0x000010, "Wrong size on FM1NGSPacket");
static_assert(offsetof(FM1NGSPacket, Data) == 0x000000, "Member 'FM1NGSPacket::Data' has a wrong offset!");

// ScriptStruct M1Data.M1ItemSelectorDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1ItemSelectorDataLink final : public FDataLink
{
};
static_assert(alignof(FM1ItemSelectorDataLink) == 0x000008, "Wrong alignment on FM1ItemSelectorDataLink");
static_assert(sizeof(FM1ItemSelectorDataLink) == 0x000030, "Wrong size on FM1ItemSelectorDataLink");

// ScriptStruct M1Data.M1EquipEncyclopediaData
// 0x0010 (0x0010 - 0x0000)
struct FM1EquipEncyclopediaData final
{
public:
	TArray<struct FM1TemplateId>                  EquipTemplateIdList;                               // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EquipEncyclopediaData) == 0x000008, "Wrong alignment on FM1EquipEncyclopediaData");
static_assert(sizeof(FM1EquipEncyclopediaData) == 0x000010, "Wrong size on FM1EquipEncyclopediaData");
static_assert(offsetof(FM1EquipEncyclopediaData, EquipTemplateIdList) == 0x000000, "Member 'FM1EquipEncyclopediaData::EquipTemplateIdList' has a wrong offset!");

// ScriptStruct M1Data.M1InventorySlotCount
// 0x0018 (0x0018 - 0x0000)
struct FM1InventorySlotCount final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1InventoryType                              InventoryType;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxCount;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ExpandSlotItem;                                    // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1InventorySlotCount) == 0x000008, "Wrong alignment on FM1InventorySlotCount");
static_assert(sizeof(FM1InventorySlotCount) == 0x000018, "Wrong size on FM1InventorySlotCount");
static_assert(offsetof(FM1InventorySlotCount, AccountUid) == 0x000000, "Member 'FM1InventorySlotCount::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1InventorySlotCount, InventoryType) == 0x000008, "Member 'FM1InventorySlotCount::InventoryType' has a wrong offset!");
static_assert(offsetof(FM1InventorySlotCount, MaxCount) == 0x00000C, "Member 'FM1InventorySlotCount::MaxCount' has a wrong offset!");
static_assert(offsetof(FM1InventorySlotCount, ExpandSlotItem) == 0x000010, "Member 'FM1InventorySlotCount::ExpandSlotItem' has a wrong offset!");

// ScriptStruct M1Data.M1ProficiencyData
// 0x0010 (0x0018 - 0x0008)
struct FM1ProficiencyData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredProficiency;                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardMasteryExp;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponRuneCapacity;                                // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ProficiencyData) == 0x000008, "Wrong alignment on FM1ProficiencyData");
static_assert(sizeof(FM1ProficiencyData) == 0x000018, "Wrong size on FM1ProficiencyData");
static_assert(offsetof(FM1ProficiencyData, TemplateId) == 0x000008, "Member 'FM1ProficiencyData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1ProficiencyData, RequiredProficiency) == 0x00000C, "Member 'FM1ProficiencyData::RequiredProficiency' has a wrong offset!");
static_assert(offsetof(FM1ProficiencyData, RewardMasteryExp) == 0x000010, "Member 'FM1ProficiencyData::RewardMasteryExp' has a wrong offset!");
static_assert(offsetof(FM1ProficiencyData, WeaponRuneCapacity) == 0x000014, "Member 'FM1ProficiencyData::WeaponRuneCapacity' has a wrong offset!");

// ScriptStruct M1Data.M1InGameSocialOptionData
// 0x0010 (0x0010 - 0x0000)
struct FM1InGameSocialOptionData final
{
public:
	EM1InGameSocialOptionType                     FriendRequestOption;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1InGameSocialOptionType                     PartyRequestOption;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1InGameSocialOptionType                     ChattingOption;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1InGameSocialOptionType                     SupportOption;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InGameSocialOptionData) == 0x000004, "Wrong alignment on FM1InGameSocialOptionData");
static_assert(sizeof(FM1InGameSocialOptionData) == 0x000010, "Wrong size on FM1InGameSocialOptionData");
static_assert(offsetof(FM1InGameSocialOptionData, FriendRequestOption) == 0x000000, "Member 'FM1InGameSocialOptionData::FriendRequestOption' has a wrong offset!");
static_assert(offsetof(FM1InGameSocialOptionData, PartyRequestOption) == 0x000004, "Member 'FM1InGameSocialOptionData::PartyRequestOption' has a wrong offset!");
static_assert(offsetof(FM1InGameSocialOptionData, ChattingOption) == 0x000008, "Member 'FM1InGameSocialOptionData::ChattingOption' has a wrong offset!");
static_assert(offsetof(FM1InGameSocialOptionData, SupportOption) == 0x00000C, "Member 'FM1InGameSocialOptionData::SupportOption' has a wrong offset!");

// ScriptStruct M1Data.M1MasteryUIData
// 0x0030 (0x0030 - 0x0000)
struct FM1MasteryUIData final
{
public:
	struct FSoftObjectPath                        IconPath;                                          // 0x0000(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StringId;                                          // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MasteryUIData) == 0x000008, "Wrong alignment on FM1MasteryUIData");
static_assert(sizeof(FM1MasteryUIData) == 0x000030, "Wrong size on FM1MasteryUIData");
static_assert(offsetof(FM1MasteryUIData, IconPath) == 0x000000, "Member 'FM1MasteryUIData::IconPath' has a wrong offset!");
static_assert(offsetof(FM1MasteryUIData, StringId) == 0x000020, "Member 'FM1MasteryUIData::StringId' has a wrong offset!");

// ScriptStruct M1Data.M1MasteryExpNoti
// 0x0018 (0x0018 - 0x0000)
struct FM1MasteryExpNoti final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          Level;                                             // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Exp;                                               // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MasteryExpNoti) == 0x000008, "Wrong alignment on FM1MasteryExpNoti");
static_assert(sizeof(FM1MasteryExpNoti) == 0x000018, "Wrong size on FM1MasteryExpNoti");
static_assert(offsetof(FM1MasteryExpNoti, AccountUid) == 0x000000, "Member 'FM1MasteryExpNoti::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1MasteryExpNoti, Level) == 0x000008, "Member 'FM1MasteryExpNoti::Level' has a wrong offset!");
static_assert(offsetof(FM1MasteryExpNoti, Exp) == 0x000010, "Member 'FM1MasteryExpNoti::Exp' has a wrong offset!");

// ScriptStruct M1Data.M1BaseItemDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1BaseItemDataLink final : public FDataLink
{
};
static_assert(alignof(FM1BaseItemDataLink) == 0x000008, "Wrong alignment on FM1BaseItemDataLink");
static_assert(sizeof(FM1BaseItemDataLink) == 0x000030, "Wrong size on FM1BaseItemDataLink");

// ScriptStruct M1Data.M1AbilityDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1AbilityDataLink final : public FDataLink
{
};
static_assert(alignof(FM1AbilityDataLink) == 0x000008, "Wrong alignment on FM1AbilityDataLink");
static_assert(sizeof(FM1AbilityDataLink) == 0x000030, "Wrong size on FM1AbilityDataLink");

// ScriptStruct M1Data.M1InstantUseItemData
// 0x0070 (0x0078 - 0x0008)
struct FM1InstantUseItemData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ObtainableCountPerChance;                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Private;                                           // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1AbilityDataLink                     Ability;                                           // 0x0020(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         PropClass;                                         // 0x0050(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1StatType                                   CurrentStatCapacity;                               // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RoundsType                                 RoundsCapacity;                                    // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NumberLimit;                                       // 0x0072(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ImportanceType                             ImportanceType;                                    // 0x0073(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1InstantUseItemData) == 0x000008, "Wrong alignment on FM1InstantUseItemData");
static_assert(sizeof(FM1InstantUseItemData) == 0x000078, "Wrong size on FM1InstantUseItemData");
static_assert(offsetof(FM1InstantUseItemData, TemplateId) == 0x000008, "Member 'FM1InstantUseItemData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1InstantUseItemData, StringId) == 0x00000C, "Member 'FM1InstantUseItemData::StringId' has a wrong offset!");
static_assert(offsetof(FM1InstantUseItemData, ObtainableCountPerChance) == 0x000014, "Member 'FM1InstantUseItemData::ObtainableCountPerChance' has a wrong offset!");
static_assert(offsetof(FM1InstantUseItemData, Private) == 0x000018, "Member 'FM1InstantUseItemData::Private' has a wrong offset!");
static_assert(offsetof(FM1InstantUseItemData, Ability) == 0x000020, "Member 'FM1InstantUseItemData::Ability' has a wrong offset!");
static_assert(offsetof(FM1InstantUseItemData, PropClass) == 0x000050, "Member 'FM1InstantUseItemData::PropClass' has a wrong offset!");
static_assert(offsetof(FM1InstantUseItemData, CurrentStatCapacity) == 0x000070, "Member 'FM1InstantUseItemData::CurrentStatCapacity' has a wrong offset!");
static_assert(offsetof(FM1InstantUseItemData, RoundsCapacity) == 0x000071, "Member 'FM1InstantUseItemData::RoundsCapacity' has a wrong offset!");
static_assert(offsetof(FM1InstantUseItemData, NumberLimit) == 0x000072, "Member 'FM1InstantUseItemData::NumberLimit' has a wrong offset!");
static_assert(offsetof(FM1InstantUseItemData, ImportanceType) == 0x000073, "Member 'FM1InstantUseItemData::ImportanceType' has a wrong offset!");

// ScriptStruct M1Data.M1RequiredItemData
// 0x0010 (0x0010 - 0x0000)
struct FM1RequiredItemData final
{
public:
	EM1ItemType                                   ItemType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ID;                                                // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RequiredItemData) == 0x000004, "Wrong alignment on FM1RequiredItemData");
static_assert(sizeof(FM1RequiredItemData) == 0x000010, "Wrong size on FM1RequiredItemData");
static_assert(offsetof(FM1RequiredItemData, ItemType) == 0x000000, "Member 'FM1RequiredItemData::ItemType' has a wrong offset!");
static_assert(offsetof(FM1RequiredItemData, ID) == 0x000004, "Member 'FM1RequiredItemData::ID' has a wrong offset!");
static_assert(offsetof(FM1RequiredItemData, Amount) == 0x00000C, "Member 'FM1RequiredItemData::Amount' has a wrong offset!");

// ScriptStruct M1Data.M1RandomOptionChangeCostWithTier
// 0x0018 (0x0018 - 0x0000)
struct FM1RandomOptionChangeCostWithTier final
{
public:
	EM1ItemTierType                               Tier;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1RequiredItemData>            Cost;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RandomOptionChangeCostWithTier) == 0x000008, "Wrong alignment on FM1RandomOptionChangeCostWithTier");
static_assert(sizeof(FM1RandomOptionChangeCostWithTier) == 0x000018, "Wrong size on FM1RandomOptionChangeCostWithTier");
static_assert(offsetof(FM1RandomOptionChangeCostWithTier, Tier) == 0x000000, "Member 'FM1RandomOptionChangeCostWithTier::Tier' has a wrong offset!");
static_assert(offsetof(FM1RandomOptionChangeCostWithTier, Cost) == 0x000008, "Member 'FM1RandomOptionChangeCostWithTier::Cost' has a wrong offset!");

// ScriptStruct M1Data.M1ChatBanInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1ChatBanInfo final
{
public:
	int64                                         AccountID;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndTime;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ChatBanInfo) == 0x000008, "Wrong alignment on FM1ChatBanInfo");
static_assert(sizeof(FM1ChatBanInfo) == 0x000010, "Wrong size on FM1ChatBanInfo");
static_assert(offsetof(FM1ChatBanInfo, AccountID) == 0x000000, "Member 'FM1ChatBanInfo::AccountID' has a wrong offset!");
static_assert(offsetof(FM1ChatBanInfo, EndTime) == 0x000008, "Member 'FM1ChatBanInfo::EndTime' has a wrong offset!");

// ScriptStruct M1Data.M1RuneEquippedInfoBundle
// 0x0018 (0x0018 - 0x0000)
struct FM1RuneEquippedInfoBundle final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1RuneLoadoutInfo>             Values;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneEquippedInfoBundle) == 0x000008, "Wrong alignment on FM1RuneEquippedInfoBundle");
static_assert(sizeof(FM1RuneEquippedInfoBundle) == 0x000018, "Wrong size on FM1RuneEquippedInfoBundle");
static_assert(offsetof(FM1RuneEquippedInfoBundle, AccountUid) == 0x000000, "Member 'FM1RuneEquippedInfoBundle::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1RuneEquippedInfoBundle, Values) == 0x000008, "Member 'FM1RuneEquippedInfoBundle::Values' has a wrong offset!");

// ScriptStruct M1Data.M1MonsterAIVulgusPost
// 0x000C (0x000C - 0x0000)
struct FM1MonsterAIVulgusPost final
{
public:
	float                                         NonBattleTargetSearchRadius;                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonBattlePatrolRadius;                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonBattlePatrolHitRadius;                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterAIVulgusPost) == 0x000004, "Wrong alignment on FM1MonsterAIVulgusPost");
static_assert(sizeof(FM1MonsterAIVulgusPost) == 0x00000C, "Wrong size on FM1MonsterAIVulgusPost");
static_assert(offsetof(FM1MonsterAIVulgusPost, NonBattleTargetSearchRadius) == 0x000000, "Member 'FM1MonsterAIVulgusPost::NonBattleTargetSearchRadius' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIVulgusPost, NonBattlePatrolRadius) == 0x000004, "Member 'FM1MonsterAIVulgusPost::NonBattlePatrolRadius' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIVulgusPost, NonBattlePatrolHitRadius) == 0x000008, "Member 'FM1MonsterAIVulgusPost::NonBattlePatrolHitRadius' has a wrong offset!");

// ScriptStruct M1Data.M1QuestDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1QuestDataLink final : public FDataLink
{
};
static_assert(alignof(FM1QuestDataLink) == 0x000008, "Wrong alignment on FM1QuestDataLink");
static_assert(sizeof(FM1QuestDataLink) == 0x000030, "Wrong size on FM1QuestDataLink");

// ScriptStruct M1Data.M1MapDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1MapDataLink final : public FDataLink
{
};
static_assert(alignof(FM1MapDataLink) == 0x000008, "Wrong alignment on FM1MapDataLink");
static_assert(sizeof(FM1MapDataLink) == 0x000030, "Wrong size on FM1MapDataLink");

// ScriptStruct M1Data.M1InstanceDungeonAbilityDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1InstanceDungeonAbilityDataLink final : public FDataLink
{
};
static_assert(alignof(FM1InstanceDungeonAbilityDataLink) == 0x000008, "Wrong alignment on FM1InstanceDungeonAbilityDataLink");
static_assert(sizeof(FM1InstanceDungeonAbilityDataLink) == 0x000030, "Wrong size on FM1InstanceDungeonAbilityDataLink");

// ScriptStruct M1Data.M1MissionDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1MissionDataLink final : public FDataLink
{
};
static_assert(alignof(FM1MissionDataLink) == 0x000008, "Wrong alignment on FM1MissionDataLink");
static_assert(sizeof(FM1MissionDataLink) == 0x000030, "Wrong size on FM1MissionDataLink");

// ScriptStruct M1Data.M1InstanceFieldContentsDataBase
// 0x0088 (0x0090 - 0x0008)
struct FM1InstanceFieldContentsDataBase : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1MapDataLink                         MapId;                                             // 0x0010(0x0030)(Edit, NativeAccessSpecifierPublic)
	class FString                                 PlayerStartTag;                                    // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1MissionDataLink                     MissionId;                                         // 0x0050(0x0030)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1InstanceDungeonAbilityDataLink> DefaultAbilities;                                  // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceFieldContentsDataBase) == 0x000008, "Wrong alignment on FM1InstanceFieldContentsDataBase");
static_assert(sizeof(FM1InstanceFieldContentsDataBase) == 0x000090, "Wrong size on FM1InstanceFieldContentsDataBase");
static_assert(offsetof(FM1InstanceFieldContentsDataBase, TemplateId) == 0x000008, "Member 'FM1InstanceFieldContentsDataBase::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1InstanceFieldContentsDataBase, MapId) == 0x000010, "Member 'FM1InstanceFieldContentsDataBase::MapId' has a wrong offset!");
static_assert(offsetof(FM1InstanceFieldContentsDataBase, PlayerStartTag) == 0x000040, "Member 'FM1InstanceFieldContentsDataBase::PlayerStartTag' has a wrong offset!");
static_assert(offsetof(FM1InstanceFieldContentsDataBase, MissionId) == 0x000050, "Member 'FM1InstanceFieldContentsDataBase::MissionId' has a wrong offset!");
static_assert(offsetof(FM1InstanceFieldContentsDataBase, DefaultAbilities) == 0x000080, "Member 'FM1InstanceFieldContentsDataBase::DefaultAbilities' has a wrong offset!");

// ScriptStruct M1Data.M1CharacterDungeonData
// 0x0030 (0x00C0 - 0x0090)
struct FM1CharacterDungeonData final : public FM1InstanceFieldContentsDataBase
{
public:
	struct FM1QuestDataLink                       QuestId;                                           // 0x0090(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CharacterDungeonData) == 0x000008, "Wrong alignment on FM1CharacterDungeonData");
static_assert(sizeof(FM1CharacterDungeonData) == 0x0000C0, "Wrong size on FM1CharacterDungeonData");
static_assert(offsetof(FM1CharacterDungeonData, QuestId) == 0x000090, "Member 'FM1CharacterDungeonData::QuestId' has a wrong offset!");

// ScriptStruct M1Data.M1PhysicalPowerOptionData
// 0x0018 (0x0020 - 0x0008)
struct FM1PhysicalPowerOptionData final : public FTableRowBase
{
public:
	bool                                          bLaunchWhenDeathRagDoll;                           // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LaunchPower;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchAssistAngle;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PowerAfterLaunch;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalPower;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PhysicalPowerOptionData) == 0x000008, "Wrong alignment on FM1PhysicalPowerOptionData");
static_assert(sizeof(FM1PhysicalPowerOptionData) == 0x000020, "Wrong size on FM1PhysicalPowerOptionData");
static_assert(offsetof(FM1PhysicalPowerOptionData, bLaunchWhenDeathRagDoll) == 0x000008, "Member 'FM1PhysicalPowerOptionData::bLaunchWhenDeathRagDoll' has a wrong offset!");
static_assert(offsetof(FM1PhysicalPowerOptionData, LaunchPower) == 0x00000C, "Member 'FM1PhysicalPowerOptionData::LaunchPower' has a wrong offset!");
static_assert(offsetof(FM1PhysicalPowerOptionData, LaunchAssistAngle) == 0x000010, "Member 'FM1PhysicalPowerOptionData::LaunchAssistAngle' has a wrong offset!");
static_assert(offsetof(FM1PhysicalPowerOptionData, PowerAfterLaunch) == 0x000014, "Member 'FM1PhysicalPowerOptionData::PowerAfterLaunch' has a wrong offset!");
static_assert(offsetof(FM1PhysicalPowerOptionData, PhysicalPower) == 0x000018, "Member 'FM1PhysicalPowerOptionData::PhysicalPower' has a wrong offset!");

// ScriptStruct M1Data.M1RotationDropMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1RotationDropMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1RotationDropMiscDataLink) == 0x000008, "Wrong alignment on FM1RotationDropMiscDataLink");
static_assert(sizeof(FM1RotationDropMiscDataLink) == 0x000030, "Wrong size on FM1RotationDropMiscDataLink");

// ScriptStruct M1Data.M1UnlockedFieldInfo
// 0x0038 (0x0038 - 0x0000)
struct FM1UnlockedFieldInfo final
{
public:
	struct FM1TemplateId                          MapTemplateId;                                     // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasEntered;                                        // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1MapSubData>                  MapSubData;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         CampEntryPointId;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1TemplateId>                  BattleZoneId;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1UnlockedFieldInfo) == 0x000008, "Wrong alignment on FM1UnlockedFieldInfo");
static_assert(sizeof(FM1UnlockedFieldInfo) == 0x000038, "Wrong size on FM1UnlockedFieldInfo");
static_assert(offsetof(FM1UnlockedFieldInfo, MapTemplateId) == 0x000000, "Member 'FM1UnlockedFieldInfo::MapTemplateId' has a wrong offset!");
static_assert(offsetof(FM1UnlockedFieldInfo, HasEntered) == 0x000004, "Member 'FM1UnlockedFieldInfo::HasEntered' has a wrong offset!");
static_assert(offsetof(FM1UnlockedFieldInfo, MapSubData) == 0x000008, "Member 'FM1UnlockedFieldInfo::MapSubData' has a wrong offset!");
static_assert(offsetof(FM1UnlockedFieldInfo, CampEntryPointId) == 0x000018, "Member 'FM1UnlockedFieldInfo::CampEntryPointId' has a wrong offset!");
static_assert(offsetof(FM1UnlockedFieldInfo, BattleZoneId) == 0x000028, "Member 'FM1UnlockedFieldInfo::BattleZoneId' has a wrong offset!");

// ScriptStruct M1Data.M1RecoilInfo
// 0x0008 (0x0008 - 0x0000)
struct FM1RecoilInfo final
{
public:
	float                                         Pitch;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Yaw;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RecoilInfo) == 0x000004, "Wrong alignment on FM1RecoilInfo");
static_assert(sizeof(FM1RecoilInfo) == 0x000008, "Wrong size on FM1RecoilInfo");
static_assert(offsetof(FM1RecoilInfo, Pitch) == 0x000000, "Member 'FM1RecoilInfo::Pitch' has a wrong offset!");
static_assert(offsetof(FM1RecoilInfo, Yaw) == 0x000004, "Member 'FM1RecoilInfo::Yaw' has a wrong offset!");

// ScriptStruct M1Data.M1RangedWeaponRecoilData
// 0x0030 (0x0038 - 0x0008)
struct FM1RangedWeaponRecoilData final : public FTableRowBase
{
public:
	class FString                                 StringId;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilApplyInterpSpeed;                            // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilRecoverInterpSpeed;                          // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilRecoverStartDelay;                           // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilResetTimeAfterFire;                          // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1RecoilInfo>                  RecoilInfos;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RangedWeaponRecoilData) == 0x000008, "Wrong alignment on FM1RangedWeaponRecoilData");
static_assert(sizeof(FM1RangedWeaponRecoilData) == 0x000038, "Wrong size on FM1RangedWeaponRecoilData");
static_assert(offsetof(FM1RangedWeaponRecoilData, StringId) == 0x000008, "Member 'FM1RangedWeaponRecoilData::StringId' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponRecoilData, RecoilApplyInterpSpeed) == 0x000018, "Member 'FM1RangedWeaponRecoilData::RecoilApplyInterpSpeed' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponRecoilData, RecoilRecoverInterpSpeed) == 0x00001C, "Member 'FM1RangedWeaponRecoilData::RecoilRecoverInterpSpeed' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponRecoilData, RecoilRecoverStartDelay) == 0x000020, "Member 'FM1RangedWeaponRecoilData::RecoilRecoverStartDelay' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponRecoilData, RecoilResetTimeAfterFire) == 0x000024, "Member 'FM1RangedWeaponRecoilData::RecoilResetTimeAfterFire' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponRecoilData, RecoilInfos) == 0x000028, "Member 'FM1RangedWeaponRecoilData::RecoilInfos' has a wrong offset!");

// ScriptStruct M1Data.M1InstantUseDropGroupElement
// 0x0014 (0x0014 - 0x0000)
struct FM1InstantUseDropGroupElement final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ValueMin;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ValueMax;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstantUseDropGroupElement) == 0x000004, "Wrong alignment on FM1InstantUseDropGroupElement");
static_assert(sizeof(FM1InstantUseDropGroupElement) == 0x000014, "Wrong size on FM1InstantUseDropGroupElement");
static_assert(offsetof(FM1InstantUseDropGroupElement, ItemId) == 0x000000, "Member 'FM1InstantUseDropGroupElement::ItemId' has a wrong offset!");
static_assert(offsetof(FM1InstantUseDropGroupElement, ValueMin) == 0x000008, "Member 'FM1InstantUseDropGroupElement::ValueMin' has a wrong offset!");
static_assert(offsetof(FM1InstantUseDropGroupElement, ValueMax) == 0x00000C, "Member 'FM1InstantUseDropGroupElement::ValueMax' has a wrong offset!");
static_assert(offsetof(FM1InstantUseDropGroupElement, Ratio) == 0x000010, "Member 'FM1InstantUseDropGroupElement::Ratio' has a wrong offset!");

// ScriptStruct M1Data.M1ProductDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1ProductDataLink final : public FDataLink
{
};
static_assert(alignof(FM1ProductDataLink) == 0x000008, "Wrong alignment on FM1ProductDataLink");
static_assert(sizeof(FM1ProductDataLink) == 0x000030, "Wrong size on FM1ProductDataLink");

// ScriptStruct M1Data.M1MailDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1MailDataLink final : public FDataLink
{
};
static_assert(alignof(FM1MailDataLink) == 0x000008, "Wrong alignment on FM1MailDataLink");
static_assert(sizeof(FM1MailDataLink) == 0x000030, "Wrong size on FM1MailDataLink");

// ScriptStruct M1Data.M1CommonShopData
// 0x0058 (0x0060 - 0x0008)
struct FM1CommonShopData : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ShopCategoryType                           CategoryType;                                      // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ShopGroupCategoryId;                               // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ShopType                                   ShopType;                                          // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1ProductDataLink>             Items;                                             // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1MailDataLink                        Mail;                                              // 0x0030(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CommonShopData) == 0x000008, "Wrong alignment on FM1CommonShopData");
static_assert(sizeof(FM1CommonShopData) == 0x000060, "Wrong size on FM1CommonShopData");
static_assert(offsetof(FM1CommonShopData, TemplateId) == 0x000008, "Member 'FM1CommonShopData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1CommonShopData, CategoryType) == 0x00000C, "Member 'FM1CommonShopData::CategoryType' has a wrong offset!");
static_assert(offsetof(FM1CommonShopData, ShopGroupCategoryId) == 0x000010, "Member 'FM1CommonShopData::ShopGroupCategoryId' has a wrong offset!");
static_assert(offsetof(FM1CommonShopData, ShopType) == 0x000018, "Member 'FM1CommonShopData::ShopType' has a wrong offset!");
static_assert(offsetof(FM1CommonShopData, Items) == 0x000020, "Member 'FM1CommonShopData::Items' has a wrong offset!");
static_assert(offsetof(FM1CommonShopData, Mail) == 0x000030, "Member 'FM1CommonShopData::Mail' has a wrong offset!");

// ScriptStruct M1Data.M1BattlePassShopData
// 0x0000 (0x0060 - 0x0060)
struct FM1BattlePassShopData final : public FM1CommonShopData
{
};
static_assert(alignof(FM1BattlePassShopData) == 0x000008, "Wrong alignment on FM1BattlePassShopData");
static_assert(sizeof(FM1BattlePassShopData) == 0x000060, "Wrong size on FM1BattlePassShopData");

// ScriptStruct M1Data.M1EliteMonsterSkillGroupDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1EliteMonsterSkillGroupDataLink final : public FDataLink
{
};
static_assert(alignof(FM1EliteMonsterSkillGroupDataLink) == 0x000008, "Wrong alignment on FM1EliteMonsterSkillGroupDataLink");
static_assert(sizeof(FM1EliteMonsterSkillGroupDataLink) == 0x000030, "Wrong size on FM1EliteMonsterSkillGroupDataLink");

// ScriptStruct M1Data.M1EliteAbilityGroup
// 0x0038 (0x0038 - 0x0000)
struct FM1EliteAbilityGroup final
{
public:
	struct FM1EliteMonsterSkillGroupDataLink      ID;                                                // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	int32                                         Rate;                                              // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1EliteAbilityGroup) == 0x000008, "Wrong alignment on FM1EliteAbilityGroup");
static_assert(sizeof(FM1EliteAbilityGroup) == 0x000038, "Wrong size on FM1EliteAbilityGroup");
static_assert(offsetof(FM1EliteAbilityGroup, ID) == 0x000000, "Member 'FM1EliteAbilityGroup::ID' has a wrong offset!");
static_assert(offsetof(FM1EliteAbilityGroup, Rate) == 0x000030, "Member 'FM1EliteAbilityGroup::Rate' has a wrong offset!");

// ScriptStruct M1Data.M1MapEliteMonsterSpawnData
// 0x0030 (0x0030 - 0x0000)
struct FM1MapEliteMonsterSpawnData final
{
public:
	int32                                         EliteMonsterSpawnMin;                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EliteMonsterSpawnMax;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EliteMonsterSpawnRatio;                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EliteMonsterSpawnSkipCount;                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1EliteAbilityGroup>           EliteAbilityGroup;                                 // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1EliteMonsterSkillGroupDataLink> DefaultEliteAbilityGroup;                          // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MapEliteMonsterSpawnData) == 0x000008, "Wrong alignment on FM1MapEliteMonsterSpawnData");
static_assert(sizeof(FM1MapEliteMonsterSpawnData) == 0x000030, "Wrong size on FM1MapEliteMonsterSpawnData");
static_assert(offsetof(FM1MapEliteMonsterSpawnData, EliteMonsterSpawnMin) == 0x000000, "Member 'FM1MapEliteMonsterSpawnData::EliteMonsterSpawnMin' has a wrong offset!");
static_assert(offsetof(FM1MapEliteMonsterSpawnData, EliteMonsterSpawnMax) == 0x000004, "Member 'FM1MapEliteMonsterSpawnData::EliteMonsterSpawnMax' has a wrong offset!");
static_assert(offsetof(FM1MapEliteMonsterSpawnData, EliteMonsterSpawnRatio) == 0x000008, "Member 'FM1MapEliteMonsterSpawnData::EliteMonsterSpawnRatio' has a wrong offset!");
static_assert(offsetof(FM1MapEliteMonsterSpawnData, EliteMonsterSpawnSkipCount) == 0x00000C, "Member 'FM1MapEliteMonsterSpawnData::EliteMonsterSpawnSkipCount' has a wrong offset!");
static_assert(offsetof(FM1MapEliteMonsterSpawnData, EliteAbilityGroup) == 0x000010, "Member 'FM1MapEliteMonsterSpawnData::EliteAbilityGroup' has a wrong offset!");
static_assert(offsetof(FM1MapEliteMonsterSpawnData, DefaultEliteAbilityGroup) == 0x000020, "Member 'FM1MapEliteMonsterSpawnData::DefaultEliteAbilityGroup' has a wrong offset!");

// ScriptStruct M1Data.M1PartyMemberInfo
// 0x0048 (0x0048 - 0x0000)
struct FM1PartyMemberInfo final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccountName;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         AuthValue;                                         // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MasteryLevel;                                      // 0x0020(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlatformId;                                        // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         PlatformUid;                                       // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         PlatformType;                                      // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Master;                                            // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCreator;                                         // 0x0042(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x5];                                       // 0x0043(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PartyMemberInfo) == 0x000008, "Wrong alignment on FM1PartyMemberInfo");
static_assert(sizeof(FM1PartyMemberInfo) == 0x000048, "Wrong size on FM1PartyMemberInfo");
static_assert(offsetof(FM1PartyMemberInfo, AccountUid) == 0x000000, "Member 'FM1PartyMemberInfo::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1PartyMemberInfo, AccountName) == 0x000008, "Member 'FM1PartyMemberInfo::AccountName' has a wrong offset!");
static_assert(offsetof(FM1PartyMemberInfo, AuthValue) == 0x000018, "Member 'FM1PartyMemberInfo::AuthValue' has a wrong offset!");
static_assert(offsetof(FM1PartyMemberInfo, MasteryLevel) == 0x000020, "Member 'FM1PartyMemberInfo::MasteryLevel' has a wrong offset!");
static_assert(offsetof(FM1PartyMemberInfo, PlatformId) == 0x000028, "Member 'FM1PartyMemberInfo::PlatformId' has a wrong offset!");
static_assert(offsetof(FM1PartyMemberInfo, PlatformUid) == 0x000038, "Member 'FM1PartyMemberInfo::PlatformUid' has a wrong offset!");
static_assert(offsetof(FM1PartyMemberInfo, PlatformType) == 0x000040, "Member 'FM1PartyMemberInfo::PlatformType' has a wrong offset!");
static_assert(offsetof(FM1PartyMemberInfo, Master) == 0x000041, "Member 'FM1PartyMemberInfo::Master' has a wrong offset!");
static_assert(offsetof(FM1PartyMemberInfo, IsCreator) == 0x000042, "Member 'FM1PartyMemberInfo::IsCreator' has a wrong offset!");

// ScriptStruct M1Data.M1CurrencyInternalDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1CurrencyInternalDataLink final : public FDataLink
{
};
static_assert(alignof(FM1CurrencyInternalDataLink) == 0x000008, "Wrong alignment on FM1CurrencyInternalDataLink");
static_assert(sizeof(FM1CurrencyInternalDataLink) == 0x000030, "Wrong size on FM1CurrencyInternalDataLink");

// ScriptStruct M1Data.M1CurrencyData
// 0x00B8 (0x00C0 - 0x0008)
struct FM1CurrencyData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ItemUIData                          UIData;                                            // 0x0018(0x0060)(Edit, NativeAccessSpecifierPublic)
	EM1CurrencyType                               CurrencyType;                                      // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         StackLimit;                                        // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         PropClass;                                         // 0x0088(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1CurrencyInternalDataLink>    InternalCurrencyList;                              // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsTemporary;                                       // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CurrencyData) == 0x000008, "Wrong alignment on FM1CurrencyData");
static_assert(sizeof(FM1CurrencyData) == 0x0000C0, "Wrong size on FM1CurrencyData");
static_assert(offsetof(FM1CurrencyData, TemplateId) == 0x000008, "Member 'FM1CurrencyData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1CurrencyData, StringId) == 0x00000C, "Member 'FM1CurrencyData::StringId' has a wrong offset!");
static_assert(offsetof(FM1CurrencyData, UIData) == 0x000018, "Member 'FM1CurrencyData::UIData' has a wrong offset!");
static_assert(offsetof(FM1CurrencyData, CurrencyType) == 0x000078, "Member 'FM1CurrencyData::CurrencyType' has a wrong offset!");
static_assert(offsetof(FM1CurrencyData, StackLimit) == 0x000080, "Member 'FM1CurrencyData::StackLimit' has a wrong offset!");
static_assert(offsetof(FM1CurrencyData, PropClass) == 0x000088, "Member 'FM1CurrencyData::PropClass' has a wrong offset!");
static_assert(offsetof(FM1CurrencyData, InternalCurrencyList) == 0x0000A8, "Member 'FM1CurrencyData::InternalCurrencyList' has a wrong offset!");
static_assert(offsetof(FM1CurrencyData, IsTemporary) == 0x0000B8, "Member 'FM1CurrencyData::IsTemporary' has a wrong offset!");

// ScriptStruct M1Data.M1BoostItemEffect
// 0x0030 (0x0030 - 0x0000)
struct FM1BoostItemEffect final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1BuffSubItemType                            BuffType;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         BoostGroupId;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoostValue;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              EndTime;                                           // 0x0020(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          NewBoostItemTid;                                   // 0x0028(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1BoostItemEffect) == 0x000008, "Wrong alignment on FM1BoostItemEffect");
static_assert(sizeof(FM1BoostItemEffect) == 0x000030, "Wrong size on FM1BoostItemEffect");
static_assert(offsetof(FM1BoostItemEffect, AccountUid) == 0x000000, "Member 'FM1BoostItemEffect::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1BoostItemEffect, BuffType) == 0x000008, "Member 'FM1BoostItemEffect::BuffType' has a wrong offset!");
static_assert(offsetof(FM1BoostItemEffect, BoostGroupId) == 0x000010, "Member 'FM1BoostItemEffect::BoostGroupId' has a wrong offset!");
static_assert(offsetof(FM1BoostItemEffect, BoostValue) == 0x000018, "Member 'FM1BoostItemEffect::BoostValue' has a wrong offset!");
static_assert(offsetof(FM1BoostItemEffect, EndTime) == 0x000020, "Member 'FM1BoostItemEffect::EndTime' has a wrong offset!");
static_assert(offsetof(FM1BoostItemEffect, NewBoostItemTid) == 0x000028, "Member 'FM1BoostItemEffect::NewBoostItemTid' has a wrong offset!");

// ScriptStruct M1Data.M1BoostItemEffectBundle
// 0x0010 (0x0010 - 0x0000)
struct FM1BoostItemEffectBundle final
{
public:
	TArray<struct FM1BoostItemEffect>             DataList;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BoostItemEffectBundle) == 0x000008, "Wrong alignment on FM1BoostItemEffectBundle");
static_assert(sizeof(FM1BoostItemEffectBundle) == 0x000010, "Wrong size on FM1BoostItemEffectBundle");
static_assert(offsetof(FM1BoostItemEffectBundle, DataList) == 0x000000, "Member 'FM1BoostItemEffectBundle::DataList' has a wrong offset!");

// ScriptStruct M1Data.M1CreditInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1CreditInfo final
{
public:
	EM1CreditType                                 CreditType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Params;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CreditInfo) == 0x000008, "Wrong alignment on FM1CreditInfo");
static_assert(sizeof(FM1CreditInfo) == 0x000018, "Wrong size on FM1CreditInfo");
static_assert(offsetof(FM1CreditInfo, CreditType) == 0x000000, "Member 'FM1CreditInfo::CreditType' has a wrong offset!");
static_assert(offsetof(FM1CreditInfo, Params) == 0x000008, "Member 'FM1CreditInfo::Params' has a wrong offset!");

// ScriptStruct M1Data.M1CurrencyDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1CurrencyDataLink final : public FDataLink
{
};
static_assert(alignof(FM1CurrencyDataLink) == 0x000008, "Wrong alignment on FM1CurrencyDataLink");
static_assert(sizeof(FM1CurrencyDataLink) == 0x000030, "Wrong size on FM1CurrencyDataLink");

// ScriptStruct M1Data.M1MoveDedicatedServerNoti
// 0x00C0 (0x00C0 - 0x0000)
struct FM1MoveDedicatedServerNoti final
{
public:
	EM1MoveDedicatedServerReason                  Reason;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 AccountUids;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1DedicatedServerInfo                 ServerInfo;                                        // 0x0018(0x00A0)(Edit, NativeAccessSpecifierPublic)
	bool                                          MovePosition;                                      // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MoveDedicatedServerNoti) == 0x000008, "Wrong alignment on FM1MoveDedicatedServerNoti");
static_assert(sizeof(FM1MoveDedicatedServerNoti) == 0x0000C0, "Wrong size on FM1MoveDedicatedServerNoti");
static_assert(offsetof(FM1MoveDedicatedServerNoti, Reason) == 0x000000, "Member 'FM1MoveDedicatedServerNoti::Reason' has a wrong offset!");
static_assert(offsetof(FM1MoveDedicatedServerNoti, AccountUids) == 0x000008, "Member 'FM1MoveDedicatedServerNoti::AccountUids' has a wrong offset!");
static_assert(offsetof(FM1MoveDedicatedServerNoti, ServerInfo) == 0x000018, "Member 'FM1MoveDedicatedServerNoti::ServerInfo' has a wrong offset!");
static_assert(offsetof(FM1MoveDedicatedServerNoti, MovePosition) == 0x0000B8, "Member 'FM1MoveDedicatedServerNoti::MovePosition' has a wrong offset!");

// ScriptStruct M1Data.M1MarkerInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1MarkerInfo final
{
public:
	class FString                                 MarkerKey;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StringId;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MarkerInfo) == 0x000008, "Wrong alignment on FM1MarkerInfo");
static_assert(sizeof(FM1MarkerInfo) == 0x000020, "Wrong size on FM1MarkerInfo");
static_assert(offsetof(FM1MarkerInfo, MarkerKey) == 0x000000, "Member 'FM1MarkerInfo::MarkerKey' has a wrong offset!");
static_assert(offsetof(FM1MarkerInfo, StringId) == 0x000010, "Member 'FM1MarkerInfo::StringId' has a wrong offset!");

// ScriptStruct M1Data.M1InstanceDungeonSelectionMODGroupDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1InstanceDungeonSelectionMODGroupDataLink final : public FDataLink
{
};
static_assert(alignof(FM1InstanceDungeonSelectionMODGroupDataLink) == 0x000008, "Wrong alignment on FM1InstanceDungeonSelectionMODGroupDataLink");
static_assert(sizeof(FM1InstanceDungeonSelectionMODGroupDataLink) == 0x000030, "Wrong size on FM1InstanceDungeonSelectionMODGroupDataLink");

// ScriptStruct M1Data.M1MasteryCanLevelUpNoti
// 0x0010 (0x0010 - 0x0000)
struct FM1MasteryCanLevelUpNoti final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          Level;                                             // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MasteryCanLevelUpNoti) == 0x000008, "Wrong alignment on FM1MasteryCanLevelUpNoti");
static_assert(sizeof(FM1MasteryCanLevelUpNoti) == 0x000010, "Wrong size on FM1MasteryCanLevelUpNoti");
static_assert(offsetof(FM1MasteryCanLevelUpNoti, AccountUid) == 0x000000, "Member 'FM1MasteryCanLevelUpNoti::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1MasteryCanLevelUpNoti, Level) == 0x000008, "Member 'FM1MasteryCanLevelUpNoti::Level' has a wrong offset!");

// ScriptStruct M1Data.M1StatOverrideData
// 0x0018 (0x0018 - 0x0000)
struct FM1StatOverrideData final
{
public:
	EM1StatType                                   StatType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Value;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StatOverrideData) == 0x000008, "Wrong alignment on FM1StatOverrideData");
static_assert(sizeof(FM1StatOverrideData) == 0x000018, "Wrong size on FM1StatOverrideData");
static_assert(offsetof(FM1StatOverrideData, StatType) == 0x000000, "Member 'FM1StatOverrideData::StatType' has a wrong offset!");
static_assert(offsetof(FM1StatOverrideData, Value) == 0x000008, "Member 'FM1StatOverrideData::Value' has a wrong offset!");

// ScriptStruct M1Data.M1LvFactorData
// 0x0018 (0x0018 - 0x0000)
struct FM1LvFactorData final
{
public:
	int32                                         NumOfPartyMember;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1StatOverrideData>            StatOverrideList;                                  // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1LvFactorData) == 0x000008, "Wrong alignment on FM1LvFactorData");
static_assert(sizeof(FM1LvFactorData) == 0x000018, "Wrong size on FM1LvFactorData");
static_assert(offsetof(FM1LvFactorData, NumOfPartyMember) == 0x000000, "Member 'FM1LvFactorData::NumOfPartyMember' has a wrong offset!");
static_assert(offsetof(FM1LvFactorData, StatOverrideList) == 0x000008, "Member 'FM1LvFactorData::StatOverrideList' has a wrong offset!");

// ScriptStruct M1Data.M1EquipmentDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1EquipmentDataLink final : public FDataLink
{
};
static_assert(alignof(FM1EquipmentDataLink) == 0x000008, "Wrong alignment on FM1EquipmentDataLink");
static_assert(sizeof(FM1EquipmentDataLink) == 0x000030, "Wrong size on FM1EquipmentDataLink");

// ScriptStruct M1Data.M1BaseWeaponItemElement
// 0x0038 (0x0038 - 0x0000)
struct FM1BaseWeaponItemElement final
{
public:
	struct FM1EquipmentDataLink                   ID;                                                // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1BaseWeaponItemElement) == 0x000008, "Wrong alignment on FM1BaseWeaponItemElement");
static_assert(sizeof(FM1BaseWeaponItemElement) == 0x000038, "Wrong size on FM1BaseWeaponItemElement");
static_assert(offsetof(FM1BaseWeaponItemElement, ID) == 0x000000, "Member 'FM1BaseWeaponItemElement::ID' has a wrong offset!");
static_assert(offsetof(FM1BaseWeaponItemElement, Level) == 0x000030, "Member 'FM1BaseWeaponItemElement::Level' has a wrong offset!");

// ScriptStruct M1Data.M1RotationDropDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1RotationDropDataLink final : public FDataLink
{
};
static_assert(alignof(FM1RotationDropDataLink) == 0x000008, "Wrong alignment on FM1RotationDropDataLink");
static_assert(sizeof(FM1RotationDropDataLink) == 0x000030, "Wrong size on FM1RotationDropDataLink");

// ScriptStruct M1Data.M1VoidBattleEntranceInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1VoidBattleEntranceInfo final
{
public:
	struct FM1TemplateId                          MapId;                                             // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1MapSubData                          MapSubData;                                        // 0x0004(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Entrance;                                          // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1VoidBattleEntranceInfo) == 0x000004, "Wrong alignment on FM1VoidBattleEntranceInfo");
static_assert(sizeof(FM1VoidBattleEntranceInfo) == 0x000018, "Wrong size on FM1VoidBattleEntranceInfo");
static_assert(offsetof(FM1VoidBattleEntranceInfo, MapId) == 0x000000, "Member 'FM1VoidBattleEntranceInfo::MapId' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleEntranceInfo, MapSubData) == 0x000004, "Member 'FM1VoidBattleEntranceInfo::MapSubData' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleEntranceInfo, Entrance) == 0x000014, "Member 'FM1VoidBattleEntranceInfo::Entrance' has a wrong offset!");

// ScriptStruct M1Data.M1VoidBattleClearInfo
// 0x0008 (0x0008 - 0x0000)
struct FM1VoidBattleClearInfo final
{
public:
	struct FM1TemplateId                          Tid;                                               // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClearCount;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1VoidBattleClearInfo) == 0x000004, "Wrong alignment on FM1VoidBattleClearInfo");
static_assert(sizeof(FM1VoidBattleClearInfo) == 0x000008, "Wrong size on FM1VoidBattleClearInfo");
static_assert(offsetof(FM1VoidBattleClearInfo, Tid) == 0x000000, "Member 'FM1VoidBattleClearInfo::Tid' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleClearInfo, ClearCount) == 0x000004, "Member 'FM1VoidBattleClearInfo::ClearCount' has a wrong offset!");

// ScriptStruct M1Data.M1MissionTargetActiveAbilityData
// 0x000C (0x000C - 0x0000)
struct FM1MissionTargetActiveAbilityData final
{
public:
	float                                         FirstDelay;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooltimeMin;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooltimeMax;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionTargetActiveAbilityData) == 0x000004, "Wrong alignment on FM1MissionTargetActiveAbilityData");
static_assert(sizeof(FM1MissionTargetActiveAbilityData) == 0x00000C, "Wrong size on FM1MissionTargetActiveAbilityData");
static_assert(offsetof(FM1MissionTargetActiveAbilityData, FirstDelay) == 0x000000, "Member 'FM1MissionTargetActiveAbilityData::FirstDelay' has a wrong offset!");
static_assert(offsetof(FM1MissionTargetActiveAbilityData, CooltimeMin) == 0x000004, "Member 'FM1MissionTargetActiveAbilityData::CooltimeMin' has a wrong offset!");
static_assert(offsetof(FM1MissionTargetActiveAbilityData, CooltimeMax) == 0x000008, "Member 'FM1MissionTargetActiveAbilityData::CooltimeMax' has a wrong offset!");

// ScriptStruct M1Data.M1MonsterTagRatePair
// 0x000C (0x000C - 0x0000)
struct FM1MonsterTagRatePair final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterTagRatePair) == 0x000004, "Wrong alignment on FM1MonsterTagRatePair");
static_assert(sizeof(FM1MonsterTagRatePair) == 0x00000C, "Wrong size on FM1MonsterTagRatePair");
static_assert(offsetof(FM1MonsterTagRatePair, ID) == 0x000000, "Member 'FM1MonsterTagRatePair::ID' has a wrong offset!");
static_assert(offsetof(FM1MonsterTagRatePair, Rate) == 0x000008, "Member 'FM1MonsterTagRatePair::Rate' has a wrong offset!");

// ScriptStruct M1Data.M1OntimeEventRemoveData
// 0x0008 (0x0008 - 0x0000)
struct FM1OntimeEventRemoveData final
{
public:
	int64                                         EventId;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1OntimeEventRemoveData) == 0x000008, "Wrong alignment on FM1OntimeEventRemoveData");
static_assert(sizeof(FM1OntimeEventRemoveData) == 0x000008, "Wrong size on FM1OntimeEventRemoveData");
static_assert(offsetof(FM1OntimeEventRemoveData, EventId) == 0x000000, "Member 'FM1OntimeEventRemoveData::EventId' has a wrong offset!");

// ScriptStruct M1Data.M1RuneSocketTypeSelection
// 0x0003 (0x0003 - 0x0000)
struct FM1RuneSocketTypeSelection final
{
public:
	EM1RuneSocketType                             SelectedSocketType;                                // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RuneSubClassType                           RuneSubClassType;                                  // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SocketIndex;                                       // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneSocketTypeSelection) == 0x000001, "Wrong alignment on FM1RuneSocketTypeSelection");
static_assert(sizeof(FM1RuneSocketTypeSelection) == 0x000003, "Wrong size on FM1RuneSocketTypeSelection");
static_assert(offsetof(FM1RuneSocketTypeSelection, SelectedSocketType) == 0x000000, "Member 'FM1RuneSocketTypeSelection::SelectedSocketType' has a wrong offset!");
static_assert(offsetof(FM1RuneSocketTypeSelection, RuneSubClassType) == 0x000001, "Member 'FM1RuneSocketTypeSelection::RuneSubClassType' has a wrong offset!");
static_assert(offsetof(FM1RuneSocketTypeSelection, SocketIndex) == 0x000002, "Member 'FM1RuneSocketTypeSelection::SocketIndex' has a wrong offset!");

// ScriptStruct M1Data.M1RunePositionBundle
// 0x0020 (0x0020 - 0x0000)
struct FM1RunePositionBundle final
{
public:
	TArray<struct FM1RunePosition>                RunePositionList;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1RuneSocketTypeSelection>     RuneSocketTypeSelectionList;                       // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RunePositionBundle) == 0x000008, "Wrong alignment on FM1RunePositionBundle");
static_assert(sizeof(FM1RunePositionBundle) == 0x000020, "Wrong size on FM1RunePositionBundle");
static_assert(offsetof(FM1RunePositionBundle, RunePositionList) == 0x000000, "Member 'FM1RunePositionBundle::RunePositionList' has a wrong offset!");
static_assert(offsetof(FM1RunePositionBundle, RuneSocketTypeSelectionList) == 0x000010, "Member 'FM1RunePositionBundle::RuneSocketTypeSelectionList' has a wrong offset!");

// ScriptStruct M1Data.M1DifficultyInfoMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1DifficultyInfoMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1DifficultyInfoMiscDataLink) == 0x000008, "Wrong alignment on FM1DifficultyInfoMiscDataLink");
static_assert(sizeof(FM1DifficultyInfoMiscDataLink) == 0x000030, "Wrong size on FM1DifficultyInfoMiscDataLink");

// ScriptStruct M1Data.M1PlatformAchievementCompleteInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1PlatformAchievementCompleteInfo final
{
public:
	struct FM1TemplateId                          AchievementId;                                     // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EM1ContentsPlatformType>               AchievedPlatforms;                                 // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PlatformAchievementCompleteInfo) == 0x000008, "Wrong alignment on FM1PlatformAchievementCompleteInfo");
static_assert(sizeof(FM1PlatformAchievementCompleteInfo) == 0x000018, "Wrong size on FM1PlatformAchievementCompleteInfo");
static_assert(offsetof(FM1PlatformAchievementCompleteInfo, AchievementId) == 0x000000, "Member 'FM1PlatformAchievementCompleteInfo::AchievementId' has a wrong offset!");
static_assert(offsetof(FM1PlatformAchievementCompleteInfo, AchievedPlatforms) == 0x000008, "Member 'FM1PlatformAchievementCompleteInfo::AchievedPlatforms' has a wrong offset!");

// ScriptStruct M1Data.M1PlatformAchievementCompleteInfoList
// 0x0010 (0x0010 - 0x0000)
struct FM1PlatformAchievementCompleteInfoList final
{
public:
	TArray<struct FM1PlatformAchievementCompleteInfo> CompleteInfos;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PlatformAchievementCompleteInfoList) == 0x000008, "Wrong alignment on FM1PlatformAchievementCompleteInfoList");
static_assert(sizeof(FM1PlatformAchievementCompleteInfoList) == 0x000010, "Wrong size on FM1PlatformAchievementCompleteInfoList");
static_assert(offsetof(FM1PlatformAchievementCompleteInfoList, CompleteInfos) == 0x000000, "Member 'FM1PlatformAchievementCompleteInfoList::CompleteInfos' has a wrong offset!");

// ScriptStruct M1Data.M1KeyText
// 0x0040 (0x0040 - 0x0000)
struct FM1KeyText final
{
public:
	class FString                                 Text;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Desc;                                              // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Narrative;                                         // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NarrativeLong;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1KeyText) == 0x000008, "Wrong alignment on FM1KeyText");
static_assert(sizeof(FM1KeyText) == 0x000040, "Wrong size on FM1KeyText");
static_assert(offsetof(FM1KeyText, Text) == 0x000000, "Member 'FM1KeyText::Text' has a wrong offset!");
static_assert(offsetof(FM1KeyText, Desc) == 0x000010, "Member 'FM1KeyText::Desc' has a wrong offset!");
static_assert(offsetof(FM1KeyText, Narrative) == 0x000020, "Member 'FM1KeyText::Narrative' has a wrong offset!");
static_assert(offsetof(FM1KeyText, NarrativeLong) == 0x000030, "Member 'FM1KeyText::NarrativeLong' has a wrong offset!");

// ScriptStruct M1Data.M1StringTableDataRow
// 0x0080 (0x0088 - 0x0008)
struct FM1StringTableDataRow : public FTableRowBase
{
public:
	struct FM1KeyText                             KO;                                                // 0x0008(0x0040)(Edit, NativeAccessSpecifierPublic)
	struct FM1KeyText                             EN;                                                // 0x0048(0x0040)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StringTableDataRow) == 0x000008, "Wrong alignment on FM1StringTableDataRow");
static_assert(sizeof(FM1StringTableDataRow) == 0x000088, "Wrong size on FM1StringTableDataRow");
static_assert(offsetof(FM1StringTableDataRow, KO) == 0x000008, "Member 'FM1StringTableDataRow::KO' has a wrong offset!");
static_assert(offsetof(FM1StringTableDataRow, EN) == 0x000048, "Member 'FM1StringTableDataRow::EN' has a wrong offset!");

// ScriptStruct M1Data.M1SkillStringTableDataRow
// 0x0000 (0x0088 - 0x0088)
struct FM1SkillStringTableDataRow final : public FM1StringTableDataRow
{
};
static_assert(alignof(FM1SkillStringTableDataRow) == 0x000008, "Wrong alignment on FM1SkillStringTableDataRow");
static_assert(sizeof(FM1SkillStringTableDataRow) == 0x000088, "Wrong size on FM1SkillStringTableDataRow");

// ScriptStruct M1Data.M1SettingInfo
// 0x0001 (0x0001 - 0x0000)
struct FM1SettingInfo final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SettingInfo) == 0x000001, "Wrong alignment on FM1SettingInfo");
static_assert(sizeof(FM1SettingInfo) == 0x000001, "Wrong size on FM1SettingInfo");

// ScriptStruct M1Data.M1LoadSettingRes
// 0x0002 (0x0002 - 0x0000)
struct FM1LoadSettingRes final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1SettingInfo                         SettingInfo;                                       // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1LoadSettingRes) == 0x000001, "Wrong alignment on FM1LoadSettingRes");
static_assert(sizeof(FM1LoadSettingRes) == 0x000002, "Wrong size on FM1LoadSettingRes");
static_assert(offsetof(FM1LoadSettingRes, Success) == 0x000000, "Member 'FM1LoadSettingRes::Success' has a wrong offset!");
static_assert(offsetof(FM1LoadSettingRes, SettingInfo) == 0x000001, "Member 'FM1LoadSettingRes::SettingInfo' has a wrong offset!");

// ScriptStruct M1Data.M1ReinforceSlotInfo
// 0x0008 (0x0008 - 0x0000)
struct FM1ReinforceSlotInfo final
{
public:
	int32                                         GroupIndex;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ReinforceSlotInfo) == 0x000004, "Wrong alignment on FM1ReinforceSlotInfo");
static_assert(sizeof(FM1ReinforceSlotInfo) == 0x000008, "Wrong size on FM1ReinforceSlotInfo");
static_assert(offsetof(FM1ReinforceSlotInfo, GroupIndex) == 0x000000, "Member 'FM1ReinforceSlotInfo::GroupIndex' has a wrong offset!");
static_assert(offsetof(FM1ReinforceSlotInfo, SlotIndex) == 0x000004, "Member 'FM1ReinforceSlotInfo::SlotIndex' has a wrong offset!");

// ScriptStruct M1Data.M1SeasonReinforceInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1SeasonReinforceInfo final
{
public:
	TArray<struct FM1ReinforceSlotInfo>           UnlockedSeasonReinforceList;                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1ReinforceSlotInfo>           EquippedSeasonReinforceList;                       // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SeasonReinforceInfo) == 0x000008, "Wrong alignment on FM1SeasonReinforceInfo");
static_assert(sizeof(FM1SeasonReinforceInfo) == 0x000020, "Wrong size on FM1SeasonReinforceInfo");
static_assert(offsetof(FM1SeasonReinforceInfo, UnlockedSeasonReinforceList) == 0x000000, "Member 'FM1SeasonReinforceInfo::UnlockedSeasonReinforceList' has a wrong offset!");
static_assert(offsetof(FM1SeasonReinforceInfo, EquippedSeasonReinforceList) == 0x000010, "Member 'FM1SeasonReinforceInfo::EquippedSeasonReinforceList' has a wrong offset!");

// ScriptStruct M1Data.M1InventorySlotExpansionOverNotiData
// 0x0018 (0x0018 - 0x0000)
struct FM1InventorySlotExpansionOverNotiData final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1InventoryType                              InventoryType;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ItemTidBox                          ItemTidBox;                                        // 0x000C(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InventorySlotExpansionOverNotiData) == 0x000008, "Wrong alignment on FM1InventorySlotExpansionOverNotiData");
static_assert(sizeof(FM1InventorySlotExpansionOverNotiData) == 0x000018, "Wrong size on FM1InventorySlotExpansionOverNotiData");
static_assert(offsetof(FM1InventorySlotExpansionOverNotiData, AccountUid) == 0x000000, "Member 'FM1InventorySlotExpansionOverNotiData::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1InventorySlotExpansionOverNotiData, InventoryType) == 0x000008, "Member 'FM1InventorySlotExpansionOverNotiData::InventoryType' has a wrong offset!");
static_assert(offsetof(FM1InventorySlotExpansionOverNotiData, ItemTidBox) == 0x00000C, "Member 'FM1InventorySlotExpansionOverNotiData::ItemTidBox' has a wrong offset!");
static_assert(offsetof(FM1InventorySlotExpansionOverNotiData, Amount) == 0x000014, "Member 'FM1InventorySlotExpansionOverNotiData::Amount' has a wrong offset!");

// ScriptStruct M1Data.DataLinkUnion
// 0x0008 (0x0030 - 0x0028)
struct FDataLinkUnion : public FDataLinkBase
{
public:
	class FName                                   ID;                                                // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDataLinkUnion) == 0x000008, "Wrong alignment on FDataLinkUnion");
static_assert(sizeof(FDataLinkUnion) == 0x000030, "Wrong size on FDataLinkUnion");
static_assert(offsetof(FDataLinkUnion, ID) == 0x000028, "Member 'FDataLinkUnion::ID' has a wrong offset!");

// ScriptStruct M1Data.M1ItemDataBox
// 0x0008 (0x0038 - 0x0030)
struct FM1ItemDataBox final : public FDataLinkUnion
{
public:
	EM1ItemType                                   Type;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ItemDataBox) == 0x000008, "Wrong alignment on FM1ItemDataBox");
static_assert(sizeof(FM1ItemDataBox) == 0x000038, "Wrong size on FM1ItemDataBox");
static_assert(offsetof(FM1ItemDataBox, Type) == 0x000030, "Member 'FM1ItemDataBox::Type' has a wrong offset!");

// ScriptStruct M1Data.M1RedeemItemBox
// 0x0008 (0x0038 - 0x0030)
struct FM1RedeemItemBox final : public FDataLinkUnion
{
public:
	EM1RedeemType                                 Type;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RedeemItemBox) == 0x000008, "Wrong alignment on FM1RedeemItemBox");
static_assert(sizeof(FM1RedeemItemBox) == 0x000038, "Wrong size on FM1RedeemItemBox");
static_assert(offsetof(FM1RedeemItemBox, Type) == 0x000030, "Member 'FM1RedeemItemBox::Type' has a wrong offset!");

// ScriptStruct M1Data.M1ConsumableItemData
// 0x0128 (0x0130 - 0x0008)
struct FM1ConsumableItemData : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ItemUIData                          UIData;                                            // 0x0018(0x0060)(Edit, NativeAccessSpecifierPublic)
	EM1ConsumableItemCategoryType                 Category;                                          // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemTierType                               TierType;                                          // 0x0079(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ConsumableItemHowToUse                     HowToUse;                                          // 0x007A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B[0x1];                                       // 0x007B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ObtainableCountPerChance;                          // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCapacity;                                       // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Deletable;                                         // 0x0084(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ItemDataBox                         SellingType;                                       // 0x0088(0x0038)(Edit, NativeAccessSpecifierPublic)
	int32                                         SellingPrice;                                      // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1RedeemItemBox                       RedeemItem;                                        // 0x00C8(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         PropClass;                                         // 0x0100(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ImportantPriority;                                 // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ImportanceType                             ImportanceType;                                    // 0x0124(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MasteryLevel;                                      // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTemporary;                                       // 0x012C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ConsumableItemData) == 0x000008, "Wrong alignment on FM1ConsumableItemData");
static_assert(sizeof(FM1ConsumableItemData) == 0x000130, "Wrong size on FM1ConsumableItemData");
static_assert(offsetof(FM1ConsumableItemData, TemplateId) == 0x000008, "Member 'FM1ConsumableItemData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1ConsumableItemData, StringId) == 0x00000C, "Member 'FM1ConsumableItemData::StringId' has a wrong offset!");
static_assert(offsetof(FM1ConsumableItemData, UIData) == 0x000018, "Member 'FM1ConsumableItemData::UIData' has a wrong offset!");
static_assert(offsetof(FM1ConsumableItemData, Category) == 0x000078, "Member 'FM1ConsumableItemData::Category' has a wrong offset!");
static_assert(offsetof(FM1ConsumableItemData, TierType) == 0x000079, "Member 'FM1ConsumableItemData::TierType' has a wrong offset!");
static_assert(offsetof(FM1ConsumableItemData, HowToUse) == 0x00007A, "Member 'FM1ConsumableItemData::HowToUse' has a wrong offset!");
static_assert(offsetof(FM1ConsumableItemData, ObtainableCountPerChance) == 0x00007C, "Member 'FM1ConsumableItemData::ObtainableCountPerChance' has a wrong offset!");
static_assert(offsetof(FM1ConsumableItemData, MaxCapacity) == 0x000080, "Member 'FM1ConsumableItemData::MaxCapacity' has a wrong offset!");
static_assert(offsetof(FM1ConsumableItemData, Deletable) == 0x000084, "Member 'FM1ConsumableItemData::Deletable' has a wrong offset!");
static_assert(offsetof(FM1ConsumableItemData, SellingType) == 0x000088, "Member 'FM1ConsumableItemData::SellingType' has a wrong offset!");
static_assert(offsetof(FM1ConsumableItemData, SellingPrice) == 0x0000C0, "Member 'FM1ConsumableItemData::SellingPrice' has a wrong offset!");
static_assert(offsetof(FM1ConsumableItemData, RedeemItem) == 0x0000C8, "Member 'FM1ConsumableItemData::RedeemItem' has a wrong offset!");
static_assert(offsetof(FM1ConsumableItemData, PropClass) == 0x000100, "Member 'FM1ConsumableItemData::PropClass' has a wrong offset!");
static_assert(offsetof(FM1ConsumableItemData, ImportantPriority) == 0x000120, "Member 'FM1ConsumableItemData::ImportantPriority' has a wrong offset!");
static_assert(offsetof(FM1ConsumableItemData, ImportanceType) == 0x000124, "Member 'FM1ConsumableItemData::ImportanceType' has a wrong offset!");
static_assert(offsetof(FM1ConsumableItemData, MasteryLevel) == 0x000128, "Member 'FM1ConsumableItemData::MasteryLevel' has a wrong offset!");
static_assert(offsetof(FM1ConsumableItemData, IsTemporary) == 0x00012C, "Member 'FM1ConsumableItemData::IsTemporary' has a wrong offset!");

// ScriptStruct M1Data.M1BoostItemData
// 0x0010 (0x0140 - 0x0130)
struct FM1BoostItemData final : public FM1ConsumableItemData
{
public:
	int32                                         BoostGroupId;                                      // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1BuffItemType                               BuffItemType;                                      // 0x0134(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1BuffSubItemType                            BuffSubItemType;                                   // 0x0135(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_136[0x2];                                      // 0x0136(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BoostValue;                                        // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RemainSec;                                         // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BoostItemData) == 0x000008, "Wrong alignment on FM1BoostItemData");
static_assert(sizeof(FM1BoostItemData) == 0x000140, "Wrong size on FM1BoostItemData");
static_assert(offsetof(FM1BoostItemData, BoostGroupId) == 0x000130, "Member 'FM1BoostItemData::BoostGroupId' has a wrong offset!");
static_assert(offsetof(FM1BoostItemData, BuffItemType) == 0x000134, "Member 'FM1BoostItemData::BuffItemType' has a wrong offset!");
static_assert(offsetof(FM1BoostItemData, BuffSubItemType) == 0x000135, "Member 'FM1BoostItemData::BuffSubItemType' has a wrong offset!");
static_assert(offsetof(FM1BoostItemData, BoostValue) == 0x000138, "Member 'FM1BoostItemData::BoostValue' has a wrong offset!");
static_assert(offsetof(FM1BoostItemData, RemainSec) == 0x00013C, "Member 'FM1BoostItemData::RemainSec' has a wrong offset!");

// ScriptStruct M1Data.M1CodexItemInfoList
// 0x0018 (0x0018 - 0x0000)
struct FM1CodexItemInfoList final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1ItemTidBox>                  ItemInfoList;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CodexItemInfoList) == 0x000008, "Wrong alignment on FM1CodexItemInfoList");
static_assert(sizeof(FM1CodexItemInfoList) == 0x000018, "Wrong size on FM1CodexItemInfoList");
static_assert(offsetof(FM1CodexItemInfoList, AccountUid) == 0x000000, "Member 'FM1CodexItemInfoList::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1CodexItemInfoList, ItemInfoList) == 0x000008, "Member 'FM1CodexItemInfoList::ItemInfoList' has a wrong offset!");

// ScriptStruct M1Data.M1AbilityData
// 0x0068 (0x0070 - 0x0008)
struct FM1AbilityData : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AbilityClass;                                      // 0x0010(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1TaggedAbilityOperationData>  Operations;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1TaggedInvokeStatusEffectData> InvokeStatusEffects;                               // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1TaggedSpawnAbilityActorData> SpawnAbilityActors;                                // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1AbilityParamData>            Params;                                            // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityData) == 0x000008, "Wrong alignment on FM1AbilityData");
static_assert(sizeof(FM1AbilityData) == 0x000070, "Wrong size on FM1AbilityData");
static_assert(offsetof(FM1AbilityData, Name) == 0x000008, "Member 'FM1AbilityData::Name' has a wrong offset!");
static_assert(offsetof(FM1AbilityData, AbilityClass) == 0x000010, "Member 'FM1AbilityData::AbilityClass' has a wrong offset!");
static_assert(offsetof(FM1AbilityData, Operations) == 0x000030, "Member 'FM1AbilityData::Operations' has a wrong offset!");
static_assert(offsetof(FM1AbilityData, InvokeStatusEffects) == 0x000040, "Member 'FM1AbilityData::InvokeStatusEffects' has a wrong offset!");
static_assert(offsetof(FM1AbilityData, SpawnAbilityActors) == 0x000050, "Member 'FM1AbilityData::SpawnAbilityActors' has a wrong offset!");
static_assert(offsetof(FM1AbilityData, Params) == 0x000060, "Member 'FM1AbilityData::Params' has a wrong offset!");

// ScriptStruct M1Data.M1InstanceDungeonAbilityData
// 0x0048 (0x00B8 - 0x0070)
struct FM1InstanceDungeonAbilityData final : public FM1AbilityData
{
public:
	class FString                                 StringId;                                          // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0080(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ApplyToPlayer;                                     // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EM1MonsterCategory>                    MonsterCategories;                                 // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceDungeonAbilityData) == 0x000008, "Wrong alignment on FM1InstanceDungeonAbilityData");
static_assert(sizeof(FM1InstanceDungeonAbilityData) == 0x0000B8, "Wrong size on FM1InstanceDungeonAbilityData");
static_assert(offsetof(FM1InstanceDungeonAbilityData, StringId) == 0x000070, "Member 'FM1InstanceDungeonAbilityData::StringId' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonAbilityData, IconPath) == 0x000080, "Member 'FM1InstanceDungeonAbilityData::IconPath' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonAbilityData, ApplyToPlayer) == 0x0000A0, "Member 'FM1InstanceDungeonAbilityData::ApplyToPlayer' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonAbilityData, MonsterCategories) == 0x0000A8, "Member 'FM1InstanceDungeonAbilityData::MonsterCategories' has a wrong offset!");

// ScriptStruct M1Data.M1FieldObjectDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1FieldObjectDataLink final : public FDataLink
{
};
static_assert(alignof(FM1FieldObjectDataLink) == 0x000008, "Wrong alignment on FM1FieldObjectDataLink");
static_assert(sizeof(FM1FieldObjectDataLink) == 0x000030, "Wrong size on FM1FieldObjectDataLink");

// ScriptStruct M1Data.M1FieldObjectSpawnInfo
// 0x0038 (0x0038 - 0x0000)
struct FM1FieldObjectSpawnInfo final
{
public:
	int32                                         Rate;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1FieldObjectDataLink                 FieldObject;                                       // 0x0008(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FieldObjectSpawnInfo) == 0x000008, "Wrong alignment on FM1FieldObjectSpawnInfo");
static_assert(sizeof(FM1FieldObjectSpawnInfo) == 0x000038, "Wrong size on FM1FieldObjectSpawnInfo");
static_assert(offsetof(FM1FieldObjectSpawnInfo, Rate) == 0x000000, "Member 'FM1FieldObjectSpawnInfo::Rate' has a wrong offset!");
static_assert(offsetof(FM1FieldObjectSpawnInfo, FieldObject) == 0x000008, "Member 'FM1FieldObjectSpawnInfo::FieldObject' has a wrong offset!");

// ScriptStruct M1Data.M1MasteryLevelData
// 0x00A0 (0x00A8 - 0x0008)
struct FM1MasteryLevelData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredExpToNextLv;                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalRequiredExpToNextLv;                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RuneWeaponCapacity;                                // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RuneCharacterCapacity;                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RuneWeaponSlot;                                    // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RuneCharacterSlot;                                 // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EquipInventorySlot;                                // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WareHouseSlot;                                     // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponSlot;                                        // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReactorSlot;                                       // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccessoryNeckSlot;                                 // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccessoryEarringSlot;                              // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccessoryRingSlot;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccessoryBraceletSlot;                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TradeCount;                                        // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CodexTargetSlot;                                   // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PresetSlot;                                        // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VoidVaultStabilizerMaxStack;                       // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConsumableSlot;                                    // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        IconPath;                                          // 0x0058(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconBigPath;                                       // 0x0078(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1MasteryUIData>               Info;                                              // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MasteryLevelData) == 0x000008, "Wrong alignment on FM1MasteryLevelData");
static_assert(sizeof(FM1MasteryLevelData) == 0x0000A8, "Wrong size on FM1MasteryLevelData");
static_assert(offsetof(FM1MasteryLevelData, TemplateId) == 0x000008, "Member 'FM1MasteryLevelData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, RequiredExpToNextLv) == 0x00000C, "Member 'FM1MasteryLevelData::RequiredExpToNextLv' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, TotalRequiredExpToNextLv) == 0x000010, "Member 'FM1MasteryLevelData::TotalRequiredExpToNextLv' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, RuneWeaponCapacity) == 0x000014, "Member 'FM1MasteryLevelData::RuneWeaponCapacity' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, RuneCharacterCapacity) == 0x000018, "Member 'FM1MasteryLevelData::RuneCharacterCapacity' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, RuneWeaponSlot) == 0x00001C, "Member 'FM1MasteryLevelData::RuneWeaponSlot' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, RuneCharacterSlot) == 0x00001D, "Member 'FM1MasteryLevelData::RuneCharacterSlot' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, EquipInventorySlot) == 0x000020, "Member 'FM1MasteryLevelData::EquipInventorySlot' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, WareHouseSlot) == 0x000024, "Member 'FM1MasteryLevelData::WareHouseSlot' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, WeaponSlot) == 0x000028, "Member 'FM1MasteryLevelData::WeaponSlot' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, ReactorSlot) == 0x00002C, "Member 'FM1MasteryLevelData::ReactorSlot' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, AccessoryNeckSlot) == 0x000030, "Member 'FM1MasteryLevelData::AccessoryNeckSlot' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, AccessoryEarringSlot) == 0x000034, "Member 'FM1MasteryLevelData::AccessoryEarringSlot' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, AccessoryRingSlot) == 0x000038, "Member 'FM1MasteryLevelData::AccessoryRingSlot' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, AccessoryBraceletSlot) == 0x00003C, "Member 'FM1MasteryLevelData::AccessoryBraceletSlot' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, TradeCount) == 0x000040, "Member 'FM1MasteryLevelData::TradeCount' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, CodexTargetSlot) == 0x000044, "Member 'FM1MasteryLevelData::CodexTargetSlot' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, PresetSlot) == 0x000048, "Member 'FM1MasteryLevelData::PresetSlot' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, VoidVaultStabilizerMaxStack) == 0x00004C, "Member 'FM1MasteryLevelData::VoidVaultStabilizerMaxStack' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, ConsumableSlot) == 0x000050, "Member 'FM1MasteryLevelData::ConsumableSlot' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, IconPath) == 0x000058, "Member 'FM1MasteryLevelData::IconPath' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, IconBigPath) == 0x000078, "Member 'FM1MasteryLevelData::IconBigPath' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelData, Info) == 0x000098, "Member 'FM1MasteryLevelData::Info' has a wrong offset!");

// ScriptStruct M1Data.M1RequestSupportInfo
// 0x0058 (0x0058 - 0x0000)
struct FM1RequestSupportInfo final
{
public:
	int64                                         RequesterAccountUid;                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RequesterAccountName;                              // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         RequesteeAccountUid;                               // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Token;                                             // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MissionTid;                                        // 0x0030(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlatformId;                                        // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         PlatfromUid;                                       // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         PlatformType;                                      // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CrossPlayOn;                                       // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RequestSupportInfo) == 0x000008, "Wrong alignment on FM1RequestSupportInfo");
static_assert(sizeof(FM1RequestSupportInfo) == 0x000058, "Wrong size on FM1RequestSupportInfo");
static_assert(offsetof(FM1RequestSupportInfo, RequesterAccountUid) == 0x000000, "Member 'FM1RequestSupportInfo::RequesterAccountUid' has a wrong offset!");
static_assert(offsetof(FM1RequestSupportInfo, RequesterAccountName) == 0x000008, "Member 'FM1RequestSupportInfo::RequesterAccountName' has a wrong offset!");
static_assert(offsetof(FM1RequestSupportInfo, RequesteeAccountUid) == 0x000018, "Member 'FM1RequestSupportInfo::RequesteeAccountUid' has a wrong offset!");
static_assert(offsetof(FM1RequestSupportInfo, Token) == 0x000020, "Member 'FM1RequestSupportInfo::Token' has a wrong offset!");
static_assert(offsetof(FM1RequestSupportInfo, MissionTid) == 0x000030, "Member 'FM1RequestSupportInfo::MissionTid' has a wrong offset!");
static_assert(offsetof(FM1RequestSupportInfo, PlatformId) == 0x000038, "Member 'FM1RequestSupportInfo::PlatformId' has a wrong offset!");
static_assert(offsetof(FM1RequestSupportInfo, PlatfromUid) == 0x000048, "Member 'FM1RequestSupportInfo::PlatfromUid' has a wrong offset!");
static_assert(offsetof(FM1RequestSupportInfo, PlatformType) == 0x000050, "Member 'FM1RequestSupportInfo::PlatformType' has a wrong offset!");
static_assert(offsetof(FM1RequestSupportInfo, CrossPlayOn) == 0x000051, "Member 'FM1RequestSupportInfo::CrossPlayOn' has a wrong offset!");

// ScriptStruct M1Data.M1TeleportToMissionInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1TeleportToMissionInfo final
{
public:
	TArray<int64>                                 AccountUids;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MissionId;                                         // 0x0010(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MoveDedicatedServerReason                  Reason;                                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TeleportToMissionInfo) == 0x000008, "Wrong alignment on FM1TeleportToMissionInfo");
static_assert(sizeof(FM1TeleportToMissionInfo) == 0x000018, "Wrong size on FM1TeleportToMissionInfo");
static_assert(offsetof(FM1TeleportToMissionInfo, AccountUids) == 0x000000, "Member 'FM1TeleportToMissionInfo::AccountUids' has a wrong offset!");
static_assert(offsetof(FM1TeleportToMissionInfo, MissionId) == 0x000010, "Member 'FM1TeleportToMissionInfo::MissionId' has a wrong offset!");
static_assert(offsetof(FM1TeleportToMissionInfo, Reason) == 0x000014, "Member 'FM1TeleportToMissionInfo::Reason' has a wrong offset!");

// ScriptStruct M1Data.M1DifficultyAbilityDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1DifficultyAbilityDataLink final : public FDataLink
{
};
static_assert(alignof(FM1DifficultyAbilityDataLink) == 0x000008, "Wrong alignment on FM1DifficultyAbilityDataLink");
static_assert(sizeof(FM1DifficultyAbilityDataLink) == 0x000030, "Wrong size on FM1DifficultyAbilityDataLink");

// ScriptStruct M1Data.M1InstanceFieldContentsDataBaseLink
// 0x0000 (0x0030 - 0x0030)
struct FM1InstanceFieldContentsDataBaseLink final : public FDataLink
{
};
static_assert(alignof(FM1InstanceFieldContentsDataBaseLink) == 0x000008, "Wrong alignment on FM1InstanceFieldContentsDataBaseLink");
static_assert(sizeof(FM1InstanceFieldContentsDataBaseLink) == 0x000030, "Wrong size on FM1InstanceFieldContentsDataBaseLink");

// ScriptStruct M1Data.M1DecomposeResultItemInfo
// 0x000C (0x000C - 0x0000)
struct FM1DecomposeResultItemInfo final
{
public:
	int32                                         TemplateId;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemType                                   Type;                                              // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DecomposeResultItemInfo) == 0x000004, "Wrong alignment on FM1DecomposeResultItemInfo");
static_assert(sizeof(FM1DecomposeResultItemInfo) == 0x00000C, "Wrong size on FM1DecomposeResultItemInfo");
static_assert(offsetof(FM1DecomposeResultItemInfo, TemplateId) == 0x000000, "Member 'FM1DecomposeResultItemInfo::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1DecomposeResultItemInfo, Type) == 0x000004, "Member 'FM1DecomposeResultItemInfo::Type' has a wrong offset!");
static_assert(offsetof(FM1DecomposeResultItemInfo, Count) == 0x000008, "Member 'FM1DecomposeResultItemInfo::Count' has a wrong offset!");

// ScriptStruct M1Data.M1MonsterSkillDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1MonsterSkillDataLink final : public FDataLink
{
};
static_assert(alignof(FM1MonsterSkillDataLink) == 0x000008, "Wrong alignment on FM1MonsterSkillDataLink");
static_assert(sizeof(FM1MonsterSkillDataLink) == 0x000030, "Wrong size on FM1MonsterSkillDataLink");

// ScriptStruct M1Data.M1InitializationData
// 0x0018 (0x0018 - 0x0000)
struct FM1InitializationData final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemType                                   ItemType;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TemplateId;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1InitializationData) == 0x000008, "Wrong alignment on FM1InitializationData");
static_assert(sizeof(FM1InitializationData) == 0x000018, "Wrong size on FM1InitializationData");
static_assert(offsetof(FM1InitializationData, AccountUid) == 0x000000, "Member 'FM1InitializationData::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1InitializationData, ItemType) == 0x000008, "Member 'FM1InitializationData::ItemType' has a wrong offset!");
static_assert(offsetof(FM1InitializationData, TemplateId) == 0x00000C, "Member 'FM1InitializationData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1InitializationData, Count) == 0x000010, "Member 'FM1InitializationData::Count' has a wrong offset!");

// ScriptStruct M1Data.M1RecommendSpecsUIDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1RecommendSpecsUIDataLink final : public FDataLink
{
};
static_assert(alignof(FM1RecommendSpecsUIDataLink) == 0x000008, "Wrong alignment on FM1RecommendSpecsUIDataLink");
static_assert(sizeof(FM1RecommendSpecsUIDataLink) == 0x000030, "Wrong size on FM1RecommendSpecsUIDataLink");

// ScriptStruct M1Data.M1VoidBattleClearUpdateNoti
// 0x0010 (0x0010 - 0x0000)
struct FM1VoidBattleClearUpdateNoti final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          Tid;                                               // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClearCount;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1VoidBattleClearUpdateNoti) == 0x000008, "Wrong alignment on FM1VoidBattleClearUpdateNoti");
static_assert(sizeof(FM1VoidBattleClearUpdateNoti) == 0x000010, "Wrong size on FM1VoidBattleClearUpdateNoti");
static_assert(offsetof(FM1VoidBattleClearUpdateNoti, AccountUid) == 0x000000, "Member 'FM1VoidBattleClearUpdateNoti::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleClearUpdateNoti, Tid) == 0x000008, "Member 'FM1VoidBattleClearUpdateNoti::Tid' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleClearUpdateNoti, ClearCount) == 0x00000C, "Member 'FM1VoidBattleClearUpdateNoti::ClearCount' has a wrong offset!");

// ScriptStruct M1Data.M1PerkAbilityData
// 0x0000 (0x0070 - 0x0070)
struct FM1PerkAbilityData final : public FM1AbilityData
{
};
static_assert(alignof(FM1PerkAbilityData) == 0x000008, "Wrong alignment on FM1PerkAbilityData");
static_assert(sizeof(FM1PerkAbilityData) == 0x000070, "Wrong size on FM1PerkAbilityData");

// ScriptStruct M1Data.M1VoidBattleDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1VoidBattleDataLink final : public FDataLink
{
};
static_assert(alignof(FM1VoidBattleDataLink) == 0x000008, "Wrong alignment on FM1VoidBattleDataLink");
static_assert(sizeof(FM1VoidBattleDataLink) == 0x000030, "Wrong size on FM1VoidBattleDataLink");

// ScriptStruct M1Data.M1BoostCurrency
// 0x0008 (0x0008 - 0x0000)
struct FM1BoostCurrency final
{
public:
	EM1CurrencyType                               Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Price;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BoostCurrency) == 0x000004, "Wrong alignment on FM1BoostCurrency");
static_assert(sizeof(FM1BoostCurrency) == 0x000008, "Wrong size on FM1BoostCurrency");
static_assert(offsetof(FM1BoostCurrency, Type) == 0x000000, "Member 'FM1BoostCurrency::Type' has a wrong offset!");
static_assert(offsetof(FM1BoostCurrency, Price) == 0x000004, "Member 'FM1BoostCurrency::Price' has a wrong offset!");

// ScriptStruct M1Data.M1ResearchMiscData
// 0x0018 (0x0020 - 0x0008)
struct FM1ResearchMiscData final : public FTableRowBase
{
public:
	int32                                         MaxBookMarkCount;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResearchMaxCount;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1BoostCurrency                       BoostUnitPriceType;                                // 0x0010(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         BoostTimeUnit;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ResearchMiscData) == 0x000008, "Wrong alignment on FM1ResearchMiscData");
static_assert(sizeof(FM1ResearchMiscData) == 0x000020, "Wrong size on FM1ResearchMiscData");
static_assert(offsetof(FM1ResearchMiscData, MaxBookMarkCount) == 0x000008, "Member 'FM1ResearchMiscData::MaxBookMarkCount' has a wrong offset!");
static_assert(offsetof(FM1ResearchMiscData, ResearchMaxCount) == 0x00000C, "Member 'FM1ResearchMiscData::ResearchMaxCount' has a wrong offset!");
static_assert(offsetof(FM1ResearchMiscData, BoostUnitPriceType) == 0x000010, "Member 'FM1ResearchMiscData::BoostUnitPriceType' has a wrong offset!");
static_assert(offsetof(FM1ResearchMiscData, BoostTimeUnit) == 0x000018, "Member 'FM1ResearchMiscData::BoostTimeUnit' has a wrong offset!");

// ScriptStruct M1Data.M1JunkItemDecomposeResult
// 0x0010 (0x0010 - 0x0000)
struct FM1JunkItemDecomposeResult final
{
public:
	TArray<struct FM1DecomposeResultItemInfo>     ItemList;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1JunkItemDecomposeResult) == 0x000008, "Wrong alignment on FM1JunkItemDecomposeResult");
static_assert(sizeof(FM1JunkItemDecomposeResult) == 0x000010, "Wrong size on FM1JunkItemDecomposeResult");
static_assert(offsetof(FM1JunkItemDecomposeResult, ItemList) == 0x000000, "Member 'FM1JunkItemDecomposeResult::ItemList' has a wrong offset!");

// ScriptStruct M1Data.M1CashShopSubCategoryClickRecord
// 0x0018 (0x0018 - 0x0000)
struct FM1CashShopSubCategoryClickRecord final
{
public:
	class FString                                 GroupCategory;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClickCount;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CashShopSubCategoryClickRecord) == 0x000008, "Wrong alignment on FM1CashShopSubCategoryClickRecord");
static_assert(sizeof(FM1CashShopSubCategoryClickRecord) == 0x000018, "Wrong size on FM1CashShopSubCategoryClickRecord");
static_assert(offsetof(FM1CashShopSubCategoryClickRecord, GroupCategory) == 0x000000, "Member 'FM1CashShopSubCategoryClickRecord::GroupCategory' has a wrong offset!");
static_assert(offsetof(FM1CashShopSubCategoryClickRecord, ClickCount) == 0x000010, "Member 'FM1CashShopSubCategoryClickRecord::ClickCount' has a wrong offset!");

// ScriptStruct M1Data.M1CashShopProductClickRecord
// 0x0008 (0x0008 - 0x0000)
struct FM1CashShopProductClickRecord final
{
public:
	struct FM1TemplateId                          ProductId;                                         // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClickCount;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CashShopProductClickRecord) == 0x000004, "Wrong alignment on FM1CashShopProductClickRecord");
static_assert(sizeof(FM1CashShopProductClickRecord) == 0x000008, "Wrong size on FM1CashShopProductClickRecord");
static_assert(offsetof(FM1CashShopProductClickRecord, ProductId) == 0x000000, "Member 'FM1CashShopProductClickRecord::ProductId' has a wrong offset!");
static_assert(offsetof(FM1CashShopProductClickRecord, ClickCount) == 0x000004, "Member 'FM1CashShopProductClickRecord::ClickCount' has a wrong offset!");

// ScriptStruct M1Data.M1CashShopClickRecordNoti
// 0x0030 (0x0030 - 0x0000)
struct FM1CashShopClickRecordNoti final
{
public:
	TArray<struct FM1CashShopCategoryClickRecord> CategoryClickRecords;                              // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1CashShopSubCategoryClickRecord> SubCategoryClickRecords;                           // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1CashShopProductClickRecord>  ProductClickRecords;                               // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CashShopClickRecordNoti) == 0x000008, "Wrong alignment on FM1CashShopClickRecordNoti");
static_assert(sizeof(FM1CashShopClickRecordNoti) == 0x000030, "Wrong size on FM1CashShopClickRecordNoti");
static_assert(offsetof(FM1CashShopClickRecordNoti, CategoryClickRecords) == 0x000000, "Member 'FM1CashShopClickRecordNoti::CategoryClickRecords' has a wrong offset!");
static_assert(offsetof(FM1CashShopClickRecordNoti, SubCategoryClickRecords) == 0x000010, "Member 'FM1CashShopClickRecordNoti::SubCategoryClickRecords' has a wrong offset!");
static_assert(offsetof(FM1CashShopClickRecordNoti, ProductClickRecords) == 0x000020, "Member 'FM1CashShopClickRecordNoti::ProductClickRecords' has a wrong offset!");

// ScriptStruct M1Data.M1DropGroupDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1DropGroupDataLink final : public FDataLink
{
};
static_assert(alignof(FM1DropGroupDataLink) == 0x000008, "Wrong alignment on FM1DropGroupDataLink");
static_assert(sizeof(FM1DropGroupDataLink) == 0x000030, "Wrong size on FM1DropGroupDataLink");

// ScriptStruct M1Data.M1DropItemElement
// 0x0038 (0x0038 - 0x0000)
struct FM1DropItemElement final
{
public:
	struct FM1DropGroupDataLink                   DropGroupId;                                       // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1DropItemElement) == 0x000008, "Wrong alignment on FM1DropItemElement");
static_assert(sizeof(FM1DropItemElement) == 0x000038, "Wrong size on FM1DropItemElement");
static_assert(offsetof(FM1DropItemElement, DropGroupId) == 0x000000, "Member 'FM1DropItemElement::DropGroupId' has a wrong offset!");
static_assert(offsetof(FM1DropItemElement, Ratio) == 0x000030, "Member 'FM1DropItemElement::Ratio' has a wrong offset!");

// ScriptStruct M1Data.M1MonsterDropInfo
// 0x0040 (0x0040 - 0x0000)
struct FM1MonsterDropInfo final
{
public:
	EM1MonsterCategory                            MonsterCategory;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MonsterSubType                             MonsterSubType;                                    // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1DropItemLink                        DropItem;                                          // 0x0008(0x0030)(Edit, NativeAccessSpecifierPublic)
	int32                                         DropEquipLevelRangeMin;                            // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropEquipLevelRangeMax;                            // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterDropInfo) == 0x000008, "Wrong alignment on FM1MonsterDropInfo");
static_assert(sizeof(FM1MonsterDropInfo) == 0x000040, "Wrong size on FM1MonsterDropInfo");
static_assert(offsetof(FM1MonsterDropInfo, MonsterCategory) == 0x000000, "Member 'FM1MonsterDropInfo::MonsterCategory' has a wrong offset!");
static_assert(offsetof(FM1MonsterDropInfo, MonsterSubType) == 0x000001, "Member 'FM1MonsterDropInfo::MonsterSubType' has a wrong offset!");
static_assert(offsetof(FM1MonsterDropInfo, DropItem) == 0x000008, "Member 'FM1MonsterDropInfo::DropItem' has a wrong offset!");
static_assert(offsetof(FM1MonsterDropInfo, DropEquipLevelRangeMin) == 0x000038, "Member 'FM1MonsterDropInfo::DropEquipLevelRangeMin' has a wrong offset!");
static_assert(offsetof(FM1MonsterDropInfo, DropEquipLevelRangeMax) == 0x00003C, "Member 'FM1MonsterDropInfo::DropEquipLevelRangeMax' has a wrong offset!");

// ScriptStruct M1Data.M1BunchItemDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1BunchItemDataLink final : public FDataLink
{
};
static_assert(alignof(FM1BunchItemDataLink) == 0x000008, "Wrong alignment on FM1BunchItemDataLink");
static_assert(sizeof(FM1BunchItemDataLink) == 0x000030, "Wrong size on FM1BunchItemDataLink");

// ScriptStruct M1Data.M1RuneAbilityData
// 0x0000 (0x0070 - 0x0070)
struct FM1RuneAbilityData final : public FM1AbilityData
{
};
static_assert(alignof(FM1RuneAbilityData) == 0x000008, "Wrong alignment on FM1RuneAbilityData");
static_assert(sizeof(FM1RuneAbilityData) == 0x000070, "Wrong size on FM1RuneAbilityData");

// ScriptStruct M1Data.M1ConsumableItemDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1ConsumableItemDataLink final : public FDataLink
{
};
static_assert(alignof(FM1ConsumableItemDataLink) == 0x000008, "Wrong alignment on FM1ConsumableItemDataLink");
static_assert(sizeof(FM1ConsumableItemDataLink) == 0x000030, "Wrong size on FM1ConsumableItemDataLink");

// ScriptStruct M1Data.M1PackageOpenerData
// 0x0028 (0x0030 - 0x0008)
struct FM1PackageOpenerData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1ConsumableItemDataLink>      OpenablePackageItems;                              // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1RequiredItemData>            RequiredItems;                                     // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PackageOpenerData) == 0x000008, "Wrong alignment on FM1PackageOpenerData");
static_assert(sizeof(FM1PackageOpenerData) == 0x000030, "Wrong size on FM1PackageOpenerData");
static_assert(offsetof(FM1PackageOpenerData, TemplateId) == 0x000008, "Member 'FM1PackageOpenerData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1PackageOpenerData, OpenablePackageItems) == 0x000010, "Member 'FM1PackageOpenerData::OpenablePackageItems' has a wrong offset!");
static_assert(offsetof(FM1PackageOpenerData, RequiredItems) == 0x000020, "Member 'FM1PackageOpenerData::RequiredItems' has a wrong offset!");

// ScriptStruct M1Data.M1ProficiencyAddExpResult
// 0x0038 (0x0038 - 0x0000)
struct FM1ProficiencyAddExpResult final
{
public:
	struct FM1TemplateId                          EquipmentId;                                       // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         OriginExp;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         BoostedExp;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1BoostExpData>                BoostExpDatas;                                     // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Exp;                                               // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ProficiencyAddExpResult) == 0x000008, "Wrong alignment on FM1ProficiencyAddExpResult");
static_assert(sizeof(FM1ProficiencyAddExpResult) == 0x000038, "Wrong size on FM1ProficiencyAddExpResult");
static_assert(offsetof(FM1ProficiencyAddExpResult, EquipmentId) == 0x000000, "Member 'FM1ProficiencyAddExpResult::EquipmentId' has a wrong offset!");
static_assert(offsetof(FM1ProficiencyAddExpResult, OriginExp) == 0x000008, "Member 'FM1ProficiencyAddExpResult::OriginExp' has a wrong offset!");
static_assert(offsetof(FM1ProficiencyAddExpResult, BoostedExp) == 0x000010, "Member 'FM1ProficiencyAddExpResult::BoostedExp' has a wrong offset!");
static_assert(offsetof(FM1ProficiencyAddExpResult, BoostExpDatas) == 0x000018, "Member 'FM1ProficiencyAddExpResult::BoostExpDatas' has a wrong offset!");
static_assert(offsetof(FM1ProficiencyAddExpResult, Level) == 0x000028, "Member 'FM1ProficiencyAddExpResult::Level' has a wrong offset!");
static_assert(offsetof(FM1ProficiencyAddExpResult, Exp) == 0x000030, "Member 'FM1ProficiencyAddExpResult::Exp' has a wrong offset!");

// ScriptStruct M1Data.M1WeaponProficiencyPointNoti
// 0x0018 (0x0018 - 0x0000)
struct FM1WeaponProficiencyPointNoti final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1ProficiencyAddExpResult>     ResultList;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponProficiencyPointNoti) == 0x000008, "Wrong alignment on FM1WeaponProficiencyPointNoti");
static_assert(sizeof(FM1WeaponProficiencyPointNoti) == 0x000018, "Wrong size on FM1WeaponProficiencyPointNoti");
static_assert(offsetof(FM1WeaponProficiencyPointNoti, AccountUid) == 0x000000, "Member 'FM1WeaponProficiencyPointNoti::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1WeaponProficiencyPointNoti, ResultList) == 0x000008, "Member 'FM1WeaponProficiencyPointNoti::ResultList' has a wrong offset!");

// ScriptStruct M1Data.M1MiniGameDropItemRequest
// 0x0018 (0x0018 - 0x0000)
struct FM1MiniGameDropItemRequest final
{
public:
	struct FM1TemplateId                          MiniGameTid;                                       // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          DifficyltyTid;                                     // 0x0004(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int64>                                 AccountUidList;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MiniGameDropItemRequest) == 0x000008, "Wrong alignment on FM1MiniGameDropItemRequest");
static_assert(sizeof(FM1MiniGameDropItemRequest) == 0x000018, "Wrong size on FM1MiniGameDropItemRequest");
static_assert(offsetof(FM1MiniGameDropItemRequest, MiniGameTid) == 0x000000, "Member 'FM1MiniGameDropItemRequest::MiniGameTid' has a wrong offset!");
static_assert(offsetof(FM1MiniGameDropItemRequest, DifficyltyTid) == 0x000004, "Member 'FM1MiniGameDropItemRequest::DifficyltyTid' has a wrong offset!");
static_assert(offsetof(FM1MiniGameDropItemRequest, AccountUidList) == 0x000008, "Member 'FM1MiniGameDropItemRequest::AccountUidList' has a wrong offset!");

// ScriptStruct M1Data.M1ItemOptionDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1ItemOptionDataLink final : public FDataLink
{
};
static_assert(alignof(FM1ItemOptionDataLink) == 0x000008, "Wrong alignment on FM1ItemOptionDataLink");
static_assert(sizeof(FM1ItemOptionDataLink) == 0x000030, "Wrong size on FM1ItemOptionDataLink");

// ScriptStruct M1Data.M1RandomOptionGroupElement
// 0x0038 (0x0038 - 0x0000)
struct FM1RandomOptionGroupElement final
{
public:
	struct FM1ItemOptionDataLink                  OptionId;                                          // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	int32                                         InitialRate;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChangeRate;                                        // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RandomOptionGroupElement) == 0x000008, "Wrong alignment on FM1RandomOptionGroupElement");
static_assert(sizeof(FM1RandomOptionGroupElement) == 0x000038, "Wrong size on FM1RandomOptionGroupElement");
static_assert(offsetof(FM1RandomOptionGroupElement, OptionId) == 0x000000, "Member 'FM1RandomOptionGroupElement::OptionId' has a wrong offset!");
static_assert(offsetof(FM1RandomOptionGroupElement, InitialRate) == 0x000030, "Member 'FM1RandomOptionGroupElement::InitialRate' has a wrong offset!");
static_assert(offsetof(FM1RandomOptionGroupElement, ChangeRate) == 0x000034, "Member 'FM1RandomOptionGroupElement::ChangeRate' has a wrong offset!");

// ScriptStruct M1Data.M1DediAccountInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1DediAccountInfo final
{
public:
	class FString                                 AccountUid;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccountName;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DediAccountInfo) == 0x000008, "Wrong alignment on FM1DediAccountInfo");
static_assert(sizeof(FM1DediAccountInfo) == 0x000020, "Wrong size on FM1DediAccountInfo");
static_assert(offsetof(FM1DediAccountInfo, AccountUid) == 0x000000, "Member 'FM1DediAccountInfo::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1DediAccountInfo, AccountName) == 0x000010, "Member 'FM1DediAccountInfo::AccountName' has a wrong offset!");

// ScriptStruct M1Data.M1DediInfoForMonitor
// 0x0060 (0x0060 - 0x0000)
struct FM1DediInfoForMonitor final
{
public:
	int32                                         ProcessId;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Port;                                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         UserCnt;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 State;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StartInfo;                                         // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Oid;                                               // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MultiWorldIndex;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ThreadAffinityIndex;                               // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldTickTimeMs;                                   // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalWorldTickTimeMs;                              // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsingSpicaNetwork;                                 // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1DediAccountInfo>             ParticipantList;                                   // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DediInfoForMonitor) == 0x000008, "Wrong alignment on FM1DediInfoForMonitor");
static_assert(sizeof(FM1DediInfoForMonitor) == 0x000060, "Wrong size on FM1DediInfoForMonitor");
static_assert(offsetof(FM1DediInfoForMonitor, ProcessId) == 0x000000, "Member 'FM1DediInfoForMonitor::ProcessId' has a wrong offset!");
static_assert(offsetof(FM1DediInfoForMonitor, Port) == 0x000004, "Member 'FM1DediInfoForMonitor::Port' has a wrong offset!");
static_assert(offsetof(FM1DediInfoForMonitor, UserCnt) == 0x000008, "Member 'FM1DediInfoForMonitor::UserCnt' has a wrong offset!");
static_assert(offsetof(FM1DediInfoForMonitor, State) == 0x000010, "Member 'FM1DediInfoForMonitor::State' has a wrong offset!");
static_assert(offsetof(FM1DediInfoForMonitor, StartInfo) == 0x000020, "Member 'FM1DediInfoForMonitor::StartInfo' has a wrong offset!");
static_assert(offsetof(FM1DediInfoForMonitor, Oid) == 0x000030, "Member 'FM1DediInfoForMonitor::Oid' has a wrong offset!");
static_assert(offsetof(FM1DediInfoForMonitor, MultiWorldIndex) == 0x000038, "Member 'FM1DediInfoForMonitor::MultiWorldIndex' has a wrong offset!");
static_assert(offsetof(FM1DediInfoForMonitor, ThreadAffinityIndex) == 0x00003C, "Member 'FM1DediInfoForMonitor::ThreadAffinityIndex' has a wrong offset!");
static_assert(offsetof(FM1DediInfoForMonitor, WorldTickTimeMs) == 0x000040, "Member 'FM1DediInfoForMonitor::WorldTickTimeMs' has a wrong offset!");
static_assert(offsetof(FM1DediInfoForMonitor, TotalWorldTickTimeMs) == 0x000044, "Member 'FM1DediInfoForMonitor::TotalWorldTickTimeMs' has a wrong offset!");
static_assert(offsetof(FM1DediInfoForMonitor, UsingSpicaNetwork) == 0x000048, "Member 'FM1DediInfoForMonitor::UsingSpicaNetwork' has a wrong offset!");
static_assert(offsetof(FM1DediInfoForMonitor, ParticipantList) == 0x000050, "Member 'FM1DediInfoForMonitor::ParticipantList' has a wrong offset!");

// ScriptStruct M1Data.M1ConsumableInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1ConsumableInfo final
{
public:
	int64                                         Uid;                                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          Tid;                                               // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Count;                                             // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemTagStatus                              TagStatus;                                         // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ConsumableInfo) == 0x000008, "Wrong alignment on FM1ConsumableInfo");
static_assert(sizeof(FM1ConsumableInfo) == 0x000020, "Wrong size on FM1ConsumableInfo");
static_assert(offsetof(FM1ConsumableInfo, Uid) == 0x000000, "Member 'FM1ConsumableInfo::Uid' has a wrong offset!");
static_assert(offsetof(FM1ConsumableInfo, Tid) == 0x000008, "Member 'FM1ConsumableInfo::Tid' has a wrong offset!");
static_assert(offsetof(FM1ConsumableInfo, Count) == 0x000010, "Member 'FM1ConsumableInfo::Count' has a wrong offset!");
static_assert(offsetof(FM1ConsumableInfo, TagStatus) == 0x000018, "Member 'FM1ConsumableInfo::TagStatus' has a wrong offset!");

// ScriptStruct M1Data.M1ChargeLevelData
// 0x0014 (0x0014 - 0x0000)
struct FM1ChargeLevelData final
{
public:
	float                                         ChargeAmount;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargeRate;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DischargeRate;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SteadyDuration;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageMultiplier;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ChargeLevelData) == 0x000004, "Wrong alignment on FM1ChargeLevelData");
static_assert(sizeof(FM1ChargeLevelData) == 0x000014, "Wrong size on FM1ChargeLevelData");
static_assert(offsetof(FM1ChargeLevelData, ChargeAmount) == 0x000000, "Member 'FM1ChargeLevelData::ChargeAmount' has a wrong offset!");
static_assert(offsetof(FM1ChargeLevelData, ChargeRate) == 0x000004, "Member 'FM1ChargeLevelData::ChargeRate' has a wrong offset!");
static_assert(offsetof(FM1ChargeLevelData, DischargeRate) == 0x000008, "Member 'FM1ChargeLevelData::DischargeRate' has a wrong offset!");
static_assert(offsetof(FM1ChargeLevelData, SteadyDuration) == 0x00000C, "Member 'FM1ChargeLevelData::SteadyDuration' has a wrong offset!");
static_assert(offsetof(FM1ChargeLevelData, DamageMultiplier) == 0x000010, "Member 'FM1ChargeLevelData::DamageMultiplier' has a wrong offset!");

// ScriptStruct M1Data.M1WorldChattingMessage
// 0x0058 (0x0058 - 0x0000)
struct FM1WorldChattingMessage final
{
public:
	class FString                                 SenderLanguage;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SenderName;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SenderMessage;                                     // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              SendTime;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SenderPlatformId;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         SenderPlatformUid;                                 // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         SenderPlatformType;                                // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1WorldChattingMessage) == 0x000008, "Wrong alignment on FM1WorldChattingMessage");
static_assert(sizeof(FM1WorldChattingMessage) == 0x000058, "Wrong size on FM1WorldChattingMessage");
static_assert(offsetof(FM1WorldChattingMessage, SenderLanguage) == 0x000000, "Member 'FM1WorldChattingMessage::SenderLanguage' has a wrong offset!");
static_assert(offsetof(FM1WorldChattingMessage, SenderName) == 0x000010, "Member 'FM1WorldChattingMessage::SenderName' has a wrong offset!");
static_assert(offsetof(FM1WorldChattingMessage, SenderMessage) == 0x000020, "Member 'FM1WorldChattingMessage::SenderMessage' has a wrong offset!");
static_assert(offsetof(FM1WorldChattingMessage, SendTime) == 0x000030, "Member 'FM1WorldChattingMessage::SendTime' has a wrong offset!");
static_assert(offsetof(FM1WorldChattingMessage, SenderPlatformId) == 0x000038, "Member 'FM1WorldChattingMessage::SenderPlatformId' has a wrong offset!");
static_assert(offsetof(FM1WorldChattingMessage, SenderPlatformUid) == 0x000048, "Member 'FM1WorldChattingMessage::SenderPlatformUid' has a wrong offset!");
static_assert(offsetof(FM1WorldChattingMessage, SenderPlatformType) == 0x000050, "Member 'FM1WorldChattingMessage::SenderPlatformType' has a wrong offset!");

// ScriptStruct M1Data.M1InitializationBundle
// 0x0010 (0x0010 - 0x0000)
struct FM1InitializationBundle final
{
public:
	TArray<struct FM1InitializationData>          InitializationDataList;                            // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InitializationBundle) == 0x000008, "Wrong alignment on FM1InitializationBundle");
static_assert(sizeof(FM1InitializationBundle) == 0x000010, "Wrong size on FM1InitializationBundle");
static_assert(offsetof(FM1InitializationBundle, InitializationDataList) == 0x000000, "Member 'FM1InitializationBundle::InitializationDataList' has a wrong offset!");

// ScriptStruct M1Data.M1DropItemLevelWeightDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1DropItemLevelWeightDataLink final : public FDataLink
{
};
static_assert(alignof(FM1DropItemLevelWeightDataLink) == 0x000008, "Wrong alignment on FM1DropItemLevelWeightDataLink");
static_assert(sizeof(FM1DropItemLevelWeightDataLink) == 0x000030, "Wrong size on FM1DropItemLevelWeightDataLink");

// ScriptStruct M1Data.M1CustomizeRingSlotInvenvory
// 0x0008 (0x0008 - 0x0000)
struct FM1CustomizeRingSlotInvenvory final
{
public:
	struct FM1TemplateId                          CustomizeTid;                                      // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Slot;                                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizeRingSlotInvenvory) == 0x000004, "Wrong alignment on FM1CustomizeRingSlotInvenvory");
static_assert(sizeof(FM1CustomizeRingSlotInvenvory) == 0x000008, "Wrong size on FM1CustomizeRingSlotInvenvory");
static_assert(offsetof(FM1CustomizeRingSlotInvenvory, CustomizeTid) == 0x000000, "Member 'FM1CustomizeRingSlotInvenvory::CustomizeTid' has a wrong offset!");
static_assert(offsetof(FM1CustomizeRingSlotInvenvory, Slot) == 0x000004, "Member 'FM1CustomizeRingSlotInvenvory::Slot' has a wrong offset!");

// ScriptStruct M1Data.M1CustomizeItem
// 0x0010 (0x0010 - 0x0000)
struct FM1CustomizeItem final
{
public:
	struct FM1TemplateId                          Tid;                                               // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EvolutionIdx;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EvolutionComplete;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizeItem) == 0x000004, "Wrong alignment on FM1CustomizeItem");
static_assert(sizeof(FM1CustomizeItem) == 0x000010, "Wrong size on FM1CustomizeItem");
static_assert(offsetof(FM1CustomizeItem, Tid) == 0x000000, "Member 'FM1CustomizeItem::Tid' has a wrong offset!");
static_assert(offsetof(FM1CustomizeItem, EvolutionIdx) == 0x000004, "Member 'FM1CustomizeItem::EvolutionIdx' has a wrong offset!");
static_assert(offsetof(FM1CustomizeItem, EvolutionComplete) == 0x000008, "Member 'FM1CustomizeItem::EvolutionComplete' has a wrong offset!");
static_assert(offsetof(FM1CustomizeItem, StackCount) == 0x00000C, "Member 'FM1CustomizeItem::StackCount' has a wrong offset!");

// ScriptStruct M1Data.M1CustomizeCharacter
// 0x0004 (0x0004 - 0x0000)
struct FM1CustomizeCharacter final
{
public:
	struct FM1TemplateId                          SkinTid;                                           // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizeCharacter) == 0x000004, "Wrong alignment on FM1CustomizeCharacter");
static_assert(sizeof(FM1CustomizeCharacter) == 0x000004, "Wrong size on FM1CustomizeCharacter");
static_assert(offsetof(FM1CustomizeCharacter, SkinTid) == 0x000000, "Member 'FM1CustomizeCharacter::SkinTid' has a wrong offset!");

// ScriptStruct M1Data.M1CustomizeCharacterInventory
// 0x0018 (0x0018 - 0x0000)
struct FM1CustomizeCharacterInventory final
{
public:
	struct FM1TemplateId                          PlayerTid;                                         // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1CustomizeCharacter>          Customizes;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizeCharacterInventory) == 0x000008, "Wrong alignment on FM1CustomizeCharacterInventory");
static_assert(sizeof(FM1CustomizeCharacterInventory) == 0x000018, "Wrong size on FM1CustomizeCharacterInventory");
static_assert(offsetof(FM1CustomizeCharacterInventory, PlayerTid) == 0x000000, "Member 'FM1CustomizeCharacterInventory::PlayerTid' has a wrong offset!");
static_assert(offsetof(FM1CustomizeCharacterInventory, Customizes) == 0x000008, "Member 'FM1CustomizeCharacterInventory::Customizes' has a wrong offset!");

// ScriptStruct M1Data.M1CustomizeWeaponInventory
// 0x0008 (0x0008 - 0x0000)
struct FM1CustomizeWeaponInventory final
{
public:
	struct FM1TemplateId                          WeaponTid;                                         // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          CustomizeTid;                                      // 0x0004(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizeWeaponInventory) == 0x000004, "Wrong alignment on FM1CustomizeWeaponInventory");
static_assert(sizeof(FM1CustomizeWeaponInventory) == 0x000008, "Wrong size on FM1CustomizeWeaponInventory");
static_assert(offsetof(FM1CustomizeWeaponInventory, WeaponTid) == 0x000000, "Member 'FM1CustomizeWeaponInventory::WeaponTid' has a wrong offset!");
static_assert(offsetof(FM1CustomizeWeaponInventory, CustomizeTid) == 0x000004, "Member 'FM1CustomizeWeaponInventory::CustomizeTid' has a wrong offset!");

// ScriptStruct M1Data.M1CustomizePaintInventory
// 0x000C (0x000C - 0x0000)
struct FM1CustomizePaintInventory final
{
public:
	struct FM1TemplateId                          SkinTid;                                           // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          PaintTid;                                          // 0x0004(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Slot;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizePaintInventory) == 0x000004, "Wrong alignment on FM1CustomizePaintInventory");
static_assert(sizeof(FM1CustomizePaintInventory) == 0x00000C, "Wrong size on FM1CustomizePaintInventory");
static_assert(offsetof(FM1CustomizePaintInventory, SkinTid) == 0x000000, "Member 'FM1CustomizePaintInventory::SkinTid' has a wrong offset!");
static_assert(offsetof(FM1CustomizePaintInventory, PaintTid) == 0x000004, "Member 'FM1CustomizePaintInventory::PaintTid' has a wrong offset!");
static_assert(offsetof(FM1CustomizePaintInventory, Slot) == 0x000008, "Member 'FM1CustomizePaintInventory::Slot' has a wrong offset!");

// ScriptStruct M1Data.M1CustomizeBoundedSkin
// 0x0018 (0x0018 - 0x0000)
struct FM1CustomizeBoundedSkin final
{
public:
	struct FM1TemplateId                          SkinTid;                                           // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1TemplateId>                  BindPaintTids;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizeBoundedSkin) == 0x000008, "Wrong alignment on FM1CustomizeBoundedSkin");
static_assert(sizeof(FM1CustomizeBoundedSkin) == 0x000018, "Wrong size on FM1CustomizeBoundedSkin");
static_assert(offsetof(FM1CustomizeBoundedSkin, SkinTid) == 0x000000, "Member 'FM1CustomizeBoundedSkin::SkinTid' has a wrong offset!");
static_assert(offsetof(FM1CustomizeBoundedSkin, BindPaintTids) == 0x000008, "Member 'FM1CustomizeBoundedSkin::BindPaintTids' has a wrong offset!");

// ScriptStruct M1Data.M1CustomizeBoundedCharacter
// 0x0018 (0x0018 - 0x0000)
struct FM1CustomizeBoundedCharacter final
{
public:
	struct FM1TemplateId                          PlayerTid;                                         // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1TemplateId>                  BindSkinTids;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizeBoundedCharacter) == 0x000008, "Wrong alignment on FM1CustomizeBoundedCharacter");
static_assert(sizeof(FM1CustomizeBoundedCharacter) == 0x000018, "Wrong size on FM1CustomizeBoundedCharacter");
static_assert(offsetof(FM1CustomizeBoundedCharacter, PlayerTid) == 0x000000, "Member 'FM1CustomizeBoundedCharacter::PlayerTid' has a wrong offset!");
static_assert(offsetof(FM1CustomizeBoundedCharacter, BindSkinTids) == 0x000008, "Member 'FM1CustomizeBoundedCharacter::BindSkinTids' has a wrong offset!");

// ScriptStruct M1Data.M1CustomizeBoundedWeapon
// 0x0018 (0x0018 - 0x0000)
struct FM1CustomizeBoundedWeapon final
{
public:
	struct FM1TemplateId                          WeaponTid;                                         // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1TemplateId>                  BindSkinTids;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizeBoundedWeapon) == 0x000008, "Wrong alignment on FM1CustomizeBoundedWeapon");
static_assert(sizeof(FM1CustomizeBoundedWeapon) == 0x000018, "Wrong size on FM1CustomizeBoundedWeapon");
static_assert(offsetof(FM1CustomizeBoundedWeapon, WeaponTid) == 0x000000, "Member 'FM1CustomizeBoundedWeapon::WeaponTid' has a wrong offset!");
static_assert(offsetof(FM1CustomizeBoundedWeapon, BindSkinTids) == 0x000008, "Member 'FM1CustomizeBoundedWeapon::BindSkinTids' has a wrong offset!");

// ScriptStruct M1Data.M1CustomizeInvenvory
// 0x0098 (0x0098 - 0x0000)
struct FM1CustomizeInvenvory final
{
public:
	EM1CustomizeReason                            Reason;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1CustomizeItem>               GainItems;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1CustomizeCharacterInventory> CustomizeCharacters;                               // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1CustomizeWeaponInventory>    CustomizeWeapons;                                  // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1CustomizePaintInventory>     CustomizePaints;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1CustomizeRingSlotInvenvory>  CustomizeRingSlot;                                 // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1TemplateId>                  CustomizeEtc;                                      // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1CustomizeBoundedSkin>        CustomizeBoundedSkin;                              // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1CustomizeBoundedCharacter>   CustomizeBoundedCharacter;                         // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1CustomizeBoundedWeapon>      CustomizeBoundedWeapon;                            // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizeInvenvory) == 0x000008, "Wrong alignment on FM1CustomizeInvenvory");
static_assert(sizeof(FM1CustomizeInvenvory) == 0x000098, "Wrong size on FM1CustomizeInvenvory");
static_assert(offsetof(FM1CustomizeInvenvory, Reason) == 0x000000, "Member 'FM1CustomizeInvenvory::Reason' has a wrong offset!");
static_assert(offsetof(FM1CustomizeInvenvory, GainItems) == 0x000008, "Member 'FM1CustomizeInvenvory::GainItems' has a wrong offset!");
static_assert(offsetof(FM1CustomizeInvenvory, CustomizeCharacters) == 0x000018, "Member 'FM1CustomizeInvenvory::CustomizeCharacters' has a wrong offset!");
static_assert(offsetof(FM1CustomizeInvenvory, CustomizeWeapons) == 0x000028, "Member 'FM1CustomizeInvenvory::CustomizeWeapons' has a wrong offset!");
static_assert(offsetof(FM1CustomizeInvenvory, CustomizePaints) == 0x000038, "Member 'FM1CustomizeInvenvory::CustomizePaints' has a wrong offset!");
static_assert(offsetof(FM1CustomizeInvenvory, CustomizeRingSlot) == 0x000048, "Member 'FM1CustomizeInvenvory::CustomizeRingSlot' has a wrong offset!");
static_assert(offsetof(FM1CustomizeInvenvory, CustomizeEtc) == 0x000058, "Member 'FM1CustomizeInvenvory::CustomizeEtc' has a wrong offset!");
static_assert(offsetof(FM1CustomizeInvenvory, CustomizeBoundedSkin) == 0x000068, "Member 'FM1CustomizeInvenvory::CustomizeBoundedSkin' has a wrong offset!");
static_assert(offsetof(FM1CustomizeInvenvory, CustomizeBoundedCharacter) == 0x000078, "Member 'FM1CustomizeInvenvory::CustomizeBoundedCharacter' has a wrong offset!");
static_assert(offsetof(FM1CustomizeInvenvory, CustomizeBoundedWeapon) == 0x000088, "Member 'FM1CustomizeInvenvory::CustomizeBoundedWeapon' has a wrong offset!");

// ScriptStruct M1Data.M1CurrencyInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1CurrencyInfo final
{
public:
	EM1CurrencyType                               Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Count;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CurrencyInfo) == 0x000008, "Wrong alignment on FM1CurrencyInfo");
static_assert(sizeof(FM1CurrencyInfo) == 0x000010, "Wrong size on FM1CurrencyInfo");
static_assert(offsetof(FM1CurrencyInfo, Type) == 0x000000, "Member 'FM1CurrencyInfo::Type' has a wrong offset!");
static_assert(offsetof(FM1CurrencyInfo, Count) == 0x000008, "Member 'FM1CurrencyInfo::Count' has a wrong offset!");

// ScriptStruct M1Data.M1SkillAssetData
// 0x0100 (0x0100 - 0x0000)
struct FM1SkillAssetData final
{
public:
	struct FSoftObjectPath                        NormalIcon;                                        // 0x0000(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ActiveIcon;                                        // 0x0020(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PreviewImage;                                      // 0x0040(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PreviewMovie;                                      // 0x0060(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Montage;                                           // 0x0080(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Sequence;                                          // 0x00A0(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CustomIconWidget;                                  // 0x00C0(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CustomHUDWidget;                                   // 0x00E0(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SkillAssetData) == 0x000008, "Wrong alignment on FM1SkillAssetData");
static_assert(sizeof(FM1SkillAssetData) == 0x000100, "Wrong size on FM1SkillAssetData");
static_assert(offsetof(FM1SkillAssetData, NormalIcon) == 0x000000, "Member 'FM1SkillAssetData::NormalIcon' has a wrong offset!");
static_assert(offsetof(FM1SkillAssetData, ActiveIcon) == 0x000020, "Member 'FM1SkillAssetData::ActiveIcon' has a wrong offset!");
static_assert(offsetof(FM1SkillAssetData, PreviewImage) == 0x000040, "Member 'FM1SkillAssetData::PreviewImage' has a wrong offset!");
static_assert(offsetof(FM1SkillAssetData, PreviewMovie) == 0x000060, "Member 'FM1SkillAssetData::PreviewMovie' has a wrong offset!");
static_assert(offsetof(FM1SkillAssetData, Montage) == 0x000080, "Member 'FM1SkillAssetData::Montage' has a wrong offset!");
static_assert(offsetof(FM1SkillAssetData, Sequence) == 0x0000A0, "Member 'FM1SkillAssetData::Sequence' has a wrong offset!");
static_assert(offsetof(FM1SkillAssetData, CustomIconWidget) == 0x0000C0, "Member 'FM1SkillAssetData::CustomIconWidget' has a wrong offset!");
static_assert(offsetof(FM1SkillAssetData, CustomHUDWidget) == 0x0000E0, "Member 'FM1SkillAssetData::CustomHUDWidget' has a wrong offset!");

// ScriptStruct M1Data.M1SkillAbilityDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1SkillAbilityDataLink final : public FDataLink
{
};
static_assert(alignof(FM1SkillAbilityDataLink) == 0x000008, "Wrong alignment on FM1SkillAbilityDataLink");
static_assert(sizeof(FM1SkillAbilityDataLink) == 0x000030, "Wrong size on FM1SkillAbilityDataLink");

// ScriptStruct M1Data.M1TaggedAbilityParamData
// 0x0018 (0x0018 - 0x0000)
struct FM1TaggedAbilityParamData final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1AbilityParamData>            Params;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TaggedAbilityParamData) == 0x000008, "Wrong alignment on FM1TaggedAbilityParamData");
static_assert(sizeof(FM1TaggedAbilityParamData) == 0x000018, "Wrong size on FM1TaggedAbilityParamData");
static_assert(offsetof(FM1TaggedAbilityParamData, Tag) == 0x000000, "Member 'FM1TaggedAbilityParamData::Tag' has a wrong offset!");
static_assert(offsetof(FM1TaggedAbilityParamData, Params) == 0x000008, "Member 'FM1TaggedAbilityParamData::Params' has a wrong offset!");

// ScriptStruct M1Data.M1SkillLevelData
// 0x0078 (0x0078 - 0x0000)
struct FM1SkillLevelData final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cooltime;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxStackCount;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StackChargingTime;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveDuration;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1StatValuePair                       ActivateCost;                                      // 0x0018(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1SkillAbilityDataLink                SkillAbility;                                      // 0x0028(0x0030)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1AbilityParamData>            Params;                                            // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1TaggedAbilityParamData>      TaggedParams;                                      // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SkillLevelData) == 0x000008, "Wrong alignment on FM1SkillLevelData");
static_assert(sizeof(FM1SkillLevelData) == 0x000078, "Wrong size on FM1SkillLevelData");
static_assert(offsetof(FM1SkillLevelData, Level) == 0x000000, "Member 'FM1SkillLevelData::Level' has a wrong offset!");
static_assert(offsetof(FM1SkillLevelData, Cooltime) == 0x000004, "Member 'FM1SkillLevelData::Cooltime' has a wrong offset!");
static_assert(offsetof(FM1SkillLevelData, MaxStackCount) == 0x000008, "Member 'FM1SkillLevelData::MaxStackCount' has a wrong offset!");
static_assert(offsetof(FM1SkillLevelData, StackChargingTime) == 0x00000C, "Member 'FM1SkillLevelData::StackChargingTime' has a wrong offset!");
static_assert(offsetof(FM1SkillLevelData, ActiveDuration) == 0x000010, "Member 'FM1SkillLevelData::ActiveDuration' has a wrong offset!");
static_assert(offsetof(FM1SkillLevelData, ActivateCost) == 0x000018, "Member 'FM1SkillLevelData::ActivateCost' has a wrong offset!");
static_assert(offsetof(FM1SkillLevelData, SkillAbility) == 0x000028, "Member 'FM1SkillLevelData::SkillAbility' has a wrong offset!");
static_assert(offsetof(FM1SkillLevelData, Params) == 0x000058, "Member 'FM1SkillLevelData::Params' has a wrong offset!");
static_assert(offsetof(FM1SkillLevelData, TaggedParams) == 0x000068, "Member 'FM1SkillLevelData::TaggedParams' has a wrong offset!");

// ScriptStruct M1Data.M1SkillData
// 0x0128 (0x0130 - 0x0008)
struct FM1SkillData : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1SkillAssetData                      AssetData;                                         // 0x0018(0x0100)(Edit, NativeAccessSpecifierPublic)
	EM1SkillType                                  Type;                                              // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ElementalDamageChannel                     ElementalType;                                     // 0x0119(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1SkillArcheType                             ArcheType;                                         // 0x011A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         GroupIndex;                                        // 0x011B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUsedInAir;                                     // 0x011C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1SkillLevelData>              LvData;                                            // 0x0120(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SkillData) == 0x000008, "Wrong alignment on FM1SkillData");
static_assert(sizeof(FM1SkillData) == 0x000130, "Wrong size on FM1SkillData");
static_assert(offsetof(FM1SkillData, Name) == 0x000008, "Member 'FM1SkillData::Name' has a wrong offset!");
static_assert(offsetof(FM1SkillData, StringId) == 0x000010, "Member 'FM1SkillData::StringId' has a wrong offset!");
static_assert(offsetof(FM1SkillData, AssetData) == 0x000018, "Member 'FM1SkillData::AssetData' has a wrong offset!");
static_assert(offsetof(FM1SkillData, Type) == 0x000118, "Member 'FM1SkillData::Type' has a wrong offset!");
static_assert(offsetof(FM1SkillData, ElementalType) == 0x000119, "Member 'FM1SkillData::ElementalType' has a wrong offset!");
static_assert(offsetof(FM1SkillData, ArcheType) == 0x00011A, "Member 'FM1SkillData::ArcheType' has a wrong offset!");
static_assert(offsetof(FM1SkillData, GroupIndex) == 0x00011B, "Member 'FM1SkillData::GroupIndex' has a wrong offset!");
static_assert(offsetof(FM1SkillData, bCanUsedInAir) == 0x00011C, "Member 'FM1SkillData::bCanUsedInAir' has a wrong offset!");
static_assert(offsetof(FM1SkillData, LvData) == 0x000120, "Member 'FM1SkillData::LvData' has a wrong offset!");

// ScriptStruct M1Data.M1StatBaseDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1StatBaseDataLink final : public FDataLink
{
};
static_assert(alignof(FM1StatBaseDataLink) == 0x000008, "Wrong alignment on FM1StatBaseDataLink");
static_assert(sizeof(FM1StatBaseDataLink) == 0x000030, "Wrong size on FM1StatBaseDataLink");

// ScriptStruct M1Data.M1InventorySlotCountBundle
// 0x0010 (0x0010 - 0x0000)
struct FM1InventorySlotCountBundle final
{
public:
	TArray<struct FM1InventorySlotCount>          DataList;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InventorySlotCountBundle) == 0x000008, "Wrong alignment on FM1InventorySlotCountBundle");
static_assert(sizeof(FM1InventorySlotCountBundle) == 0x000010, "Wrong size on FM1InventorySlotCountBundle");
static_assert(offsetof(FM1InventorySlotCountBundle, DataList) == 0x000000, "Member 'FM1InventorySlotCountBundle::DataList' has a wrong offset!");

// ScriptStruct M1Data.M1SearchKeywordInfo
// 0x0040 (0x0040 - 0x0000)
struct FM1SearchKeywordInfo final
{
public:
	class FString                                 StringId;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Payload;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconImage;                                         // 0x0020(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SearchKeywordInfo) == 0x000008, "Wrong alignment on FM1SearchKeywordInfo");
static_assert(sizeof(FM1SearchKeywordInfo) == 0x000040, "Wrong size on FM1SearchKeywordInfo");
static_assert(offsetof(FM1SearchKeywordInfo, StringId) == 0x000000, "Member 'FM1SearchKeywordInfo::StringId' has a wrong offset!");
static_assert(offsetof(FM1SearchKeywordInfo, Payload) == 0x000010, "Member 'FM1SearchKeywordInfo::Payload' has a wrong offset!");
static_assert(offsetof(FM1SearchKeywordInfo, IconImage) == 0x000020, "Member 'FM1SearchKeywordInfo::IconImage' has a wrong offset!");

// ScriptStruct M1Data.M1UnixTime
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FM1UnixTime final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UnixTime) == 0x000004, "Wrong alignment on FM1UnixTime");
static_assert(sizeof(FM1UnixTime) == 0x000004, "Wrong size on FM1UnixTime");

// ScriptStruct M1Data.M1EquipmentBaseInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1EquipmentBaseInfo final
{
public:
	int64                                         Uid;                                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          Tid;                                               // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1UnixTime                            CreateDate;                                        // 0x000C(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemTagStatus                              TagStatus;                                         // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WareHouse;                                         // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1EquipmentBaseInfo) == 0x000008, "Wrong alignment on FM1EquipmentBaseInfo");
static_assert(sizeof(FM1EquipmentBaseInfo) == 0x000018, "Wrong size on FM1EquipmentBaseInfo");
static_assert(offsetof(FM1EquipmentBaseInfo, Uid) == 0x000000, "Member 'FM1EquipmentBaseInfo::Uid' has a wrong offset!");
static_assert(offsetof(FM1EquipmentBaseInfo, Tid) == 0x000008, "Member 'FM1EquipmentBaseInfo::Tid' has a wrong offset!");
static_assert(offsetof(FM1EquipmentBaseInfo, CreateDate) == 0x00000C, "Member 'FM1EquipmentBaseInfo::CreateDate' has a wrong offset!");
static_assert(offsetof(FM1EquipmentBaseInfo, Level) == 0x000010, "Member 'FM1EquipmentBaseInfo::Level' has a wrong offset!");
static_assert(offsetof(FM1EquipmentBaseInfo, TagStatus) == 0x000014, "Member 'FM1EquipmentBaseInfo::TagStatus' has a wrong offset!");
static_assert(offsetof(FM1EquipmentBaseInfo, WareHouse) == 0x000015, "Member 'FM1EquipmentBaseInfo::WareHouse' has a wrong offset!");

// ScriptStruct M1Data.M1RuneSocketGrantDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1RuneSocketGrantDataLink final : public FDataLink
{
};
static_assert(alignof(FM1RuneSocketGrantDataLink) == 0x000008, "Wrong alignment on FM1RuneSocketGrantDataLink");
static_assert(sizeof(FM1RuneSocketGrantDataLink) == 0x000030, "Wrong size on FM1RuneSocketGrantDataLink");

// ScriptStruct M1Data.M1VoidBattleStartCondition
// 0x0018 (0x0018 - 0x0000)
struct FM1VoidBattleStartCondition final
{
public:
	EM1VoidBattleStartConditionType               Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Params;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1VoidBattleStartCondition) == 0x000008, "Wrong alignment on FM1VoidBattleStartCondition");
static_assert(sizeof(FM1VoidBattleStartCondition) == 0x000018, "Wrong size on FM1VoidBattleStartCondition");
static_assert(offsetof(FM1VoidBattleStartCondition, Type) == 0x000000, "Member 'FM1VoidBattleStartCondition::Type' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleStartCondition, Params) == 0x000008, "Member 'FM1VoidBattleStartCondition::Params' has a wrong offset!");

// ScriptStruct M1Data.M1VoidBattleStartConditionByTid
// 0x0018 (0x0018 - 0x0000)
struct FM1VoidBattleStartConditionByTid final
{
public:
	struct FM1TemplateId                          Tid;                                               // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1VoidBattleStartCondition>    StartConditions;                                   // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1VoidBattleStartConditionByTid) == 0x000008, "Wrong alignment on FM1VoidBattleStartConditionByTid");
static_assert(sizeof(FM1VoidBattleStartConditionByTid) == 0x000018, "Wrong size on FM1VoidBattleStartConditionByTid");
static_assert(offsetof(FM1VoidBattleStartConditionByTid, Tid) == 0x000000, "Member 'FM1VoidBattleStartConditionByTid::Tid' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleStartConditionByTid, StartConditions) == 0x000008, "Member 'FM1VoidBattleStartConditionByTid::StartConditions' has a wrong offset!");

// ScriptStruct M1Data.M1SearchKeywordDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1SearchKeywordDataLink final : public FDataLink
{
};
static_assert(alignof(FM1SearchKeywordDataLink) == 0x000008, "Wrong alignment on FM1SearchKeywordDataLink");
static_assert(sizeof(FM1SearchKeywordDataLink) == 0x000030, "Wrong size on FM1SearchKeywordDataLink");

// ScriptStruct M1Data.M1BattlePassMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1BattlePassMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1BattlePassMiscDataLink) == 0x000008, "Wrong alignment on FM1BattlePassMiscDataLink");
static_assert(sizeof(FM1BattlePassMiscDataLink) == 0x000030, "Wrong size on FM1BattlePassMiscDataLink");

// ScriptStruct M1Data.M1RecordInfo
// 0x0004 (0x0004 - 0x0000)
struct FM1RecordInfo final
{
public:
	struct FM1TemplateId                          Tid;                                               // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RecordInfo) == 0x000004, "Wrong alignment on FM1RecordInfo");
static_assert(sizeof(FM1RecordInfo) == 0x000004, "Wrong size on FM1RecordInfo");
static_assert(offsetof(FM1RecordInfo, Tid) == 0x000000, "Member 'FM1RecordInfo::Tid' has a wrong offset!");

// ScriptStruct M1Data.M1RewardType
// 0x0040 (0x0040 - 0x0000)
struct FM1RewardType final
{
public:
	struct FM1ItemDataBox                         RewardItem;                                        // 0x0000(0x0038)(Edit, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RewardType) == 0x000008, "Wrong alignment on FM1RewardType");
static_assert(sizeof(FM1RewardType) == 0x000040, "Wrong size on FM1RewardType");
static_assert(offsetof(FM1RewardType, RewardItem) == 0x000000, "Member 'FM1RewardType::RewardItem' has a wrong offset!");
static_assert(offsetof(FM1RewardType, Count) == 0x000038, "Member 'FM1RewardType::Count' has a wrong offset!");

// ScriptStruct M1Data.M1SeasonExpNoti
// 0x0018 (0x0018 - 0x0000)
struct FM1SeasonExpNoti final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SeasonId;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Exp;                                               // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SeasonExpNoti) == 0x000008, "Wrong alignment on FM1SeasonExpNoti");
static_assert(sizeof(FM1SeasonExpNoti) == 0x000018, "Wrong size on FM1SeasonExpNoti");
static_assert(offsetof(FM1SeasonExpNoti, AccountUid) == 0x000000, "Member 'FM1SeasonExpNoti::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1SeasonExpNoti, SeasonId) == 0x000008, "Member 'FM1SeasonExpNoti::SeasonId' has a wrong offset!");
static_assert(offsetof(FM1SeasonExpNoti, Level) == 0x00000C, "Member 'FM1SeasonExpNoti::Level' has a wrong offset!");
static_assert(offsetof(FM1SeasonExpNoti, Exp) == 0x000010, "Member 'FM1SeasonExpNoti::Exp' has a wrong offset!");

// ScriptStruct M1Data.M1MasteryInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1MasteryInfo final
{
public:
	struct FM1TemplateId                          Level;                                             // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Exp;                                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MasteryInfo) == 0x000008, "Wrong alignment on FM1MasteryInfo");
static_assert(sizeof(FM1MasteryInfo) == 0x000010, "Wrong size on FM1MasteryInfo");
static_assert(offsetof(FM1MasteryInfo, Level) == 0x000000, "Member 'FM1MasteryInfo::Level' has a wrong offset!");
static_assert(offsetof(FM1MasteryInfo, Exp) == 0x000008, "Member 'FM1MasteryInfo::Exp' has a wrong offset!");

// ScriptStruct M1Data.M1PlatformAchievementDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1PlatformAchievementDataLink final : public FDataLink
{
};
static_assert(alignof(FM1PlatformAchievementDataLink) == 0x000008, "Wrong alignment on FM1PlatformAchievementDataLink");
static_assert(sizeof(FM1PlatformAchievementDataLink) == 0x000030, "Wrong size on FM1PlatformAchievementDataLink");

// ScriptStruct M1Data.M1InvasionDungeonCompleteResult
// 0x0028 (0x0028 - 0x0000)
struct FM1InvasionDungeonCompleteResult final
{
public:
	EM1InstanceDungeonCompleteReason              Reason;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ReceiveUid;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          Tid;                                               // 0x0010(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardBaseExp;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardBonusExp;                                    // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalRewardExpBef;                                 // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalRewardExpAft;                                 // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1InvasionDungeonCompleteResult) == 0x000008, "Wrong alignment on FM1InvasionDungeonCompleteResult");
static_assert(sizeof(FM1InvasionDungeonCompleteResult) == 0x000028, "Wrong size on FM1InvasionDungeonCompleteResult");
static_assert(offsetof(FM1InvasionDungeonCompleteResult, Reason) == 0x000000, "Member 'FM1InvasionDungeonCompleteResult::Reason' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonCompleteResult, ReceiveUid) == 0x000008, "Member 'FM1InvasionDungeonCompleteResult::ReceiveUid' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonCompleteResult, Tid) == 0x000010, "Member 'FM1InvasionDungeonCompleteResult::Tid' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonCompleteResult, RewardBaseExp) == 0x000014, "Member 'FM1InvasionDungeonCompleteResult::RewardBaseExp' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonCompleteResult, RewardBonusExp) == 0x000018, "Member 'FM1InvasionDungeonCompleteResult::RewardBonusExp' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonCompleteResult, TotalRewardExpBef) == 0x00001C, "Member 'FM1InvasionDungeonCompleteResult::TotalRewardExpBef' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonCompleteResult, TotalRewardExpAft) == 0x000020, "Member 'FM1InvasionDungeonCompleteResult::TotalRewardExpAft' has a wrong offset!");

// ScriptStruct M1Data.M1RuneInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1RuneInfo final
{
public:
	int64                                         Uid;                                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          Tid;                                               // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Enchant;                                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         EquipCount;                                        // 0x0010(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RuneInfo) == 0x000008, "Wrong alignment on FM1RuneInfo");
static_assert(sizeof(FM1RuneInfo) == 0x000018, "Wrong size on FM1RuneInfo");
static_assert(offsetof(FM1RuneInfo, Uid) == 0x000000, "Member 'FM1RuneInfo::Uid' has a wrong offset!");
static_assert(offsetof(FM1RuneInfo, Tid) == 0x000008, "Member 'FM1RuneInfo::Tid' has a wrong offset!");
static_assert(offsetof(FM1RuneInfo, Enchant) == 0x00000C, "Member 'FM1RuneInfo::Enchant' has a wrong offset!");
static_assert(offsetof(FM1RuneInfo, EquipCount) == 0x000010, "Member 'FM1RuneInfo::EquipCount' has a wrong offset!");

// ScriptStruct M1Data.M1RandomOptionChangeData
// 0x0018 (0x0020 - 0x0008)
struct FM1RandomOptionChangeData final : public FTableRowBase
{
public:
	int32                                         OptionLockStep;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1EquipmentCategoryType                      EquipmentCategoryType;                             // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1RandomOptionChangeCostWithTier> CostByTier;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RandomOptionChangeData) == 0x000008, "Wrong alignment on FM1RandomOptionChangeData");
static_assert(sizeof(FM1RandomOptionChangeData) == 0x000020, "Wrong size on FM1RandomOptionChangeData");
static_assert(offsetof(FM1RandomOptionChangeData, OptionLockStep) == 0x000008, "Member 'FM1RandomOptionChangeData::OptionLockStep' has a wrong offset!");
static_assert(offsetof(FM1RandomOptionChangeData, EquipmentCategoryType) == 0x00000C, "Member 'FM1RandomOptionChangeData::EquipmentCategoryType' has a wrong offset!");
static_assert(offsetof(FM1RandomOptionChangeData, CostByTier) == 0x000010, "Member 'FM1RandomOptionChangeData::CostByTier' has a wrong offset!");

// ScriptStruct M1Data.M1TitleItemInfo
// 0x0004 (0x0004 - 0x0000)
struct FM1TitleItemInfo final
{
public:
	struct FM1TemplateId                          Tid;                                               // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TitleItemInfo) == 0x000004, "Wrong alignment on FM1TitleItemInfo");
static_assert(sizeof(FM1TitleItemInfo) == 0x000004, "Wrong size on FM1TitleItemInfo");
static_assert(offsetof(FM1TitleItemInfo, Tid) == 0x000000, "Member 'FM1TitleItemInfo::Tid' has a wrong offset!");

// ScriptStruct M1Data.M1WorldMissionDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1WorldMissionDataLink final : public FDataLink
{
};
static_assert(alignof(FM1WorldMissionDataLink) == 0x000008, "Wrong alignment on FM1WorldMissionDataLink");
static_assert(sizeof(FM1WorldMissionDataLink) == 0x000030, "Wrong size on FM1WorldMissionDataLink");

// ScriptStruct M1Data.M1MonsterDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1MonsterDataLink final : public FDataLink
{
};
static_assert(alignof(FM1MonsterDataLink) == 0x000008, "Wrong alignment on FM1MonsterDataLink");
static_assert(sizeof(FM1MonsterDataLink) == 0x000030, "Wrong size on FM1MonsterDataLink");

// ScriptStruct M1Data.M1EncountInfo
// 0x0038 (0x0038 - 0x0000)
struct FM1EncountInfo final
{
public:
	struct FM1MonsterDataLink                     MonsterId;                                         // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	float                                         EncountRate;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1EncountInfo) == 0x000008, "Wrong alignment on FM1EncountInfo");
static_assert(sizeof(FM1EncountInfo) == 0x000038, "Wrong size on FM1EncountInfo");
static_assert(offsetof(FM1EncountInfo, MonsterId) == 0x000000, "Member 'FM1EncountInfo::MonsterId' has a wrong offset!");
static_assert(offsetof(FM1EncountInfo, EncountRate) == 0x000030, "Member 'FM1EncountInfo::EncountRate' has a wrong offset!");

// ScriptStruct M1Data.M1WorldMissionMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1WorldMissionMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1WorldMissionMiscDataLink) == 0x000008, "Wrong alignment on FM1WorldMissionMiscDataLink");
static_assert(sizeof(FM1WorldMissionMiscDataLink) == 0x000030, "Wrong size on FM1WorldMissionMiscDataLink");

// ScriptStruct M1Data.M1MailItemInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1MailItemInfo final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemTidBox                          ItemTidBox;                                        // 0x0004(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Amount;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Received;                                          // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MailItemInfo) == 0x000008, "Wrong alignment on FM1MailItemInfo");
static_assert(sizeof(FM1MailItemInfo) == 0x000020, "Wrong size on FM1MailItemInfo");
static_assert(offsetof(FM1MailItemInfo, Index) == 0x000000, "Member 'FM1MailItemInfo::Index' has a wrong offset!");
static_assert(offsetof(FM1MailItemInfo, ItemTidBox) == 0x000004, "Member 'FM1MailItemInfo::ItemTidBox' has a wrong offset!");
static_assert(offsetof(FM1MailItemInfo, Amount) == 0x000010, "Member 'FM1MailItemInfo::Amount' has a wrong offset!");
static_assert(offsetof(FM1MailItemInfo, Received) == 0x000018, "Member 'FM1MailItemInfo::Received' has a wrong offset!");

// ScriptStruct M1Data.M1EquipmentRandomOptionInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1EquipmentRandomOptionInfo final
{
public:
	int64                                         EquipmentUid;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         Index;                                             // 0x0008(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1TemplateId                          Tid;                                               // 0x000C(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ScaledInteger                       StatValue;                                         // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EquipmentRandomOptionInfo) == 0x000008, "Wrong alignment on FM1EquipmentRandomOptionInfo");
static_assert(sizeof(FM1EquipmentRandomOptionInfo) == 0x000018, "Wrong size on FM1EquipmentRandomOptionInfo");
static_assert(offsetof(FM1EquipmentRandomOptionInfo, EquipmentUid) == 0x000000, "Member 'FM1EquipmentRandomOptionInfo::EquipmentUid' has a wrong offset!");
static_assert(offsetof(FM1EquipmentRandomOptionInfo, Index) == 0x000008, "Member 'FM1EquipmentRandomOptionInfo::Index' has a wrong offset!");
static_assert(offsetof(FM1EquipmentRandomOptionInfo, Tid) == 0x00000C, "Member 'FM1EquipmentRandomOptionInfo::Tid' has a wrong offset!");
static_assert(offsetof(FM1EquipmentRandomOptionInfo, StatValue) == 0x000010, "Member 'FM1EquipmentRandomOptionInfo::StatValue' has a wrong offset!");

// ScriptStruct M1Data.M1PerkInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1PerkInfo final
{
public:
	int64                                         EquipmentUid;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          Tid;                                               // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PerkInfo) == 0x000008, "Wrong alignment on FM1PerkInfo");
static_assert(sizeof(FM1PerkInfo) == 0x000010, "Wrong size on FM1PerkInfo");
static_assert(offsetof(FM1PerkInfo, EquipmentUid) == 0x000000, "Member 'FM1PerkInfo::EquipmentUid' has a wrong offset!");
static_assert(offsetof(FM1PerkInfo, Tid) == 0x000008, "Member 'FM1PerkInfo::Tid' has a wrong offset!");
static_assert(offsetof(FM1PerkInfo, Level) == 0x00000C, "Member 'FM1PerkInfo::Level' has a wrong offset!");

// ScriptStruct M1Data.M1EquipmentMailItemInfo
// 0x0030 (0x0030 - 0x0000)
struct FM1EquipmentMailItemInfo final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          TemplateId;                                        // 0x0004(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Received;                                          // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1EquipmentRandomOptionInfo>   RandomOptions;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1PerkInfo>                    Perks;                                             // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EquipmentMailItemInfo) == 0x000008, "Wrong alignment on FM1EquipmentMailItemInfo");
static_assert(sizeof(FM1EquipmentMailItemInfo) == 0x000030, "Wrong size on FM1EquipmentMailItemInfo");
static_assert(offsetof(FM1EquipmentMailItemInfo, Index) == 0x000000, "Member 'FM1EquipmentMailItemInfo::Index' has a wrong offset!");
static_assert(offsetof(FM1EquipmentMailItemInfo, TemplateId) == 0x000004, "Member 'FM1EquipmentMailItemInfo::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1EquipmentMailItemInfo, Level) == 0x000008, "Member 'FM1EquipmentMailItemInfo::Level' has a wrong offset!");
static_assert(offsetof(FM1EquipmentMailItemInfo, Received) == 0x00000C, "Member 'FM1EquipmentMailItemInfo::Received' has a wrong offset!");
static_assert(offsetof(FM1EquipmentMailItemInfo, RandomOptions) == 0x000010, "Member 'FM1EquipmentMailItemInfo::RandomOptions' has a wrong offset!");
static_assert(offsetof(FM1EquipmentMailItemInfo, Perks) == 0x000020, "Member 'FM1EquipmentMailItemInfo::Perks' has a wrong offset!");

// ScriptStruct M1Data.M1RuneMailItemInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1RuneMailItemInfo final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          TemplateId;                                        // 0x0004(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnchantLevel;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Received;                                          // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RuneMailItemInfo) == 0x000004, "Wrong alignment on FM1RuneMailItemInfo");
static_assert(sizeof(FM1RuneMailItemInfo) == 0x000010, "Wrong size on FM1RuneMailItemInfo");
static_assert(offsetof(FM1RuneMailItemInfo, Index) == 0x000000, "Member 'FM1RuneMailItemInfo::Index' has a wrong offset!");
static_assert(offsetof(FM1RuneMailItemInfo, TemplateId) == 0x000004, "Member 'FM1RuneMailItemInfo::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1RuneMailItemInfo, EnchantLevel) == 0x000008, "Member 'FM1RuneMailItemInfo::EnchantLevel' has a wrong offset!");
static_assert(offsetof(FM1RuneMailItemInfo, Received) == 0x00000C, "Member 'FM1RuneMailItemInfo::Received' has a wrong offset!");

// ScriptStruct M1Data.M1MailInfo
// 0x0090 (0x0090 - 0x0000)
struct FM1MailInfo final
{
public:
	EM1MailType                                   MailType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MailId;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MailTemplateId;                                    // 0x0010(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Sender;                                            // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Content;                                           // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              StartDate;                                         // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndDate;                                           // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Reading;                                           // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1MailItemInfo>                ItemList;                                          // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1EquipmentMailItemInfo>       EquipItemList;                                     // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1RuneMailItemInfo>            RuneItemList;                                      // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MailInfo) == 0x000008, "Wrong alignment on FM1MailInfo");
static_assert(sizeof(FM1MailInfo) == 0x000090, "Wrong size on FM1MailInfo");
static_assert(offsetof(FM1MailInfo, MailType) == 0x000000, "Member 'FM1MailInfo::MailType' has a wrong offset!");
static_assert(offsetof(FM1MailInfo, MailId) == 0x000008, "Member 'FM1MailInfo::MailId' has a wrong offset!");
static_assert(offsetof(FM1MailInfo, MailTemplateId) == 0x000010, "Member 'FM1MailInfo::MailTemplateId' has a wrong offset!");
static_assert(offsetof(FM1MailInfo, Sender) == 0x000018, "Member 'FM1MailInfo::Sender' has a wrong offset!");
static_assert(offsetof(FM1MailInfo, Title) == 0x000028, "Member 'FM1MailInfo::Title' has a wrong offset!");
static_assert(offsetof(FM1MailInfo, Content) == 0x000038, "Member 'FM1MailInfo::Content' has a wrong offset!");
static_assert(offsetof(FM1MailInfo, StartDate) == 0x000048, "Member 'FM1MailInfo::StartDate' has a wrong offset!");
static_assert(offsetof(FM1MailInfo, EndDate) == 0x000050, "Member 'FM1MailInfo::EndDate' has a wrong offset!");
static_assert(offsetof(FM1MailInfo, Reading) == 0x000058, "Member 'FM1MailInfo::Reading' has a wrong offset!");
static_assert(offsetof(FM1MailInfo, ItemList) == 0x000060, "Member 'FM1MailInfo::ItemList' has a wrong offset!");
static_assert(offsetof(FM1MailInfo, EquipItemList) == 0x000070, "Member 'FM1MailInfo::EquipItemList' has a wrong offset!");
static_assert(offsetof(FM1MailInfo, RuneItemList) == 0x000080, "Member 'FM1MailInfo::RuneItemList' has a wrong offset!");

// ScriptStruct M1Data.M1MailInfoBundle
// 0x0018 (0x0018 - 0x0000)
struct FM1MailInfoBundle final
{
public:
	EM1MailReason                                 Reason;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1MailInfo>                    MailList;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MailInfoBundle) == 0x000008, "Wrong alignment on FM1MailInfoBundle");
static_assert(sizeof(FM1MailInfoBundle) == 0x000018, "Wrong size on FM1MailInfoBundle");
static_assert(offsetof(FM1MailInfoBundle, Reason) == 0x000000, "Member 'FM1MailInfoBundle::Reason' has a wrong offset!");
static_assert(offsetof(FM1MailInfoBundle, MailList) == 0x000008, "Member 'FM1MailInfoBundle::MailList' has a wrong offset!");

// ScriptStruct M1Data.M1ItemDecomposeResult
// 0x0010 (0x0010 - 0x0000)
struct FM1ItemDecomposeResult final
{
public:
	TArray<struct FM1DecomposeResultItemInfo>     ItemList;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemDecomposeResult) == 0x000008, "Wrong alignment on FM1ItemDecomposeResult");
static_assert(sizeof(FM1ItemDecomposeResult) == 0x000010, "Wrong size on FM1ItemDecomposeResult");
static_assert(offsetof(FM1ItemDecomposeResult, ItemList) == 0x000000, "Member 'FM1ItemDecomposeResult::ItemList' has a wrong offset!");

// ScriptStruct M1Data.M1QuestStartCondition
// 0x0018 (0x0018 - 0x0000)
struct FM1QuestStartCondition final
{
public:
	EM1QuestStartConditionType                    Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Params;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1QuestStartCondition) == 0x000008, "Wrong alignment on FM1QuestStartCondition");
static_assert(sizeof(FM1QuestStartCondition) == 0x000018, "Wrong size on FM1QuestStartCondition");
static_assert(offsetof(FM1QuestStartCondition, Type) == 0x000000, "Member 'FM1QuestStartCondition::Type' has a wrong offset!");
static_assert(offsetof(FM1QuestStartCondition, Count) == 0x000004, "Member 'FM1QuestStartCondition::Count' has a wrong offset!");
static_assert(offsetof(FM1QuestStartCondition, Params) == 0x000008, "Member 'FM1QuestStartCondition::Params' has a wrong offset!");

// ScriptStruct M1Data.M1MapBattleZoneDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1MapBattleZoneDataLink final : public FDataLink
{
};
static_assert(alignof(FM1MapBattleZoneDataLink) == 0x000008, "Wrong alignment on FM1MapBattleZoneDataLink");
static_assert(sizeof(FM1MapBattleZoneDataLink) == 0x000030, "Wrong size on FM1MapBattleZoneDataLink");

// ScriptStruct M1Data.M1DifficultyAbilityInfo
// 0x0038 (0x0038 - 0x0000)
struct FM1DifficultyAbilityInfo final
{
public:
	bool                                          ApplyToPlayer;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1DifficultyAbilityDataLink           AbilityData;                                       // 0x0008(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DifficultyAbilityInfo) == 0x000008, "Wrong alignment on FM1DifficultyAbilityInfo");
static_assert(sizeof(FM1DifficultyAbilityInfo) == 0x000038, "Wrong size on FM1DifficultyAbilityInfo");
static_assert(offsetof(FM1DifficultyAbilityInfo, ApplyToPlayer) == 0x000000, "Member 'FM1DifficultyAbilityInfo::ApplyToPlayer' has a wrong offset!");
static_assert(offsetof(FM1DifficultyAbilityInfo, AbilityData) == 0x000008, "Member 'FM1DifficultyAbilityInfo::AbilityData' has a wrong offset!");

// ScriptStruct M1Data.M1BattleZoneDifficultyData
// 0x0040 (0x0040 - 0x0000)
struct FM1BattleZoneDifficultyData final
{
public:
	struct FM1MapBattleZoneDataLink               BattleZoneId;                                      // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1DifficultyAbilityInfo>       DifficultyAbilityInfo;                             // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattleZoneDifficultyData) == 0x000008, "Wrong alignment on FM1BattleZoneDifficultyData");
static_assert(sizeof(FM1BattleZoneDifficultyData) == 0x000040, "Wrong size on FM1BattleZoneDifficultyData");
static_assert(offsetof(FM1BattleZoneDifficultyData, BattleZoneId) == 0x000000, "Member 'FM1BattleZoneDifficultyData::BattleZoneId' has a wrong offset!");
static_assert(offsetof(FM1BattleZoneDifficultyData, DifficultyAbilityInfo) == 0x000030, "Member 'FM1BattleZoneDifficultyData::DifficultyAbilityInfo' has a wrong offset!");

// ScriptStruct M1Data.M1FieldDifficultyData
// 0x0040 (0x0040 - 0x0000)
struct FM1FieldDifficultyData final
{
public:
	struct FM1MapDataLink                         MapId;                                             // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1BattleZoneDifficultyData>    BattleZoneDifficulty;                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FieldDifficultyData) == 0x000008, "Wrong alignment on FM1FieldDifficultyData");
static_assert(sizeof(FM1FieldDifficultyData) == 0x000040, "Wrong size on FM1FieldDifficultyData");
static_assert(offsetof(FM1FieldDifficultyData, MapId) == 0x000000, "Member 'FM1FieldDifficultyData::MapId' has a wrong offset!");
static_assert(offsetof(FM1FieldDifficultyData, BattleZoneDifficulty) == 0x000030, "Member 'FM1FieldDifficultyData::BattleZoneDifficulty' has a wrong offset!");

// ScriptStruct M1Data.M1DifficultyInfoData
// 0x0078 (0x0080 - 0x0008)
struct FM1DifficultyInfoData final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          TemplateId;                                        // 0x0010(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1QuestDataLink                       UnlockQuest;                                       // 0x0018(0x0030)(Edit, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0050(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1FieldDifficultyData>         FieldDifficultyData;                               // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DifficultyInfoData) == 0x000008, "Wrong alignment on FM1DifficultyInfoData");
static_assert(sizeof(FM1DifficultyInfoData) == 0x000080, "Wrong size on FM1DifficultyInfoData");
static_assert(offsetof(FM1DifficultyInfoData, Name) == 0x000008, "Member 'FM1DifficultyInfoData::Name' has a wrong offset!");
static_assert(offsetof(FM1DifficultyInfoData, TemplateId) == 0x000010, "Member 'FM1DifficultyInfoData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1DifficultyInfoData, UnlockQuest) == 0x000018, "Member 'FM1DifficultyInfoData::UnlockQuest' has a wrong offset!");
static_assert(offsetof(FM1DifficultyInfoData, StringId) == 0x000048, "Member 'FM1DifficultyInfoData::StringId' has a wrong offset!");
static_assert(offsetof(FM1DifficultyInfoData, IconPath) == 0x000050, "Member 'FM1DifficultyInfoData::IconPath' has a wrong offset!");
static_assert(offsetof(FM1DifficultyInfoData, FieldDifficultyData) == 0x000070, "Member 'FM1DifficultyInfoData::FieldDifficultyData' has a wrong offset!");

// ScriptStruct M1Data.M1ItemBoxesInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1ItemBoxesInfo final
{
public:
	TArray<struct FM1ItemUidBox>                  ItemBoxList;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemBoxesInfo) == 0x000008, "Wrong alignment on FM1ItemBoxesInfo");
static_assert(sizeof(FM1ItemBoxesInfo) == 0x000010, "Wrong size on FM1ItemBoxesInfo");
static_assert(offsetof(FM1ItemBoxesInfo, ItemBoxList) == 0x000000, "Member 'FM1ItemBoxesInfo::ItemBoxList' has a wrong offset!");

// ScriptStruct M1Data.M1BattlePassChallengeDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1BattlePassChallengeDataLink final : public FDataLink
{
};
static_assert(alignof(FM1BattlePassChallengeDataLink) == 0x000008, "Wrong alignment on FM1BattlePassChallengeDataLink");
static_assert(sizeof(FM1BattlePassChallengeDataLink) == 0x000030, "Wrong size on FM1BattlePassChallengeDataLink");

// ScriptStruct M1Data.M1PaintData
// 0x0008 (0x0008 - 0x0000)
struct FM1PaintData final
{
public:
	struct FM1TemplateId                          PaintTid;                                          // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Slot;                                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PaintData) == 0x000004, "Wrong alignment on FM1PaintData");
static_assert(sizeof(FM1PaintData) == 0x000008, "Wrong size on FM1PaintData");
static_assert(offsetof(FM1PaintData, PaintTid) == 0x000000, "Member 'FM1PaintData::PaintTid' has a wrong offset!");
static_assert(offsetof(FM1PaintData, Slot) == 0x000004, "Member 'FM1PaintData::Slot' has a wrong offset!");

// ScriptStruct M1Data.M1CodexTrackingData
// 0x000C (0x000C - 0x0000)
struct FM1CodexTrackingData final
{
public:
	EM1CodexTrackingType                          TrackingType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          SlotIndex;                                         // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1TemplateId                          TrackingTid;                                       // 0x0004(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ResearchMaterial;                                  // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CodexTrackingData) == 0x000004, "Wrong alignment on FM1CodexTrackingData");
static_assert(sizeof(FM1CodexTrackingData) == 0x00000C, "Wrong size on FM1CodexTrackingData");
static_assert(offsetof(FM1CodexTrackingData, TrackingType) == 0x000000, "Member 'FM1CodexTrackingData::TrackingType' has a wrong offset!");
static_assert(offsetof(FM1CodexTrackingData, SlotIndex) == 0x000001, "Member 'FM1CodexTrackingData::SlotIndex' has a wrong offset!");
static_assert(offsetof(FM1CodexTrackingData, TrackingTid) == 0x000004, "Member 'FM1CodexTrackingData::TrackingTid' has a wrong offset!");
static_assert(offsetof(FM1CodexTrackingData, ResearchMaterial) == 0x000008, "Member 'FM1CodexTrackingData::ResearchMaterial' has a wrong offset!");

// ScriptStruct M1Data.M1CodexTrackingList
// 0x0010 (0x0010 - 0x0000)
struct FM1CodexTrackingList final
{
public:
	TArray<struct FM1CodexTrackingData>           Trackings;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CodexTrackingList) == 0x000008, "Wrong alignment on FM1CodexTrackingList");
static_assert(sizeof(FM1CodexTrackingList) == 0x000010, "Wrong size on FM1CodexTrackingList");
static_assert(offsetof(FM1CodexTrackingList, Trackings) == 0x000000, "Member 'FM1CodexTrackingList::Trackings' has a wrong offset!");

// ScriptStruct M1Data.M1MissionRequiredActivateCondition
// 0x0018 (0x0018 - 0x0000)
struct FM1MissionRequiredActivateCondition final
{
public:
	EM1MissionRequiredActivateConditionType       Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Params;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionRequiredActivateCondition) == 0x000008, "Wrong alignment on FM1MissionRequiredActivateCondition");
static_assert(sizeof(FM1MissionRequiredActivateCondition) == 0x000018, "Wrong size on FM1MissionRequiredActivateCondition");
static_assert(offsetof(FM1MissionRequiredActivateCondition, Type) == 0x000000, "Member 'FM1MissionRequiredActivateCondition::Type' has a wrong offset!");
static_assert(offsetof(FM1MissionRequiredActivateCondition, Params) == 0x000008, "Member 'FM1MissionRequiredActivateCondition::Params' has a wrong offset!");

// ScriptStruct M1Data.M1QuestGroupData
// 0x0018 (0x0020 - 0x0008)
struct FM1QuestGroupData final : public FTableRowBase
{
public:
	class FName                                   StringId;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1QuestDataLink>               QuestList;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1QuestGroupData) == 0x000008, "Wrong alignment on FM1QuestGroupData");
static_assert(sizeof(FM1QuestGroupData) == 0x000020, "Wrong size on FM1QuestGroupData");
static_assert(offsetof(FM1QuestGroupData, StringId) == 0x000008, "Member 'FM1QuestGroupData::StringId' has a wrong offset!");
static_assert(offsetof(FM1QuestGroupData, QuestList) == 0x000010, "Member 'FM1QuestGroupData::QuestList' has a wrong offset!");

// ScriptStruct M1Data.M1TracingQuestInfo
// 0x0008 (0x0008 - 0x0000)
struct FM1TracingQuestInfo final
{
public:
	struct FM1TemplateId                          QuestTid;                                          // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1QuestType                                  QuestType;                                         // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1TracingQuestInfo) == 0x000004, "Wrong alignment on FM1TracingQuestInfo");
static_assert(sizeof(FM1TracingQuestInfo) == 0x000008, "Wrong size on FM1TracingQuestInfo");
static_assert(offsetof(FM1TracingQuestInfo, QuestTid) == 0x000000, "Member 'FM1TracingQuestInfo::QuestTid' has a wrong offset!");
static_assert(offsetof(FM1TracingQuestInfo, QuestType) == 0x000004, "Member 'FM1TracingQuestInfo::QuestType' has a wrong offset!");

// ScriptStruct M1Data.M1QuestSubCondition
// 0x0018 (0x0018 - 0x0000)
struct FM1QuestSubCondition final
{
public:
	EM1QuestSubConditionType                      Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Value;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1QuestSubCondition) == 0x000008, "Wrong alignment on FM1QuestSubCondition");
static_assert(sizeof(FM1QuestSubCondition) == 0x000018, "Wrong size on FM1QuestSubCondition");
static_assert(offsetof(FM1QuestSubCondition, Type) == 0x000000, "Member 'FM1QuestSubCondition::Type' has a wrong offset!");
static_assert(offsetof(FM1QuestSubCondition, Value) == 0x000008, "Member 'FM1QuestSubCondition::Value' has a wrong offset!");

// ScriptStruct M1Data.M1CompleteCondition
// 0x0040 (0x0040 - 0x0000)
struct FM1CompleteCondition final
{
public:
	EM1CompleteConditionType                      Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StringId;                                          // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Params;                                            // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 WorldMapTarget;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1QuestSubCondition>           SubConditions;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CompleteCondition) == 0x000008, "Wrong alignment on FM1CompleteCondition");
static_assert(sizeof(FM1CompleteCondition) == 0x000040, "Wrong size on FM1CompleteCondition");
static_assert(offsetof(FM1CompleteCondition, Type) == 0x000000, "Member 'FM1CompleteCondition::Type' has a wrong offset!");
static_assert(offsetof(FM1CompleteCondition, StringId) == 0x000004, "Member 'FM1CompleteCondition::StringId' has a wrong offset!");
static_assert(offsetof(FM1CompleteCondition, Count) == 0x00000C, "Member 'FM1CompleteCondition::Count' has a wrong offset!");
static_assert(offsetof(FM1CompleteCondition, Params) == 0x000010, "Member 'FM1CompleteCondition::Params' has a wrong offset!");
static_assert(offsetof(FM1CompleteCondition, WorldMapTarget) == 0x000020, "Member 'FM1CompleteCondition::WorldMapTarget' has a wrong offset!");
static_assert(offsetof(FM1CompleteCondition, SubConditions) == 0x000030, "Member 'FM1CompleteCondition::SubConditions' has a wrong offset!");

// ScriptStruct M1Data.M1ItemSelectorUnit
// 0x0018 (0x0018 - 0x0000)
struct FM1ItemSelectorUnit final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1ItemDataBox>                 Items;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemSelectorUnit) == 0x000008, "Wrong alignment on FM1ItemSelectorUnit");
static_assert(sizeof(FM1ItemSelectorUnit) == 0x000018, "Wrong size on FM1ItemSelectorUnit");
static_assert(offsetof(FM1ItemSelectorUnit, Index) == 0x000000, "Member 'FM1ItemSelectorUnit::Index' has a wrong offset!");
static_assert(offsetof(FM1ItemSelectorUnit, Items) == 0x000008, "Member 'FM1ItemSelectorUnit::Items' has a wrong offset!");

// ScriptStruct M1Data.M1ItemSelectorData
// 0x0090 (0x0098 - 0x0008)
struct FM1ItemSelectorData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1ItemSelectorUnit>            Units;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   GroupName;                                         // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemUIData                          UIData;                                            // 0x0030(0x0060)(Edit, NativeAccessSpecifierPublic)
	bool                                          bIncludeUltimate;                                  // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ItemSelectorData) == 0x000008, "Wrong alignment on FM1ItemSelectorData");
static_assert(sizeof(FM1ItemSelectorData) == 0x000098, "Wrong size on FM1ItemSelectorData");
static_assert(offsetof(FM1ItemSelectorData, TemplateId) == 0x000008, "Member 'FM1ItemSelectorData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1ItemSelectorData, Units) == 0x000010, "Member 'FM1ItemSelectorData::Units' has a wrong offset!");
static_assert(offsetof(FM1ItemSelectorData, GroupName) == 0x000020, "Member 'FM1ItemSelectorData::GroupName' has a wrong offset!");
static_assert(offsetof(FM1ItemSelectorData, StringId) == 0x000028, "Member 'FM1ItemSelectorData::StringId' has a wrong offset!");
static_assert(offsetof(FM1ItemSelectorData, UIData) == 0x000030, "Member 'FM1ItemSelectorData::UIData' has a wrong offset!");
static_assert(offsetof(FM1ItemSelectorData, bIncludeUltimate) == 0x000090, "Member 'FM1ItemSelectorData::bIncludeUltimate' has a wrong offset!");

// ScriptStruct M1Data.M1CustomizingItemInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1CustomizingItemInfo final
{
public:
	struct FM1TemplateId                          Tid;                                               // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EvolutionIdx;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EvolutionComplete;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizingItemInfo) == 0x000004, "Wrong alignment on FM1CustomizingItemInfo");
static_assert(sizeof(FM1CustomizingItemInfo) == 0x000010, "Wrong size on FM1CustomizingItemInfo");
static_assert(offsetof(FM1CustomizingItemInfo, Tid) == 0x000000, "Member 'FM1CustomizingItemInfo::Tid' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemInfo, EvolutionIdx) == 0x000004, "Member 'FM1CustomizingItemInfo::EvolutionIdx' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemInfo, EvolutionComplete) == 0x000008, "Member 'FM1CustomizingItemInfo::EvolutionComplete' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemInfo, StackCount) == 0x00000C, "Member 'FM1CustomizingItemInfo::StackCount' has a wrong offset!");

// ScriptStruct M1Data.M1AutomationTestNestData
// 0x0008 (0x0008 - 0x0000)
struct FM1AutomationTestNestData final
{
public:
	int32                                         MaxHp;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxMp;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AutomationTestNestData) == 0x000004, "Wrong alignment on FM1AutomationTestNestData");
static_assert(sizeof(FM1AutomationTestNestData) == 0x000008, "Wrong size on FM1AutomationTestNestData");
static_assert(offsetof(FM1AutomationTestNestData, MaxHp) == 0x000000, "Member 'FM1AutomationTestNestData::MaxHp' has a wrong offset!");
static_assert(offsetof(FM1AutomationTestNestData, MaxMp) == 0x000004, "Member 'FM1AutomationTestNestData::MaxMp' has a wrong offset!");

// ScriptStruct M1Data.M1MapSubDataStrId
// 0x0018 (0x0018 - 0x0000)
struct FM1MapSubDataStrId final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MapSubType                                 Type;                                              // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MapSubDataStrId) == 0x000008, "Wrong alignment on FM1MapSubDataStrId");
static_assert(sizeof(FM1MapSubDataStrId) == 0x000018, "Wrong size on FM1MapSubDataStrId");
static_assert(offsetof(FM1MapSubDataStrId, ID) == 0x000000, "Member 'FM1MapSubDataStrId::ID' has a wrong offset!");
static_assert(offsetof(FM1MapSubDataStrId, Type) == 0x000010, "Member 'FM1MapSubDataStrId::Type' has a wrong offset!");

// ScriptStruct M1Data.M1MapEntryPointUIData
// 0x0040 (0x0040 - 0x0000)
struct FM1MapEntryPointUIData final
{
public:
	struct FSoftObjectPath                        LockIconPath;                                      // 0x0000(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UnlockIconPath;                                    // 0x0020(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MapEntryPointUIData) == 0x000008, "Wrong alignment on FM1MapEntryPointUIData");
static_assert(sizeof(FM1MapEntryPointUIData) == 0x000040, "Wrong size on FM1MapEntryPointUIData");
static_assert(offsetof(FM1MapEntryPointUIData, LockIconPath) == 0x000000, "Member 'FM1MapEntryPointUIData::LockIconPath' has a wrong offset!");
static_assert(offsetof(FM1MapEntryPointUIData, UnlockIconPath) == 0x000020, "Member 'FM1MapEntryPointUIData::UnlockIconPath' has a wrong offset!");

// ScriptStruct M1Data.M1MapEntryPointInfo
// 0x00A8 (0x00A8 - 0x0000)
struct FM1MapEntryPointInfo final
{
public:
	class FString                                 PointId;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1MapBattleZoneDataLink               BattleZone;                                        // 0x0010(0x0030)(Edit, NativeAccessSpecifierPublic)
	EM1EntryPointUnlockType                       UnlockType;                                        // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringId;                                          // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RoleStringId;                                      // 0x0058(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1MapEntryPointUIData                 UIData;                                            // 0x0068(0x0040)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MapEntryPointInfo) == 0x000008, "Wrong alignment on FM1MapEntryPointInfo");
static_assert(sizeof(FM1MapEntryPointInfo) == 0x0000A8, "Wrong size on FM1MapEntryPointInfo");
static_assert(offsetof(FM1MapEntryPointInfo, PointId) == 0x000000, "Member 'FM1MapEntryPointInfo::PointId' has a wrong offset!");
static_assert(offsetof(FM1MapEntryPointInfo, BattleZone) == 0x000010, "Member 'FM1MapEntryPointInfo::BattleZone' has a wrong offset!");
static_assert(offsetof(FM1MapEntryPointInfo, UnlockType) == 0x000040, "Member 'FM1MapEntryPointInfo::UnlockType' has a wrong offset!");
static_assert(offsetof(FM1MapEntryPointInfo, StringId) == 0x000048, "Member 'FM1MapEntryPointInfo::StringId' has a wrong offset!");
static_assert(offsetof(FM1MapEntryPointInfo, RoleStringId) == 0x000058, "Member 'FM1MapEntryPointInfo::RoleStringId' has a wrong offset!");
static_assert(offsetof(FM1MapEntryPointInfo, UIData) == 0x000068, "Member 'FM1MapEntryPointInfo::UIData' has a wrong offset!");

// ScriptStruct M1Data.M1MapLoadingInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1MapLoadingInfo final
{
public:
	EM1MapSubType                                 Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ID;                                                // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MapLoadingInfo) == 0x000008, "Wrong alignment on FM1MapLoadingInfo");
static_assert(sizeof(FM1MapLoadingInfo) == 0x000018, "Wrong size on FM1MapLoadingInfo");
static_assert(offsetof(FM1MapLoadingInfo, Type) == 0x000000, "Member 'FM1MapLoadingInfo::Type' has a wrong offset!");
static_assert(offsetof(FM1MapLoadingInfo, ID) == 0x000008, "Member 'FM1MapLoadingInfo::ID' has a wrong offset!");

// ScriptStruct M1Data.M1MapData
// 0x0118 (0x0120 - 0x0008)
struct FM1MapData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForTest;                                          // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringId;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SortId;                                            // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MapType                                    Type;                                              // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        Level;                                             // 0x0038(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IntroduceSequence;                                 // 0x0058(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        EnterSequence;                                     // 0x0078(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1MapSubDataStrId>             SubData;                                           // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1MapEntryPointInfo>           EntryPointInfos;                                   // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1MapLoadingInfo>              LoadingTooltipTag;                                 // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1MapLoadingInfo>              LoadingImageGroup;                                 // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          FieldOption;                                       // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1MapEliteMonsterSpawnData            EliteMonsterSpawnData;                             // 0x00E0(0x0030)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1MapBattleZoneDataLink>       BattleZones;                                       // 0x0110(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MapData) == 0x000008, "Wrong alignment on FM1MapData");
static_assert(sizeof(FM1MapData) == 0x000120, "Wrong size on FM1MapData");
static_assert(offsetof(FM1MapData, TemplateId) == 0x000008, "Member 'FM1MapData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1MapData, bForTest) == 0x00000C, "Member 'FM1MapData::bForTest' has a wrong offset!");
static_assert(offsetof(FM1MapData, StringId) == 0x000010, "Member 'FM1MapData::StringId' has a wrong offset!");
static_assert(offsetof(FM1MapData, SortId) == 0x000020, "Member 'FM1MapData::SortId' has a wrong offset!");
static_assert(offsetof(FM1MapData, Type) == 0x000030, "Member 'FM1MapData::Type' has a wrong offset!");
static_assert(offsetof(FM1MapData, Level) == 0x000038, "Member 'FM1MapData::Level' has a wrong offset!");
static_assert(offsetof(FM1MapData, IntroduceSequence) == 0x000058, "Member 'FM1MapData::IntroduceSequence' has a wrong offset!");
static_assert(offsetof(FM1MapData, EnterSequence) == 0x000078, "Member 'FM1MapData::EnterSequence' has a wrong offset!");
static_assert(offsetof(FM1MapData, SubData) == 0x000098, "Member 'FM1MapData::SubData' has a wrong offset!");
static_assert(offsetof(FM1MapData, EntryPointInfos) == 0x0000A8, "Member 'FM1MapData::EntryPointInfos' has a wrong offset!");
static_assert(offsetof(FM1MapData, LoadingTooltipTag) == 0x0000B8, "Member 'FM1MapData::LoadingTooltipTag' has a wrong offset!");
static_assert(offsetof(FM1MapData, LoadingImageGroup) == 0x0000C8, "Member 'FM1MapData::LoadingImageGroup' has a wrong offset!");
static_assert(offsetof(FM1MapData, FieldOption) == 0x0000D8, "Member 'FM1MapData::FieldOption' has a wrong offset!");
static_assert(offsetof(FM1MapData, EliteMonsterSpawnData) == 0x0000E0, "Member 'FM1MapData::EliteMonsterSpawnData' has a wrong offset!");
static_assert(offsetof(FM1MapData, BattleZones) == 0x000110, "Member 'FM1MapData::BattleZones' has a wrong offset!");

// ScriptStruct M1Data.M1ReactorEnchantInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1ReactorEnchantInfo final
{
public:
	int64                                         EquipmentUid;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnchantLevel;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ReactorEnchantInfo) == 0x000008, "Wrong alignment on FM1ReactorEnchantInfo");
static_assert(sizeof(FM1ReactorEnchantInfo) == 0x000010, "Wrong size on FM1ReactorEnchantInfo");
static_assert(offsetof(FM1ReactorEnchantInfo, EquipmentUid) == 0x000000, "Member 'FM1ReactorEnchantInfo::EquipmentUid' has a wrong offset!");
static_assert(offsetof(FM1ReactorEnchantInfo, EnchantLevel) == 0x000008, "Member 'FM1ReactorEnchantInfo::EnchantLevel' has a wrong offset!");

// ScriptStruct M1Data.M1ChatChannelDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1ChatChannelDataLink final : public FDataLink
{
};
static_assert(alignof(FM1ChatChannelDataLink) == 0x000008, "Wrong alignment on FM1ChatChannelDataLink");
static_assert(sizeof(FM1ChatChannelDataLink) == 0x000030, "Wrong size on FM1ChatChannelDataLink");

// ScriptStruct M1Data.M1PlayerDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1PlayerDataLink final : public FDataLink
{
};
static_assert(alignof(FM1PlayerDataLink) == 0x000008, "Wrong alignment on FM1PlayerDataLink");
static_assert(sizeof(FM1PlayerDataLink) == 0x000030, "Wrong size on FM1PlayerDataLink");

// ScriptStruct M1Data.M1MiniGameSpecialCharacterInfo
// 0x0038 (0x0038 - 0x0000)
struct FM1MiniGameSpecialCharacterInfo final
{
public:
	struct FM1PlayerDataLink                      Character;                                         // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	class FName                                   DialogueId;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MiniGameSpecialCharacterInfo) == 0x000008, "Wrong alignment on FM1MiniGameSpecialCharacterInfo");
static_assert(sizeof(FM1MiniGameSpecialCharacterInfo) == 0x000038, "Wrong size on FM1MiniGameSpecialCharacterInfo");
static_assert(offsetof(FM1MiniGameSpecialCharacterInfo, Character) == 0x000000, "Member 'FM1MiniGameSpecialCharacterInfo::Character' has a wrong offset!");
static_assert(offsetof(FM1MiniGameSpecialCharacterInfo, DialogueId) == 0x000030, "Member 'FM1MiniGameSpecialCharacterInfo::DialogueId' has a wrong offset!");

// ScriptStruct M1Data.M1MiniGameExtraSettings
// 0x0018 (0x0018 - 0x0000)
struct FM1MiniGameExtraSettings final
{
public:
	EM1MiniGameType                               Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1MiniGameSpecialCharacterInfo> SpecialCharacters;                                 // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MiniGameExtraSettings) == 0x000008, "Wrong alignment on FM1MiniGameExtraSettings");
static_assert(sizeof(FM1MiniGameExtraSettings) == 0x000018, "Wrong size on FM1MiniGameExtraSettings");
static_assert(offsetof(FM1MiniGameExtraSettings, Type) == 0x000000, "Member 'FM1MiniGameExtraSettings::Type' has a wrong offset!");
static_assert(offsetof(FM1MiniGameExtraSettings, SpecialCharacters) == 0x000008, "Member 'FM1MiniGameExtraSettings::SpecialCharacters' has a wrong offset!");

// ScriptStruct M1Data.M1MiniGameMiscData
// 0x0010 (0x0018 - 0x0008)
struct FM1MiniGameMiscData final : public FTableRowBase
{
public:
	TArray<struct FM1MiniGameExtraSettings>       ExtraSettings;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MiniGameMiscData) == 0x000008, "Wrong alignment on FM1MiniGameMiscData");
static_assert(sizeof(FM1MiniGameMiscData) == 0x000018, "Wrong size on FM1MiniGameMiscData");
static_assert(offsetof(FM1MiniGameMiscData, ExtraSettings) == 0x000008, "Member 'FM1MiniGameMiscData::ExtraSettings' has a wrong offset!");

// ScriptStruct M1Data.M1MissionInfo
// 0x000C (0x000C - 0x0000)
struct FM1MissionInfo final
{
public:
	struct FM1TemplateId                          MissionId;                                         // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Complete;                                          // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CompleteCnt;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionInfo) == 0x000004, "Wrong alignment on FM1MissionInfo");
static_assert(sizeof(FM1MissionInfo) == 0x00000C, "Wrong size on FM1MissionInfo");
static_assert(offsetof(FM1MissionInfo, MissionId) == 0x000000, "Member 'FM1MissionInfo::MissionId' has a wrong offset!");
static_assert(offsetof(FM1MissionInfo, Complete) == 0x000004, "Member 'FM1MissionInfo::Complete' has a wrong offset!");
static_assert(offsetof(FM1MissionInfo, CompleteCnt) == 0x000008, "Member 'FM1MissionInfo::CompleteCnt' has a wrong offset!");

// ScriptStruct M1Data.M1LoadingGroupList
// 0x0018 (0x0018 - 0x0000)
struct FM1LoadingGroupList final
{
public:
	class FString                                 GroupId;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ratio;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1LoadingGroupList) == 0x000008, "Wrong alignment on FM1LoadingGroupList");
static_assert(sizeof(FM1LoadingGroupList) == 0x000018, "Wrong size on FM1LoadingGroupList");
static_assert(offsetof(FM1LoadingGroupList, GroupId) == 0x000000, "Member 'FM1LoadingGroupList::GroupId' has a wrong offset!");
static_assert(offsetof(FM1LoadingGroupList, Ratio) == 0x000010, "Member 'FM1LoadingGroupList::Ratio' has a wrong offset!");

// ScriptStruct M1Data.M1LoadingImageRandomData
// 0x0010 (0x0018 - 0x0008)
struct FM1LoadingImageRandomData final : public FTableRowBase
{
public:
	TArray<struct FM1LoadingGroupList>            LoadingGroupList;                                  // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1LoadingImageRandomData) == 0x000008, "Wrong alignment on FM1LoadingImageRandomData");
static_assert(sizeof(FM1LoadingImageRandomData) == 0x000018, "Wrong size on FM1LoadingImageRandomData");
static_assert(offsetof(FM1LoadingImageRandomData, LoadingGroupList) == 0x000008, "Member 'FM1LoadingImageRandomData::LoadingGroupList' has a wrong offset!");

// ScriptStruct M1Data.M1PackageGroupElement
// 0x0048 (0x0048 - 0x0000)
struct FM1PackageGroupElement final
{
public:
	struct FM1ItemDataBox                         Item;                                              // 0x0000(0x0038)(Edit, NativeAccessSpecifierPublic)
	int32                                         ValueMin;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ValueMax;                                          // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PackageGroupElement) == 0x000008, "Wrong alignment on FM1PackageGroupElement");
static_assert(sizeof(FM1PackageGroupElement) == 0x000048, "Wrong size on FM1PackageGroupElement");
static_assert(offsetof(FM1PackageGroupElement, Item) == 0x000000, "Member 'FM1PackageGroupElement::Item' has a wrong offset!");
static_assert(offsetof(FM1PackageGroupElement, ValueMin) == 0x000038, "Member 'FM1PackageGroupElement::ValueMin' has a wrong offset!");
static_assert(offsetof(FM1PackageGroupElement, ValueMax) == 0x00003C, "Member 'FM1PackageGroupElement::ValueMax' has a wrong offset!");
static_assert(offsetof(FM1PackageGroupElement, Ratio) == 0x000040, "Member 'FM1PackageGroupElement::Ratio' has a wrong offset!");

// ScriptStruct M1Data.M1TitleItemInvenvory
// 0x0020 (0x0020 - 0x0000)
struct FM1TitleItemInvenvory final
{
public:
	EM1TitleReason                                Reason;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1TemplateId>                  GainTitles;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          PrefixTitle;                                       // 0x0018(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          SuffixTitle;                                       // 0x001C(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TitleItemInvenvory) == 0x000008, "Wrong alignment on FM1TitleItemInvenvory");
static_assert(sizeof(FM1TitleItemInvenvory) == 0x000020, "Wrong size on FM1TitleItemInvenvory");
static_assert(offsetof(FM1TitleItemInvenvory, Reason) == 0x000000, "Member 'FM1TitleItemInvenvory::Reason' has a wrong offset!");
static_assert(offsetof(FM1TitleItemInvenvory, GainTitles) == 0x000008, "Member 'FM1TitleItemInvenvory::GainTitles' has a wrong offset!");
static_assert(offsetof(FM1TitleItemInvenvory, PrefixTitle) == 0x000018, "Member 'FM1TitleItemInvenvory::PrefixTitle' has a wrong offset!");
static_assert(offsetof(FM1TitleItemInvenvory, SuffixTitle) == 0x00001C, "Member 'FM1TitleItemInvenvory::SuffixTitle' has a wrong offset!");

// ScriptStruct M1Data.M1RuneCostIncreaseResource
// 0x0038 (0x0038 - 0x0000)
struct FM1RuneCostIncreaseResource final
{
public:
	struct FM1ConsumableItemDataLink              ItemData;                                          // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RuneCostIncreaseResource) == 0x000008, "Wrong alignment on FM1RuneCostIncreaseResource");
static_assert(sizeof(FM1RuneCostIncreaseResource) == 0x000038, "Wrong size on FM1RuneCostIncreaseResource");
static_assert(offsetof(FM1RuneCostIncreaseResource, ItemData) == 0x000000, "Member 'FM1RuneCostIncreaseResource::ItemData' has a wrong offset!");
static_assert(offsetof(FM1RuneCostIncreaseResource, Amount) == 0x000030, "Member 'FM1RuneCostIncreaseResource::Amount' has a wrong offset!");

// ScriptStruct M1Data.M1Friend
// 0x0038 (0x0038 - 0x0000)
struct FM1Friend final
{
public:
	class FString                                 AccountName;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Online;                                            // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BookMark;                                          // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlatformId;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         PlatformUid;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         PlatformType;                                      // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MasteryRankLevel;                                  // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Friend) == 0x000008, "Wrong alignment on FM1Friend");
static_assert(sizeof(FM1Friend) == 0x000038, "Wrong size on FM1Friend");
static_assert(offsetof(FM1Friend, AccountName) == 0x000000, "Member 'FM1Friend::AccountName' has a wrong offset!");
static_assert(offsetof(FM1Friend, Online) == 0x000010, "Member 'FM1Friend::Online' has a wrong offset!");
static_assert(offsetof(FM1Friend, BookMark) == 0x000011, "Member 'FM1Friend::BookMark' has a wrong offset!");
static_assert(offsetof(FM1Friend, PlatformId) == 0x000018, "Member 'FM1Friend::PlatformId' has a wrong offset!");
static_assert(offsetof(FM1Friend, PlatformUid) == 0x000028, "Member 'FM1Friend::PlatformUid' has a wrong offset!");
static_assert(offsetof(FM1Friend, PlatformType) == 0x000030, "Member 'FM1Friend::PlatformType' has a wrong offset!");
static_assert(offsetof(FM1Friend, MasteryRankLevel) == 0x000034, "Member 'FM1Friend::MasteryRankLevel' has a wrong offset!");

// ScriptStruct M1Data.M1FriendList
// 0x0018 (0x0018 - 0x0000)
struct FM1FriendList final
{
public:
	EM1FriendUpdateType                           UpdateType;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1Friend>                      Value;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FriendList) == 0x000008, "Wrong alignment on FM1FriendList");
static_assert(sizeof(FM1FriendList) == 0x000018, "Wrong size on FM1FriendList");
static_assert(offsetof(FM1FriendList, UpdateType) == 0x000000, "Member 'FM1FriendList::UpdateType' has a wrong offset!");
static_assert(offsetof(FM1FriendList, Value) == 0x000008, "Member 'FM1FriendList::Value' has a wrong offset!");

// ScriptStruct M1Data.M1WeaponProficiencyInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1WeaponProficiencyInfo final
{
public:
	struct FM1TemplateId                          Tid;                                               // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Exp;                                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReset;                                           // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1WeaponProficiencyInfo) == 0x000008, "Wrong alignment on FM1WeaponProficiencyInfo");
static_assert(sizeof(FM1WeaponProficiencyInfo) == 0x000018, "Wrong size on FM1WeaponProficiencyInfo");
static_assert(offsetof(FM1WeaponProficiencyInfo, Tid) == 0x000000, "Member 'FM1WeaponProficiencyInfo::Tid' has a wrong offset!");
static_assert(offsetof(FM1WeaponProficiencyInfo, Level) == 0x000004, "Member 'FM1WeaponProficiencyInfo::Level' has a wrong offset!");
static_assert(offsetof(FM1WeaponProficiencyInfo, Exp) == 0x000008, "Member 'FM1WeaponProficiencyInfo::Exp' has a wrong offset!");
static_assert(offsetof(FM1WeaponProficiencyInfo, IsReset) == 0x000010, "Member 'FM1WeaponProficiencyInfo::IsReset' has a wrong offset!");

// ScriptStruct M1Data.M1ItemInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1ItemInfo final
{
public:
	int64                                         ID;                                                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Quantity;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         CreateDate;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemInfo) == 0x000008, "Wrong alignment on FM1ItemInfo");
static_assert(sizeof(FM1ItemInfo) == 0x000018, "Wrong size on FM1ItemInfo");
static_assert(offsetof(FM1ItemInfo, ID) == 0x000000, "Member 'FM1ItemInfo::ID' has a wrong offset!");
static_assert(offsetof(FM1ItemInfo, Quantity) == 0x000008, "Member 'FM1ItemInfo::Quantity' has a wrong offset!");
static_assert(offsetof(FM1ItemInfo, CreateDate) == 0x000010, "Member 'FM1ItemInfo::CreateDate' has a wrong offset!");

// ScriptStruct M1Data.M1WearingInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1WearingInfo final
{
public:
	int32                                         SocketIndex;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         EquipmentUid;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WearingInfo) == 0x000008, "Wrong alignment on FM1WearingInfo");
static_assert(sizeof(FM1WearingInfo) == 0x000010, "Wrong size on FM1WearingInfo");
static_assert(offsetof(FM1WearingInfo, SocketIndex) == 0x000000, "Member 'FM1WearingInfo::SocketIndex' has a wrong offset!");
static_assert(offsetof(FM1WearingInfo, EquipmentUid) == 0x000008, "Member 'FM1WearingInfo::EquipmentUid' has a wrong offset!");

// ScriptStruct M1Data.M1NewMailPushInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1NewMailPushInfo final
{
public:
	EM1MailType                                   MailType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         AccountUid;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int64>                                 NewMailIdList;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NewMailPushInfo) == 0x000008, "Wrong alignment on FM1NewMailPushInfo");
static_assert(sizeof(FM1NewMailPushInfo) == 0x000020, "Wrong size on FM1NewMailPushInfo");
static_assert(offsetof(FM1NewMailPushInfo, MailType) == 0x000000, "Member 'FM1NewMailPushInfo::MailType' has a wrong offset!");
static_assert(offsetof(FM1NewMailPushInfo, AccountUid) == 0x000008, "Member 'FM1NewMailPushInfo::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1NewMailPushInfo, NewMailIdList) == 0x000010, "Member 'FM1NewMailPushInfo::NewMailIdList' has a wrong offset!");

// ScriptStruct M1Data.M1SlotVersionPair
// 0x0008 (0x0008 - 0x0000)
struct FM1SlotVersionPair final
{
public:
	uint8                                         SlotIndex;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Version;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SlotVersionPair) == 0x000004, "Wrong alignment on FM1SlotVersionPair");
static_assert(sizeof(FM1SlotVersionPair) == 0x000008, "Wrong size on FM1SlotVersionPair");
static_assert(offsetof(FM1SlotVersionPair, SlotIndex) == 0x000000, "Member 'FM1SlotVersionPair::SlotIndex' has a wrong offset!");
static_assert(offsetof(FM1SlotVersionPair, Version) == 0x000004, "Member 'FM1SlotVersionPair::Version' has a wrong offset!");

// ScriptStruct M1Data.M1RuneLoadoutReq
// 0x0018 (0x0018 - 0x0000)
struct FM1RuneLoadoutReq final
{
public:
	struct FM1ItemTidBox                          OwnerTid;                                          // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FM1SlotVersionPair>             Versions;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneLoadoutReq) == 0x000008, "Wrong alignment on FM1RuneLoadoutReq");
static_assert(sizeof(FM1RuneLoadoutReq) == 0x000018, "Wrong size on FM1RuneLoadoutReq");
static_assert(offsetof(FM1RuneLoadoutReq, OwnerTid) == 0x000000, "Member 'FM1RuneLoadoutReq::OwnerTid' has a wrong offset!");
static_assert(offsetof(FM1RuneLoadoutReq, Versions) == 0x000008, "Member 'FM1RuneLoadoutReq::Versions' has a wrong offset!");

// ScriptStruct M1Data.M1AutomationTestOtherData
// 0x0050 (0x0058 - 0x0008)
struct FM1AutomationTestOtherData final : public FTableRowBase
{
public:
	int32                                         Value;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        UnrealAsset1;                                      // 0x0010(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name1;                                             // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Vector1;                                           // 0x0038(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotator1;                                          // 0x0044(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FDateTime                              Dt;                                                // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AutomationTestOtherData) == 0x000008, "Wrong alignment on FM1AutomationTestOtherData");
static_assert(sizeof(FM1AutomationTestOtherData) == 0x000058, "Wrong size on FM1AutomationTestOtherData");
static_assert(offsetof(FM1AutomationTestOtherData, Value) == 0x000008, "Member 'FM1AutomationTestOtherData::Value' has a wrong offset!");
static_assert(offsetof(FM1AutomationTestOtherData, UnrealAsset1) == 0x000010, "Member 'FM1AutomationTestOtherData::UnrealAsset1' has a wrong offset!");
static_assert(offsetof(FM1AutomationTestOtherData, Name1) == 0x000030, "Member 'FM1AutomationTestOtherData::Name1' has a wrong offset!");
static_assert(offsetof(FM1AutomationTestOtherData, Vector1) == 0x000038, "Member 'FM1AutomationTestOtherData::Vector1' has a wrong offset!");
static_assert(offsetof(FM1AutomationTestOtherData, Rotator1) == 0x000044, "Member 'FM1AutomationTestOtherData::Rotator1' has a wrong offset!");
static_assert(offsetof(FM1AutomationTestOtherData, Dt) == 0x000050, "Member 'FM1AutomationTestOtherData::Dt' has a wrong offset!");

// ScriptStruct M1Data.M1StatTypeOpFloat
// 0x0008 (0x0008 - 0x0000)
struct FM1StatTypeOpFloat final
{
public:
	EM1StatType                                   StatType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1StatModifierOp                             ModOp;                                             // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StatTypeOpFloat) == 0x000004, "Wrong alignment on FM1StatTypeOpFloat");
static_assert(sizeof(FM1StatTypeOpFloat) == 0x000008, "Wrong size on FM1StatTypeOpFloat");
static_assert(offsetof(FM1StatTypeOpFloat, StatType) == 0x000000, "Member 'FM1StatTypeOpFloat::StatType' has a wrong offset!");
static_assert(offsetof(FM1StatTypeOpFloat, ModOp) == 0x000001, "Member 'FM1StatTypeOpFloat::ModOp' has a wrong offset!");
static_assert(offsetof(FM1StatTypeOpFloat, Value) == 0x000004, "Member 'FM1StatTypeOpFloat::Value' has a wrong offset!");

// ScriptStruct M1Data.M1ProductIdInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1ProductIdInfo final
{
public:
	EM1LoginPlatformTypes                         PlatformType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ProductId;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ProductIdInfo) == 0x000008, "Wrong alignment on FM1ProductIdInfo");
static_assert(sizeof(FM1ProductIdInfo) == 0x000018, "Wrong size on FM1ProductIdInfo");
static_assert(offsetof(FM1ProductIdInfo, PlatformType) == 0x000000, "Member 'FM1ProductIdInfo::PlatformType' has a wrong offset!");
static_assert(offsetof(FM1ProductIdInfo, ProductId) == 0x000008, "Member 'FM1ProductIdInfo::ProductId' has a wrong offset!");

// ScriptStruct M1Data.M1StoryStringTableDataRow
// 0x0008 (0x0090 - 0x0088)
struct FM1StoryStringTableDataRow final : public FM1StringTableDataRow
{
public:
	bool                                          NeedStringKeyReplacement;                          // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1StoryStringTableDataRow) == 0x000008, "Wrong alignment on FM1StoryStringTableDataRow");
static_assert(sizeof(FM1StoryStringTableDataRow) == 0x000090, "Wrong size on FM1StoryStringTableDataRow");
static_assert(offsetof(FM1StoryStringTableDataRow, NeedStringKeyReplacement) == 0x000088, "Member 'FM1StoryStringTableDataRow::NeedStringKeyReplacement' has a wrong offset!");

// ScriptStruct M1Data.M1PaintSimpleInfo
// 0x0008 (0x0008 - 0x0000)
struct FM1PaintSimpleInfo final
{
public:
	struct FM1TemplateId                          PaintTid;                                          // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Slot;                                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PaintSimpleInfo) == 0x000004, "Wrong alignment on FM1PaintSimpleInfo");
static_assert(sizeof(FM1PaintSimpleInfo) == 0x000008, "Wrong size on FM1PaintSimpleInfo");
static_assert(offsetof(FM1PaintSimpleInfo, PaintTid) == 0x000000, "Member 'FM1PaintSimpleInfo::PaintTid' has a wrong offset!");
static_assert(offsetof(FM1PaintSimpleInfo, Slot) == 0x000004, "Member 'FM1PaintSimpleInfo::Slot' has a wrong offset!");

// ScriptStruct M1Data.M1SkinSimpleInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1SkinSimpleInfo final
{
public:
	struct FM1TemplateId                          SkinTid;                                           // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Slot;                                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Evolution;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1PaintSimpleInfo>             Paints;                                            // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SkinSimpleInfo) == 0x000008, "Wrong alignment on FM1SkinSimpleInfo");
static_assert(sizeof(FM1SkinSimpleInfo) == 0x000020, "Wrong size on FM1SkinSimpleInfo");
static_assert(offsetof(FM1SkinSimpleInfo, SkinTid) == 0x000000, "Member 'FM1SkinSimpleInfo::SkinTid' has a wrong offset!");
static_assert(offsetof(FM1SkinSimpleInfo, Slot) == 0x000004, "Member 'FM1SkinSimpleInfo::Slot' has a wrong offset!");
static_assert(offsetof(FM1SkinSimpleInfo, Evolution) == 0x000008, "Member 'FM1SkinSimpleInfo::Evolution' has a wrong offset!");
static_assert(offsetof(FM1SkinSimpleInfo, Paints) == 0x000010, "Member 'FM1SkinSimpleInfo::Paints' has a wrong offset!");

// ScriptStruct M1Data.M1MonsterAIOverride
// 0x000C (0x000C - 0x0000)
struct FM1MonsterAIOverride final
{
public:
	struct FM1MonsterAIVulgusPost                 VulgusPost;                                        // 0x0000(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterAIOverride) == 0x000004, "Wrong alignment on FM1MonsterAIOverride");
static_assert(sizeof(FM1MonsterAIOverride) == 0x00000C, "Wrong size on FM1MonsterAIOverride");
static_assert(offsetof(FM1MonsterAIOverride, VulgusPost) == 0x000000, "Member 'FM1MonsterAIOverride::VulgusPost' has a wrong offset!");

// ScriptStruct M1Data.M1MonsterAISubBehaviorTree
// 0x0028 (0x0028 - 0x0000)
struct FM1MonsterAISubBehaviorTree final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BTPath;                                            // 0x0008(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterAISubBehaviorTree) == 0x000008, "Wrong alignment on FM1MonsterAISubBehaviorTree");
static_assert(sizeof(FM1MonsterAISubBehaviorTree) == 0x000028, "Wrong size on FM1MonsterAISubBehaviorTree");
static_assert(offsetof(FM1MonsterAISubBehaviorTree, Tag) == 0x000000, "Member 'FM1MonsterAISubBehaviorTree::Tag' has a wrong offset!");
static_assert(offsetof(FM1MonsterAISubBehaviorTree, BTPath) == 0x000008, "Member 'FM1MonsterAISubBehaviorTree::BTPath' has a wrong offset!");

// ScriptStruct M1Data.M1MonsterAIBattleState
// 0x0060 (0x0060 - 0x0000)
struct FM1MonsterAIBattleState final
{
public:
	float                                         AttackRadius;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetSearchRadius;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetSearchTimeMin;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetSearchTimeMax;                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetSearchAngle;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetChangeRate;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RelationsCheckType                         Relations;                                         // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           QueryTag;                                          // 0x001C(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1AITargetingPriority                        TargetingPriority;                                 // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckTargetVisible;                                // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetHoldRadius;                                  // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PursuitRadius;                                     // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllianceCallRadius;                                // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllianceBattleRadius;                              // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatrolHitRadius;                                   // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatrolRadius;                                      // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCoverUpInBattle;                                // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaitTimeOnCoverUp;                                 // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseHomeLocationWithTargetSearch;                   // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 BattleRangeList;                                   // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterAIBattleState) == 0x000008, "Wrong alignment on FM1MonsterAIBattleState");
static_assert(sizeof(FM1MonsterAIBattleState) == 0x000060, "Wrong size on FM1MonsterAIBattleState");
static_assert(offsetof(FM1MonsterAIBattleState, AttackRadius) == 0x000000, "Member 'FM1MonsterAIBattleState::AttackRadius' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIBattleState, TargetSearchRadius) == 0x000004, "Member 'FM1MonsterAIBattleState::TargetSearchRadius' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIBattleState, TargetSearchTimeMin) == 0x000008, "Member 'FM1MonsterAIBattleState::TargetSearchTimeMin' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIBattleState, TargetSearchTimeMax) == 0x00000C, "Member 'FM1MonsterAIBattleState::TargetSearchTimeMax' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIBattleState, TargetSearchAngle) == 0x000010, "Member 'FM1MonsterAIBattleState::TargetSearchAngle' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIBattleState, TargetChangeRate) == 0x000014, "Member 'FM1MonsterAIBattleState::TargetChangeRate' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIBattleState, Relations) == 0x000018, "Member 'FM1MonsterAIBattleState::Relations' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIBattleState, QueryTag) == 0x00001C, "Member 'FM1MonsterAIBattleState::QueryTag' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIBattleState, TargetingPriority) == 0x000024, "Member 'FM1MonsterAIBattleState::TargetingPriority' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIBattleState, CheckTargetVisible) == 0x000028, "Member 'FM1MonsterAIBattleState::CheckTargetVisible' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIBattleState, TargetHoldRadius) == 0x00002C, "Member 'FM1MonsterAIBattleState::TargetHoldRadius' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIBattleState, PursuitRadius) == 0x000030, "Member 'FM1MonsterAIBattleState::PursuitRadius' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIBattleState, AllianceCallRadius) == 0x000034, "Member 'FM1MonsterAIBattleState::AllianceCallRadius' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIBattleState, AllianceBattleRadius) == 0x000038, "Member 'FM1MonsterAIBattleState::AllianceBattleRadius' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIBattleState, PatrolHitRadius) == 0x00003C, "Member 'FM1MonsterAIBattleState::PatrolHitRadius' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIBattleState, PatrolRadius) == 0x000040, "Member 'FM1MonsterAIBattleState::PatrolRadius' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIBattleState, UseCoverUpInBattle) == 0x000044, "Member 'FM1MonsterAIBattleState::UseCoverUpInBattle' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIBattleState, WaitTimeOnCoverUp) == 0x000048, "Member 'FM1MonsterAIBattleState::WaitTimeOnCoverUp' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIBattleState, UseHomeLocationWithTargetSearch) == 0x00004C, "Member 'FM1MonsterAIBattleState::UseHomeLocationWithTargetSearch' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIBattleState, BattleRangeList) == 0x000050, "Member 'FM1MonsterAIBattleState::BattleRangeList' has a wrong offset!");

// ScriptStruct M1Data.M1MonsterAIMission
// 0x0018 (0x0018 - 0x0000)
struct FM1MonsterAIMission final
{
public:
	float                                         TargetObjectSearchRadius;                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetObjectApproachRadius;                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 MissionRangeList;                                  // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterAIMission) == 0x000008, "Wrong alignment on FM1MonsterAIMission");
static_assert(sizeof(FM1MonsterAIMission) == 0x000018, "Wrong size on FM1MonsterAIMission");
static_assert(offsetof(FM1MonsterAIMission, TargetObjectSearchRadius) == 0x000000, "Member 'FM1MonsterAIMission::TargetObjectSearchRadius' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIMission, TargetObjectApproachRadius) == 0x000004, "Member 'FM1MonsterAIMission::TargetObjectApproachRadius' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIMission, MissionRangeList) == 0x000008, "Member 'FM1MonsterAIMission::MissionRangeList' has a wrong offset!");

// ScriptStruct M1Data.M1MonsterAIData
// 0x01B8 (0x01C0 - 0x0008)
struct FM1MonsterAIData : public FTableRowBase
{
public:
	class FString                                 StringId;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BTPath;                                            // 0x0018(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1MonsterAISubBehaviorTree            SubBT;                                             // 0x0038(0x0028)(Edit, NativeAccessSpecifierPublic)
	EM1MonsterAIPattern                           MonsterPattern;                                    // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TargetSearchEnable;                                // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x2];                                       // 0x0062(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SightRadius;                                       // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1AITargetingType                            TargetingType;                                     // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AfterAttackDelay;                                  // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllianceCallEnable;                                // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllianceBattleEnable;                              // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1MonsterAIBattleState                NonBattle;                                         // 0x0078(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FM1MonsterAIBattleState                Battle;                                            // 0x00D8(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FM1MonsterAIBattleState                BattleEnd;                                         // 0x0138(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FM1MonsterAIMission                    Mission;                                           // 0x0198(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FM1MonsterAIOverride                   Override;                                          // 0x01B0(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MonsterAIData) == 0x000008, "Wrong alignment on FM1MonsterAIData");
static_assert(sizeof(FM1MonsterAIData) == 0x0001C0, "Wrong size on FM1MonsterAIData");
static_assert(offsetof(FM1MonsterAIData, StringId) == 0x000008, "Member 'FM1MonsterAIData::StringId' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIData, BTPath) == 0x000018, "Member 'FM1MonsterAIData::BTPath' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIData, SubBT) == 0x000038, "Member 'FM1MonsterAIData::SubBT' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIData, MonsterPattern) == 0x000060, "Member 'FM1MonsterAIData::MonsterPattern' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIData, TargetSearchEnable) == 0x000061, "Member 'FM1MonsterAIData::TargetSearchEnable' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIData, SightRadius) == 0x000064, "Member 'FM1MonsterAIData::SightRadius' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIData, TargetingType) == 0x000068, "Member 'FM1MonsterAIData::TargetingType' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIData, AfterAttackDelay) == 0x00006C, "Member 'FM1MonsterAIData::AfterAttackDelay' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIData, AllianceCallEnable) == 0x000070, "Member 'FM1MonsterAIData::AllianceCallEnable' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIData, AllianceBattleEnable) == 0x000071, "Member 'FM1MonsterAIData::AllianceBattleEnable' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIData, NonBattle) == 0x000078, "Member 'FM1MonsterAIData::NonBattle' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIData, Battle) == 0x0000D8, "Member 'FM1MonsterAIData::Battle' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIData, BattleEnd) == 0x000138, "Member 'FM1MonsterAIData::BattleEnd' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIData, Mission) == 0x000198, "Member 'FM1MonsterAIData::Mission' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIData, Override) == 0x0001B0, "Member 'FM1MonsterAIData::Override' has a wrong offset!");

// ScriptStruct M1Data.M1WearingSimpleInfo
// 0x0038 (0x0038 - 0x0000)
struct FM1WearingSimpleInfo final
{
public:
	int32                                         SocketIndex;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         EquipmentUid;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          EquipmentTid;                                      // 0x0010(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1SkinSimpleInfo                      Customize;                                         // 0x0018(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WearingSimpleInfo) == 0x000008, "Wrong alignment on FM1WearingSimpleInfo");
static_assert(sizeof(FM1WearingSimpleInfo) == 0x000038, "Wrong size on FM1WearingSimpleInfo");
static_assert(offsetof(FM1WearingSimpleInfo, SocketIndex) == 0x000000, "Member 'FM1WearingSimpleInfo::SocketIndex' has a wrong offset!");
static_assert(offsetof(FM1WearingSimpleInfo, EquipmentUid) == 0x000008, "Member 'FM1WearingSimpleInfo::EquipmentUid' has a wrong offset!");
static_assert(offsetof(FM1WearingSimpleInfo, EquipmentTid) == 0x000010, "Member 'FM1WearingSimpleInfo::EquipmentTid' has a wrong offset!");
static_assert(offsetof(FM1WearingSimpleInfo, Customize) == 0x000018, "Member 'FM1WearingSimpleInfo::Customize' has a wrong offset!");

// ScriptStruct M1Data.M1RegionLatency
// 0x0018 (0x0018 - 0x0000)
struct FM1RegionLatency final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Latency;                                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RegionLatency) == 0x000008, "Wrong alignment on FM1RegionLatency");
static_assert(sizeof(FM1RegionLatency) == 0x000018, "Wrong size on FM1RegionLatency");
static_assert(offsetof(FM1RegionLatency, Name) == 0x000000, "Member 'FM1RegionLatency::Name' has a wrong offset!");
static_assert(offsetof(FM1RegionLatency, Latency) == 0x000010, "Member 'FM1RegionLatency::Latency' has a wrong offset!");

// ScriptStruct M1Data.M1RegionLatencyInfosMs
// 0x0010 (0x0010 - 0x0000)
struct FM1RegionLatencyInfosMs final
{
public:
	TArray<struct FM1RegionLatency>               Infos;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RegionLatencyInfosMs) == 0x000008, "Wrong alignment on FM1RegionLatencyInfosMs");
static_assert(sizeof(FM1RegionLatencyInfosMs) == 0x000010, "Wrong size on FM1RegionLatencyInfosMs");
static_assert(offsetof(FM1RegionLatencyInfosMs, Infos) == 0x000000, "Member 'FM1RegionLatencyInfosMs::Infos' has a wrong offset!");

// ScriptStruct M1Data.M1AuidWithLatencyInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1AuidWithLatencyInfo final
{
public:
	TArray<int64>                                 AccountUids;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1RegionLatencyInfosMs                LatencyInfo;                                       // 0x0010(0x0010)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AuidWithLatencyInfo) == 0x000008, "Wrong alignment on FM1AuidWithLatencyInfo");
static_assert(sizeof(FM1AuidWithLatencyInfo) == 0x000020, "Wrong size on FM1AuidWithLatencyInfo");
static_assert(offsetof(FM1AuidWithLatencyInfo, AccountUids) == 0x000000, "Member 'FM1AuidWithLatencyInfo::AccountUids' has a wrong offset!");
static_assert(offsetof(FM1AuidWithLatencyInfo, LatencyInfo) == 0x000010, "Member 'FM1AuidWithLatencyInfo::LatencyInfo' has a wrong offset!");

// ScriptStruct M1Data.M1SetMatchingInfo
// 0x0028 (0x0028 - 0x0000)
struct FM1SetMatchingInfo final
{
public:
	TArray<int64>                                 AccountUids;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsPrivateMatching;                                 // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1AuidWithLatencyInfo>         LatencyInfos;                                      // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SetMatchingInfo) == 0x000008, "Wrong alignment on FM1SetMatchingInfo");
static_assert(sizeof(FM1SetMatchingInfo) == 0x000028, "Wrong size on FM1SetMatchingInfo");
static_assert(offsetof(FM1SetMatchingInfo, AccountUids) == 0x000000, "Member 'FM1SetMatchingInfo::AccountUids' has a wrong offset!");
static_assert(offsetof(FM1SetMatchingInfo, IsPrivateMatching) == 0x000010, "Member 'FM1SetMatchingInfo::IsPrivateMatching' has a wrong offset!");
static_assert(offsetof(FM1SetMatchingInfo, LatencyInfos) == 0x000018, "Member 'FM1SetMatchingInfo::LatencyInfos' has a wrong offset!");

// ScriptStruct M1Data.M1CharacterSimpleInfo
// 0x0028 (0x0028 - 0x0000)
struct FM1CharacterSimpleInfo final
{
public:
	int64                                         Uid;                                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          CharacterTid;                                      // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLevel;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Favorites;                                         // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1SkinSimpleInfo>              Customizes;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CharacterSimpleInfo) == 0x000008, "Wrong alignment on FM1CharacterSimpleInfo");
static_assert(sizeof(FM1CharacterSimpleInfo) == 0x000028, "Wrong size on FM1CharacterSimpleInfo");
static_assert(offsetof(FM1CharacterSimpleInfo, Uid) == 0x000000, "Member 'FM1CharacterSimpleInfo::Uid' has a wrong offset!");
static_assert(offsetof(FM1CharacterSimpleInfo, CharacterTid) == 0x000008, "Member 'FM1CharacterSimpleInfo::CharacterTid' has a wrong offset!");
static_assert(offsetof(FM1CharacterSimpleInfo, Level) == 0x00000C, "Member 'FM1CharacterSimpleInfo::Level' has a wrong offset!");
static_assert(offsetof(FM1CharacterSimpleInfo, MaxLevel) == 0x000010, "Member 'FM1CharacterSimpleInfo::MaxLevel' has a wrong offset!");
static_assert(offsetof(FM1CharacterSimpleInfo, Favorites) == 0x000014, "Member 'FM1CharacterSimpleInfo::Favorites' has a wrong offset!");
static_assert(offsetof(FM1CharacterSimpleInfo, Customizes) == 0x000018, "Member 'FM1CharacterSimpleInfo::Customizes' has a wrong offset!");

// ScriptStruct M1Data.M1MonsterTagData
// 0x0018 (0x0020 - 0x0008)
struct FM1MonsterTagData final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          TemplateId;                                        // 0x0010(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GroupId;                                           // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1EMonsterTagRateType                        RateType;                                          // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MonsterTagData) == 0x000008, "Wrong alignment on FM1MonsterTagData");
static_assert(sizeof(FM1MonsterTagData) == 0x000020, "Wrong size on FM1MonsterTagData");
static_assert(offsetof(FM1MonsterTagData, Name) == 0x000008, "Member 'FM1MonsterTagData::Name' has a wrong offset!");
static_assert(offsetof(FM1MonsterTagData, TemplateId) == 0x000010, "Member 'FM1MonsterTagData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1MonsterTagData, GroupId) == 0x000014, "Member 'FM1MonsterTagData::GroupId' has a wrong offset!");
static_assert(offsetof(FM1MonsterTagData, RateType) == 0x00001C, "Member 'FM1MonsterTagData::RateType' has a wrong offset!");

// ScriptStruct M1Data.M1AccountSimpleInfo
// 0x00B8 (0x00B8 - 0x0000)
struct FM1AccountSimpleInfo final
{
public:
	int64                                         Uid;                                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LoginPlatformId;                                   // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         LoginPlatformUid;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         LoginPlatformType;                                 // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1WearingSimpleInfo>           WearingList;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int64                                         CombatPower;                                       // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              CreatedTime;                                       // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         PlayTime;                                          // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1CharacterSimpleInfo>         CharacterList;                                     // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int64                                         SelectedCharacter;                                 // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MasteryRankLevel;                                  // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MasteryRankExp;                                    // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Region;                                            // 0x0088(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          LastMapTemplateId;                                 // 0x0098(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          LastBattleZoneId;                                  // 0x009C(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastFieldDifficulty;                               // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1TemplateId>                  CustomizeList;                                     // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AccountSimpleInfo) == 0x000008, "Wrong alignment on FM1AccountSimpleInfo");
static_assert(sizeof(FM1AccountSimpleInfo) == 0x0000B8, "Wrong size on FM1AccountSimpleInfo");
static_assert(offsetof(FM1AccountSimpleInfo, Uid) == 0x000000, "Member 'FM1AccountSimpleInfo::Uid' has a wrong offset!");
static_assert(offsetof(FM1AccountSimpleInfo, Name) == 0x000008, "Member 'FM1AccountSimpleInfo::Name' has a wrong offset!");
static_assert(offsetof(FM1AccountSimpleInfo, LoginPlatformId) == 0x000018, "Member 'FM1AccountSimpleInfo::LoginPlatformId' has a wrong offset!");
static_assert(offsetof(FM1AccountSimpleInfo, LoginPlatformUid) == 0x000028, "Member 'FM1AccountSimpleInfo::LoginPlatformUid' has a wrong offset!");
static_assert(offsetof(FM1AccountSimpleInfo, LoginPlatformType) == 0x000030, "Member 'FM1AccountSimpleInfo::LoginPlatformType' has a wrong offset!");
static_assert(offsetof(FM1AccountSimpleInfo, WearingList) == 0x000038, "Member 'FM1AccountSimpleInfo::WearingList' has a wrong offset!");
static_assert(offsetof(FM1AccountSimpleInfo, CombatPower) == 0x000048, "Member 'FM1AccountSimpleInfo::CombatPower' has a wrong offset!");
static_assert(offsetof(FM1AccountSimpleInfo, CreatedTime) == 0x000050, "Member 'FM1AccountSimpleInfo::CreatedTime' has a wrong offset!");
static_assert(offsetof(FM1AccountSimpleInfo, PlayTime) == 0x000058, "Member 'FM1AccountSimpleInfo::PlayTime' has a wrong offset!");
static_assert(offsetof(FM1AccountSimpleInfo, CharacterList) == 0x000060, "Member 'FM1AccountSimpleInfo::CharacterList' has a wrong offset!");
static_assert(offsetof(FM1AccountSimpleInfo, SelectedCharacter) == 0x000070, "Member 'FM1AccountSimpleInfo::SelectedCharacter' has a wrong offset!");
static_assert(offsetof(FM1AccountSimpleInfo, MasteryRankLevel) == 0x000078, "Member 'FM1AccountSimpleInfo::MasteryRankLevel' has a wrong offset!");
static_assert(offsetof(FM1AccountSimpleInfo, MasteryRankExp) == 0x000080, "Member 'FM1AccountSimpleInfo::MasteryRankExp' has a wrong offset!");
static_assert(offsetof(FM1AccountSimpleInfo, Region) == 0x000088, "Member 'FM1AccountSimpleInfo::Region' has a wrong offset!");
static_assert(offsetof(FM1AccountSimpleInfo, LastMapTemplateId) == 0x000098, "Member 'FM1AccountSimpleInfo::LastMapTemplateId' has a wrong offset!");
static_assert(offsetof(FM1AccountSimpleInfo, LastBattleZoneId) == 0x00009C, "Member 'FM1AccountSimpleInfo::LastBattleZoneId' has a wrong offset!");
static_assert(offsetof(FM1AccountSimpleInfo, LastFieldDifficulty) == 0x0000A0, "Member 'FM1AccountSimpleInfo::LastFieldDifficulty' has a wrong offset!");
static_assert(offsetof(FM1AccountSimpleInfo, CustomizeList) == 0x0000A8, "Member 'FM1AccountSimpleInfo::CustomizeList' has a wrong offset!");

// ScriptStruct M1Data.M1AuthAndLoadCharactersRes
// 0x00B8 (0x00B8 - 0x0000)
struct FM1AuthAndLoadCharactersRes final
{
public:
	struct FM1AccountSimpleInfo                   AccountSimpleInfo;                                 // 0x0000(0x00B8)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AuthAndLoadCharactersRes) == 0x000008, "Wrong alignment on FM1AuthAndLoadCharactersRes");
static_assert(sizeof(FM1AuthAndLoadCharactersRes) == 0x0000B8, "Wrong size on FM1AuthAndLoadCharactersRes");
static_assert(offsetof(FM1AuthAndLoadCharactersRes, AccountSimpleInfo) == 0x000000, "Member 'FM1AuthAndLoadCharactersRes::AccountSimpleInfo' has a wrong offset!");

// ScriptStruct M1Data.M1QuestStartPoint
// 0x0018 (0x0018 - 0x0000)
struct FM1QuestStartPoint final
{
public:
	EM1QuestStartPointType                        Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Params;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1QuestStartPoint) == 0x000008, "Wrong alignment on FM1QuestStartPoint");
static_assert(sizeof(FM1QuestStartPoint) == 0x000018, "Wrong size on FM1QuestStartPoint");
static_assert(offsetof(FM1QuestStartPoint, Type) == 0x000000, "Member 'FM1QuestStartPoint::Type' has a wrong offset!");
static_assert(offsetof(FM1QuestStartPoint, Params) == 0x000008, "Member 'FM1QuestStartPoint::Params' has a wrong offset!");

// ScriptStruct M1Data.M1CurrencyPair
// 0x0008 (0x0008 - 0x0000)
struct FM1CurrencyPair final
{
public:
	EM1CurrencyType                               Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CurrencyPair) == 0x000004, "Wrong alignment on FM1CurrencyPair");
static_assert(sizeof(FM1CurrencyPair) == 0x000008, "Wrong size on FM1CurrencyPair");
static_assert(offsetof(FM1CurrencyPair, Type) == 0x000000, "Member 'FM1CurrencyPair::Type' has a wrong offset!");
static_assert(offsetof(FM1CurrencyPair, Amount) == 0x000004, "Member 'FM1CurrencyPair::Amount' has a wrong offset!");

// ScriptStruct M1Data.M1QuestCompleteConditionGroupInfo
// 0x000C (0x000C - 0x0000)
struct FM1QuestCompleteConditionGroupInfo final
{
public:
	EM1QuestCompleteConditionGroupType            Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GroupStringId;                                     // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1QuestCompleteConditionGroupInfo) == 0x000004, "Wrong alignment on FM1QuestCompleteConditionGroupInfo");
static_assert(sizeof(FM1QuestCompleteConditionGroupInfo) == 0x00000C, "Wrong size on FM1QuestCompleteConditionGroupInfo");
static_assert(offsetof(FM1QuestCompleteConditionGroupInfo, Type) == 0x000000, "Member 'FM1QuestCompleteConditionGroupInfo::Type' has a wrong offset!");
static_assert(offsetof(FM1QuestCompleteConditionGroupInfo, GroupStringId) == 0x000004, "Member 'FM1QuestCompleteConditionGroupInfo::GroupStringId' has a wrong offset!");

// ScriptStruct M1Data.M1QuestDirection
// 0x0038 (0x0038 - 0x0000)
struct FM1QuestDirection final
{
public:
	EM1QuestDirectionType                         Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Params;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AssetPath;                                         // 0x0018(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1QuestDirection) == 0x000008, "Wrong alignment on FM1QuestDirection");
static_assert(sizeof(FM1QuestDirection) == 0x000038, "Wrong size on FM1QuestDirection");
static_assert(offsetof(FM1QuestDirection, Type) == 0x000000, "Member 'FM1QuestDirection::Type' has a wrong offset!");
static_assert(offsetof(FM1QuestDirection, Params) == 0x000008, "Member 'FM1QuestDirection::Params' has a wrong offset!");
static_assert(offsetof(FM1QuestDirection, AssetPath) == 0x000018, "Member 'FM1QuestDirection::AssetPath' has a wrong offset!");

// ScriptStruct M1Data.M1OpenField
// 0x0020 (0x0020 - 0x0000)
struct FM1OpenField final
{
public:
	struct FM1TemplateId                          MapTemplateId;                                     // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1MapSubDataStrId                     SubData;                                           // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1OpenField) == 0x000008, "Wrong alignment on FM1OpenField");
static_assert(sizeof(FM1OpenField) == 0x000020, "Wrong size on FM1OpenField");
static_assert(offsetof(FM1OpenField, MapTemplateId) == 0x000000, "Member 'FM1OpenField::MapTemplateId' has a wrong offset!");
static_assert(offsetof(FM1OpenField, SubData) == 0x000008, "Member 'FM1OpenField::SubData' has a wrong offset!");

// ScriptStruct M1Data.M1QuestRewardItem
// 0x0048 (0x0048 - 0x0000)
struct FM1QuestRewardItem final
{
public:
	struct FM1ItemDataBox                         Item;                                              // 0x0000(0x0038)(Edit, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMainItem;                                        // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowAsGroupQuestReward;                            // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1QuestRewardItem) == 0x000008, "Wrong alignment on FM1QuestRewardItem");
static_assert(sizeof(FM1QuestRewardItem) == 0x000048, "Wrong size on FM1QuestRewardItem");
static_assert(offsetof(FM1QuestRewardItem, Item) == 0x000000, "Member 'FM1QuestRewardItem::Item' has a wrong offset!");
static_assert(offsetof(FM1QuestRewardItem, Amount) == 0x000038, "Member 'FM1QuestRewardItem::Amount' has a wrong offset!");
static_assert(offsetof(FM1QuestRewardItem, Level) == 0x00003C, "Member 'FM1QuestRewardItem::Level' has a wrong offset!");
static_assert(offsetof(FM1QuestRewardItem, IsMainItem) == 0x000040, "Member 'FM1QuestRewardItem::IsMainItem' has a wrong offset!");
static_assert(offsetof(FM1QuestRewardItem, ShowAsGroupQuestReward) == 0x000041, "Member 'FM1QuestRewardItem::ShowAsGroupQuestReward' has a wrong offset!");

// ScriptStruct M1Data.M1QuestData
// 0x00E0 (0x00E8 - 0x0008)
struct FM1QuestData : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringIdName;                                      // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1QuestType                                  Type;                                              // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1QuestStartPoint>             StartPoints;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1QuestStartCondition>         StartConditions;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1QuestCompleteConditionGroupInfo     CompleteConditionGroupInfo;                        // 0x0038(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1CompleteCondition>           CompleteConditions;                                // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1QuestDirection>              QuestDirections;                                   // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1OpenField                           OpenField;                                         // 0x0068(0x0020)(Edit, NativeAccessSpecifierPublic)
	int64                                         RewardCharacterExp;                                // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         RewardMasteryExp;                                  // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         RewardSeasonExp;                                   // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1CurrencyPair>                RewardCurrencies;                                  // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1QuestRewardItem>             RewardItems;                                       // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1PlayerDataLink>              RequiredCharacterIds;                              // 0x00C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 OutgoingMailId;                                    // 0x00D0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubTrackerPriority;                                // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressId;                                        // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1QuestData) == 0x000008, "Wrong alignment on FM1QuestData");
static_assert(sizeof(FM1QuestData) == 0x0000E8, "Wrong size on FM1QuestData");
static_assert(offsetof(FM1QuestData, TemplateId) == 0x000008, "Member 'FM1QuestData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1QuestData, StringIdName) == 0x00000C, "Member 'FM1QuestData::StringIdName' has a wrong offset!");
static_assert(offsetof(FM1QuestData, Type) == 0x000014, "Member 'FM1QuestData::Type' has a wrong offset!");
static_assert(offsetof(FM1QuestData, StartPoints) == 0x000018, "Member 'FM1QuestData::StartPoints' has a wrong offset!");
static_assert(offsetof(FM1QuestData, StartConditions) == 0x000028, "Member 'FM1QuestData::StartConditions' has a wrong offset!");
static_assert(offsetof(FM1QuestData, CompleteConditionGroupInfo) == 0x000038, "Member 'FM1QuestData::CompleteConditionGroupInfo' has a wrong offset!");
static_assert(offsetof(FM1QuestData, CompleteConditions) == 0x000048, "Member 'FM1QuestData::CompleteConditions' has a wrong offset!");
static_assert(offsetof(FM1QuestData, QuestDirections) == 0x000058, "Member 'FM1QuestData::QuestDirections' has a wrong offset!");
static_assert(offsetof(FM1QuestData, OpenField) == 0x000068, "Member 'FM1QuestData::OpenField' has a wrong offset!");
static_assert(offsetof(FM1QuestData, RewardCharacterExp) == 0x000088, "Member 'FM1QuestData::RewardCharacterExp' has a wrong offset!");
static_assert(offsetof(FM1QuestData, RewardMasteryExp) == 0x000090, "Member 'FM1QuestData::RewardMasteryExp' has a wrong offset!");
static_assert(offsetof(FM1QuestData, RewardSeasonExp) == 0x000098, "Member 'FM1QuestData::RewardSeasonExp' has a wrong offset!");
static_assert(offsetof(FM1QuestData, RewardCurrencies) == 0x0000A0, "Member 'FM1QuestData::RewardCurrencies' has a wrong offset!");
static_assert(offsetof(FM1QuestData, RewardItems) == 0x0000B0, "Member 'FM1QuestData::RewardItems' has a wrong offset!");
static_assert(offsetof(FM1QuestData, RequiredCharacterIds) == 0x0000C0, "Member 'FM1QuestData::RequiredCharacterIds' has a wrong offset!");
static_assert(offsetof(FM1QuestData, OutgoingMailId) == 0x0000D0, "Member 'FM1QuestData::OutgoingMailId' has a wrong offset!");
static_assert(offsetof(FM1QuestData, SubTrackerPriority) == 0x0000E0, "Member 'FM1QuestData::SubTrackerPriority' has a wrong offset!");
static_assert(offsetof(FM1QuestData, ProgressId) == 0x0000E4, "Member 'FM1QuestData::ProgressId' has a wrong offset!");

// ScriptStruct M1Data.M1CrashInfoTransData
// 0x0020 (0x0020 - 0x0000)
struct FM1CrashInfoTransData final
{
public:
	class FString                                 DumpPath;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LogPath;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CrashInfoTransData) == 0x000008, "Wrong alignment on FM1CrashInfoTransData");
static_assert(sizeof(FM1CrashInfoTransData) == 0x000020, "Wrong size on FM1CrashInfoTransData");
static_assert(offsetof(FM1CrashInfoTransData, DumpPath) == 0x000000, "Member 'FM1CrashInfoTransData::DumpPath' has a wrong offset!");
static_assert(offsetof(FM1CrashInfoTransData, LogPath) == 0x000010, "Member 'FM1CrashInfoTransData::LogPath' has a wrong offset!");

// ScriptStruct M1Data.M1GameServerMoveData
// 0x0048 (0x0048 - 0x0000)
struct FM1GameServerMoveData final
{
public:
	int32                                         MoveServerIndex;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MoveServerVersion;                                 // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MoveServerAddr;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         MovePort;                                          // 0x0028(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         DediOid;                                           // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SessionToken;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GameServerMoveData) == 0x000008, "Wrong alignment on FM1GameServerMoveData");
static_assert(sizeof(FM1GameServerMoveData) == 0x000048, "Wrong size on FM1GameServerMoveData");
static_assert(offsetof(FM1GameServerMoveData, MoveServerIndex) == 0x000000, "Member 'FM1GameServerMoveData::MoveServerIndex' has a wrong offset!");
static_assert(offsetof(FM1GameServerMoveData, MoveServerVersion) == 0x000008, "Member 'FM1GameServerMoveData::MoveServerVersion' has a wrong offset!");
static_assert(offsetof(FM1GameServerMoveData, MoveServerAddr) == 0x000018, "Member 'FM1GameServerMoveData::MoveServerAddr' has a wrong offset!");
static_assert(offsetof(FM1GameServerMoveData, MovePort) == 0x000028, "Member 'FM1GameServerMoveData::MovePort' has a wrong offset!");
static_assert(offsetof(FM1GameServerMoveData, DediOid) == 0x000030, "Member 'FM1GameServerMoveData::DediOid' has a wrong offset!");
static_assert(offsetof(FM1GameServerMoveData, SessionToken) == 0x000038, "Member 'FM1GameServerMoveData::SessionToken' has a wrong offset!");

// ScriptStruct M1Data.M1BunchItemDetailData
// 0x0040 (0x0040 - 0x0000)
struct FM1BunchItemDetailData final
{
public:
	struct FM1ItemDataBox                         Item;                                              // 0x0000(0x0038)(Edit, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PriceAmount;                                       // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BunchItemDetailData) == 0x000008, "Wrong alignment on FM1BunchItemDetailData");
static_assert(sizeof(FM1BunchItemDetailData) == 0x000040, "Wrong size on FM1BunchItemDetailData");
static_assert(offsetof(FM1BunchItemDetailData, Item) == 0x000000, "Member 'FM1BunchItemDetailData::Item' has a wrong offset!");
static_assert(offsetof(FM1BunchItemDetailData, Amount) == 0x000038, "Member 'FM1BunchItemDetailData::Amount' has a wrong offset!");
static_assert(offsetof(FM1BunchItemDetailData, PriceAmount) == 0x00003C, "Member 'FM1BunchItemDetailData::PriceAmount' has a wrong offset!");

// ScriptStruct M1Data.M1BlockUser
// 0x0030 (0x0030 - 0x0000)
struct FM1BlockUser final
{
public:
	class FString                                 AccountName;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlatformId;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         PlatformUid;                                       // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         PlatformType;                                      // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1BlockUser) == 0x000008, "Wrong alignment on FM1BlockUser");
static_assert(sizeof(FM1BlockUser) == 0x000030, "Wrong size on FM1BlockUser");
static_assert(offsetof(FM1BlockUser, AccountName) == 0x000000, "Member 'FM1BlockUser::AccountName' has a wrong offset!");
static_assert(offsetof(FM1BlockUser, PlatformId) == 0x000010, "Member 'FM1BlockUser::PlatformId' has a wrong offset!");
static_assert(offsetof(FM1BlockUser, PlatformUid) == 0x000020, "Member 'FM1BlockUser::PlatformUid' has a wrong offset!");
static_assert(offsetof(FM1BlockUser, PlatformType) == 0x000028, "Member 'FM1BlockUser::PlatformType' has a wrong offset!");

// ScriptStruct M1Data.M1BlockList
// 0x0018 (0x0018 - 0x0000)
struct FM1BlockList final
{
public:
	EM1BlockUpdateType                            UpdateType;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1BlockUser>                   BlockUsers;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BlockList) == 0x000008, "Wrong alignment on FM1BlockList");
static_assert(sizeof(FM1BlockList) == 0x000018, "Wrong size on FM1BlockList");
static_assert(offsetof(FM1BlockList, UpdateType) == 0x000000, "Member 'FM1BlockList::UpdateType' has a wrong offset!");
static_assert(offsetof(FM1BlockList, BlockUsers) == 0x000008, "Member 'FM1BlockList::BlockUsers' has a wrong offset!");

// ScriptStruct M1Data.M1EnchantRequiredCurrencyData
// 0x0008 (0x0008 - 0x0000)
struct FM1EnchantRequiredCurrencyData final
{
public:
	EM1CurrencyType                               Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EnchantRequiredCurrencyData) == 0x000004, "Wrong alignment on FM1EnchantRequiredCurrencyData");
static_assert(sizeof(FM1EnchantRequiredCurrencyData) == 0x000008, "Wrong size on FM1EnchantRequiredCurrencyData");
static_assert(offsetof(FM1EnchantRequiredCurrencyData, Type) == 0x000000, "Member 'FM1EnchantRequiredCurrencyData::Type' has a wrong offset!");
static_assert(offsetof(FM1EnchantRequiredCurrencyData, Value) == 0x000004, "Member 'FM1EnchantRequiredCurrencyData::Value' has a wrong offset!");

// ScriptStruct M1Data.M1FriendRequest
// 0x0038 (0x0038 - 0x0000)
struct FM1FriendRequest final
{
public:
	class FString                                 AccountName;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              RequestTime;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RequesterPlatformId;                               // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         RequestPlatformUid;                                // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         RequestPlayformType;                               // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1FriendRequest) == 0x000008, "Wrong alignment on FM1FriendRequest");
static_assert(sizeof(FM1FriendRequest) == 0x000038, "Wrong size on FM1FriendRequest");
static_assert(offsetof(FM1FriendRequest, AccountName) == 0x000000, "Member 'FM1FriendRequest::AccountName' has a wrong offset!");
static_assert(offsetof(FM1FriendRequest, RequestTime) == 0x000010, "Member 'FM1FriendRequest::RequestTime' has a wrong offset!");
static_assert(offsetof(FM1FriendRequest, RequesterPlatformId) == 0x000018, "Member 'FM1FriendRequest::RequesterPlatformId' has a wrong offset!");
static_assert(offsetof(FM1FriendRequest, RequestPlatformUid) == 0x000028, "Member 'FM1FriendRequest::RequestPlatformUid' has a wrong offset!");
static_assert(offsetof(FM1FriendRequest, RequestPlayformType) == 0x000030, "Member 'FM1FriendRequest::RequestPlayformType' has a wrong offset!");

// ScriptStruct M1Data.M1FriendRequestList
// 0x0018 (0x0018 - 0x0000)
struct FM1FriendRequestList final
{
public:
	EM1FriendUpdateType                           UpdateType;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1FriendRequest>               Value;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FriendRequestList) == 0x000008, "Wrong alignment on FM1FriendRequestList");
static_assert(sizeof(FM1FriendRequestList) == 0x000018, "Wrong size on FM1FriendRequestList");
static_assert(offsetof(FM1FriendRequestList, UpdateType) == 0x000000, "Member 'FM1FriendRequestList::UpdateType' has a wrong offset!");
static_assert(offsetof(FM1FriendRequestList, Value) == 0x000008, "Member 'FM1FriendRequestList::Value' has a wrong offset!");

// ScriptStruct M1Data.M1ProductMiscData
// 0x0008 (0x0010 - 0x0008)
struct FM1ProductMiscData final : public FTableRowBase
{
public:
	int32                                         ImminentDayDeadline;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ProductMiscData) == 0x000008, "Wrong alignment on FM1ProductMiscData");
static_assert(sizeof(FM1ProductMiscData) == 0x000010, "Wrong size on FM1ProductMiscData");
static_assert(offsetof(FM1ProductMiscData, ImminentDayDeadline) == 0x000008, "Member 'FM1ProductMiscData::ImminentDayDeadline' has a wrong offset!");

// ScriptStruct M1Data.M1RemoveAllByPlatformBlockParam
// 0x0010 (0x0010 - 0x0000)
struct FM1RemoveAllByPlatformBlockParam final
{
public:
	TArray<class FString>                         AccountNames;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RemoveAllByPlatformBlockParam) == 0x000008, "Wrong alignment on FM1RemoveAllByPlatformBlockParam");
static_assert(sizeof(FM1RemoveAllByPlatformBlockParam) == 0x000010, "Wrong size on FM1RemoveAllByPlatformBlockParam");
static_assert(offsetof(FM1RemoveAllByPlatformBlockParam, AccountNames) == 0x000000, "Member 'FM1RemoveAllByPlatformBlockParam::AccountNames' has a wrong offset!");

// ScriptStruct M1Data.M1DummyData
// 0x0001 (0x0001 - 0x0000)
struct FM1DummyData final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1DummyData) == 0x000001, "Wrong alignment on FM1DummyData");
static_assert(sizeof(FM1DummyData) == 0x000001, "Wrong size on FM1DummyData");

// ScriptStruct M1Data.M1PartyJoinLobbyForCertRes
// 0x00A8 (0x00A8 - 0x0000)
struct FM1PartyJoinLobbyForCertRes final
{
public:
	EM1PartyContentsType                          ContentsType;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1PartyErrorCode                             ErrorCode;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1DedicatedServerInfo                 SelectedDedicatedServerInfo;                       // 0x0008(0x00A0)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PartyJoinLobbyForCertRes) == 0x000008, "Wrong alignment on FM1PartyJoinLobbyForCertRes");
static_assert(sizeof(FM1PartyJoinLobbyForCertRes) == 0x0000A8, "Wrong size on FM1PartyJoinLobbyForCertRes");
static_assert(offsetof(FM1PartyJoinLobbyForCertRes, ContentsType) == 0x000000, "Member 'FM1PartyJoinLobbyForCertRes::ContentsType' has a wrong offset!");
static_assert(offsetof(FM1PartyJoinLobbyForCertRes, ErrorCode) == 0x000004, "Member 'FM1PartyJoinLobbyForCertRes::ErrorCode' has a wrong offset!");
static_assert(offsetof(FM1PartyJoinLobbyForCertRes, SelectedDedicatedServerInfo) == 0x000008, "Member 'FM1PartyJoinLobbyForCertRes::SelectedDedicatedServerInfo' has a wrong offset!");

// ScriptStruct M1Data.M1WareHouseIncrementCost
// 0x000C (0x000C - 0x0000)
struct FM1WareHouseIncrementCost final
{
public:
	int32                                         IncrementGrade;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IncrementSlotCount;                                // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WareHouseIncrementCost) == 0x000004, "Wrong alignment on FM1WareHouseIncrementCost");
static_assert(sizeof(FM1WareHouseIncrementCost) == 0x00000C, "Wrong size on FM1WareHouseIncrementCost");
static_assert(offsetof(FM1WareHouseIncrementCost, IncrementGrade) == 0x000000, "Member 'FM1WareHouseIncrementCost::IncrementGrade' has a wrong offset!");
static_assert(offsetof(FM1WareHouseIncrementCost, IncrementSlotCount) == 0x000004, "Member 'FM1WareHouseIncrementCost::IncrementSlotCount' has a wrong offset!");
static_assert(offsetof(FM1WareHouseIncrementCost, Cost) == 0x000008, "Member 'FM1WareHouseIncrementCost::Cost' has a wrong offset!");

// ScriptStruct M1Data.M1AnnouncementNoti
// 0x0018 (0x0018 - 0x0000)
struct FM1AnnouncementNoti final
{
public:
	EM1AnnouncementType                           AnnouncementType;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NoticeContext;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AnnouncementNoti) == 0x000008, "Wrong alignment on FM1AnnouncementNoti");
static_assert(sizeof(FM1AnnouncementNoti) == 0x000018, "Wrong size on FM1AnnouncementNoti");
static_assert(offsetof(FM1AnnouncementNoti, AnnouncementType) == 0x000000, "Member 'FM1AnnouncementNoti::AnnouncementType' has a wrong offset!");
static_assert(offsetof(FM1AnnouncementNoti, NoticeContext) == 0x000008, "Member 'FM1AnnouncementNoti::NoticeContext' has a wrong offset!");

// ScriptStruct M1Data.M1RPC_SUB_HEADER
// 0x0004 (0x0004 - 0x0000)
struct FM1RPC_SUB_HEADER final
{
public:
	int16                                         SourceServer;                                      // 0x0000(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         TargetServer;                                      // 0x0002(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RPC_SUB_HEADER) == 0x000002, "Wrong alignment on FM1RPC_SUB_HEADER");
static_assert(sizeof(FM1RPC_SUB_HEADER) == 0x000004, "Wrong size on FM1RPC_SUB_HEADER");
static_assert(offsetof(FM1RPC_SUB_HEADER, SourceServer) == 0x000000, "Member 'FM1RPC_SUB_HEADER::SourceServer' has a wrong offset!");
static_assert(offsetof(FM1RPC_SUB_HEADER, TargetServer) == 0x000002, "Member 'FM1RPC_SUB_HEADER::TargetServer' has a wrong offset!");

// ScriptStruct M1Data.M1RPC_HEADER
// 0x0008 (0x0008 - 0x0000)
struct FM1RPC_HEADER final
{
public:
	int32                                         RequestID;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         ProcedureId;                                       // 0x0004(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RPC_HEADER) == 0x000004, "Wrong alignment on FM1RPC_HEADER");
static_assert(sizeof(FM1RPC_HEADER) == 0x000008, "Wrong size on FM1RPC_HEADER");
static_assert(offsetof(FM1RPC_HEADER, RequestID) == 0x000000, "Member 'FM1RPC_HEADER::RequestID' has a wrong offset!");
static_assert(offsetof(FM1RPC_HEADER, ProcedureId) == 0x000004, "Member 'FM1RPC_HEADER::ProcedureId' has a wrong offset!");

// ScriptStruct M1Data.M1ProductUIData
// 0x0060 (0x0060 - 0x0000)
struct FM1ProductUIData final
{
public:
	struct FSoftObjectPath                        IconPath;                                          // 0x0000(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconBigPath;                                       // 0x0020(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DetailImagePath;                                   // 0x0040(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ProductUIData) == 0x000008, "Wrong alignment on FM1ProductUIData");
static_assert(sizeof(FM1ProductUIData) == 0x000060, "Wrong size on FM1ProductUIData");
static_assert(offsetof(FM1ProductUIData, IconPath) == 0x000000, "Member 'FM1ProductUIData::IconPath' has a wrong offset!");
static_assert(offsetof(FM1ProductUIData, IconBigPath) == 0x000020, "Member 'FM1ProductUIData::IconBigPath' has a wrong offset!");
static_assert(offsetof(FM1ProductUIData, DetailImagePath) == 0x000040, "Member 'FM1ProductUIData::DetailImagePath' has a wrong offset!");

// ScriptStruct M1Data.M1EE_ERROR
// 0x0018 (0x0018 - 0x0000)
struct FM1EE_ERROR final
{
public:
	int32                                         RequestID;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ErrorCode;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ErrorMessage;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EE_ERROR) == 0x000008, "Wrong alignment on FM1EE_ERROR");
static_assert(sizeof(FM1EE_ERROR) == 0x000018, "Wrong size on FM1EE_ERROR");
static_assert(offsetof(FM1EE_ERROR, RequestID) == 0x000000, "Member 'FM1EE_ERROR::RequestID' has a wrong offset!");
static_assert(offsetof(FM1EE_ERROR, ErrorCode) == 0x000004, "Member 'FM1EE_ERROR::ErrorCode' has a wrong offset!");
static_assert(offsetof(FM1EE_ERROR, ErrorMessage) == 0x000008, "Member 'FM1EE_ERROR::ErrorMessage' has a wrong offset!");

// ScriptStruct M1Data.M1EE_OK
// 0x0001 (0x0001 - 0x0000)
struct FM1EE_OK final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1EE_OK) == 0x000001, "Wrong alignment on FM1EE_OK");
static_assert(sizeof(FM1EE_OK) == 0x000001, "Wrong size on FM1EE_OK");

// ScriptStruct M1Data.M1MapGoalInfo
// 0x0030 (0x0030 - 0x0000)
struct FM1MapGoalInfo final
{
public:
	EM1MapGoalType                                GoalType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GoalId;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1MapSubDataStrId                     SubData;                                           // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MapGoalInfo) == 0x000008, "Wrong alignment on FM1MapGoalInfo");
static_assert(sizeof(FM1MapGoalInfo) == 0x000030, "Wrong size on FM1MapGoalInfo");
static_assert(offsetof(FM1MapGoalInfo, GoalType) == 0x000000, "Member 'FM1MapGoalInfo::GoalType' has a wrong offset!");
static_assert(offsetof(FM1MapGoalInfo, GoalId) == 0x000008, "Member 'FM1MapGoalInfo::GoalId' has a wrong offset!");
static_assert(offsetof(FM1MapGoalInfo, SubData) == 0x000018, "Member 'FM1MapGoalInfo::SubData' has a wrong offset!");

// ScriptStruct M1Data.M1AutomationTestOtherDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1AutomationTestOtherDataLink final : public FDataLink
{
};
static_assert(alignof(FM1AutomationTestOtherDataLink) == 0x000008, "Wrong alignment on FM1AutomationTestOtherDataLink");
static_assert(sizeof(FM1AutomationTestOtherDataLink) == 0x000030, "Wrong size on FM1AutomationTestOtherDataLink");

// ScriptStruct M1Data.M1AutomationTestCharacterDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1AutomationTestCharacterDataLink final : public FDataLink
{
};
static_assert(alignof(FM1AutomationTestCharacterDataLink) == 0x000008, "Wrong alignment on FM1AutomationTestCharacterDataLink");
static_assert(sizeof(FM1AutomationTestCharacterDataLink) == 0x000030, "Wrong size on FM1AutomationTestCharacterDataLink");

// ScriptStruct M1Data.M1AutomationTestNpcDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1AutomationTestNpcDataLink final : public FDataLink
{
};
static_assert(alignof(FM1AutomationTestNpcDataLink) == 0x000008, "Wrong alignment on FM1AutomationTestNpcDataLink");
static_assert(sizeof(FM1AutomationTestNpcDataLink) == 0x000030, "Wrong size on FM1AutomationTestNpcDataLink");

// ScriptStruct M1Data.M1AutomationTestStatData
// 0x0028 (0x0028 - 0x0000)
struct FM1AutomationTestStatData final
{
public:
	struct FM1AutomationTestNestData              Nest;                                              // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         MaxHp;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxMp;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1AutomationTestAttr                         MainAttr;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EM1AutomationTestAttr>                 SubAttrs;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AutomationTestStatData) == 0x000008, "Wrong alignment on FM1AutomationTestStatData");
static_assert(sizeof(FM1AutomationTestStatData) == 0x000028, "Wrong size on FM1AutomationTestStatData");
static_assert(offsetof(FM1AutomationTestStatData, Nest) == 0x000000, "Member 'FM1AutomationTestStatData::Nest' has a wrong offset!");
static_assert(offsetof(FM1AutomationTestStatData, MaxHp) == 0x000008, "Member 'FM1AutomationTestStatData::MaxHp' has a wrong offset!");
static_assert(offsetof(FM1AutomationTestStatData, MaxMp) == 0x00000C, "Member 'FM1AutomationTestStatData::MaxMp' has a wrong offset!");
static_assert(offsetof(FM1AutomationTestStatData, MainAttr) == 0x000010, "Member 'FM1AutomationTestStatData::MainAttr' has a wrong offset!");
static_assert(offsetof(FM1AutomationTestStatData, SubAttrs) == 0x000018, "Member 'FM1AutomationTestStatData::SubAttrs' has a wrong offset!");

// ScriptStruct M1Data.M1AutomationTestCharacterData
// 0x0080 (0x0088 - 0x0008)
struct FM1AutomationTestCharacterData : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EM1AutomationTestAttr>                 CharacterAttrs;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1AutomationTestNestData>      Nests;                                             // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1AutomationTestStatData              Stat;                                              // 0x0030(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FM1AutomationTestOtherDataLink         Other;                                             // 0x0058(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AutomationTestCharacterData) == 0x000008, "Wrong alignment on FM1AutomationTestCharacterData");
static_assert(sizeof(FM1AutomationTestCharacterData) == 0x000088, "Wrong size on FM1AutomationTestCharacterData");
static_assert(offsetof(FM1AutomationTestCharacterData, TemplateId) == 0x000008, "Member 'FM1AutomationTestCharacterData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1AutomationTestCharacterData, CharacterAttrs) == 0x000010, "Member 'FM1AutomationTestCharacterData::CharacterAttrs' has a wrong offset!");
static_assert(offsetof(FM1AutomationTestCharacterData, Nests) == 0x000020, "Member 'FM1AutomationTestCharacterData::Nests' has a wrong offset!");
static_assert(offsetof(FM1AutomationTestCharacterData, Stat) == 0x000030, "Member 'FM1AutomationTestCharacterData::Stat' has a wrong offset!");
static_assert(offsetof(FM1AutomationTestCharacterData, Other) == 0x000058, "Member 'FM1AutomationTestCharacterData::Other' has a wrong offset!");

// ScriptStruct M1Data.M1AutomationTestNpcData
// 0x0028 (0x00B0 - 0x0088)
struct FM1AutomationTestNpcData final : public FM1AutomationTestCharacterData
{
public:
	struct FM1AutomationTestStatData              SecondStat;                                        // 0x0088(0x0028)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AutomationTestNpcData) == 0x000008, "Wrong alignment on FM1AutomationTestNpcData");
static_assert(sizeof(FM1AutomationTestNpcData) == 0x0000B0, "Wrong size on FM1AutomationTestNpcData");
static_assert(offsetof(FM1AutomationTestNpcData, SecondStat) == 0x000088, "Member 'FM1AutomationTestNpcData::SecondStat' has a wrong offset!");

// ScriptStruct M1Data.M1CommonGaugeData
// 0x0048 (0x0048 - 0x0000)
struct FM1CommonGaugeData final
{
public:
	class FString                                 CurrentStatStringId;                               // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MaxStatStringId;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFillOnInit;                                       // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         WidgetPath;                                        // 0x0028(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CommonGaugeData) == 0x000008, "Wrong alignment on FM1CommonGaugeData");
static_assert(sizeof(FM1CommonGaugeData) == 0x000048, "Wrong size on FM1CommonGaugeData");
static_assert(offsetof(FM1CommonGaugeData, CurrentStatStringId) == 0x000000, "Member 'FM1CommonGaugeData::CurrentStatStringId' has a wrong offset!");
static_assert(offsetof(FM1CommonGaugeData, MaxStatStringId) == 0x000010, "Member 'FM1CommonGaugeData::MaxStatStringId' has a wrong offset!");
static_assert(offsetof(FM1CommonGaugeData, bFillOnInit) == 0x000020, "Member 'FM1CommonGaugeData::bFillOnInit' has a wrong offset!");
static_assert(offsetof(FM1CommonGaugeData, WidgetPath) == 0x000028, "Member 'FM1CommonGaugeData::WidgetPath' has a wrong offset!");

// ScriptStruct M1Data.M1InstantUseItemDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1InstantUseItemDataLink final : public FDataLink
{
};
static_assert(alignof(FM1InstantUseItemDataLink) == 0x000008, "Wrong alignment on FM1InstantUseItemDataLink");
static_assert(sizeof(FM1InstantUseItemDataLink) == 0x000030, "Wrong size on FM1InstantUseItemDataLink");

// ScriptStruct M1Data.M1StatDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1StatDataLink final : public FDataLink
{
};
static_assert(alignof(FM1StatDataLink) == 0x000008, "Wrong alignment on FM1StatDataLink");
static_assert(sizeof(FM1StatDataLink) == 0x000030, "Wrong size on FM1StatDataLink");

// ScriptStruct M1Data.M1RangedWeaponRecoilDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1RangedWeaponRecoilDataLink final : public FDataLink
{
};
static_assert(alignof(FM1RangedWeaponRecoilDataLink) == 0x000008, "Wrong alignment on FM1RangedWeaponRecoilDataLink");
static_assert(sizeof(FM1RangedWeaponRecoilDataLink) == 0x000030, "Wrong size on FM1RangedWeaponRecoilDataLink");

// ScriptStruct M1Data.M1InstantUseDropGroupDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1InstantUseDropGroupDataLink final : public FDataLink
{
};
static_assert(alignof(FM1InstantUseDropGroupDataLink) == 0x000008, "Wrong alignment on FM1InstantUseDropGroupDataLink");
static_assert(sizeof(FM1InstantUseDropGroupDataLink) == 0x000030, "Wrong size on FM1InstantUseDropGroupDataLink");

// ScriptStruct M1Data.M1VariableMaxCapacity
// 0x0038 (0x0038 - 0x0000)
struct FM1VariableMaxCapacity final
{
public:
	struct FM1ConsumableItemDataLink              TargetItemId;                                      // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	int32                                         MaxCapacity;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1VariableMaxCapacity) == 0x000008, "Wrong alignment on FM1VariableMaxCapacity");
static_assert(sizeof(FM1VariableMaxCapacity) == 0x000038, "Wrong size on FM1VariableMaxCapacity");
static_assert(offsetof(FM1VariableMaxCapacity, TargetItemId) == 0x000000, "Member 'FM1VariableMaxCapacity::TargetItemId' has a wrong offset!");
static_assert(offsetof(FM1VariableMaxCapacity, MaxCapacity) == 0x000030, "Member 'FM1VariableMaxCapacity::MaxCapacity' has a wrong offset!");

// ScriptStruct M1Data.M1StringTableDataRowLink
// 0x0000 (0x0030 - 0x0030)
struct FM1StringTableDataRowLink final : public FDataLink
{
};
static_assert(alignof(FM1StringTableDataRowLink) == 0x000008, "Wrong alignment on FM1StringTableDataRowLink");
static_assert(sizeof(FM1StringTableDataRowLink) == 0x000030, "Wrong size on FM1StringTableDataRowLink");

// ScriptStruct M1Data.M1MissionFieldPrerequisite
// 0x0020 (0x0020 - 0x0000)
struct FM1MissionFieldPrerequisite final
{
public:
	EM1PrerequisiteType                           Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Value;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredProgress;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MissionFieldPrerequisite) == 0x000008, "Wrong alignment on FM1MissionFieldPrerequisite");
static_assert(sizeof(FM1MissionFieldPrerequisite) == 0x000020, "Wrong size on FM1MissionFieldPrerequisite");
static_assert(offsetof(FM1MissionFieldPrerequisite, Type) == 0x000000, "Member 'FM1MissionFieldPrerequisite::Type' has a wrong offset!");
static_assert(offsetof(FM1MissionFieldPrerequisite, Value) == 0x000008, "Member 'FM1MissionFieldPrerequisite::Value' has a wrong offset!");
static_assert(offsetof(FM1MissionFieldPrerequisite, RequiredProgress) == 0x000018, "Member 'FM1MissionFieldPrerequisite::RequiredProgress' has a wrong offset!");

// ScriptStruct M1Data.M1ItemStringTableDataRowLink
// 0x0000 (0x0030 - 0x0030)
struct FM1ItemStringTableDataRowLink final : public FDataLink
{
};
static_assert(alignof(FM1ItemStringTableDataRowLink) == 0x000008, "Wrong alignment on FM1ItemStringTableDataRowLink");
static_assert(sizeof(FM1ItemStringTableDataRowLink) == 0x000030, "Wrong size on FM1ItemStringTableDataRowLink");

// ScriptStruct M1Data.M1SystemStringTableDataRowLink
// 0x0000 (0x0030 - 0x0030)
struct FM1SystemStringTableDataRowLink final : public FDataLink
{
};
static_assert(alignof(FM1SystemStringTableDataRowLink) == 0x000008, "Wrong alignment on FM1SystemStringTableDataRowLink");
static_assert(sizeof(FM1SystemStringTableDataRowLink) == 0x000030, "Wrong size on FM1SystemStringTableDataRowLink");

// ScriptStruct M1Data.M1UIStringTableDataRowLink
// 0x0000 (0x0030 - 0x0030)
struct FM1UIStringTableDataRowLink final : public FDataLink
{
};
static_assert(alignof(FM1UIStringTableDataRowLink) == 0x000008, "Wrong alignment on FM1UIStringTableDataRowLink");
static_assert(sizeof(FM1UIStringTableDataRowLink) == 0x000030, "Wrong size on FM1UIStringTableDataRowLink");

// ScriptStruct M1Data.M1RandomOptionGroupDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1RandomOptionGroupDataLink final : public FDataLink
{
};
static_assert(alignof(FM1RandomOptionGroupDataLink) == 0x000008, "Wrong alignment on FM1RandomOptionGroupDataLink");
static_assert(sizeof(FM1RandomOptionGroupDataLink) == 0x000030, "Wrong size on FM1RandomOptionGroupDataLink");

// ScriptStruct M1Data.M1EquipmentLevel
// 0x0080 (0x0080 - 0x0000)
struct FM1EquipmentLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1StatValuePair>               VariableBaseStats;                                 // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1RandomOptionGroupDataLink           RandomOptionGroupId;                               // 0x0018(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FM1AbilityDataLink                     ActiveAbility;                                     // 0x0048(0x0030)(Edit, NativeAccessSpecifierPublic)
	int32                                         SellingPrice;                                      // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1EquipmentLevel) == 0x000008, "Wrong alignment on FM1EquipmentLevel");
static_assert(sizeof(FM1EquipmentLevel) == 0x000080, "Wrong size on FM1EquipmentLevel");
static_assert(offsetof(FM1EquipmentLevel, Level) == 0x000000, "Member 'FM1EquipmentLevel::Level' has a wrong offset!");
static_assert(offsetof(FM1EquipmentLevel, VariableBaseStats) == 0x000008, "Member 'FM1EquipmentLevel::VariableBaseStats' has a wrong offset!");
static_assert(offsetof(FM1EquipmentLevel, RandomOptionGroupId) == 0x000018, "Member 'FM1EquipmentLevel::RandomOptionGroupId' has a wrong offset!");
static_assert(offsetof(FM1EquipmentLevel, ActiveAbility) == 0x000048, "Member 'FM1EquipmentLevel::ActiveAbility' has a wrong offset!");
static_assert(offsetof(FM1EquipmentLevel, SellingPrice) == 0x000078, "Member 'FM1EquipmentLevel::SellingPrice' has a wrong offset!");

// ScriptStruct M1Data.M1EquipmentData
// 0x00E8 (0x00F0 - 0x0008)
struct FM1EquipmentData : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ItemUIData                          UIData;                                            // 0x0018(0x0060)(Edit, NativeAccessSpecifierPublic)
	EM1EquipmentCategoryType                      CategoryType;                                      // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1EquipItemClassType                         ClassType;                                         // 0x0079(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemTierType                               TierType;                                          // 0x007A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B[0x5];                                       // 0x007B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1StatValuePair>               BaseStats;                                         // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1EquipmentLevel>              Lv;                                                // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         RuneSocketCount;                                   // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1StatValuePair>               RequiredStats;                                     // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         PropClass;                                         // 0x00B8(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1CurrencyType                               SellingType;                                       // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ImportantPriority;                                 // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ImportanceType                             ImportanceType;                                    // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MasteryLevel;                                      // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTemporary;                                       // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1EquipmentData) == 0x000008, "Wrong alignment on FM1EquipmentData");
static_assert(sizeof(FM1EquipmentData) == 0x0000F0, "Wrong size on FM1EquipmentData");
static_assert(offsetof(FM1EquipmentData, TemplateId) == 0x000008, "Member 'FM1EquipmentData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1EquipmentData, StringId) == 0x00000C, "Member 'FM1EquipmentData::StringId' has a wrong offset!");
static_assert(offsetof(FM1EquipmentData, UIData) == 0x000018, "Member 'FM1EquipmentData::UIData' has a wrong offset!");
static_assert(offsetof(FM1EquipmentData, CategoryType) == 0x000078, "Member 'FM1EquipmentData::CategoryType' has a wrong offset!");
static_assert(offsetof(FM1EquipmentData, ClassType) == 0x000079, "Member 'FM1EquipmentData::ClassType' has a wrong offset!");
static_assert(offsetof(FM1EquipmentData, TierType) == 0x00007A, "Member 'FM1EquipmentData::TierType' has a wrong offset!");
static_assert(offsetof(FM1EquipmentData, BaseStats) == 0x000080, "Member 'FM1EquipmentData::BaseStats' has a wrong offset!");
static_assert(offsetof(FM1EquipmentData, Lv) == 0x000090, "Member 'FM1EquipmentData::Lv' has a wrong offset!");
static_assert(offsetof(FM1EquipmentData, RuneSocketCount) == 0x0000A0, "Member 'FM1EquipmentData::RuneSocketCount' has a wrong offset!");
static_assert(offsetof(FM1EquipmentData, RequiredStats) == 0x0000A8, "Member 'FM1EquipmentData::RequiredStats' has a wrong offset!");
static_assert(offsetof(FM1EquipmentData, PropClass) == 0x0000B8, "Member 'FM1EquipmentData::PropClass' has a wrong offset!");
static_assert(offsetof(FM1EquipmentData, SellingType) == 0x0000D8, "Member 'FM1EquipmentData::SellingType' has a wrong offset!");
static_assert(offsetof(FM1EquipmentData, ImportantPriority) == 0x0000DC, "Member 'FM1EquipmentData::ImportantPriority' has a wrong offset!");
static_assert(offsetof(FM1EquipmentData, ImportanceType) == 0x0000E0, "Member 'FM1EquipmentData::ImportanceType' has a wrong offset!");
static_assert(offsetof(FM1EquipmentData, MasteryLevel) == 0x0000E4, "Member 'FM1EquipmentData::MasteryLevel' has a wrong offset!");
static_assert(offsetof(FM1EquipmentData, IsTemporary) == 0x0000E8, "Member 'FM1EquipmentData::IsTemporary' has a wrong offset!");

// ScriptStruct M1Data.M1SkillStringTableDataRowLink
// 0x0000 (0x0030 - 0x0030)
struct FM1SkillStringTableDataRowLink final : public FDataLink
{
};
static_assert(alignof(FM1SkillStringTableDataRowLink) == 0x000008, "Wrong alignment on FM1SkillStringTableDataRowLink");
static_assert(sizeof(FM1SkillStringTableDataRowLink) == 0x000030, "Wrong size on FM1SkillStringTableDataRowLink");

// ScriptStruct M1Data.M1CharacterStringTableDataRowLink
// 0x0000 (0x0030 - 0x0030)
struct FM1CharacterStringTableDataRowLink final : public FDataLink
{
};
static_assert(alignof(FM1CharacterStringTableDataRowLink) == 0x000008, "Wrong alignment on FM1CharacterStringTableDataRowLink");
static_assert(sizeof(FM1CharacterStringTableDataRowLink) == 0x000030, "Wrong size on FM1CharacterStringTableDataRowLink");

// ScriptStruct M1Data.M1StoryStringTableDataRowLink
// 0x0000 (0x0030 - 0x0030)
struct FM1StoryStringTableDataRowLink final : public FDataLink
{
};
static_assert(alignof(FM1StoryStringTableDataRowLink) == 0x000008, "Wrong alignment on FM1StoryStringTableDataRowLink");
static_assert(sizeof(FM1StoryStringTableDataRowLink) == 0x000030, "Wrong size on FM1StoryStringTableDataRowLink");

// ScriptStruct M1Data.M1ReservedStringTableDataRowLink
// 0x0000 (0x0030 - 0x0030)
struct FM1ReservedStringTableDataRowLink final : public FDataLink
{
};
static_assert(alignof(FM1ReservedStringTableDataRowLink) == 0x000008, "Wrong alignment on FM1ReservedStringTableDataRowLink");
static_assert(sizeof(FM1ReservedStringTableDataRowLink) == 0x000030, "Wrong size on FM1ReservedStringTableDataRowLink");

// ScriptStruct M1Data.M1DropGroupElement
// 0x0048 (0x0048 - 0x0000)
struct FM1DropGroupElement final
{
public:
	struct FM1ItemDataBox                         Item;                                              // 0x0000(0x0038)(Edit, NativeAccessSpecifierPublic)
	int32                                         ValueMin;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ValueMax;                                          // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1DropGroupElement) == 0x000008, "Wrong alignment on FM1DropGroupElement");
static_assert(sizeof(FM1DropGroupElement) == 0x000048, "Wrong size on FM1DropGroupElement");
static_assert(offsetof(FM1DropGroupElement, Item) == 0x000000, "Member 'FM1DropGroupElement::Item' has a wrong offset!");
static_assert(offsetof(FM1DropGroupElement, ValueMin) == 0x000038, "Member 'FM1DropGroupElement::ValueMin' has a wrong offset!");
static_assert(offsetof(FM1DropGroupElement, ValueMax) == 0x00003C, "Member 'FM1DropGroupElement::ValueMax' has a wrong offset!");
static_assert(offsetof(FM1DropGroupElement, Ratio) == 0x000040, "Member 'FM1DropGroupElement::Ratio' has a wrong offset!");

// ScriptStruct M1Data.M1ContentsStringTableDataRowLink
// 0x0000 (0x0030 - 0x0030)
struct FM1ContentsStringTableDataRowLink final : public FDataLink
{
};
static_assert(alignof(FM1ContentsStringTableDataRowLink) == 0x000008, "Wrong alignment on FM1ContentsStringTableDataRowLink");
static_assert(sizeof(FM1ContentsStringTableDataRowLink) == 0x000030, "Wrong size on FM1ContentsStringTableDataRowLink");

// ScriptStruct M1Data.M1ProductStringTableDataRowLink
// 0x0000 (0x0030 - 0x0030)
struct FM1ProductStringTableDataRowLink final : public FDataLink
{
};
static_assert(alignof(FM1ProductStringTableDataRowLink) == 0x000008, "Wrong alignment on FM1ProductStringTableDataRowLink");
static_assert(sizeof(FM1ProductStringTableDataRowLink) == 0x000030, "Wrong size on FM1ProductStringTableDataRowLink");

// ScriptStruct M1Data.M1MonsterTagDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1MonsterTagDataLink final : public FDataLink
{
};
static_assert(alignof(FM1MonsterTagDataLink) == 0x000008, "Wrong alignment on FM1MonsterTagDataLink");
static_assert(sizeof(FM1MonsterTagDataLink) == 0x000030, "Wrong size on FM1MonsterTagDataLink");

// ScriptStruct M1Data.M1ItemDef
// 0x0048 (0x0048 - 0x0000)
struct FM1ItemDef final
{
public:
	struct FM1ItemDataBox                         Item;                                              // 0x0000(0x0038)(Edit, NativeAccessSpecifierPublic)
	int64                                         Amount;                                            // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ratio;                                             // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ItemDef) == 0x000008, "Wrong alignment on FM1ItemDef");
static_assert(sizeof(FM1ItemDef) == 0x000048, "Wrong size on FM1ItemDef");
static_assert(offsetof(FM1ItemDef, Item) == 0x000000, "Member 'FM1ItemDef::Item' has a wrong offset!");
static_assert(offsetof(FM1ItemDef, Amount) == 0x000038, "Member 'FM1ItemDef::Amount' has a wrong offset!");
static_assert(offsetof(FM1ItemDef, Ratio) == 0x000040, "Member 'FM1ItemDef::Ratio' has a wrong offset!");

// ScriptStruct M1Data.M1ItemDefBundle
// 0x0018 (0x0018 - 0x0000)
struct FM1ItemDefBundle final
{
public:
	int32                                         Ratio;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1ItemDef>                     Items;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemDefBundle) == 0x000008, "Wrong alignment on FM1ItemDefBundle");
static_assert(sizeof(FM1ItemDefBundle) == 0x000018, "Wrong size on FM1ItemDefBundle");
static_assert(offsetof(FM1ItemDefBundle, Ratio) == 0x000000, "Member 'FM1ItemDefBundle::Ratio' has a wrong offset!");
static_assert(offsetof(FM1ItemDefBundle, Items) == 0x000008, "Member 'FM1ItemDefBundle::Items' has a wrong offset!");

// ScriptStruct M1Data.M1HitPointDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1HitPointDataLink final : public FDataLink
{
};
static_assert(alignof(FM1HitPointDataLink) == 0x000008, "Wrong alignment on FM1HitPointDataLink");
static_assert(sizeof(FM1HitPointDataLink) == 0x000030, "Wrong size on FM1HitPointDataLink");

// ScriptStruct M1Data.M1NpcServiceUnlockDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1NpcServiceUnlockDataLink final : public FDataLink
{
};
static_assert(alignof(FM1NpcServiceUnlockDataLink) == 0x000008, "Wrong alignment on FM1NpcServiceUnlockDataLink");
static_assert(sizeof(FM1NpcServiceUnlockDataLink) == 0x000030, "Wrong size on FM1NpcServiceUnlockDataLink");

// ScriptStruct M1Data.M1DialogDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1DialogDataLink final : public FDataLink
{
};
static_assert(alignof(FM1DialogDataLink) == 0x000008, "Wrong alignment on FM1DialogDataLink");
static_assert(sizeof(FM1DialogDataLink) == 0x000030, "Wrong size on FM1DialogDataLink");

// ScriptStruct M1Data.M1MissionRewardsEvaluateCondition
// 0x0018 (0x0018 - 0x0000)
struct FM1MissionRewardsEvaluateCondition final
{
public:
	EM1MissionRewardsEvaluateConditionType        Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Params;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionRewardsEvaluateCondition) == 0x000008, "Wrong alignment on FM1MissionRewardsEvaluateCondition");
static_assert(sizeof(FM1MissionRewardsEvaluateCondition) == 0x000018, "Wrong size on FM1MissionRewardsEvaluateCondition");
static_assert(offsetof(FM1MissionRewardsEvaluateCondition, Type) == 0x000000, "Member 'FM1MissionRewardsEvaluateCondition::Type' has a wrong offset!");
static_assert(offsetof(FM1MissionRewardsEvaluateCondition, Params) == 0x000008, "Member 'FM1MissionRewardsEvaluateCondition::Params' has a wrong offset!");

// ScriptStruct M1Data.M1LoadingTooltipDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1LoadingTooltipDataLink final : public FDataLink
{
};
static_assert(alignof(FM1LoadingTooltipDataLink) == 0x000008, "Wrong alignment on FM1LoadingTooltipDataLink");
static_assert(sizeof(FM1LoadingTooltipDataLink) == 0x000030, "Wrong size on FM1LoadingTooltipDataLink");

// ScriptStruct M1Data.M1LoadingImageRandomDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1LoadingImageRandomDataLink final : public FDataLink
{
};
static_assert(alignof(FM1LoadingImageRandomDataLink) == 0x000008, "Wrong alignment on FM1LoadingImageRandomDataLink");
static_assert(sizeof(FM1LoadingImageRandomDataLink) == 0x000030, "Wrong size on FM1LoadingImageRandomDataLink");

// ScriptStruct M1Data.M1TestAssetDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1TestAssetDataLink final : public FDataLink
{
};
static_assert(alignof(FM1TestAssetDataLink) == 0x000008, "Wrong alignment on FM1TestAssetDataLink");
static_assert(sizeof(FM1TestAssetDataLink) == 0x000030, "Wrong size on FM1TestAssetDataLink");

// ScriptStruct M1Data.M1RuneUIDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1RuneUIDataLink final : public FDataLink
{
};
static_assert(alignof(FM1RuneUIDataLink) == 0x000008, "Wrong alignment on FM1RuneUIDataLink");
static_assert(sizeof(FM1RuneUIDataLink) == 0x000030, "Wrong size on FM1RuneUIDataLink");

// ScriptStruct M1Data.M1RuneAutoEquipLink
// 0x0000 (0x0030 - 0x0030)
struct FM1RuneAutoEquipLink final : public FDataLink
{
};
static_assert(alignof(FM1RuneAutoEquipLink) == 0x000008, "Wrong alignment on FM1RuneAutoEquipLink");
static_assert(sizeof(FM1RuneAutoEquipLink) == 0x000030, "Wrong size on FM1RuneAutoEquipLink");

// ScriptStruct M1Data.M1EpicMonsterSkillDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1EpicMonsterSkillDataLink final : public FDataLink
{
};
static_assert(alignof(FM1EpicMonsterSkillDataLink) == 0x000008, "Wrong alignment on FM1EpicMonsterSkillDataLink");
static_assert(sizeof(FM1EpicMonsterSkillDataLink) == 0x000030, "Wrong size on FM1EpicMonsterSkillDataLink");

// ScriptStruct M1Data.M1InstanceDungeonSelectionMODDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1InstanceDungeonSelectionMODDataLink final : public FDataLink
{
};
static_assert(alignof(FM1InstanceDungeonSelectionMODDataLink) == 0x000008, "Wrong alignment on FM1InstanceDungeonSelectionMODDataLink");
static_assert(sizeof(FM1InstanceDungeonSelectionMODDataLink) == 0x000030, "Wrong size on FM1InstanceDungeonSelectionMODDataLink");

// ScriptStruct M1Data.M1InstanceDungeonSelectionMODInfo
// 0x0038 (0x0038 - 0x0000)
struct FM1InstanceDungeonSelectionMODInfo final
{
public:
	bool                                          Default;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1InstanceDungeonSelectionMODDataLink MODData;                                           // 0x0008(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceDungeonSelectionMODInfo) == 0x000008, "Wrong alignment on FM1InstanceDungeonSelectionMODInfo");
static_assert(sizeof(FM1InstanceDungeonSelectionMODInfo) == 0x000038, "Wrong size on FM1InstanceDungeonSelectionMODInfo");
static_assert(offsetof(FM1InstanceDungeonSelectionMODInfo, Default) == 0x000000, "Member 'FM1InstanceDungeonSelectionMODInfo::Default' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonSelectionMODInfo, MODData) == 0x000008, "Member 'FM1InstanceDungeonSelectionMODInfo::MODData' has a wrong offset!");

// ScriptStruct M1Data.M1EliteMonsterSkillDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1EliteMonsterSkillDataLink final : public FDataLink
{
};
static_assert(alignof(FM1EliteMonsterSkillDataLink) == 0x000008, "Wrong alignment on FM1EliteMonsterSkillDataLink");
static_assert(sizeof(FM1EliteMonsterSkillDataLink) == 0x000030, "Wrong size on FM1EliteMonsterSkillDataLink");

// ScriptStruct M1Data.M1PhysicalPowerOptionDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1PhysicalPowerOptionDataLink final : public FDataLink
{
};
static_assert(alignof(FM1PhysicalPowerOptionDataLink) == 0x000008, "Wrong alignment on FM1PhysicalPowerOptionDataLink");
static_assert(sizeof(FM1PhysicalPowerOptionDataLink) == 0x000030, "Wrong size on FM1PhysicalPowerOptionDataLink");

// ScriptStruct M1Data.M1InvasionDungeonTimeAttackGroupLink
// 0x0000 (0x0030 - 0x0030)
struct FM1InvasionDungeonTimeAttackGroupLink final : public FDataLink
{
};
static_assert(alignof(FM1InvasionDungeonTimeAttackGroupLink) == 0x000008, "Wrong alignment on FM1InvasionDungeonTimeAttackGroupLink");
static_assert(sizeof(FM1InvasionDungeonTimeAttackGroupLink) == 0x000030, "Wrong size on FM1InvasionDungeonTimeAttackGroupLink");

// ScriptStruct M1Data.M1InvasionDungeonTimeAttackReward
// 0x0038 (0x0038 - 0x0000)
struct FM1InvasionDungeonTimeAttackReward final
{
public:
	struct FSoftObjectPath                        IconPath;                                          // 0x0000(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimeSec;                                           // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SeasonExp;                                         // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1InvasionDungeonTimeAttackGroupLink> RewardGroups;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InvasionDungeonTimeAttackReward) == 0x000008, "Wrong alignment on FM1InvasionDungeonTimeAttackReward");
static_assert(sizeof(FM1InvasionDungeonTimeAttackReward) == 0x000038, "Wrong size on FM1InvasionDungeonTimeAttackReward");
static_assert(offsetof(FM1InvasionDungeonTimeAttackReward, IconPath) == 0x000000, "Member 'FM1InvasionDungeonTimeAttackReward::IconPath' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonTimeAttackReward, TimeSec) == 0x000020, "Member 'FM1InvasionDungeonTimeAttackReward::TimeSec' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonTimeAttackReward, SeasonExp) == 0x000024, "Member 'FM1InvasionDungeonTimeAttackReward::SeasonExp' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonTimeAttackReward, RewardGroups) == 0x000028, "Member 'FM1InvasionDungeonTimeAttackReward::RewardGroups' has a wrong offset!");

// ScriptStruct M1Data.M1SkillRedirectDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1SkillRedirectDataLink final : public FDataLink
{
};
static_assert(alignof(FM1SkillRedirectDataLink) == 0x000008, "Wrong alignment on FM1SkillRedirectDataLink");
static_assert(sizeof(FM1SkillRedirectDataLink) == 0x000030, "Wrong size on FM1SkillRedirectDataLink");

// ScriptStruct M1Data.M1SkillTooltipDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1SkillTooltipDataLink final : public FDataLink
{
};
static_assert(alignof(FM1SkillTooltipDataLink) == 0x000008, "Wrong alignment on FM1SkillTooltipDataLink");
static_assert(sizeof(FM1SkillTooltipDataLink) == 0x000030, "Wrong size on FM1SkillTooltipDataLink");

// ScriptStruct M1Data.M1PerkTooltipDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1PerkTooltipDataLink final : public FDataLink
{
};
static_assert(alignof(FM1PerkTooltipDataLink) == 0x000008, "Wrong alignment on FM1PerkTooltipDataLink");
static_assert(sizeof(FM1PerkTooltipDataLink) == 0x000030, "Wrong size on FM1PerkTooltipDataLink");

// ScriptStruct M1Data.M1SeasonReinforceAbilityDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1SeasonReinforceAbilityDataLink final : public FDataLink
{
};
static_assert(alignof(FM1SeasonReinforceAbilityDataLink) == 0x000008, "Wrong alignment on FM1SeasonReinforceAbilityDataLink");
static_assert(sizeof(FM1SeasonReinforceAbilityDataLink) == 0x000030, "Wrong size on FM1SeasonReinforceAbilityDataLink");

// ScriptStruct M1Data.M1InstanceDungeonMODData
// 0x0018 (0x0020 - 0x0008)
struct FM1InstanceDungeonMODData : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringId;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceDungeonMODData) == 0x000008, "Wrong alignment on FM1InstanceDungeonMODData");
static_assert(sizeof(FM1InstanceDungeonMODData) == 0x000020, "Wrong size on FM1InstanceDungeonMODData");
static_assert(offsetof(FM1InstanceDungeonMODData, TemplateId) == 0x000008, "Member 'FM1InstanceDungeonMODData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonMODData, StringId) == 0x000010, "Member 'FM1InstanceDungeonMODData::StringId' has a wrong offset!");

// ScriptStruct M1Data.M1InvasionDungeonMODData
// 0x0030 (0x0050 - 0x0020)
struct FM1InvasionDungeonMODData final : public FM1InstanceDungeonMODData
{
public:
	struct FM1InstanceDungeonAbilityDataLink      AbilityData;                                       // 0x0020(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InvasionDungeonMODData) == 0x000008, "Wrong alignment on FM1InvasionDungeonMODData");
static_assert(sizeof(FM1InvasionDungeonMODData) == 0x000050, "Wrong size on FM1InvasionDungeonMODData");
static_assert(offsetof(FM1InvasionDungeonMODData, AbilityData) == 0x000020, "Member 'FM1InvasionDungeonMODData::AbilityData' has a wrong offset!");

// ScriptStruct M1Data.M1SeasonReinforceDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1SeasonReinforceDataLink final : public FDataLink
{
};
static_assert(alignof(FM1SeasonReinforceDataLink) == 0x000008, "Wrong alignment on FM1SeasonReinforceDataLink");
static_assert(sizeof(FM1SeasonReinforceDataLink) == 0x000030, "Wrong size on FM1SeasonReinforceDataLink");

// ScriptStruct M1Data.M1SummonsDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1SummonsDataLink final : public FDataLink
{
};
static_assert(alignof(FM1SummonsDataLink) == 0x000008, "Wrong alignment on FM1SummonsDataLink");
static_assert(sizeof(FM1SummonsDataLink) == 0x000030, "Wrong size on FM1SummonsDataLink");

// ScriptStruct M1Data.M1SummonsAIDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1SummonsAIDataLink final : public FDataLink
{
};
static_assert(alignof(FM1SummonsAIDataLink) == 0x000008, "Wrong alignment on FM1SummonsAIDataLink");
static_assert(sizeof(FM1SummonsAIDataLink) == 0x000030, "Wrong size on FM1SummonsAIDataLink");

// ScriptStruct M1Data.M1SummonsSkillDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1SummonsSkillDataLink final : public FDataLink
{
};
static_assert(alignof(FM1SummonsSkillDataLink) == 0x000008, "Wrong alignment on FM1SummonsSkillDataLink");
static_assert(sizeof(FM1SummonsSkillDataLink) == 0x000030, "Wrong size on FM1SummonsSkillDataLink");

// ScriptStruct M1Data.M1ChallengeDetailData
// 0x0068 (0x0068 - 0x0000)
struct FM1ChallengeDetailData final
{
public:
	struct FM1QuestDataLink                       QuestId;                                           // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	EM1EventResetType                             ResetType;                                         // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1MailDataLink                        EventRewardMailId;                                 // 0x0038(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ChallengeDetailData) == 0x000008, "Wrong alignment on FM1ChallengeDetailData");
static_assert(sizeof(FM1ChallengeDetailData) == 0x000068, "Wrong size on FM1ChallengeDetailData");
static_assert(offsetof(FM1ChallengeDetailData, QuestId) == 0x000000, "Member 'FM1ChallengeDetailData::QuestId' has a wrong offset!");
static_assert(offsetof(FM1ChallengeDetailData, ResetType) == 0x000030, "Member 'FM1ChallengeDetailData::ResetType' has a wrong offset!");
static_assert(offsetof(FM1ChallengeDetailData, EventRewardMailId) == 0x000038, "Member 'FM1ChallengeDetailData::EventRewardMailId' has a wrong offset!");

// ScriptStruct M1Data.M1EventData
// 0x0070 (0x0078 - 0x0008)
struct FM1EventData : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1EventType                                  Type;                                              // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              StartTime;                                         // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndTime;                                           // 0x0020(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BGPath;                                            // 0x0028(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0048(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1ChallengeDetailData>         ChallengeDataList;                                 // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EventData) == 0x000008, "Wrong alignment on FM1EventData");
static_assert(sizeof(FM1EventData) == 0x000078, "Wrong size on FM1EventData");
static_assert(offsetof(FM1EventData, TemplateId) == 0x000008, "Member 'FM1EventData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1EventData, StringId) == 0x00000C, "Member 'FM1EventData::StringId' has a wrong offset!");
static_assert(offsetof(FM1EventData, Type) == 0x000014, "Member 'FM1EventData::Type' has a wrong offset!");
static_assert(offsetof(FM1EventData, StartTime) == 0x000018, "Member 'FM1EventData::StartTime' has a wrong offset!");
static_assert(offsetof(FM1EventData, EndTime) == 0x000020, "Member 'FM1EventData::EndTime' has a wrong offset!");
static_assert(offsetof(FM1EventData, BGPath) == 0x000028, "Member 'FM1EventData::BGPath' has a wrong offset!");
static_assert(offsetof(FM1EventData, IconPath) == 0x000048, "Member 'FM1EventData::IconPath' has a wrong offset!");
static_assert(offsetof(FM1EventData, ChallengeDataList) == 0x000068, "Member 'FM1EventData::ChallengeDataList' has a wrong offset!");

// ScriptStruct M1Data.M1CustomizingAbilityDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1CustomizingAbilityDataLink final : public FDataLink
{
};
static_assert(alignof(FM1CustomizingAbilityDataLink) == 0x000008, "Wrong alignment on FM1CustomizingAbilityDataLink");
static_assert(sizeof(FM1CustomizingAbilityDataLink) == 0x000030, "Wrong size on FM1CustomizingAbilityDataLink");

// ScriptStruct M1Data.M1PerkAbilityDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1PerkAbilityDataLink final : public FDataLink
{
};
static_assert(alignof(FM1PerkAbilityDataLink) == 0x000008, "Wrong alignment on FM1PerkAbilityDataLink");
static_assert(sizeof(FM1PerkAbilityDataLink) == 0x000030, "Wrong size on FM1PerkAbilityDataLink");

// ScriptStruct M1Data.M1ReactorAbilityDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1ReactorAbilityDataLink final : public FDataLink
{
};
static_assert(alignof(FM1ReactorAbilityDataLink) == 0x000008, "Wrong alignment on FM1ReactorAbilityDataLink");
static_assert(sizeof(FM1ReactorAbilityDataLink) == 0x000030, "Wrong size on FM1ReactorAbilityDataLink");

// ScriptStruct M1Data.M1SetOptionAbilityDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1SetOptionAbilityDataLink final : public FDataLink
{
};
static_assert(alignof(FM1SetOptionAbilityDataLink) == 0x000008, "Wrong alignment on FM1SetOptionAbilityDataLink");
static_assert(sizeof(FM1SetOptionAbilityDataLink) == 0x000030, "Wrong size on FM1SetOptionAbilityDataLink");

// ScriptStruct M1Data.M1EventDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1EventDataLink final : public FDataLink
{
};
static_assert(alignof(FM1EventDataLink) == 0x000008, "Wrong alignment on FM1EventDataLink");
static_assert(sizeof(FM1EventDataLink) == 0x000030, "Wrong size on FM1EventDataLink");

// ScriptStruct M1Data.M1RuneDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1RuneDataLink final : public FDataLink
{
};
static_assert(alignof(FM1RuneDataLink) == 0x000008, "Wrong alignment on FM1RuneDataLink");
static_assert(sizeof(FM1RuneDataLink) == 0x000030, "Wrong size on FM1RuneDataLink");

// ScriptStruct M1Data.M1RuneIdData
// 0x0030 (0x0030 - 0x0000)
struct FM1RuneIdData final
{
public:
	struct FM1RuneDataLink                        RuneId;                                            // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneIdData) == 0x000008, "Wrong alignment on FM1RuneIdData");
static_assert(sizeof(FM1RuneIdData) == 0x000030, "Wrong size on FM1RuneIdData");
static_assert(offsetof(FM1RuneIdData, RuneId) == 0x000000, "Member 'FM1RuneIdData::RuneId' has a wrong offset!");

// ScriptStruct M1Data.M1MissionMonsterAbilityDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1MissionMonsterAbilityDataLink final : public FDataLink
{
};
static_assert(alignof(FM1MissionMonsterAbilityDataLink) == 0x000008, "Wrong alignment on FM1MissionMonsterAbilityDataLink");
static_assert(sizeof(FM1MissionMonsterAbilityDataLink) == 0x000030, "Wrong size on FM1MissionMonsterAbilityDataLink");

// ScriptStruct M1Data.M1ChatBlockRuleDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1ChatBlockRuleDataLink final : public FDataLink
{
};
static_assert(alignof(FM1ChatBlockRuleDataLink) == 0x000008, "Wrong alignment on FM1ChatBlockRuleDataLink");
static_assert(sizeof(FM1ChatBlockRuleDataLink) == 0x000030, "Wrong size on FM1ChatBlockRuleDataLink");

// ScriptStruct M1Data.M1CreditsDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1CreditsDataLink final : public FDataLink
{
};
static_assert(alignof(FM1CreditsDataLink) == 0x000008, "Wrong alignment on FM1CreditsDataLink");
static_assert(sizeof(FM1CreditsDataLink) == 0x000030, "Wrong size on FM1CreditsDataLink");

// ScriptStruct M1Data.M1SetOptionDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1SetOptionDataLink final : public FDataLink
{
};
static_assert(alignof(FM1SetOptionDataLink) == 0x000008, "Wrong alignment on FM1SetOptionDataLink");
static_assert(sizeof(FM1SetOptionDataLink) == 0x000030, "Wrong size on FM1SetOptionDataLink");

// ScriptStruct M1Data.M1MissionTargetAbilityDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1MissionTargetAbilityDataLink final : public FDataLink
{
};
static_assert(alignof(FM1MissionTargetAbilityDataLink) == 0x000008, "Wrong alignment on FM1MissionTargetAbilityDataLink");
static_assert(sizeof(FM1MissionTargetAbilityDataLink) == 0x000030, "Wrong size on FM1MissionTargetAbilityDataLink");

// ScriptStruct M1Data.M1MissionTargetDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1MissionTargetDataLink final : public FDataLink
{
};
static_assert(alignof(FM1MissionTargetDataLink) == 0x000008, "Wrong alignment on FM1MissionTargetDataLink");
static_assert(sizeof(FM1MissionTargetDataLink) == 0x000030, "Wrong size on FM1MissionTargetDataLink");

// ScriptStruct M1Data.M1LaboratoryMonsterSpawnDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1LaboratoryMonsterSpawnDataLink final : public FDataLink
{
};
static_assert(alignof(FM1LaboratoryMonsterSpawnDataLink) == 0x000008, "Wrong alignment on FM1LaboratoryMonsterSpawnDataLink");
static_assert(sizeof(FM1LaboratoryMonsterSpawnDataLink) == 0x000030, "Wrong size on FM1LaboratoryMonsterSpawnDataLink");

// ScriptStruct M1Data.M1BattlePassLevelDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1BattlePassLevelDataLink final : public FDataLink
{
};
static_assert(alignof(FM1BattlePassLevelDataLink) == 0x000008, "Wrong alignment on FM1BattlePassLevelDataLink");
static_assert(sizeof(FM1BattlePassLevelDataLink) == 0x000030, "Wrong size on FM1BattlePassLevelDataLink");

// ScriptStruct M1Data.M1PerkEnchantRequiredItemData
// 0x0010 (0x0010 - 0x0000)
struct FM1PerkEnchantRequiredItemData final
{
public:
	EM1ItemType                                   Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ID;                                                // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PerkEnchantRequiredItemData) == 0x000004, "Wrong alignment on FM1PerkEnchantRequiredItemData");
static_assert(sizeof(FM1PerkEnchantRequiredItemData) == 0x000010, "Wrong size on FM1PerkEnchantRequiredItemData");
static_assert(offsetof(FM1PerkEnchantRequiredItemData, Type) == 0x000000, "Member 'FM1PerkEnchantRequiredItemData::Type' has a wrong offset!");
static_assert(offsetof(FM1PerkEnchantRequiredItemData, ID) == 0x000004, "Member 'FM1PerkEnchantRequiredItemData::ID' has a wrong offset!");
static_assert(offsetof(FM1PerkEnchantRequiredItemData, Amount) == 0x00000C, "Member 'FM1PerkEnchantRequiredItemData::Amount' has a wrong offset!");

// ScriptStruct M1Data.M1PerkDetailData
// 0x0080 (0x0080 - 0x0000)
struct FM1PerkDetailData final
{
public:
	int32                                         EnchantLevel;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1PerkAbilityDataLink                 Ability;                                           // 0x0008(0x0030)(Edit, NativeAccessSpecifierPublic)
	class FString                                 StringId;                                          // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbilityProbability;                                // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1AbilityParamData>            Params;                                            // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1TaggedAbilityParamData>      TaggedParams;                                      // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1PerkEnchantRequiredItemData> EnchantRequiredItems;                              // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PerkDetailData) == 0x000008, "Wrong alignment on FM1PerkDetailData");
static_assert(sizeof(FM1PerkDetailData) == 0x000080, "Wrong size on FM1PerkDetailData");
static_assert(offsetof(FM1PerkDetailData, EnchantLevel) == 0x000000, "Member 'FM1PerkDetailData::EnchantLevel' has a wrong offset!");
static_assert(offsetof(FM1PerkDetailData, Ability) == 0x000008, "Member 'FM1PerkDetailData::Ability' has a wrong offset!");
static_assert(offsetof(FM1PerkDetailData, StringId) == 0x000038, "Member 'FM1PerkDetailData::StringId' has a wrong offset!");
static_assert(offsetof(FM1PerkDetailData, AbilityProbability) == 0x000048, "Member 'FM1PerkDetailData::AbilityProbability' has a wrong offset!");
static_assert(offsetof(FM1PerkDetailData, Params) == 0x000050, "Member 'FM1PerkDetailData::Params' has a wrong offset!");
static_assert(offsetof(FM1PerkDetailData, TaggedParams) == 0x000060, "Member 'FM1PerkDetailData::TaggedParams' has a wrong offset!");
static_assert(offsetof(FM1PerkDetailData, EnchantRequiredItems) == 0x000070, "Member 'FM1PerkDetailData::EnchantRequiredItems' has a wrong offset!");

// ScriptStruct M1Data.M1PerkUIData
// 0x0060 (0x0060 - 0x0000)
struct FM1PerkUIData final
{
public:
	struct FSoftObjectPath                        IconPath;                                          // 0x0000(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CustomHUDWidget;                                   // 0x0020(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PreviewMovie;                                      // 0x0040(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PerkUIData) == 0x000008, "Wrong alignment on FM1PerkUIData");
static_assert(sizeof(FM1PerkUIData) == 0x000060, "Wrong size on FM1PerkUIData");
static_assert(offsetof(FM1PerkUIData, IconPath) == 0x000000, "Member 'FM1PerkUIData::IconPath' has a wrong offset!");
static_assert(offsetof(FM1PerkUIData, CustomHUDWidget) == 0x000020, "Member 'FM1PerkUIData::CustomHUDWidget' has a wrong offset!");
static_assert(offsetof(FM1PerkUIData, PreviewMovie) == 0x000040, "Member 'FM1PerkUIData::PreviewMovie' has a wrong offset!");

// ScriptStruct M1Data.M1PerkData
// 0x0078 (0x0080 - 0x0008)
struct FM1PerkData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1PerkDetailData>              DetailDataList;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1PerkUIData                          UIData;                                            // 0x0020(0x0060)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PerkData) == 0x000008, "Wrong alignment on FM1PerkData");
static_assert(sizeof(FM1PerkData) == 0x000080, "Wrong size on FM1PerkData");
static_assert(offsetof(FM1PerkData, TemplateId) == 0x000008, "Member 'FM1PerkData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1PerkData, DetailDataList) == 0x000010, "Member 'FM1PerkData::DetailDataList' has a wrong offset!");
static_assert(offsetof(FM1PerkData, UIData) == 0x000020, "Member 'FM1PerkData::UIData' has a wrong offset!");

// ScriptStruct M1Data.M1MultiSupplierDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1MultiSupplierDataLink final : public FDataLink
{
};
static_assert(alignof(FM1MultiSupplierDataLink) == 0x000008, "Wrong alignment on FM1MultiSupplierDataLink");
static_assert(sizeof(FM1MultiSupplierDataLink) == 0x000030, "Wrong size on FM1MultiSupplierDataLink");

// ScriptStruct M1Data.M1ReactorOptimizedValueByTier
// 0x000C (0x000C - 0x0000)
struct FM1ReactorOptimizedValueByTier final
{
public:
	EM1ItemTierType                               Tier;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SatisfactionRatio;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DissatisfactionRatio;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ReactorOptimizedValueByTier) == 0x000004, "Wrong alignment on FM1ReactorOptimizedValueByTier");
static_assert(sizeof(FM1ReactorOptimizedValueByTier) == 0x00000C, "Wrong size on FM1ReactorOptimizedValueByTier");
static_assert(offsetof(FM1ReactorOptimizedValueByTier, Tier) == 0x000000, "Member 'FM1ReactorOptimizedValueByTier::Tier' has a wrong offset!");
static_assert(offsetof(FM1ReactorOptimizedValueByTier, SatisfactionRatio) == 0x000004, "Member 'FM1ReactorOptimizedValueByTier::SatisfactionRatio' has a wrong offset!");
static_assert(offsetof(FM1ReactorOptimizedValueByTier, DissatisfactionRatio) == 0x000008, "Member 'FM1ReactorOptimizedValueByTier::DissatisfactionRatio' has a wrong offset!");

// ScriptStruct M1Data.M1SimpleItemInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1SimpleItemInfo final
{
public:
	EM1ItemType                                   Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1TemplateId                          TemplateId;                                        // 0x0004(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Count;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SimpleItemInfo) == 0x000008, "Wrong alignment on FM1SimpleItemInfo");
static_assert(sizeof(FM1SimpleItemInfo) == 0x000010, "Wrong size on FM1SimpleItemInfo");
static_assert(offsetof(FM1SimpleItemInfo, Type) == 0x000000, "Member 'FM1SimpleItemInfo::Type' has a wrong offset!");
static_assert(offsetof(FM1SimpleItemInfo, TemplateId) == 0x000004, "Member 'FM1SimpleItemInfo::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1SimpleItemInfo, Count) == 0x000008, "Member 'FM1SimpleItemInfo::Count' has a wrong offset!");

// ScriptStruct M1Data.M1CharacterSizeData
// 0x0008 (0x0008 - 0x0000)
struct FM1CharacterSizeData final
{
public:
	EM1CharacterSize                              Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Size;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CharacterSizeData) == 0x000004, "Wrong alignment on FM1CharacterSizeData");
static_assert(sizeof(FM1CharacterSizeData) == 0x000008, "Wrong size on FM1CharacterSizeData");
static_assert(offsetof(FM1CharacterSizeData, Type) == 0x000000, "Member 'FM1CharacterSizeData::Type' has a wrong offset!");
static_assert(offsetof(FM1CharacterSizeData, Size) == 0x000004, "Member 'FM1CharacterSizeData::Size' has a wrong offset!");

// ScriptStruct M1Data.M1ProductDiscountPeriodData
// 0x0018 (0x0018 - 0x0000)
struct FM1ProductDiscountPeriodData final
{
public:
	struct FDateTime                              StartTime;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndTime;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiscountRate;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ProductDiscountPeriodData) == 0x000008, "Wrong alignment on FM1ProductDiscountPeriodData");
static_assert(sizeof(FM1ProductDiscountPeriodData) == 0x000018, "Wrong size on FM1ProductDiscountPeriodData");
static_assert(offsetof(FM1ProductDiscountPeriodData, StartTime) == 0x000000, "Member 'FM1ProductDiscountPeriodData::StartTime' has a wrong offset!");
static_assert(offsetof(FM1ProductDiscountPeriodData, EndTime) == 0x000008, "Member 'FM1ProductDiscountPeriodData::EndTime' has a wrong offset!");
static_assert(offsetof(FM1ProductDiscountPeriodData, DiscountRate) == 0x000010, "Member 'FM1ProductDiscountPeriodData::DiscountRate' has a wrong offset!");

// ScriptStruct M1Data.M1GaugeStatInfo
// 0x0003 (0x0003 - 0x0000)
struct FM1GaugeStatInfo final
{
public:
	bool                                          bGauge;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1StatType                                   MaxType;                                           // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFillOnInit;                                       // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GaugeStatInfo) == 0x000001, "Wrong alignment on FM1GaugeStatInfo");
static_assert(sizeof(FM1GaugeStatInfo) == 0x000003, "Wrong size on FM1GaugeStatInfo");
static_assert(offsetof(FM1GaugeStatInfo, bGauge) == 0x000000, "Member 'FM1GaugeStatInfo::bGauge' has a wrong offset!");
static_assert(offsetof(FM1GaugeStatInfo, MaxType) == 0x000001, "Member 'FM1GaugeStatInfo::MaxType' has a wrong offset!");
static_assert(offsetof(FM1GaugeStatInfo, bFillOnInit) == 0x000002, "Member 'FM1GaugeStatInfo::bFillOnInit' has a wrong offset!");

// ScriptStruct M1Data.M1StatUIData
// 0x0020 (0x0020 - 0x0000)
struct FM1StatUIData final
{
public:
	bool                                          UIRecord;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UIGroupId;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OrderInGroup;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1StatUIRecordType                           UIRecordType;                                      // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DecimalPlaces;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChart;                                            // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1RangedFloat                         ChartRange;                                        // 0x0018(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StatUIData) == 0x000004, "Wrong alignment on FM1StatUIData");
static_assert(sizeof(FM1StatUIData) == 0x000020, "Wrong size on FM1StatUIData");
static_assert(offsetof(FM1StatUIData, UIRecord) == 0x000000, "Member 'FM1StatUIData::UIRecord' has a wrong offset!");
static_assert(offsetof(FM1StatUIData, UIGroupId) == 0x000004, "Member 'FM1StatUIData::UIGroupId' has a wrong offset!");
static_assert(offsetof(FM1StatUIData, OrderInGroup) == 0x000008, "Member 'FM1StatUIData::OrderInGroup' has a wrong offset!");
static_assert(offsetof(FM1StatUIData, UIRecordType) == 0x00000C, "Member 'FM1StatUIData::UIRecordType' has a wrong offset!");
static_assert(offsetof(FM1StatUIData, DecimalPlaces) == 0x000010, "Member 'FM1StatUIData::DecimalPlaces' has a wrong offset!");
static_assert(offsetof(FM1StatUIData, bChart) == 0x000014, "Member 'FM1StatUIData::bChart' has a wrong offset!");
static_assert(offsetof(FM1StatUIData, ChartRange) == 0x000018, "Member 'FM1StatUIData::ChartRange' has a wrong offset!");

// ScriptStruct M1Data.M1StatBaseData
// 0x0008 (0x0010 - 0x0008)
struct FM1StatBaseData : public FTableRowBase
{
public:
	EM1StatType                                   StatTypeEnum;                                      // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EM1StatValueOrder                             ValueOrder;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StatBaseData) == 0x000008, "Wrong alignment on FM1StatBaseData");
static_assert(sizeof(FM1StatBaseData) == 0x000010, "Wrong size on FM1StatBaseData");
static_assert(offsetof(FM1StatBaseData, StatTypeEnum) == 0x000008, "Member 'FM1StatBaseData::StatTypeEnum' has a wrong offset!");
static_assert(offsetof(FM1StatBaseData, ValueOrder) == 0x00000C, "Member 'FM1StatBaseData::ValueOrder' has a wrong offset!");

// ScriptStruct M1Data.M1ProductDetailData
// 0x0060 (0x0060 - 0x0000)
struct FM1ProductDetailData final
{
public:
	struct FM1ItemDataBox                         Item;                                              // 0x0000(0x0038)(Edit, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PriceAmount;                                       // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiscountPriceAmount;                               // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         PlatformType;                                      // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StringId;                                          // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BGId;                                              // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortId;                                            // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ProductDetailData) == 0x000008, "Wrong alignment on FM1ProductDetailData");
static_assert(sizeof(FM1ProductDetailData) == 0x000060, "Wrong size on FM1ProductDetailData");
static_assert(offsetof(FM1ProductDetailData, Item) == 0x000000, "Member 'FM1ProductDetailData::Item' has a wrong offset!");
static_assert(offsetof(FM1ProductDetailData, Amount) == 0x000038, "Member 'FM1ProductDetailData::Amount' has a wrong offset!");
static_assert(offsetof(FM1ProductDetailData, PriceAmount) == 0x00003C, "Member 'FM1ProductDetailData::PriceAmount' has a wrong offset!");
static_assert(offsetof(FM1ProductDetailData, DiscountPriceAmount) == 0x000040, "Member 'FM1ProductDetailData::DiscountPriceAmount' has a wrong offset!");
static_assert(offsetof(FM1ProductDetailData, PlatformType) == 0x000044, "Member 'FM1ProductDetailData::PlatformType' has a wrong offset!");
static_assert(offsetof(FM1ProductDetailData, StringId) == 0x000048, "Member 'FM1ProductDetailData::StringId' has a wrong offset!");
static_assert(offsetof(FM1ProductDetailData, BGId) == 0x000050, "Member 'FM1ProductDetailData::BGId' has a wrong offset!");
static_assert(offsetof(FM1ProductDetailData, SortId) == 0x000058, "Member 'FM1ProductDetailData::SortId' has a wrong offset!");

// ScriptStruct M1Data.M1ProductData
// 0x0188 (0x0190 - 0x0008)
struct FM1ProductData : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ProductType                                Type;                                              // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ItemDataBox                         PriceType;                                         // 0x0010(0x0038)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1ProductDetailData>           Items;                                             // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1ProductDiscountPeriodData>   DiscountPeriodDataList;                            // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 GroupId;                                           // 0x0068(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1MailDataLink                        Mail;                                              // 0x0078(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FM1ProductUIData                       UIData;                                            // 0x00A8(0x0060)(Edit, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BGId;                                              // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisible;                                          // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPopular;                                          // 0x0119(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11A[0x6];                                      // 0x011A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        BGMaterial;                                        // 0x0120(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Page;                                              // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortId;                                            // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredLevel;                                     // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredPage;                                      // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              StartTime;                                         // 0x0150(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndTime;                                           // 0x0158(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuyableCount;                                      // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ShopResetType                              ResetType;                                         // 0x0164(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1DayOfWeek                                  ResetDayOfWeek;                                    // 0x0165(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_166[0x2];                                      // 0x0166(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResetHour;                                         // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 RepeatCount;                                       // 0x0170(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1ConsumableItemDataLink>      TicketInfos;                                       // 0x0180(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ProductData) == 0x000008, "Wrong alignment on FM1ProductData");
static_assert(sizeof(FM1ProductData) == 0x000190, "Wrong size on FM1ProductData");
static_assert(offsetof(FM1ProductData, TemplateId) == 0x000008, "Member 'FM1ProductData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1ProductData, Type) == 0x00000C, "Member 'FM1ProductData::Type' has a wrong offset!");
static_assert(offsetof(FM1ProductData, PriceType) == 0x000010, "Member 'FM1ProductData::PriceType' has a wrong offset!");
static_assert(offsetof(FM1ProductData, Items) == 0x000048, "Member 'FM1ProductData::Items' has a wrong offset!");
static_assert(offsetof(FM1ProductData, DiscountPeriodDataList) == 0x000058, "Member 'FM1ProductData::DiscountPeriodDataList' has a wrong offset!");
static_assert(offsetof(FM1ProductData, GroupId) == 0x000068, "Member 'FM1ProductData::GroupId' has a wrong offset!");
static_assert(offsetof(FM1ProductData, Mail) == 0x000078, "Member 'FM1ProductData::Mail' has a wrong offset!");
static_assert(offsetof(FM1ProductData, UIData) == 0x0000A8, "Member 'FM1ProductData::UIData' has a wrong offset!");
static_assert(offsetof(FM1ProductData, StringId) == 0x000108, "Member 'FM1ProductData::StringId' has a wrong offset!");
static_assert(offsetof(FM1ProductData, BGId) == 0x000110, "Member 'FM1ProductData::BGId' has a wrong offset!");
static_assert(offsetof(FM1ProductData, bVisible) == 0x000118, "Member 'FM1ProductData::bVisible' has a wrong offset!");
static_assert(offsetof(FM1ProductData, bPopular) == 0x000119, "Member 'FM1ProductData::bPopular' has a wrong offset!");
static_assert(offsetof(FM1ProductData, BGMaterial) == 0x000120, "Member 'FM1ProductData::BGMaterial' has a wrong offset!");
static_assert(offsetof(FM1ProductData, Page) == 0x000140, "Member 'FM1ProductData::Page' has a wrong offset!");
static_assert(offsetof(FM1ProductData, SortId) == 0x000144, "Member 'FM1ProductData::SortId' has a wrong offset!");
static_assert(offsetof(FM1ProductData, RequiredLevel) == 0x000148, "Member 'FM1ProductData::RequiredLevel' has a wrong offset!");
static_assert(offsetof(FM1ProductData, RequiredPage) == 0x00014C, "Member 'FM1ProductData::RequiredPage' has a wrong offset!");
static_assert(offsetof(FM1ProductData, StartTime) == 0x000150, "Member 'FM1ProductData::StartTime' has a wrong offset!");
static_assert(offsetof(FM1ProductData, EndTime) == 0x000158, "Member 'FM1ProductData::EndTime' has a wrong offset!");
static_assert(offsetof(FM1ProductData, BuyableCount) == 0x000160, "Member 'FM1ProductData::BuyableCount' has a wrong offset!");
static_assert(offsetof(FM1ProductData, ResetType) == 0x000164, "Member 'FM1ProductData::ResetType' has a wrong offset!");
static_assert(offsetof(FM1ProductData, ResetDayOfWeek) == 0x000165, "Member 'FM1ProductData::ResetDayOfWeek' has a wrong offset!");
static_assert(offsetof(FM1ProductData, ResetHour) == 0x000168, "Member 'FM1ProductData::ResetHour' has a wrong offset!");
static_assert(offsetof(FM1ProductData, RepeatCount) == 0x000170, "Member 'FM1ProductData::RepeatCount' has a wrong offset!");
static_assert(offsetof(FM1ProductData, TicketInfos) == 0x000180, "Member 'FM1ProductData::TicketInfos' has a wrong offset!");

// ScriptStruct M1Data.M1PaidProductData
// 0x0010 (0x01A0 - 0x0190)
struct FM1PaidProductData final : public FM1ProductData
{
public:
	TArray<struct FM1ProductIdInfo>               ProductIdInfoList;                                 // 0x0190(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PaidProductData) == 0x000008, "Wrong alignment on FM1PaidProductData");
static_assert(sizeof(FM1PaidProductData) == 0x0001A0, "Wrong size on FM1PaidProductData");
static_assert(offsetof(FM1PaidProductData, ProductIdInfoList) == 0x000190, "Member 'FM1PaidProductData::ProductIdInfoList' has a wrong offset!");

// ScriptStruct M1Data.M1StatData
// 0x0080 (0x0090 - 0x0010)
struct FM1StatData final : public FM1StatBaseData
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0010(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringId;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1StatUIData                          UIData;                                            // 0x0028(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1StatModifierClampInfo               ClampInfo;                                         // 0x0048(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CombatPowerConstant;                               // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        IconImage;                                         // 0x0068(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1GaugeStatInfo                       GaugeInfo;                                         // 0x0088(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B[0x1];                                       // 0x008B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SortOrder;                                         // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StatData) == 0x000008, "Wrong alignment on FM1StatData");
static_assert(sizeof(FM1StatData) == 0x000090, "Wrong size on FM1StatData");
static_assert(offsetof(FM1StatData, TemplateId) == 0x000010, "Member 'FM1StatData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1StatData, StringId) == 0x000018, "Member 'FM1StatData::StringId' has a wrong offset!");
static_assert(offsetof(FM1StatData, UIData) == 0x000028, "Member 'FM1StatData::UIData' has a wrong offset!");
static_assert(offsetof(FM1StatData, ClampInfo) == 0x000048, "Member 'FM1StatData::ClampInfo' has a wrong offset!");
static_assert(offsetof(FM1StatData, CombatPowerConstant) == 0x000060, "Member 'FM1StatData::CombatPowerConstant' has a wrong offset!");
static_assert(offsetof(FM1StatData, IconImage) == 0x000068, "Member 'FM1StatData::IconImage' has a wrong offset!");
static_assert(offsetof(FM1StatData, GaugeInfo) == 0x000088, "Member 'FM1StatData::GaugeInfo' has a wrong offset!");
static_assert(offsetof(FM1StatData, SortOrder) == 0x00008C, "Member 'FM1StatData::SortOrder' has a wrong offset!");

// ScriptStruct M1Data.M1InstantUseDropGroupData
// 0x0018 (0x0020 - 0x0008)
struct FM1InstantUseDropGroupData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1InstantUseDropGroupElement>  DropGroupElementList;                              // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstantUseDropGroupData) == 0x000008, "Wrong alignment on FM1InstantUseDropGroupData");
static_assert(sizeof(FM1InstantUseDropGroupData) == 0x000020, "Wrong size on FM1InstantUseDropGroupData");
static_assert(offsetof(FM1InstantUseDropGroupData, TemplateId) == 0x000008, "Member 'FM1InstantUseDropGroupData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1InstantUseDropGroupData, DropGroupElementList) == 0x000010, "Member 'FM1InstantUseDropGroupData::DropGroupElementList' has a wrong offset!");

// ScriptStruct M1Data.M1DediRequestInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1DediRequestInfo final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         DediOid;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DediRequestInfo) == 0x000008, "Wrong alignment on FM1DediRequestInfo");
static_assert(sizeof(FM1DediRequestInfo) == 0x000010, "Wrong size on FM1DediRequestInfo");
static_assert(offsetof(FM1DediRequestInfo, Index) == 0x000000, "Member 'FM1DediRequestInfo::Index' has a wrong offset!");
static_assert(offsetof(FM1DediRequestInfo, DediOid) == 0x000008, "Member 'FM1DediRequestInfo::DediOid' has a wrong offset!");

// ScriptStruct M1Data.M1ItemStringTableDataRow
// 0x0000 (0x0088 - 0x0088)
struct FM1ItemStringTableDataRow final : public FM1StringTableDataRow
{
};
static_assert(alignof(FM1ItemStringTableDataRow) == 0x000008, "Wrong alignment on FM1ItemStringTableDataRow");
static_assert(sizeof(FM1ItemStringTableDataRow) == 0x000088, "Wrong size on FM1ItemStringTableDataRow");

// ScriptStruct M1Data.M1ResearchResourceItem
// 0x0038 (0x0038 - 0x0000)
struct FM1ResearchResourceItem final
{
public:
	struct FM1ConsumableItemDataLink              ItemId;                                            // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ResearchResourceItem) == 0x000008, "Wrong alignment on FM1ResearchResourceItem");
static_assert(sizeof(FM1ResearchResourceItem) == 0x000038, "Wrong size on FM1ResearchResourceItem");
static_assert(offsetof(FM1ResearchResourceItem, ItemId) == 0x000000, "Member 'FM1ResearchResourceItem::ItemId' has a wrong offset!");
static_assert(offsetof(FM1ResearchResourceItem, Amount) == 0x000030, "Member 'FM1ResearchResourceItem::Amount' has a wrong offset!");

// ScriptStruct M1Data.M1SystemStringTableDataRow
// 0x0000 (0x0088 - 0x0088)
struct FM1SystemStringTableDataRow final : public FM1StringTableDataRow
{
};
static_assert(alignof(FM1SystemStringTableDataRow) == 0x000008, "Wrong alignment on FM1SystemStringTableDataRow");
static_assert(sizeof(FM1SystemStringTableDataRow) == 0x000088, "Wrong size on FM1SystemStringTableDataRow");

// ScriptStruct M1Data.M1UIStringTableDataRow
// 0x0000 (0x0088 - 0x0088)
struct FM1UIStringTableDataRow final : public FM1StringTableDataRow
{
};
static_assert(alignof(FM1UIStringTableDataRow) == 0x000008, "Wrong alignment on FM1UIStringTableDataRow");
static_assert(sizeof(FM1UIStringTableDataRow) == 0x000088, "Wrong size on FM1UIStringTableDataRow");

// ScriptStruct M1Data.M1VoidBattleUnlockCondition
// 0x0018 (0x0018 - 0x0000)
struct FM1VoidBattleUnlockCondition final
{
public:
	EM1VoidBattleUnlockConditionType              Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Params;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1VoidBattleUnlockCondition) == 0x000008, "Wrong alignment on FM1VoidBattleUnlockCondition");
static_assert(sizeof(FM1VoidBattleUnlockCondition) == 0x000018, "Wrong size on FM1VoidBattleUnlockCondition");
static_assert(offsetof(FM1VoidBattleUnlockCondition, Type) == 0x000000, "Member 'FM1VoidBattleUnlockCondition::Type' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleUnlockCondition, Params) == 0x000008, "Member 'FM1VoidBattleUnlockCondition::Params' has a wrong offset!");

// ScriptStruct M1Data.M1LevelByNumOfSquadMember
// 0x0008 (0x0008 - 0x0000)
struct FM1LevelByNumOfSquadMember final
{
public:
	int32                                         NumOfMembers;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterLevel;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1LevelByNumOfSquadMember) == 0x000004, "Wrong alignment on FM1LevelByNumOfSquadMember");
static_assert(sizeof(FM1LevelByNumOfSquadMember) == 0x000008, "Wrong size on FM1LevelByNumOfSquadMember");
static_assert(offsetof(FM1LevelByNumOfSquadMember, NumOfMembers) == 0x000000, "Member 'FM1LevelByNumOfSquadMember::NumOfMembers' has a wrong offset!");
static_assert(offsetof(FM1LevelByNumOfSquadMember, MonsterLevel) == 0x000004, "Member 'FM1LevelByNumOfSquadMember::MonsterLevel' has a wrong offset!");

// ScriptStruct M1Data.M1VoidBattleInfo
// 0x0050 (0x0050 - 0x0000)
struct FM1VoidBattleInfo final
{
public:
	class FString                                 MonsterId;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StringId;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1LevelByNumOfSquadMember>     MonsterLevelBySquad;                               // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EM1VoidBattleDifficulty                       Difficulty;                                        // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TimeLimit;                                         // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeathCount;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FieldId;                                           // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1VoidBattleInfo) == 0x000008, "Wrong alignment on FM1VoidBattleInfo");
static_assert(sizeof(FM1VoidBattleInfo) == 0x000050, "Wrong size on FM1VoidBattleInfo");
static_assert(offsetof(FM1VoidBattleInfo, MonsterId) == 0x000000, "Member 'FM1VoidBattleInfo::MonsterId' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleInfo, StringId) == 0x000010, "Member 'FM1VoidBattleInfo::StringId' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleInfo, MonsterLevelBySquad) == 0x000020, "Member 'FM1VoidBattleInfo::MonsterLevelBySquad' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleInfo, Difficulty) == 0x000030, "Member 'FM1VoidBattleInfo::Difficulty' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleInfo, TimeLimit) == 0x000034, "Member 'FM1VoidBattleInfo::TimeLimit' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleInfo, DeathCount) == 0x000038, "Member 'FM1VoidBattleInfo::DeathCount' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleInfo, FieldId) == 0x000040, "Member 'FM1VoidBattleInfo::FieldId' has a wrong offset!");

// ScriptStruct M1Data.M1PackageOpenerDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1PackageOpenerDataLink final : public FDataLink
{
};
static_assert(alignof(FM1PackageOpenerDataLink) == 0x000008, "Wrong alignment on FM1PackageOpenerDataLink");
static_assert(sizeof(FM1PackageOpenerDataLink) == 0x000030, "Wrong size on FM1PackageOpenerDataLink");

// ScriptStruct M1Data.M1VoidBattleRequiredItem
// 0x0038 (0x0038 - 0x0000)
struct FM1VoidBattleRequiredItem final
{
public:
	struct FM1ConsumableItemDataLink              ItemId;                                            // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1VoidBattleRequiredItem) == 0x000008, "Wrong alignment on FM1VoidBattleRequiredItem");
static_assert(sizeof(FM1VoidBattleRequiredItem) == 0x000038, "Wrong size on FM1VoidBattleRequiredItem");
static_assert(offsetof(FM1VoidBattleRequiredItem, ItemId) == 0x000000, "Member 'FM1VoidBattleRequiredItem::ItemId' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleRequiredItem, Amount) == 0x000030, "Member 'FM1VoidBattleRequiredItem::Amount' has a wrong offset!");

// ScriptStruct M1Data.M1VoidBattleRewards
// 0x0008 (0x0008 - 0x0000)
struct FM1VoidBattleRewards final
{
public:
	struct FM1CurrencyPair                        Currency;                                          // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1VoidBattleRewards) == 0x000004, "Wrong alignment on FM1VoidBattleRewards");
static_assert(sizeof(FM1VoidBattleRewards) == 0x000008, "Wrong size on FM1VoidBattleRewards");
static_assert(offsetof(FM1VoidBattleRewards, Currency) == 0x000000, "Member 'FM1VoidBattleRewards::Currency' has a wrong offset!");

// ScriptStruct M1Data.M1VoidBattleBossElementalResTypes
// 0x0004 (0x0004 - 0x0000)
struct FM1VoidBattleBossElementalResTypes final
{
public:
	EM1ElementalDegreeType                        BlazerResType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ElementalDegreeType                        GlacierResType;                                    // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ElementalDegreeType                        ElectricityResType;                                // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ElementalDegreeType                        DemonicResType;                                    // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1VoidBattleBossElementalResTypes) == 0x000001, "Wrong alignment on FM1VoidBattleBossElementalResTypes");
static_assert(sizeof(FM1VoidBattleBossElementalResTypes) == 0x000004, "Wrong size on FM1VoidBattleBossElementalResTypes");
static_assert(offsetof(FM1VoidBattleBossElementalResTypes, BlazerResType) == 0x000000, "Member 'FM1VoidBattleBossElementalResTypes::BlazerResType' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleBossElementalResTypes, GlacierResType) == 0x000001, "Member 'FM1VoidBattleBossElementalResTypes::GlacierResType' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleBossElementalResTypes, ElectricityResType) == 0x000002, "Member 'FM1VoidBattleBossElementalResTypes::ElectricityResType' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleBossElementalResTypes, DemonicResType) == 0x000003, "Member 'FM1VoidBattleBossElementalResTypes::DemonicResType' has a wrong offset!");

// ScriptStruct M1Data.M1VoidBattleBossInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1VoidBattleBossInfo final
{
public:
	EM1ElementalDamageChannel                     ElementalAtkType;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RecommendElementalDefValue;                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1VoidBattleBossElementalResTypes     ElementalResTypes;                                 // 0x0008(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         MinMembers;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1VoidBattleBossInfo) == 0x000004, "Wrong alignment on FM1VoidBattleBossInfo");
static_assert(sizeof(FM1VoidBattleBossInfo) == 0x000010, "Wrong size on FM1VoidBattleBossInfo");
static_assert(offsetof(FM1VoidBattleBossInfo, ElementalAtkType) == 0x000000, "Member 'FM1VoidBattleBossInfo::ElementalAtkType' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleBossInfo, RecommendElementalDefValue) == 0x000004, "Member 'FM1VoidBattleBossInfo::RecommendElementalDefValue' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleBossInfo, ElementalResTypes) == 0x000008, "Member 'FM1VoidBattleBossInfo::ElementalResTypes' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleBossInfo, MinMembers) == 0x00000C, "Member 'FM1VoidBattleBossInfo::MinMembers' has a wrong offset!");

// ScriptStruct M1Data.M1VoidBattleUIData
// 0x0080 (0x0080 - 0x0000)
struct FM1VoidBattleUIData final
{
public:
	struct FSoftObjectPath                        LockIconPath;                                      // 0x0000(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UnlockIconPath;                                    // 0x0020(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SmallIconPath;                                     // 0x0040(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         InfoWidgetPath;                                    // 0x0060(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1VoidBattleUIData) == 0x000008, "Wrong alignment on FM1VoidBattleUIData");
static_assert(sizeof(FM1VoidBattleUIData) == 0x000080, "Wrong size on FM1VoidBattleUIData");
static_assert(offsetof(FM1VoidBattleUIData, LockIconPath) == 0x000000, "Member 'FM1VoidBattleUIData::LockIconPath' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleUIData, UnlockIconPath) == 0x000020, "Member 'FM1VoidBattleUIData::UnlockIconPath' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleUIData, SmallIconPath) == 0x000040, "Member 'FM1VoidBattleUIData::SmallIconPath' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleUIData, InfoWidgetPath) == 0x000060, "Member 'FM1VoidBattleUIData::InfoWidgetPath' has a wrong offset!");

// ScriptStruct M1Data.M1VoidBattleData
// 0x0180 (0x0188 - 0x0008)
struct FM1VoidBattleData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1VoidBattleInfo                      VoidBattleInfos;                                   // 0x0010(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1VoidBattleRequiredItem>      RequiredItems;                                     // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1VoidBattleUnlockCondition>   UnlockConditions;                                  // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1VoidBattleStartCondition>    StartConditions;                                   // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1VoidBattleRewards                   Rewards;                                           // 0x0090(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1PackageOpenerDataLink               PackageOpenerId;                                   // 0x0098(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FM1VoidBattleBossInfo                  BossInfo;                                          // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1VoidBattleUIData                    UIData;                                            // 0x00D8(0x0080)(Edit, NativeAccessSpecifierPublic)
	struct FM1RecommendSpecsUIDataLink            RecommedSpecs;                                     // 0x0158(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1VoidBattleData) == 0x000008, "Wrong alignment on FM1VoidBattleData");
static_assert(sizeof(FM1VoidBattleData) == 0x000188, "Wrong size on FM1VoidBattleData");
static_assert(offsetof(FM1VoidBattleData, TemplateId) == 0x000008, "Member 'FM1VoidBattleData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleData, VoidBattleInfos) == 0x000010, "Member 'FM1VoidBattleData::VoidBattleInfos' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleData, RequiredItems) == 0x000060, "Member 'FM1VoidBattleData::RequiredItems' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleData, UnlockConditions) == 0x000070, "Member 'FM1VoidBattleData::UnlockConditions' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleData, StartConditions) == 0x000080, "Member 'FM1VoidBattleData::StartConditions' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleData, Rewards) == 0x000090, "Member 'FM1VoidBattleData::Rewards' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleData, PackageOpenerId) == 0x000098, "Member 'FM1VoidBattleData::PackageOpenerId' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleData, BossInfo) == 0x0000C8, "Member 'FM1VoidBattleData::BossInfo' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleData, UIData) == 0x0000D8, "Member 'FM1VoidBattleData::UIData' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleData, RecommedSpecs) == 0x000158, "Member 'FM1VoidBattleData::RecommedSpecs' has a wrong offset!");

// ScriptStruct M1Data.M1CharacterStringTableDataRow
// 0x0000 (0x0088 - 0x0088)
struct FM1CharacterStringTableDataRow final : public FM1StringTableDataRow
{
};
static_assert(alignof(FM1CharacterStringTableDataRow) == 0x000008, "Wrong alignment on FM1CharacterStringTableDataRow");
static_assert(sizeof(FM1CharacterStringTableDataRow) == 0x000088, "Wrong size on FM1CharacterStringTableDataRow");

// ScriptStruct M1Data.M1ReservedStringTableDataRow
// 0x0000 (0x0088 - 0x0088)
struct FM1ReservedStringTableDataRow final : public FM1StringTableDataRow
{
};
static_assert(alignof(FM1ReservedStringTableDataRow) == 0x000008, "Wrong alignment on FM1ReservedStringTableDataRow");
static_assert(sizeof(FM1ReservedStringTableDataRow) == 0x000088, "Wrong size on FM1ReservedStringTableDataRow");

// ScriptStruct M1Data.M1ContentsStringTableDataRow
// 0x0000 (0x0088 - 0x0088)
struct FM1ContentsStringTableDataRow final : public FM1StringTableDataRow
{
};
static_assert(alignof(FM1ContentsStringTableDataRow) == 0x000008, "Wrong alignment on FM1ContentsStringTableDataRow");
static_assert(sizeof(FM1ContentsStringTableDataRow) == 0x000088, "Wrong size on FM1ContentsStringTableDataRow");

// ScriptStruct M1Data.M1InstanceDungeonScoreInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1InstanceDungeonScoreInfo final
{
public:
	int32                                         MaxScore;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 MonsterKillScore;                                  // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceDungeonScoreInfo) == 0x000008, "Wrong alignment on FM1InstanceDungeonScoreInfo");
static_assert(sizeof(FM1InstanceDungeonScoreInfo) == 0x000018, "Wrong size on FM1InstanceDungeonScoreInfo");
static_assert(offsetof(FM1InstanceDungeonScoreInfo, MaxScore) == 0x000000, "Member 'FM1InstanceDungeonScoreInfo::MaxScore' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonScoreInfo, MonsterKillScore) == 0x000008, "Member 'FM1InstanceDungeonScoreInfo::MonsterKillScore' has a wrong offset!");

// ScriptStruct M1Data.M1ProductStringTableDataRow
// 0x0000 (0x0088 - 0x0088)
struct FM1ProductStringTableDataRow final : public FM1StringTableDataRow
{
};
static_assert(alignof(FM1ProductStringTableDataRow) == 0x000008, "Wrong alignment on FM1ProductStringTableDataRow");
static_assert(sizeof(FM1ProductStringTableDataRow) == 0x000088, "Wrong size on FM1ProductStringTableDataRow");

// ScriptStruct M1Data.M1InstanceDungeonScoreSection
// 0x0008 (0x0008 - 0x0000)
struct FM1InstanceDungeonScoreSection final
{
public:
	int32                                         Score;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ratio;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceDungeonScoreSection) == 0x000004, "Wrong alignment on FM1InstanceDungeonScoreSection");
static_assert(sizeof(FM1InstanceDungeonScoreSection) == 0x000008, "Wrong size on FM1InstanceDungeonScoreSection");
static_assert(offsetof(FM1InstanceDungeonScoreSection, Score) == 0x000000, "Member 'FM1InstanceDungeonScoreSection::Score' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonScoreSection, Ratio) == 0x000004, "Member 'FM1InstanceDungeonScoreSection::Ratio' has a wrong offset!");

// ScriptStruct M1Data.M1InstanceDungeonModifierPresetCommonInfo
// 0x0004 (0x0004 - 0x0000)
struct FM1InstanceDungeonModifierPresetCommonInfo final
{
public:
	float                                         ScoreBonus;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceDungeonModifierPresetCommonInfo) == 0x000004, "Wrong alignment on FM1InstanceDungeonModifierPresetCommonInfo");
static_assert(sizeof(FM1InstanceDungeonModifierPresetCommonInfo) == 0x000004, "Wrong size on FM1InstanceDungeonModifierPresetCommonInfo");
static_assert(offsetof(FM1InstanceDungeonModifierPresetCommonInfo, ScoreBonus) == 0x000000, "Member 'FM1InstanceDungeonModifierPresetCommonInfo::ScoreBonus' has a wrong offset!");

// ScriptStruct M1Data.M1RangeCondition
// 0x0018 (0x0018 - 0x0000)
struct FM1RangeCondition final
{
public:
	bool                                          NeedRangeCheck;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RangeMin;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeMax;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighRange;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowRange;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleRangeMax;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RangeCondition) == 0x000004, "Wrong alignment on FM1RangeCondition");
static_assert(sizeof(FM1RangeCondition) == 0x000018, "Wrong size on FM1RangeCondition");
static_assert(offsetof(FM1RangeCondition, NeedRangeCheck) == 0x000000, "Member 'FM1RangeCondition::NeedRangeCheck' has a wrong offset!");
static_assert(offsetof(FM1RangeCondition, RangeMin) == 0x000004, "Member 'FM1RangeCondition::RangeMin' has a wrong offset!");
static_assert(offsetof(FM1RangeCondition, RangeMax) == 0x000008, "Member 'FM1RangeCondition::RangeMax' has a wrong offset!");
static_assert(offsetof(FM1RangeCondition, HighRange) == 0x00000C, "Member 'FM1RangeCondition::HighRange' has a wrong offset!");
static_assert(offsetof(FM1RangeCondition, LowRange) == 0x000010, "Member 'FM1RangeCondition::LowRange' has a wrong offset!");
static_assert(offsetof(FM1RangeCondition, AngleRangeMax) == 0x000014, "Member 'FM1RangeCondition::AngleRangeMax' has a wrong offset!");

// ScriptStruct M1Data.M1HitPointInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1HitPointInfo final
{
public:
	class FString                                 BoneName;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HPDamageRate;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1DamageAdvantageType                        AdvantageType;                                     // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1HitPointInfo) == 0x000008, "Wrong alignment on FM1HitPointInfo");
static_assert(sizeof(FM1HitPointInfo) == 0x000018, "Wrong size on FM1HitPointInfo");
static_assert(offsetof(FM1HitPointInfo, BoneName) == 0x000000, "Member 'FM1HitPointInfo::BoneName' has a wrong offset!");
static_assert(offsetof(FM1HitPointInfo, HPDamageRate) == 0x000010, "Member 'FM1HitPointInfo::HPDamageRate' has a wrong offset!");
static_assert(offsetof(FM1HitPointInfo, AdvantageType) == 0x000014, "Member 'FM1HitPointInfo::AdvantageType' has a wrong offset!");

// ScriptStruct M1Data.M1HitPointData
// 0x0020 (0x0028 - 0x0008)
struct FM1HitPointData final : public FTableRowBase
{
public:
	class FString                                 StringId;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1HitPointInfo>                Param;                                             // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1HitPointData) == 0x000008, "Wrong alignment on FM1HitPointData");
static_assert(sizeof(FM1HitPointData) == 0x000028, "Wrong size on FM1HitPointData");
static_assert(offsetof(FM1HitPointData, StringId) == 0x000008, "Member 'FM1HitPointData::StringId' has a wrong offset!");
static_assert(offsetof(FM1HitPointData, Param) == 0x000018, "Member 'FM1HitPointData::Param' has a wrong offset!");

// ScriptStruct M1Data.M1PerkDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1PerkDataLink final : public FDataLink
{
};
static_assert(alignof(FM1PerkDataLink) == 0x000008, "Wrong alignment on FM1PerkDataLink");
static_assert(sizeof(FM1PerkDataLink) == 0x000030, "Wrong size on FM1PerkDataLink");

// ScriptStruct M1Data.M1InstanceDungeonModifierPresetDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1InstanceDungeonModifierPresetDataLink final : public FDataLink
{
};
static_assert(alignof(FM1InstanceDungeonModifierPresetDataLink) == 0x000008, "Wrong alignment on FM1InstanceDungeonModifierPresetDataLink");
static_assert(sizeof(FM1InstanceDungeonModifierPresetDataLink) == 0x000030, "Wrong size on FM1InstanceDungeonModifierPresetDataLink");

// ScriptStruct M1Data.M1NpcServiceUnlockData
// 0x0020 (0x0028 - 0x0008)
struct FM1NpcServiceUnlockData final : public FTableRowBase
{
public:
	EM1NpcServiceType                             ServiceType;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1NpcServiceUnlockCondition>   UnlockConditions;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   UnlockNotificationToastId;                         // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NpcServiceUnlockData) == 0x000008, "Wrong alignment on FM1NpcServiceUnlockData");
static_assert(sizeof(FM1NpcServiceUnlockData) == 0x000028, "Wrong size on FM1NpcServiceUnlockData");
static_assert(offsetof(FM1NpcServiceUnlockData, ServiceType) == 0x000008, "Member 'FM1NpcServiceUnlockData::ServiceType' has a wrong offset!");
static_assert(offsetof(FM1NpcServiceUnlockData, UnlockConditions) == 0x000010, "Member 'FM1NpcServiceUnlockData::UnlockConditions' has a wrong offset!");
static_assert(offsetof(FM1NpcServiceUnlockData, UnlockNotificationToastId) == 0x000020, "Member 'FM1NpcServiceUnlockData::UnlockNotificationToastId' has a wrong offset!");

// ScriptStruct M1Data.M1DialogData
// 0x0038 (0x0040 - 0x0008)
struct FM1DialogData final : public FTableRowBase
{
public:
	class FName                                   CharacterId;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1DialogueType                               Type;                                              // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VoiceKey;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextDialog;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1MarkerInfo>                  MarkerInfoList;                                    // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DialogData) == 0x000008, "Wrong alignment on FM1DialogData");
static_assert(sizeof(FM1DialogData) == 0x000040, "Wrong size on FM1DialogData");
static_assert(offsetof(FM1DialogData, CharacterId) == 0x000008, "Member 'FM1DialogData::CharacterId' has a wrong offset!");
static_assert(offsetof(FM1DialogData, Type) == 0x000010, "Member 'FM1DialogData::Type' has a wrong offset!");
static_assert(offsetof(FM1DialogData, VoiceKey) == 0x000018, "Member 'FM1DialogData::VoiceKey' has a wrong offset!");
static_assert(offsetof(FM1DialogData, NextDialog) == 0x000028, "Member 'FM1DialogData::NextDialog' has a wrong offset!");
static_assert(offsetof(FM1DialogData, MarkerInfoList) == 0x000030, "Member 'FM1DialogData::MarkerInfoList' has a wrong offset!");

// ScriptStruct M1Data.M1EncountData
// 0x0038 (0x0040 - 0x0008)
struct FM1EncountData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EncountLevelMin;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EncountLevelMax;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         EncountPointMin;                                   // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         EncountPointMax;                                   // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncountTimer;                                      // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1EncountInfo>                 Encount;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EncountData) == 0x000008, "Wrong alignment on FM1EncountData");
static_assert(sizeof(FM1EncountData) == 0x000040, "Wrong size on FM1EncountData");
static_assert(offsetof(FM1EncountData, TemplateId) == 0x000008, "Member 'FM1EncountData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1EncountData, EncountLevelMin) == 0x00000C, "Member 'FM1EncountData::EncountLevelMin' has a wrong offset!");
static_assert(offsetof(FM1EncountData, EncountLevelMax) == 0x000010, "Member 'FM1EncountData::EncountLevelMax' has a wrong offset!");
static_assert(offsetof(FM1EncountData, EncountPointMin) == 0x000018, "Member 'FM1EncountData::EncountPointMin' has a wrong offset!");
static_assert(offsetof(FM1EncountData, EncountPointMax) == 0x000020, "Member 'FM1EncountData::EncountPointMax' has a wrong offset!");
static_assert(offsetof(FM1EncountData, EncountTimer) == 0x000028, "Member 'FM1EncountData::EncountTimer' has a wrong offset!");
static_assert(offsetof(FM1EncountData, Encount) == 0x000030, "Member 'FM1EncountData::Encount' has a wrong offset!");

// ScriptStruct M1Data.M1InvasionDungeonMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1InvasionDungeonMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1InvasionDungeonMiscDataLink) == 0x000008, "Wrong alignment on FM1InvasionDungeonMiscDataLink");
static_assert(sizeof(FM1InvasionDungeonMiscDataLink) == 0x000030, "Wrong size on FM1InvasionDungeonMiscDataLink");

// ScriptStruct M1Data.M1MasteryRank
// 0x0008 (0x0008 - 0x0000)
struct FM1MasteryRank final
{
public:
	int32                                         Min;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MasteryRank) == 0x000004, "Wrong alignment on FM1MasteryRank");
static_assert(sizeof(FM1MasteryRank) == 0x000008, "Wrong size on FM1MasteryRank");
static_assert(offsetof(FM1MasteryRank, Min) == 0x000000, "Member 'FM1MasteryRank::Min' has a wrong offset!");
static_assert(offsetof(FM1MasteryRank, Max) == 0x000004, "Member 'FM1MasteryRank::Max' has a wrong offset!");

// ScriptStruct M1Data.M1ProficiencyDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1ProficiencyDataLink final : public FDataLink
{
};
static_assert(alignof(FM1ProficiencyDataLink) == 0x000008, "Wrong alignment on FM1ProficiencyDataLink");
static_assert(sizeof(FM1ProficiencyDataLink) == 0x000030, "Wrong size on FM1ProficiencyDataLink");

// ScriptStruct M1Data.M1LoadingTooltipData
// 0x0028 (0x0030 - 0x0008)
struct FM1LoadingTooltipData final : public FTableRowBase
{
public:
	class FString                                 StringId;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1MasteryRank                         MasteryRank;                                       // 0x0018(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Tags;                                              // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1LoadingTooltipData) == 0x000008, "Wrong alignment on FM1LoadingTooltipData");
static_assert(sizeof(FM1LoadingTooltipData) == 0x000030, "Wrong size on FM1LoadingTooltipData");
static_assert(offsetof(FM1LoadingTooltipData, StringId) == 0x000008, "Member 'FM1LoadingTooltipData::StringId' has a wrong offset!");
static_assert(offsetof(FM1LoadingTooltipData, MasteryRank) == 0x000018, "Member 'FM1LoadingTooltipData::MasteryRank' has a wrong offset!");
static_assert(offsetof(FM1LoadingTooltipData, Tags) == 0x000020, "Member 'FM1LoadingTooltipData::Tags' has a wrong offset!");

// ScriptStruct M1Data.M1TestAssetData
// 0x0020 (0x0028 - 0x0008)
struct FM1TestAssetData final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        AssetData;                                         // 0x0008(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TestAssetData) == 0x000008, "Wrong alignment on FM1TestAssetData");
static_assert(sizeof(FM1TestAssetData) == 0x000028, "Wrong size on FM1TestAssetData");
static_assert(offsetof(FM1TestAssetData, AssetData) == 0x000008, "Member 'FM1TestAssetData::AssetData' has a wrong offset!");

// ScriptStruct M1Data.M1InstanceDungeonFixedMODDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1InstanceDungeonFixedMODDataLink final : public FDataLink
{
};
static_assert(alignof(FM1InstanceDungeonFixedMODDataLink) == 0x000008, "Wrong alignment on FM1InstanceDungeonFixedMODDataLink");
static_assert(sizeof(FM1InstanceDungeonFixedMODDataLink) == 0x000030, "Wrong size on FM1InstanceDungeonFixedMODDataLink");

// ScriptStruct M1Data.M1AbilityTargetData
// 0x0030 (0x0030 - 0x0000)
struct FM1AbilityTargetData final
{
public:
	struct FSoftClassPath                         AbilityTargetClass;                                // 0x0000(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1AbilityParamData>            Params;                                            // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityTargetData) == 0x000008, "Wrong alignment on FM1AbilityTargetData");
static_assert(sizeof(FM1AbilityTargetData) == 0x000030, "Wrong size on FM1AbilityTargetData");
static_assert(offsetof(FM1AbilityTargetData, AbilityTargetClass) == 0x000000, "Member 'FM1AbilityTargetData::AbilityTargetClass' has a wrong offset!");
static_assert(offsetof(FM1AbilityTargetData, Params) == 0x000020, "Member 'FM1AbilityTargetData::Params' has a wrong offset!");

// ScriptStruct M1Data.M1RuneUIStatDesc
// 0x0028 (0x0028 - 0x0000)
struct FM1RuneUIStatDesc final
{
public:
	EM1StatType                                   StatEnum;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StatsType;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SeperatedStringKey;                                // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReferValue;                                        // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanNotCombine;                                    // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RuneUIStatDesc) == 0x000008, "Wrong alignment on FM1RuneUIStatDesc");
static_assert(sizeof(FM1RuneUIStatDesc) == 0x000028, "Wrong size on FM1RuneUIStatDesc");
static_assert(offsetof(FM1RuneUIStatDesc, StatEnum) == 0x000000, "Member 'FM1RuneUIStatDesc::StatEnum' has a wrong offset!");
static_assert(offsetof(FM1RuneUIStatDesc, StatsType) == 0x000008, "Member 'FM1RuneUIStatDesc::StatsType' has a wrong offset!");
static_assert(offsetof(FM1RuneUIStatDesc, SeperatedStringKey) == 0x000018, "Member 'FM1RuneUIStatDesc::SeperatedStringKey' has a wrong offset!");
static_assert(offsetof(FM1RuneUIStatDesc, ReferValue) == 0x000020, "Member 'FM1RuneUIStatDesc::ReferValue' has a wrong offset!");
static_assert(offsetof(FM1RuneUIStatDesc, bCanNotCombine) == 0x000024, "Member 'FM1RuneUIStatDesc::bCanNotCombine' has a wrong offset!");

// ScriptStruct M1Data.M1ReactorEnchantRequireDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1ReactorEnchantRequireDataLink final : public FDataLink
{
};
static_assert(alignof(FM1ReactorEnchantRequireDataLink) == 0x000008, "Wrong alignment on FM1ReactorEnchantRequireDataLink");
static_assert(sizeof(FM1ReactorEnchantRequireDataLink) == 0x000030, "Wrong size on FM1ReactorEnchantRequireDataLink");

// ScriptStruct M1Data.M1RuneUIReferData
// 0x0004 (0x0004 - 0x0000)
struct FM1RuneUIReferData final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneUIReferData) == 0x000004, "Wrong alignment on FM1RuneUIReferData");
static_assert(sizeof(FM1RuneUIReferData) == 0x000004, "Wrong size on FM1RuneUIReferData");
static_assert(offsetof(FM1RuneUIReferData, Value) == 0x000000, "Member 'FM1RuneUIReferData::Value' has a wrong offset!");

// ScriptStruct M1Data.M1RuneUIDesc
// 0x0030 (0x0030 - 0x0000)
struct FM1RuneUIDesc final
{
public:
	class FName                                   ConditionStringKey;                                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CommentStringKey;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1RuneUIReferData>             Refer;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1RuneUIStatDesc>              Stat;                                              // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneUIDesc) == 0x000008, "Wrong alignment on FM1RuneUIDesc");
static_assert(sizeof(FM1RuneUIDesc) == 0x000030, "Wrong size on FM1RuneUIDesc");
static_assert(offsetof(FM1RuneUIDesc, ConditionStringKey) == 0x000000, "Member 'FM1RuneUIDesc::ConditionStringKey' has a wrong offset!");
static_assert(offsetof(FM1RuneUIDesc, CommentStringKey) == 0x000008, "Member 'FM1RuneUIDesc::CommentStringKey' has a wrong offset!");
static_assert(offsetof(FM1RuneUIDesc, Refer) == 0x000010, "Member 'FM1RuneUIDesc::Refer' has a wrong offset!");
static_assert(offsetof(FM1RuneUIDesc, Stat) == 0x000020, "Member 'FM1RuneUIDesc::Stat' has a wrong offset!");

// ScriptStruct M1Data.M1RuneUIData
// 0x0028 (0x0030 - 0x0008)
struct FM1RuneUIData final : public FTableRowBase
{
public:
	class FString                                 StringId;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TitleStringKey;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1RuneUIDesc>                  CombineDesc;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneUIData) == 0x000008, "Wrong alignment on FM1RuneUIData");
static_assert(sizeof(FM1RuneUIData) == 0x000030, "Wrong size on FM1RuneUIData");
static_assert(offsetof(FM1RuneUIData, StringId) == 0x000008, "Member 'FM1RuneUIData::StringId' has a wrong offset!");
static_assert(offsetof(FM1RuneUIData, TitleStringKey) == 0x000018, "Member 'FM1RuneUIData::TitleStringKey' has a wrong offset!");
static_assert(offsetof(FM1RuneUIData, CombineDesc) == 0x000020, "Member 'FM1RuneUIData::CombineDesc' has a wrong offset!");

// ScriptStruct M1Data.M1MonsterHPInfoClass
// 0x0028 (0x0028 - 0x0000)
struct FM1MonsterHPInfoClass final
{
public:
	EM1MonsterCategory                            MonsterCategory;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         MonsterInfoClass;                                  // 0x0008(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterHPInfoClass) == 0x000008, "Wrong alignment on FM1MonsterHPInfoClass");
static_assert(sizeof(FM1MonsterHPInfoClass) == 0x000028, "Wrong size on FM1MonsterHPInfoClass");
static_assert(offsetof(FM1MonsterHPInfoClass, MonsterCategory) == 0x000000, "Member 'FM1MonsterHPInfoClass::MonsterCategory' has a wrong offset!");
static_assert(offsetof(FM1MonsterHPInfoClass, MonsterInfoClass) == 0x000008, "Member 'FM1MonsterHPInfoClass::MonsterInfoClass' has a wrong offset!");

// ScriptStruct M1Data.M1MonsterMiscData
// 0x0010 (0x0018 - 0x0008)
struct FM1MonsterMiscData final : public FTableRowBase
{
public:
	TArray<struct FM1MonsterHPInfoClass>          InfoClassList;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterMiscData) == 0x000008, "Wrong alignment on FM1MonsterMiscData");
static_assert(sizeof(FM1MonsterMiscData) == 0x000018, "Wrong size on FM1MonsterMiscData");
static_assert(offsetof(FM1MonsterMiscData, InfoClassList) == 0x000008, "Member 'FM1MonsterMiscData::InfoClassList' has a wrong offset!");

// ScriptStruct M1Data.M1RuneAutoEquip
// 0x0058 (0x0060 - 0x0008)
struct FM1RuneAutoEquip final : public FTableRowBase
{
public:
	struct FM1PlayerDataLink                      EquipTargetCharacter;                              // 0x0008(0x0030)(Edit, NativeAccessSpecifierPublic)
	EM1EquipItemClassType                         EquipTargetWeapon;                                 // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1RuneDataLink>                RuneList;                                          // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneAutoEquip) == 0x000008, "Wrong alignment on FM1RuneAutoEquip");
static_assert(sizeof(FM1RuneAutoEquip) == 0x000060, "Wrong size on FM1RuneAutoEquip");
static_assert(offsetof(FM1RuneAutoEquip, EquipTargetCharacter) == 0x000008, "Member 'FM1RuneAutoEquip::EquipTargetCharacter' has a wrong offset!");
static_assert(offsetof(FM1RuneAutoEquip, EquipTargetWeapon) == 0x000038, "Member 'FM1RuneAutoEquip::EquipTargetWeapon' has a wrong offset!");
static_assert(offsetof(FM1RuneAutoEquip, RuneList) == 0x000040, "Member 'FM1RuneAutoEquip::RuneList' has a wrong offset!");
static_assert(offsetof(FM1RuneAutoEquip, Comment) == 0x000050, "Member 'FM1RuneAutoEquip::Comment' has a wrong offset!");

// ScriptStruct M1Data.M1ItemOptionStat
// 0x0010 (0x0010 - 0x0000)
struct FM1ItemOptionStat final
{
public:
	EM1StatType                                   StatTypeEnum;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1StatModifierOp                             Op;                                                // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StatValueMin;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StatValueMax;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DecimalPlaces;                                     // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ItemOptionStat) == 0x000004, "Wrong alignment on FM1ItemOptionStat");
static_assert(sizeof(FM1ItemOptionStat) == 0x000010, "Wrong size on FM1ItemOptionStat");
static_assert(offsetof(FM1ItemOptionStat, StatTypeEnum) == 0x000000, "Member 'FM1ItemOptionStat::StatTypeEnum' has a wrong offset!");
static_assert(offsetof(FM1ItemOptionStat, Op) == 0x000001, "Member 'FM1ItemOptionStat::Op' has a wrong offset!");
static_assert(offsetof(FM1ItemOptionStat, StatValueMin) == 0x000004, "Member 'FM1ItemOptionStat::StatValueMin' has a wrong offset!");
static_assert(offsetof(FM1ItemOptionStat, StatValueMax) == 0x000008, "Member 'FM1ItemOptionStat::StatValueMax' has a wrong offset!");
static_assert(offsetof(FM1ItemOptionStat, DecimalPlaces) == 0x00000C, "Member 'FM1ItemOptionStat::DecimalPlaces' has a wrong offset!");

// ScriptStruct M1Data.M1InstanceDungeonMODDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1InstanceDungeonMODDataLink final : public FDataLink
{
};
static_assert(alignof(FM1InstanceDungeonMODDataLink) == 0x000008, "Wrong alignment on FM1InstanceDungeonMODDataLink");
static_assert(sizeof(FM1InstanceDungeonMODDataLink) == 0x000030, "Wrong size on FM1InstanceDungeonMODDataLink");

// ScriptStruct M1Data.M1ShopRestrictionInfo
// 0x0004 (0x0004 - 0x0000)
struct FM1ShopRestrictionInfo final
{
public:
	int32                                         ProductionTid;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ShopRestrictionInfo) == 0x000004, "Wrong alignment on FM1ShopRestrictionInfo");
static_assert(sizeof(FM1ShopRestrictionInfo) == 0x000004, "Wrong size on FM1ShopRestrictionInfo");
static_assert(offsetof(FM1ShopRestrictionInfo, ProductionTid) == 0x000000, "Member 'FM1ShopRestrictionInfo::ProductionTid' has a wrong offset!");

// ScriptStruct M1Data.M1ShopRestrictionInfoBundle
// 0x0010 (0x0010 - 0x0000)
struct FM1ShopRestrictionInfoBundle final
{
public:
	TArray<struct FM1ShopRestrictionInfo>         ShopRestrictionInfoList;                           // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ShopRestrictionInfoBundle) == 0x000008, "Wrong alignment on FM1ShopRestrictionInfoBundle");
static_assert(sizeof(FM1ShopRestrictionInfoBundle) == 0x000010, "Wrong size on FM1ShopRestrictionInfoBundle");
static_assert(offsetof(FM1ShopRestrictionInfoBundle, ShopRestrictionInfoList) == 0x000000, "Member 'FM1ShopRestrictionInfoBundle::ShopRestrictionInfoList' has a wrong offset!");

// ScriptStruct M1Data.M1ReactorEnchantEffectInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1ReactorEnchantEffectInfo final
{
public:
	int32                                         EnchantLevel;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1StatValuePair>               Stats;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ReactorEnchantEffectInfo) == 0x000008, "Wrong alignment on FM1ReactorEnchantEffectInfo");
static_assert(sizeof(FM1ReactorEnchantEffectInfo) == 0x000018, "Wrong size on FM1ReactorEnchantEffectInfo");
static_assert(offsetof(FM1ReactorEnchantEffectInfo, EnchantLevel) == 0x000000, "Member 'FM1ReactorEnchantEffectInfo::EnchantLevel' has a wrong offset!");
static_assert(offsetof(FM1ReactorEnchantEffectInfo, Stats) == 0x000008, "Member 'FM1ReactorEnchantEffectInfo::Stats' has a wrong offset!");

// ScriptStruct M1Data.M1ReactorEnchantEffectByItemLevel
// 0x0018 (0x0018 - 0x0000)
struct FM1ReactorEnchantEffectByItemLevel final
{
public:
	int32                                         ItemLevel;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1ReactorEnchantEffectInfo>    EnchantEffectInfo;                                 // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ReactorEnchantEffectByItemLevel) == 0x000008, "Wrong alignment on FM1ReactorEnchantEffectByItemLevel");
static_assert(sizeof(FM1ReactorEnchantEffectByItemLevel) == 0x000018, "Wrong size on FM1ReactorEnchantEffectByItemLevel");
static_assert(offsetof(FM1ReactorEnchantEffectByItemLevel, ItemLevel) == 0x000000, "Member 'FM1ReactorEnchantEffectByItemLevel::ItemLevel' has a wrong offset!");
static_assert(offsetof(FM1ReactorEnchantEffectByItemLevel, EnchantEffectInfo) == 0x000008, "Member 'FM1ReactorEnchantEffectByItemLevel::EnchantEffectInfo' has a wrong offset!");

// ScriptStruct M1Data.M1ReactorOptimizedCondition
// 0x0018 (0x0018 - 0x0000)
struct FM1ReactorOptimizedCondition final
{
public:
	EM1ReactorOptimizedConditionType              ConditionType;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ConditionId;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ReactorOptimizedCondition) == 0x000008, "Wrong alignment on FM1ReactorOptimizedCondition");
static_assert(sizeof(FM1ReactorOptimizedCondition) == 0x000018, "Wrong size on FM1ReactorOptimizedCondition");
static_assert(offsetof(FM1ReactorOptimizedCondition, ConditionType) == 0x000000, "Member 'FM1ReactorOptimizedCondition::ConditionType' has a wrong offset!");
static_assert(offsetof(FM1ReactorOptimizedCondition, ConditionId) == 0x000008, "Member 'FM1ReactorOptimizedCondition::ConditionId' has a wrong offset!");

// ScriptStruct M1Data.M1ReactorData
// 0x0078 (0x0168 - 0x00F0)
struct FM1ReactorData final : public FM1EquipmentData
{
public:
	bool                                          Enchantable;                                       // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1ReactorEnchantEffectByItemLevel> EnchantEffectByItemLv;                             // 0x00F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1ReactorAbilityDataLink              Ability;                                           // 0x0108(0x0030)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1AbilityParamData>            Params;                                            // 0x0138(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1TaggedAbilityParamData>      TaggedParams;                                      // 0x0148(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1ReactorOptimizedCondition>   OptimizedConditions;                               // 0x0158(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ReactorData) == 0x000008, "Wrong alignment on FM1ReactorData");
static_assert(sizeof(FM1ReactorData) == 0x000168, "Wrong size on FM1ReactorData");
static_assert(offsetof(FM1ReactorData, Enchantable) == 0x0000F0, "Member 'FM1ReactorData::Enchantable' has a wrong offset!");
static_assert(offsetof(FM1ReactorData, EnchantEffectByItemLv) == 0x0000F8, "Member 'FM1ReactorData::EnchantEffectByItemLv' has a wrong offset!");
static_assert(offsetof(FM1ReactorData, Ability) == 0x000108, "Member 'FM1ReactorData::Ability' has a wrong offset!");
static_assert(offsetof(FM1ReactorData, Params) == 0x000138, "Member 'FM1ReactorData::Params' has a wrong offset!");
static_assert(offsetof(FM1ReactorData, TaggedParams) == 0x000148, "Member 'FM1ReactorData::TaggedParams' has a wrong offset!");
static_assert(offsetof(FM1ReactorData, OptimizedConditions) == 0x000158, "Member 'FM1ReactorData::OptimizedConditions' has a wrong offset!");

// ScriptStruct M1Data.M1SkillTargetSearchParam
// 0x0028 (0x0028 - 0x0000)
struct FM1SkillTargetSearchParam final
{
public:
	struct FSoftObjectPath                        EnvQuery;                                          // 0x0000(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusMin;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusMax;                                         // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SkillTargetSearchParam) == 0x000008, "Wrong alignment on FM1SkillTargetSearchParam");
static_assert(sizeof(FM1SkillTargetSearchParam) == 0x000028, "Wrong size on FM1SkillTargetSearchParam");
static_assert(offsetof(FM1SkillTargetSearchParam, EnvQuery) == 0x000000, "Member 'FM1SkillTargetSearchParam::EnvQuery' has a wrong offset!");
static_assert(offsetof(FM1SkillTargetSearchParam, RadiusMin) == 0x000020, "Member 'FM1SkillTargetSearchParam::RadiusMin' has a wrong offset!");
static_assert(offsetof(FM1SkillTargetSearchParam, RadiusMax) == 0x000024, "Member 'FM1SkillTargetSearchParam::RadiusMax' has a wrong offset!");

// ScriptStruct M1Data.M1TitleDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1TitleDataLink final : public FDataLink
{
};
static_assert(alignof(FM1TitleDataLink) == 0x000008, "Wrong alignment on FM1TitleDataLink");
static_assert(sizeof(FM1TitleDataLink) == 0x000030, "Wrong size on FM1TitleDataLink");

// ScriptStruct M1Data.M1EpicMonsterSkillData
// 0x0000 (0x0130 - 0x0130)
struct FM1EpicMonsterSkillData final : public FM1SkillData
{
};
static_assert(alignof(FM1EpicMonsterSkillData) == 0x000008, "Wrong alignment on FM1EpicMonsterSkillData");
static_assert(sizeof(FM1EpicMonsterSkillData) == 0x000130, "Wrong size on FM1EpicMonsterSkillData");

// ScriptStruct M1Data.M1MonsterSkillData
// 0x0050 (0x0180 - 0x0130)
struct FM1MonsterSkillData : public FM1SkillData
{
public:
	float                                         SelectRate;                                        // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1RangeCondition                      RangeCondition;                                    // 0x0134(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1SkillTargetSearchParam              SearchParam;                                       // 0x0150(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          bStopSkillWhenMainTargetInvalid;                   // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanMove;                                          // 0x0179(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17A[0x6];                                      // 0x017A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MonsterSkillData) == 0x000008, "Wrong alignment on FM1MonsterSkillData");
static_assert(sizeof(FM1MonsterSkillData) == 0x000180, "Wrong size on FM1MonsterSkillData");
static_assert(offsetof(FM1MonsterSkillData, SelectRate) == 0x000130, "Member 'FM1MonsterSkillData::SelectRate' has a wrong offset!");
static_assert(offsetof(FM1MonsterSkillData, RangeCondition) == 0x000134, "Member 'FM1MonsterSkillData::RangeCondition' has a wrong offset!");
static_assert(offsetof(FM1MonsterSkillData, SearchParam) == 0x000150, "Member 'FM1MonsterSkillData::SearchParam' has a wrong offset!");
static_assert(offsetof(FM1MonsterSkillData, bStopSkillWhenMainTargetInvalid) == 0x000178, "Member 'FM1MonsterSkillData::bStopSkillWhenMainTargetInvalid' has a wrong offset!");
static_assert(offsetof(FM1MonsterSkillData, bCanMove) == 0x000179, "Member 'FM1MonsterSkillData::bCanMove' has a wrong offset!");

// ScriptStruct M1Data.M1EliteMonsterSkillData
// 0x0010 (0x0140 - 0x0130)
struct FM1EliteMonsterSkillData final : public FM1SkillData
{
public:
	bool                                          DontGiveByMonster;                                 // 0x0130(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   UIGroupId;                                         // 0x0134(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1EliteMonsterSkillData) == 0x000008, "Wrong alignment on FM1EliteMonsterSkillData");
static_assert(sizeof(FM1EliteMonsterSkillData) == 0x000140, "Wrong size on FM1EliteMonsterSkillData");
static_assert(offsetof(FM1EliteMonsterSkillData, DontGiveByMonster) == 0x000130, "Member 'FM1EliteMonsterSkillData::DontGiveByMonster' has a wrong offset!");
static_assert(offsetof(FM1EliteMonsterSkillData, UIGroupId) == 0x000134, "Member 'FM1EliteMonsterSkillData::UIGroupId' has a wrong offset!");

// ScriptStruct M1Data.M1DifficultyInfoDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1DifficultyInfoDataLink final : public FDataLink
{
};
static_assert(alignof(FM1DifficultyInfoDataLink) == 0x000008, "Wrong alignment on FM1DifficultyInfoDataLink");
static_assert(sizeof(FM1DifficultyInfoDataLink) == 0x000030, "Wrong size on FM1DifficultyInfoDataLink");

// ScriptStruct M1Data.M1ReactorEnchantRequiredItemData
// 0x0014 (0x0014 - 0x0000)
struct FM1ReactorEnchantRequiredItemData final
{
public:
	EM1ItemType                                   ItemType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ID;                                                // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConditionLevel;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ReactorEnchantRequiredItemData) == 0x000004, "Wrong alignment on FM1ReactorEnchantRequiredItemData");
static_assert(sizeof(FM1ReactorEnchantRequiredItemData) == 0x000014, "Wrong size on FM1ReactorEnchantRequiredItemData");
static_assert(offsetof(FM1ReactorEnchantRequiredItemData, ItemType) == 0x000000, "Member 'FM1ReactorEnchantRequiredItemData::ItemType' has a wrong offset!");
static_assert(offsetof(FM1ReactorEnchantRequiredItemData, ID) == 0x000004, "Member 'FM1ReactorEnchantRequiredItemData::ID' has a wrong offset!");
static_assert(offsetof(FM1ReactorEnchantRequiredItemData, Amount) == 0x00000C, "Member 'FM1ReactorEnchantRequiredItemData::Amount' has a wrong offset!");
static_assert(offsetof(FM1ReactorEnchantRequiredItemData, ConditionLevel) == 0x000010, "Member 'FM1ReactorEnchantRequiredItemData::ConditionLevel' has a wrong offset!");

// ScriptStruct M1Data.M1ReactorEnchantRequiredData
// 0x0018 (0x0018 - 0x0000)
struct FM1ReactorEnchantRequiredData final
{
public:
	int32                                         EnchantLevel;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1ReactorEnchantRequiredItemData> RequiredItemDataList;                              // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ReactorEnchantRequiredData) == 0x000008, "Wrong alignment on FM1ReactorEnchantRequiredData");
static_assert(sizeof(FM1ReactorEnchantRequiredData) == 0x000018, "Wrong size on FM1ReactorEnchantRequiredData");
static_assert(offsetof(FM1ReactorEnchantRequiredData, EnchantLevel) == 0x000000, "Member 'FM1ReactorEnchantRequiredData::EnchantLevel' has a wrong offset!");
static_assert(offsetof(FM1ReactorEnchantRequiredData, RequiredItemDataList) == 0x000008, "Member 'FM1ReactorEnchantRequiredData::RequiredItemDataList' has a wrong offset!");

// ScriptStruct M1Data.M1ReactorEnchantRequiredDataByItemLevel
// 0x0018 (0x0018 - 0x0000)
struct FM1ReactorEnchantRequiredDataByItemLevel final
{
public:
	int32                                         ItemLevel;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1ReactorEnchantRequiredData>  RequireDataByEnchantLv;                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ReactorEnchantRequiredDataByItemLevel) == 0x000008, "Wrong alignment on FM1ReactorEnchantRequiredDataByItemLevel");
static_assert(sizeof(FM1ReactorEnchantRequiredDataByItemLevel) == 0x000018, "Wrong size on FM1ReactorEnchantRequiredDataByItemLevel");
static_assert(offsetof(FM1ReactorEnchantRequiredDataByItemLevel, ItemLevel) == 0x000000, "Member 'FM1ReactorEnchantRequiredDataByItemLevel::ItemLevel' has a wrong offset!");
static_assert(offsetof(FM1ReactorEnchantRequiredDataByItemLevel, RequireDataByEnchantLv) == 0x000008, "Member 'FM1ReactorEnchantRequiredDataByItemLevel::RequireDataByEnchantLv' has a wrong offset!");

// ScriptStruct M1Data.M1ReactorEnchantRequireData
// 0x0018 (0x0020 - 0x0008)
struct FM1ReactorEnchantRequireData final : public FTableRowBase
{
public:
	EM1ItemTierType                               Tier;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1ReactorEnchantRequiredDataByItemLevel> EnchantRequireDataByItemLv;                        // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ReactorEnchantRequireData) == 0x000008, "Wrong alignment on FM1ReactorEnchantRequireData");
static_assert(sizeof(FM1ReactorEnchantRequireData) == 0x000020, "Wrong size on FM1ReactorEnchantRequireData");
static_assert(offsetof(FM1ReactorEnchantRequireData, Tier) == 0x000008, "Member 'FM1ReactorEnchantRequireData::Tier' has a wrong offset!");
static_assert(offsetof(FM1ReactorEnchantRequireData, EnchantRequireDataByItemLv) == 0x000010, "Member 'FM1ReactorEnchantRequireData::EnchantRequireDataByItemLv' has a wrong offset!");

// ScriptStruct M1Data.M1EliteMonsterSkillSelectInfo
// 0x0038 (0x0038 - 0x0000)
struct FM1EliteMonsterSkillSelectInfo final
{
public:
	struct FM1EliteMonsterSkillDataLink           ID;                                                // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1EliteMonsterSkillSelectInfo) == 0x000008, "Wrong alignment on FM1EliteMonsterSkillSelectInfo");
static_assert(sizeof(FM1EliteMonsterSkillSelectInfo) == 0x000038, "Wrong size on FM1EliteMonsterSkillSelectInfo");
static_assert(offsetof(FM1EliteMonsterSkillSelectInfo, ID) == 0x000000, "Member 'FM1EliteMonsterSkillSelectInfo::ID' has a wrong offset!");
static_assert(offsetof(FM1EliteMonsterSkillSelectInfo, Rate) == 0x000030, "Member 'FM1EliteMonsterSkillSelectInfo::Rate' has a wrong offset!");

// ScriptStruct M1Data.M1EliteMonsterSkillGroupData
// 0x0010 (0x0018 - 0x0008)
struct FM1EliteMonsterSkillGroupData final : public FTableRowBase
{
public:
	TArray<struct FM1EliteMonsterSkillSelectInfo> Skills;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EliteMonsterSkillGroupData) == 0x000008, "Wrong alignment on FM1EliteMonsterSkillGroupData");
static_assert(sizeof(FM1EliteMonsterSkillGroupData) == 0x000018, "Wrong size on FM1EliteMonsterSkillGroupData");
static_assert(offsetof(FM1EliteMonsterSkillGroupData, Skills) == 0x000008, "Member 'FM1EliteMonsterSkillGroupData::Skills' has a wrong offset!");

// ScriptStruct M1Data.M1SkillAbilityData
// 0x0048 (0x00B8 - 0x0070)
struct FM1SkillAbilityData final : public FM1AbilityData
{
public:
	struct FSoftObjectPath                        Montage;                                           // 0x0070(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Sequence;                                          // 0x0090(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeInterrupted;                                 // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SkillAbilityData) == 0x000008, "Wrong alignment on FM1SkillAbilityData");
static_assert(sizeof(FM1SkillAbilityData) == 0x0000B8, "Wrong size on FM1SkillAbilityData");
static_assert(offsetof(FM1SkillAbilityData, Montage) == 0x000070, "Member 'FM1SkillAbilityData::Montage' has a wrong offset!");
static_assert(offsetof(FM1SkillAbilityData, Sequence) == 0x000090, "Member 'FM1SkillAbilityData::Sequence' has a wrong offset!");
static_assert(offsetof(FM1SkillAbilityData, bCanBeInterrupted) == 0x0000B0, "Member 'FM1SkillAbilityData::bCanBeInterrupted' has a wrong offset!");

// ScriptStruct M1Data.M1SkillRedirectInfo
// 0x0040 (0x0040 - 0x0000)
struct FM1SkillRedirectInfo final
{
public:
	struct FM1SkillDataLink                       Skill;                                             // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	class FString                                 Slot;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SkillRedirectInfo) == 0x000008, "Wrong alignment on FM1SkillRedirectInfo");
static_assert(sizeof(FM1SkillRedirectInfo) == 0x000040, "Wrong size on FM1SkillRedirectInfo");
static_assert(offsetof(FM1SkillRedirectInfo, Skill) == 0x000000, "Member 'FM1SkillRedirectInfo::Skill' has a wrong offset!");
static_assert(offsetof(FM1SkillRedirectInfo, Slot) == 0x000030, "Member 'FM1SkillRedirectInfo::Slot' has a wrong offset!");

// ScriptStruct M1Data.M1AchievementCategoryDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1AchievementCategoryDataLink final : public FDataLink
{
};
static_assert(alignof(FM1AchievementCategoryDataLink) == 0x000008, "Wrong alignment on FM1AchievementCategoryDataLink");
static_assert(sizeof(FM1AchievementCategoryDataLink) == 0x000030, "Wrong size on FM1AchievementCategoryDataLink");

// ScriptStruct M1Data.M1SkillRedirectData
// 0x0020 (0x0028 - 0x0008)
struct FM1SkillRedirectData final : public FTableRowBase
{
public:
	TArray<struct FM1SkillRedirectInfo>           NormalSkills;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1SkillRedirectInfo>           UltimateSkills;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SkillRedirectData) == 0x000008, "Wrong alignment on FM1SkillRedirectData");
static_assert(sizeof(FM1SkillRedirectData) == 0x000028, "Wrong size on FM1SkillRedirectData");
static_assert(offsetof(FM1SkillRedirectData, NormalSkills) == 0x000008, "Member 'FM1SkillRedirectData::NormalSkills' has a wrong offset!");
static_assert(offsetof(FM1SkillRedirectData, UltimateSkills) == 0x000018, "Member 'FM1SkillRedirectData::UltimateSkills' has a wrong offset!");

// ScriptStruct M1Data.M1SkillTooltipLevelData
// 0x0018 (0x0018 - 0x0000)
struct FM1SkillTooltipLevelData final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1AbilityParamData>            Params;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SkillTooltipLevelData) == 0x000008, "Wrong alignment on FM1SkillTooltipLevelData");
static_assert(sizeof(FM1SkillTooltipLevelData) == 0x000018, "Wrong size on FM1SkillTooltipLevelData");
static_assert(offsetof(FM1SkillTooltipLevelData, Level) == 0x000000, "Member 'FM1SkillTooltipLevelData::Level' has a wrong offset!");
static_assert(offsetof(FM1SkillTooltipLevelData, Params) == 0x000008, "Member 'FM1SkillTooltipLevelData::Params' has a wrong offset!");

// ScriptStruct M1Data.M1SkillTooltipDetailData
// 0x0050 (0x0050 - 0x0000)
struct FM1SkillTooltipDetailData final
{
public:
	class FName                                   DataStringID;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FormatStringID;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1SkillInfoTextFormatType                    TextFormatType;                                    // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DecimalPlaces;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1SkillInfoBenefitType                       BenefitType;                                       // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         CalcClass;                                         // 0x0020(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1SkillTooltipLevelData>       LvData;                                            // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SkillTooltipDetailData) == 0x000008, "Wrong alignment on FM1SkillTooltipDetailData");
static_assert(sizeof(FM1SkillTooltipDetailData) == 0x000050, "Wrong size on FM1SkillTooltipDetailData");
static_assert(offsetof(FM1SkillTooltipDetailData, DataStringID) == 0x000000, "Member 'FM1SkillTooltipDetailData::DataStringID' has a wrong offset!");
static_assert(offsetof(FM1SkillTooltipDetailData, FormatStringID) == 0x000008, "Member 'FM1SkillTooltipDetailData::FormatStringID' has a wrong offset!");
static_assert(offsetof(FM1SkillTooltipDetailData, TextFormatType) == 0x000010, "Member 'FM1SkillTooltipDetailData::TextFormatType' has a wrong offset!");
static_assert(offsetof(FM1SkillTooltipDetailData, DecimalPlaces) == 0x000014, "Member 'FM1SkillTooltipDetailData::DecimalPlaces' has a wrong offset!");
static_assert(offsetof(FM1SkillTooltipDetailData, BenefitType) == 0x000018, "Member 'FM1SkillTooltipDetailData::BenefitType' has a wrong offset!");
static_assert(offsetof(FM1SkillTooltipDetailData, CalcClass) == 0x000020, "Member 'FM1SkillTooltipDetailData::CalcClass' has a wrong offset!");
static_assert(offsetof(FM1SkillTooltipDetailData, LvData) == 0x000040, "Member 'FM1SkillTooltipDetailData::LvData' has a wrong offset!");

// ScriptStruct M1Data.M1SeasonDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1SeasonDataLink final : public FDataLink
{
};
static_assert(alignof(FM1SeasonDataLink) == 0x000008, "Wrong alignment on FM1SeasonDataLink");
static_assert(sizeof(FM1SeasonDataLink) == 0x000030, "Wrong size on FM1SeasonDataLink");

// ScriptStruct M1Data.M1SkillTooltipData
// 0x0018 (0x0020 - 0x0008)
struct FM1SkillTooltipData : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1SkillTooltipDetailData>      DetailData;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SkillTooltipData) == 0x000008, "Wrong alignment on FM1SkillTooltipData");
static_assert(sizeof(FM1SkillTooltipData) == 0x000020, "Wrong size on FM1SkillTooltipData");
static_assert(offsetof(FM1SkillTooltipData, Name) == 0x000008, "Member 'FM1SkillTooltipData::Name' has a wrong offset!");
static_assert(offsetof(FM1SkillTooltipData, DetailData) == 0x000010, "Member 'FM1SkillTooltipData::DetailData' has a wrong offset!");

// ScriptStruct M1Data.M1ItemLevelUpgradeDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1ItemLevelUpgradeDataLink final : public FDataLink
{
};
static_assert(alignof(FM1ItemLevelUpgradeDataLink) == 0x000008, "Wrong alignment on FM1ItemLevelUpgradeDataLink");
static_assert(sizeof(FM1ItemLevelUpgradeDataLink) == 0x000030, "Wrong size on FM1ItemLevelUpgradeDataLink");

// ScriptStruct M1Data.M1PerkTooltipData
// 0x0000 (0x0020 - 0x0020)
struct FM1PerkTooltipData final : public FM1SkillTooltipData
{
};
static_assert(alignof(FM1PerkTooltipData) == 0x000008, "Wrong alignment on FM1PerkTooltipData");
static_assert(sizeof(FM1PerkTooltipData) == 0x000020, "Wrong size on FM1PerkTooltipData");

// ScriptStruct M1Data.M1SeasonReinforceAbilityData
// 0x0000 (0x0070 - 0x0070)
struct FM1SeasonReinforceAbilityData final : public FM1AbilityData
{
};
static_assert(alignof(FM1SeasonReinforceAbilityData) == 0x000008, "Wrong alignment on FM1SeasonReinforceAbilityData");
static_assert(sizeof(FM1SeasonReinforceAbilityData) == 0x000070, "Wrong size on FM1SeasonReinforceAbilityData");

// ScriptStruct M1Data.M1SeasonReinforceData
// 0x0060 (0x0068 - 0x0008)
struct FM1SeasonReinforceData final : public FTableRowBase
{
public:
	class FName                                   StringId;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0010(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1SeasonReinforceGroupType                   GroupType;                                         // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Cooltime;                                          // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1SeasonReinforceAbilityDataLink      SeasonReinforceAbility;                            // 0x0038(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SeasonReinforceData) == 0x000008, "Wrong alignment on FM1SeasonReinforceData");
static_assert(sizeof(FM1SeasonReinforceData) == 0x000068, "Wrong size on FM1SeasonReinforceData");
static_assert(offsetof(FM1SeasonReinforceData, StringId) == 0x000008, "Member 'FM1SeasonReinforceData::StringId' has a wrong offset!");
static_assert(offsetof(FM1SeasonReinforceData, IconPath) == 0x000010, "Member 'FM1SeasonReinforceData::IconPath' has a wrong offset!");
static_assert(offsetof(FM1SeasonReinforceData, GroupType) == 0x000030, "Member 'FM1SeasonReinforceData::GroupType' has a wrong offset!");
static_assert(offsetof(FM1SeasonReinforceData, Cooltime) == 0x000034, "Member 'FM1SeasonReinforceData::Cooltime' has a wrong offset!");
static_assert(offsetof(FM1SeasonReinforceData, SeasonReinforceAbility) == 0x000038, "Member 'FM1SeasonReinforceData::SeasonReinforceAbility' has a wrong offset!");

// ScriptStruct M1Data.M1RuneMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1RuneMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1RuneMiscDataLink) == 0x000008, "Wrong alignment on FM1RuneMiscDataLink");
static_assert(sizeof(FM1RuneMiscDataLink) == 0x000030, "Wrong size on FM1RuneMiscDataLink");

// ScriptStruct M1Data.M1StatusEffectUIData
// 0x0038 (0x0038 - 0x0000)
struct FM1StatusEffectUIData final
{
public:
	struct FSoftObjectPath                        Icon;                                              // 0x0000(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NoticeStringId;                                    // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ToastId;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StatusEffectUIData) == 0x000008, "Wrong alignment on FM1StatusEffectUIData");
static_assert(sizeof(FM1StatusEffectUIData) == 0x000038, "Wrong size on FM1StatusEffectUIData");
static_assert(offsetof(FM1StatusEffectUIData, Icon) == 0x000000, "Member 'FM1StatusEffectUIData::Icon' has a wrong offset!");
static_assert(offsetof(FM1StatusEffectUIData, NoticeStringId) == 0x000020, "Member 'FM1StatusEffectUIData::NoticeStringId' has a wrong offset!");
static_assert(offsetof(FM1StatusEffectUIData, ToastId) == 0x000030, "Member 'FM1StatusEffectUIData::ToastId' has a wrong offset!");

// ScriptStruct M1Data.M1QuestGroupDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1QuestGroupDataLink final : public FDataLink
{
};
static_assert(alignof(FM1QuestGroupDataLink) == 0x000008, "Wrong alignment on FM1QuestGroupDataLink");
static_assert(sizeof(FM1QuestGroupDataLink) == 0x000030, "Wrong size on FM1QuestGroupDataLink");

// ScriptStruct M1Data.M1StatusEffectData
// 0x0098 (0x0108 - 0x0070)
struct FM1StatusEffectData final : public FM1AbilityData
{
public:
	struct FGameplayTag                           BlockingOwnerTag;                                  // 0x0070(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Channel;                                           // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ApplyPriority;                                     // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1StatusEffectAmassType                      AmassType;                                         // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplaceOnlyDuration;                              // 0x0081(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x2];                                       // 0x0082(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxStackCount;                                     // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartStackCount;                                   // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1StatusEffectStackDecreasePolicy            StackDecreasePolicy;                               // 0x008C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Duration;                                          // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Period;                                            // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1StatusEffectUIData                  UIData;                                            // 0x00A8(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTag                           IdTag;                                             // 0x00E0(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   RemoveTags;                                        // 0x00E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   ImmuneTags;                                        // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StatusEffectData) == 0x000008, "Wrong alignment on FM1StatusEffectData");
static_assert(sizeof(FM1StatusEffectData) == 0x000108, "Wrong size on FM1StatusEffectData");
static_assert(offsetof(FM1StatusEffectData, BlockingOwnerTag) == 0x000070, "Member 'FM1StatusEffectData::BlockingOwnerTag' has a wrong offset!");
static_assert(offsetof(FM1StatusEffectData, Channel) == 0x000078, "Member 'FM1StatusEffectData::Channel' has a wrong offset!");
static_assert(offsetof(FM1StatusEffectData, ApplyPriority) == 0x00007C, "Member 'FM1StatusEffectData::ApplyPriority' has a wrong offset!");
static_assert(offsetof(FM1StatusEffectData, AmassType) == 0x000080, "Member 'FM1StatusEffectData::AmassType' has a wrong offset!");
static_assert(offsetof(FM1StatusEffectData, bReplaceOnlyDuration) == 0x000081, "Member 'FM1StatusEffectData::bReplaceOnlyDuration' has a wrong offset!");
static_assert(offsetof(FM1StatusEffectData, MaxStackCount) == 0x000084, "Member 'FM1StatusEffectData::MaxStackCount' has a wrong offset!");
static_assert(offsetof(FM1StatusEffectData, StartStackCount) == 0x000088, "Member 'FM1StatusEffectData::StartStackCount' has a wrong offset!");
static_assert(offsetof(FM1StatusEffectData, StackDecreasePolicy) == 0x00008C, "Member 'FM1StatusEffectData::StackDecreasePolicy' has a wrong offset!");
static_assert(offsetof(FM1StatusEffectData, Duration) == 0x000090, "Member 'FM1StatusEffectData::Duration' has a wrong offset!");
static_assert(offsetof(FM1StatusEffectData, Period) == 0x0000A0, "Member 'FM1StatusEffectData::Period' has a wrong offset!");
static_assert(offsetof(FM1StatusEffectData, UIData) == 0x0000A8, "Member 'FM1StatusEffectData::UIData' has a wrong offset!");
static_assert(offsetof(FM1StatusEffectData, IdTag) == 0x0000E0, "Member 'FM1StatusEffectData::IdTag' has a wrong offset!");
static_assert(offsetof(FM1StatusEffectData, RemoveTags) == 0x0000E8, "Member 'FM1StatusEffectData::RemoveTags' has a wrong offset!");
static_assert(offsetof(FM1StatusEffectData, ImmuneTags) == 0x0000F8, "Member 'FM1StatusEffectData::ImmuneTags' has a wrong offset!");

// ScriptStruct M1Data.M1SummonsLevelInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1SummonsLevelInfo final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lifetime;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1StatValuePair>               AdjectiveStats;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SummonsLevelInfo) == 0x000008, "Wrong alignment on FM1SummonsLevelInfo");
static_assert(sizeof(FM1SummonsLevelInfo) == 0x000018, "Wrong size on FM1SummonsLevelInfo");
static_assert(offsetof(FM1SummonsLevelInfo, Level) == 0x000000, "Member 'FM1SummonsLevelInfo::Level' has a wrong offset!");
static_assert(offsetof(FM1SummonsLevelInfo, Lifetime) == 0x000004, "Member 'FM1SummonsLevelInfo::Lifetime' has a wrong offset!");
static_assert(offsetof(FM1SummonsLevelInfo, AdjectiveStats) == 0x000008, "Member 'FM1SummonsLevelInfo::AdjectiveStats' has a wrong offset!");

// ScriptStruct M1Data.M1RuneComposeDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1RuneComposeDataLink final : public FDataLink
{
};
static_assert(alignof(FM1RuneComposeDataLink) == 0x000008, "Wrong alignment on FM1RuneComposeDataLink");
static_assert(sizeof(FM1RuneComposeDataLink) == 0x000030, "Wrong size on FM1RuneComposeDataLink");

// ScriptStruct M1Data.M1BattlePassChallengeMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1BattlePassChallengeMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1BattlePassChallengeMiscDataLink) == 0x000008, "Wrong alignment on FM1BattlePassChallengeMiscDataLink");
static_assert(sizeof(FM1BattlePassChallengeMiscDataLink) == 0x000030, "Wrong size on FM1BattlePassChallengeMiscDataLink");

// ScriptStruct M1Data.M1SummonsData
// 0x0010 (0x0190 - 0x0180)
struct FM1SummonsData final : public FM1MonsterData
{
public:
	TArray<struct FM1SummonsLevelInfo>            SummonsLv;                                         // 0x0180(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SummonsData) == 0x000008, "Wrong alignment on FM1SummonsData");
static_assert(sizeof(FM1SummonsData) == 0x000190, "Wrong size on FM1SummonsData");
static_assert(offsetof(FM1SummonsData, SummonsLv) == 0x000180, "Member 'FM1SummonsData::SummonsLv' has a wrong offset!");

// ScriptStruct M1Data.M1ReactorMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1ReactorMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1ReactorMiscDataLink) == 0x000008, "Wrong alignment on FM1ReactorMiscDataLink");
static_assert(sizeof(FM1ReactorMiscDataLink) == 0x000030, "Wrong size on FM1ReactorMiscDataLink");

// ScriptStruct M1Data.M1SummonsAIData
// 0x0000 (0x01C0 - 0x01C0)
struct FM1SummonsAIData final : public FM1MonsterAIData
{
};
static_assert(alignof(FM1SummonsAIData) == 0x000008, "Wrong alignment on FM1SummonsAIData");
static_assert(sizeof(FM1SummonsAIData) == 0x0001C0, "Wrong size on FM1SummonsAIData");

// ScriptStruct M1Data.M1SummonsSkillData
// 0x0000 (0x0180 - 0x0180)
struct FM1SummonsSkillData final : public FM1MonsterSkillData
{
};
static_assert(alignof(FM1SummonsSkillData) == 0x000008, "Wrong alignment on FM1SummonsSkillData");
static_assert(sizeof(FM1SummonsSkillData) == 0x000180, "Wrong size on FM1SummonsSkillData");

// ScriptStruct M1Data.M1CustomizingAbilityData
// 0x0000 (0x0070 - 0x0070)
struct FM1CustomizingAbilityData final : public FM1AbilityData
{
};
static_assert(alignof(FM1CustomizingAbilityData) == 0x000008, "Wrong alignment on FM1CustomizingAbilityData");
static_assert(sizeof(FM1CustomizingAbilityData) == 0x000070, "Wrong size on FM1CustomizingAbilityData");

// ScriptStruct M1Data.M1ReactorAbilityData
// 0x0000 (0x0070 - 0x0070)
struct FM1ReactorAbilityData final : public FM1AbilityData
{
};
static_assert(alignof(FM1ReactorAbilityData) == 0x000008, "Wrong alignment on FM1ReactorAbilityData");
static_assert(sizeof(FM1ReactorAbilityData) == 0x000070, "Wrong size on FM1ReactorAbilityData");

// ScriptStruct M1Data.M1MiniGameDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1MiniGameDataLink final : public FDataLink
{
};
static_assert(alignof(FM1MiniGameDataLink) == 0x000008, "Wrong alignment on FM1MiniGameDataLink");
static_assert(sizeof(FM1MiniGameDataLink) == 0x000030, "Wrong size on FM1MiniGameDataLink");

// ScriptStruct M1Data.M1SetOptionAbilityData
// 0x0000 (0x0070 - 0x0070)
struct FM1SetOptionAbilityData final : public FM1AbilityData
{
};
static_assert(alignof(FM1SetOptionAbilityData) == 0x000008, "Wrong alignment on FM1SetOptionAbilityData");
static_assert(sizeof(FM1SetOptionAbilityData) == 0x000070, "Wrong size on FM1SetOptionAbilityData");

// ScriptStruct M1Data.M1MissionMonsterAbilityData
// 0x0000 (0x0070 - 0x0070)
struct FM1MissionMonsterAbilityData final : public FM1AbilityData
{
};
static_assert(alignof(FM1MissionMonsterAbilityData) == 0x000008, "Wrong alignment on FM1MissionMonsterAbilityData");
static_assert(sizeof(FM1MissionMonsterAbilityData) == 0x000070, "Wrong size on FM1MissionMonsterAbilityData");

// ScriptStruct M1Data.M1ChatBlockRuleData
// 0x0010 (0x0018 - 0x0008)
struct FM1ChatBlockRuleData final : public FTableRowBase
{
public:
	EM1ChattingBlockRule                          Rule;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseBlock;                                          // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RestrictStackCount;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResetStackInterval;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnblockTime;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ChatBlockRuleData) == 0x000008, "Wrong alignment on FM1ChatBlockRuleData");
static_assert(sizeof(FM1ChatBlockRuleData) == 0x000018, "Wrong size on FM1ChatBlockRuleData");
static_assert(offsetof(FM1ChatBlockRuleData, Rule) == 0x000008, "Member 'FM1ChatBlockRuleData::Rule' has a wrong offset!");
static_assert(offsetof(FM1ChatBlockRuleData, UseBlock) == 0x000009, "Member 'FM1ChatBlockRuleData::UseBlock' has a wrong offset!");
static_assert(offsetof(FM1ChatBlockRuleData, RestrictStackCount) == 0x00000C, "Member 'FM1ChatBlockRuleData::RestrictStackCount' has a wrong offset!");
static_assert(offsetof(FM1ChatBlockRuleData, ResetStackInterval) == 0x000010, "Member 'FM1ChatBlockRuleData::ResetStackInterval' has a wrong offset!");
static_assert(offsetof(FM1ChatBlockRuleData, UnblockTime) == 0x000014, "Member 'FM1ChatBlockRuleData::UnblockTime' has a wrong offset!");

// ScriptStruct M1Data.M1ChatChannelData
// 0x0038 (0x0040 - 0x0008)
struct FM1ChatChannelData final : public FTableRowBase
{
public:
	EM1ChattingType                               Channel;                                           // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EM1ChattingTab>                        DisplayTabs;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          DisplayInAllLanguages;                             // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UserUseCheck;                                      // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InputCoolTime;                                     // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChatCmd;                                           // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChatCmdParamCnt;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ChatChannelData) == 0x000008, "Wrong alignment on FM1ChatChannelData");
static_assert(sizeof(FM1ChatChannelData) == 0x000040, "Wrong size on FM1ChatChannelData");
static_assert(offsetof(FM1ChatChannelData, Channel) == 0x000008, "Member 'FM1ChatChannelData::Channel' has a wrong offset!");
static_assert(offsetof(FM1ChatChannelData, DisplayTabs) == 0x000010, "Member 'FM1ChatChannelData::DisplayTabs' has a wrong offset!");
static_assert(offsetof(FM1ChatChannelData, DisplayInAllLanguages) == 0x000020, "Member 'FM1ChatChannelData::DisplayInAllLanguages' has a wrong offset!");
static_assert(offsetof(FM1ChatChannelData, UserUseCheck) == 0x000021, "Member 'FM1ChatChannelData::UserUseCheck' has a wrong offset!");
static_assert(offsetof(FM1ChatChannelData, InputCoolTime) == 0x000024, "Member 'FM1ChatChannelData::InputCoolTime' has a wrong offset!");
static_assert(offsetof(FM1ChatChannelData, ChatCmd) == 0x000028, "Member 'FM1ChatChannelData::ChatCmd' has a wrong offset!");
static_assert(offsetof(FM1ChatChannelData, ChatCmdParamCnt) == 0x000038, "Member 'FM1ChatChannelData::ChatCmdParamCnt' has a wrong offset!");

// ScriptStruct M1Data.M1CreditsData
// 0x0010 (0x0018 - 0x0008)
struct FM1CreditsData final : public FTableRowBase
{
public:
	TArray<struct FM1CreditInfo>                  Infos;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CreditsData) == 0x000008, "Wrong alignment on FM1CreditsData");
static_assert(sizeof(FM1CreditsData) == 0x000018, "Wrong size on FM1CreditsData");
static_assert(offsetof(FM1CreditsData, Infos) == 0x000008, "Member 'FM1CreditsData::Infos' has a wrong offset!");

// ScriptStruct M1Data.M1DifficultiesDropItem
// 0x0060 (0x0060 - 0x0000)
struct FM1DifficultiesDropItem final
{
public:
	struct FM1DifficultyInfoDataLink              DifficultyId;                                      // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FM1DropItemLink                        DropItem;                                          // 0x0030(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DifficultiesDropItem) == 0x000008, "Wrong alignment on FM1DifficultiesDropItem");
static_assert(sizeof(FM1DifficultiesDropItem) == 0x000060, "Wrong size on FM1DifficultiesDropItem");
static_assert(offsetof(FM1DifficultiesDropItem, DifficultyId) == 0x000000, "Member 'FM1DifficultiesDropItem::DifficultyId' has a wrong offset!");
static_assert(offsetof(FM1DifficultiesDropItem, DropItem) == 0x000030, "Member 'FM1DifficultiesDropItem::DropItem' has a wrong offset!");

// ScriptStruct M1Data.M1FieldObjectSpawnGroupData
// 0x0010 (0x0018 - 0x0008)
struct FM1FieldObjectSpawnGroupData final : public FTableRowBase
{
public:
	TArray<struct FM1FieldObjectSpawnInfo>        SpawnObject;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FieldObjectSpawnGroupData) == 0x000008, "Wrong alignment on FM1FieldObjectSpawnGroupData");
static_assert(sizeof(FM1FieldObjectSpawnGroupData) == 0x000018, "Wrong size on FM1FieldObjectSpawnGroupData");
static_assert(offsetof(FM1FieldObjectSpawnGroupData, SpawnObject) == 0x000008, "Member 'FM1FieldObjectSpawnGroupData::SpawnObject' has a wrong offset!");

// ScriptStruct M1Data.M1CharacterUIData
// 0x0080 (0x0080 - 0x0000)
struct FM1CharacterUIData final
{
public:
	struct FSoftObjectPath                        IconPath;                                          // 0x0000(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BigIconPath;                                       // 0x0020(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IntroduceSequence;                                 // 0x0040(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CustomHUDWidgetPath;                               // 0x0060(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CharacterUIData) == 0x000008, "Wrong alignment on FM1CharacterUIData");
static_assert(sizeof(FM1CharacterUIData) == 0x000080, "Wrong size on FM1CharacterUIData");
static_assert(offsetof(FM1CharacterUIData, IconPath) == 0x000000, "Member 'FM1CharacterUIData::IconPath' has a wrong offset!");
static_assert(offsetof(FM1CharacterUIData, BigIconPath) == 0x000020, "Member 'FM1CharacterUIData::BigIconPath' has a wrong offset!");
static_assert(offsetof(FM1CharacterUIData, IntroduceSequence) == 0x000040, "Member 'FM1CharacterUIData::IntroduceSequence' has a wrong offset!");
static_assert(offsetof(FM1CharacterUIData, CustomHUDWidgetPath) == 0x000060, "Member 'FM1CharacterUIData::CustomHUDWidgetPath' has a wrong offset!");

// ScriptStruct M1Data.M1MissionTargetAbilityData
// 0x0010 (0x0080 - 0x0070)
struct FM1MissionTargetAbilityData final : public FM1AbilityData
{
public:
	bool                                          Passive;                                           // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1MissionTargetActiveAbilityData      ActiveAbility;                                     // 0x0074(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionTargetAbilityData) == 0x000008, "Wrong alignment on FM1MissionTargetAbilityData");
static_assert(sizeof(FM1MissionTargetAbilityData) == 0x000080, "Wrong size on FM1MissionTargetAbilityData");
static_assert(offsetof(FM1MissionTargetAbilityData, Passive) == 0x000070, "Member 'FM1MissionTargetAbilityData::Passive' has a wrong offset!");
static_assert(offsetof(FM1MissionTargetAbilityData, ActiveAbility) == 0x000074, "Member 'FM1MissionTargetAbilityData::ActiveAbility' has a wrong offset!");

// ScriptStruct M1Data.M1MissionTargetLevelData
// 0x0028 (0x0028 - 0x0000)
struct FM1MissionTargetLevelData final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1StatValuePair>               VariableBaseStats;                                 // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1MissionTargetAbilityDataLink> Abilities;                                         // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionTargetLevelData) == 0x000008, "Wrong alignment on FM1MissionTargetLevelData");
static_assert(sizeof(FM1MissionTargetLevelData) == 0x000028, "Wrong size on FM1MissionTargetLevelData");
static_assert(offsetof(FM1MissionTargetLevelData, Level) == 0x000000, "Member 'FM1MissionTargetLevelData::Level' has a wrong offset!");
static_assert(offsetof(FM1MissionTargetLevelData, VariableBaseStats) == 0x000008, "Member 'FM1MissionTargetLevelData::VariableBaseStats' has a wrong offset!");
static_assert(offsetof(FM1MissionTargetLevelData, Abilities) == 0x000018, "Member 'FM1MissionTargetLevelData::Abilities' has a wrong offset!");

// ScriptStruct M1Data.M1MissionTargetData
// 0x0050 (0x0058 - 0x0008)
struct FM1MissionTargetData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringId;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MissionTargetType                          Type;                                              // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         BlueprintClass;                                    // 0x0028(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1MissionTargetLevelData>      Lv;                                                // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionTargetData) == 0x000008, "Wrong alignment on FM1MissionTargetData");
static_assert(sizeof(FM1MissionTargetData) == 0x000058, "Wrong size on FM1MissionTargetData");
static_assert(offsetof(FM1MissionTargetData, TemplateId) == 0x000008, "Member 'FM1MissionTargetData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1MissionTargetData, StringId) == 0x000010, "Member 'FM1MissionTargetData::StringId' has a wrong offset!");
static_assert(offsetof(FM1MissionTargetData, Type) == 0x000020, "Member 'FM1MissionTargetData::Type' has a wrong offset!");
static_assert(offsetof(FM1MissionTargetData, BlueprintClass) == 0x000028, "Member 'FM1MissionTargetData::BlueprintClass' has a wrong offset!");
static_assert(offsetof(FM1MissionTargetData, Lv) == 0x000048, "Member 'FM1MissionTargetData::Lv' has a wrong offset!");

// ScriptStruct M1Data.M1DropGroupData
// 0x0018 (0x0020 - 0x0008)
struct FM1DropGroupData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1DropGroupType                              DropGroupType;                                     // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1DropGroupElement>            DropGroupElementList;                              // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DropGroupData) == 0x000008, "Wrong alignment on FM1DropGroupData");
static_assert(sizeof(FM1DropGroupData) == 0x000020, "Wrong size on FM1DropGroupData");
static_assert(offsetof(FM1DropGroupData, TemplateId) == 0x000008, "Member 'FM1DropGroupData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1DropGroupData, DropGroupType) == 0x00000C, "Member 'FM1DropGroupData::DropGroupType' has a wrong offset!");
static_assert(offsetof(FM1DropGroupData, DropGroupElementList) == 0x000010, "Member 'FM1DropGroupData::DropGroupElementList' has a wrong offset!");

// ScriptStruct M1Data.M1LaboratoryMonsterSpawnData
// 0x0018 (0x0020 - 0x0008)
struct FM1LaboratoryMonsterSpawnData final : public FTableRowBase
{
public:
	int32                                         Index;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1MonsterDataLink>             SpawnList;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1LaboratoryMonsterSpawnData) == 0x000008, "Wrong alignment on FM1LaboratoryMonsterSpawnData");
static_assert(sizeof(FM1LaboratoryMonsterSpawnData) == 0x000020, "Wrong size on FM1LaboratoryMonsterSpawnData");
static_assert(offsetof(FM1LaboratoryMonsterSpawnData, Index) == 0x000008, "Member 'FM1LaboratoryMonsterSpawnData::Index' has a wrong offset!");
static_assert(offsetof(FM1LaboratoryMonsterSpawnData, SpawnList) == 0x000010, "Member 'FM1LaboratoryMonsterSpawnData::SpawnList' has a wrong offset!");

// ScriptStruct M1Data.M1DifficultyAbilityData
// 0x0028 (0x0098 - 0x0070)
struct FM1DifficultyAbilityData final : public FM1AbilityData
{
public:
	class FName                                   StringId;                                          // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0078(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DifficultyAbilityData) == 0x000008, "Wrong alignment on FM1DifficultyAbilityData");
static_assert(sizeof(FM1DifficultyAbilityData) == 0x000098, "Wrong size on FM1DifficultyAbilityData");
static_assert(offsetof(FM1DifficultyAbilityData, StringId) == 0x000070, "Member 'FM1DifficultyAbilityData::StringId' has a wrong offset!");
static_assert(offsetof(FM1DifficultyAbilityData, IconPath) == 0x000078, "Member 'FM1DifficultyAbilityData::IconPath' has a wrong offset!");

// ScriptStruct M1Data.M1MultiSupplierAbilityParamData
// 0x0018 (0x0018 - 0x0000)
struct FM1MultiSupplierAbilityParamData final
{
public:
	class FString                                 AbilityId;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1StatType                                   CurrentStatCapacity;                               // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RoundsType                                 RoundsCapacity;                                    // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MultiSupplierAbilityParamData) == 0x000008, "Wrong alignment on FM1MultiSupplierAbilityParamData");
static_assert(sizeof(FM1MultiSupplierAbilityParamData) == 0x000018, "Wrong size on FM1MultiSupplierAbilityParamData");
static_assert(offsetof(FM1MultiSupplierAbilityParamData, AbilityId) == 0x000000, "Member 'FM1MultiSupplierAbilityParamData::AbilityId' has a wrong offset!");
static_assert(offsetof(FM1MultiSupplierAbilityParamData, CurrentStatCapacity) == 0x000010, "Member 'FM1MultiSupplierAbilityParamData::CurrentStatCapacity' has a wrong offset!");
static_assert(offsetof(FM1MultiSupplierAbilityParamData, RoundsCapacity) == 0x000011, "Member 'FM1MultiSupplierAbilityParamData::RoundsCapacity' has a wrong offset!");
static_assert(offsetof(FM1MultiSupplierAbilityParamData, Value) == 0x000014, "Member 'FM1MultiSupplierAbilityParamData::Value' has a wrong offset!");

// ScriptStruct M1Data.M1MissionRewards
// 0x0060 (0x0060 - 0x0000)
struct FM1MissionRewards final
{
public:
	int32                                         LevelMin;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelMax;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         CharacterExp;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MasteryExp;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1CurrencyPair                        Currency;                                          // 0x0018(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FM1ItemDefBundle>               ItemBundles;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1ItemDef>                     Items;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1ItemDef>                     FirstItems;                                        // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1ItemDefBundle>               ItemsByGrade;                                      // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionRewards) == 0x000008, "Wrong alignment on FM1MissionRewards");
static_assert(sizeof(FM1MissionRewards) == 0x000060, "Wrong size on FM1MissionRewards");
static_assert(offsetof(FM1MissionRewards, LevelMin) == 0x000000, "Member 'FM1MissionRewards::LevelMin' has a wrong offset!");
static_assert(offsetof(FM1MissionRewards, LevelMax) == 0x000004, "Member 'FM1MissionRewards::LevelMax' has a wrong offset!");
static_assert(offsetof(FM1MissionRewards, CharacterExp) == 0x000008, "Member 'FM1MissionRewards::CharacterExp' has a wrong offset!");
static_assert(offsetof(FM1MissionRewards, MasteryExp) == 0x000010, "Member 'FM1MissionRewards::MasteryExp' has a wrong offset!");
static_assert(offsetof(FM1MissionRewards, Currency) == 0x000018, "Member 'FM1MissionRewards::Currency' has a wrong offset!");
static_assert(offsetof(FM1MissionRewards, ItemBundles) == 0x000020, "Member 'FM1MissionRewards::ItemBundles' has a wrong offset!");
static_assert(offsetof(FM1MissionRewards, Items) == 0x000030, "Member 'FM1MissionRewards::Items' has a wrong offset!");
static_assert(offsetof(FM1MissionRewards, FirstItems) == 0x000040, "Member 'FM1MissionRewards::FirstItems' has a wrong offset!");
static_assert(offsetof(FM1MissionRewards, ItemsByGrade) == 0x000050, "Member 'FM1MissionRewards::ItemsByGrade' has a wrong offset!");

// ScriptStruct M1Data.M1MultiSupplierData
// 0x0018 (0x0020 - 0x0008)
struct FM1MultiSupplierData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReuseTimer;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1MultiSupplierAbilityParamData> Operations;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MultiSupplierData) == 0x000008, "Wrong alignment on FM1MultiSupplierData");
static_assert(sizeof(FM1MultiSupplierData) == 0x000020, "Wrong size on FM1MultiSupplierData");
static_assert(offsetof(FM1MultiSupplierData, TemplateId) == 0x000008, "Member 'FM1MultiSupplierData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1MultiSupplierData, ReuseTimer) == 0x00000C, "Member 'FM1MultiSupplierData::ReuseTimer' has a wrong offset!");
static_assert(offsetof(FM1MultiSupplierData, Operations) == 0x000010, "Member 'FM1MultiSupplierData::Operations' has a wrong offset!");

// ScriptStruct M1Data.M1SearchKeywordData
// 0x0018 (0x0020 - 0x0008)
struct FM1SearchKeywordData final : public FTableRowBase
{
public:
	EM1SearchKeywordType                          SearchType;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1SearchKeywordInfo>           Keywords;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SearchKeywordData) == 0x000008, "Wrong alignment on FM1SearchKeywordData");
static_assert(sizeof(FM1SearchKeywordData) == 0x000020, "Wrong size on FM1SearchKeywordData");
static_assert(offsetof(FM1SearchKeywordData, SearchType) == 0x000008, "Member 'FM1SearchKeywordData::SearchType' has a wrong offset!");
static_assert(offsetof(FM1SearchKeywordData, Keywords) == 0x000010, "Member 'FM1SearchKeywordData::Keywords' has a wrong offset!");

// ScriptStruct M1Data.M1BoostItemDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1BoostItemDataLink final : public FDataLink
{
};
static_assert(alignof(FM1BoostItemDataLink) == 0x000008, "Wrong alignment on FM1BoostItemDataLink");
static_assert(sizeof(FM1BoostItemDataLink) == 0x000030, "Wrong size on FM1BoostItemDataLink");

// ScriptStruct M1Data.M1MissionData
// 0x0178 (0x0180 - 0x0008)
struct FM1MissionData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MissionCategory                            MissionCategory;                                   // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MissionTypeStringId;                               // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EM1LegionCategory>                     LegionCategory;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   PlayTimeGuideStringId;                             // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1QuestDataLink                       PrerequsiteQuestId;                                // 0x0038(0x0030)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1MissionDataLink>             PrerequisiteMissionIds;                            // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         RequiredMasteryRank;                               // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1MissionFieldPrerequisite            FieldPrerequisite;                                 // 0x0080(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FM1MissionRequiredActivateCondition    RequiredActivateCondition;                         // 0x00A0(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FM1MissionRewardsEvaluateCondition     RewardsEvaluateCondition;                          // 0x00B8(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FM1MissionRewards                      Rewards;                                           // 0x00D0(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FM1PackageOpenerDataLink               PackageOpenerId;                                   // 0x0130(0x0030)(Edit, NativeAccessSpecifierPublic)
	int32                                         MissionMonsterLevel;                               // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OutgoingMailId;                                    // 0x0168(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideDisplayPathGuide;                             // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x3];                                      // 0x0179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExpRatio;                                          // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionData) == 0x000008, "Wrong alignment on FM1MissionData");
static_assert(sizeof(FM1MissionData) == 0x000180, "Wrong size on FM1MissionData");
static_assert(offsetof(FM1MissionData, TemplateId) == 0x000008, "Member 'FM1MissionData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1MissionData, MissionCategory) == 0x00000C, "Member 'FM1MissionData::MissionCategory' has a wrong offset!");
static_assert(offsetof(FM1MissionData, MissionTypeStringId) == 0x000010, "Member 'FM1MissionData::MissionTypeStringId' has a wrong offset!");
static_assert(offsetof(FM1MissionData, StringId) == 0x000018, "Member 'FM1MissionData::StringId' has a wrong offset!");
static_assert(offsetof(FM1MissionData, LegionCategory) == 0x000020, "Member 'FM1MissionData::LegionCategory' has a wrong offset!");
static_assert(offsetof(FM1MissionData, PlayTimeGuideStringId) == 0x000030, "Member 'FM1MissionData::PlayTimeGuideStringId' has a wrong offset!");
static_assert(offsetof(FM1MissionData, PrerequsiteQuestId) == 0x000038, "Member 'FM1MissionData::PrerequsiteQuestId' has a wrong offset!");
static_assert(offsetof(FM1MissionData, PrerequisiteMissionIds) == 0x000068, "Member 'FM1MissionData::PrerequisiteMissionIds' has a wrong offset!");
static_assert(offsetof(FM1MissionData, RequiredMasteryRank) == 0x000078, "Member 'FM1MissionData::RequiredMasteryRank' has a wrong offset!");
static_assert(offsetof(FM1MissionData, FieldPrerequisite) == 0x000080, "Member 'FM1MissionData::FieldPrerequisite' has a wrong offset!");
static_assert(offsetof(FM1MissionData, RequiredActivateCondition) == 0x0000A0, "Member 'FM1MissionData::RequiredActivateCondition' has a wrong offset!");
static_assert(offsetof(FM1MissionData, RewardsEvaluateCondition) == 0x0000B8, "Member 'FM1MissionData::RewardsEvaluateCondition' has a wrong offset!");
static_assert(offsetof(FM1MissionData, Rewards) == 0x0000D0, "Member 'FM1MissionData::Rewards' has a wrong offset!");
static_assert(offsetof(FM1MissionData, PackageOpenerId) == 0x000130, "Member 'FM1MissionData::PackageOpenerId' has a wrong offset!");
static_assert(offsetof(FM1MissionData, MissionMonsterLevel) == 0x000160, "Member 'FM1MissionData::MissionMonsterLevel' has a wrong offset!");
static_assert(offsetof(FM1MissionData, OutgoingMailId) == 0x000168, "Member 'FM1MissionData::OutgoingMailId' has a wrong offset!");
static_assert(offsetof(FM1MissionData, bHideDisplayPathGuide) == 0x000178, "Member 'FM1MissionData::bHideDisplayPathGuide' has a wrong offset!");
static_assert(offsetof(FM1MissionData, ExpRatio) == 0x00017C, "Member 'FM1MissionData::ExpRatio' has a wrong offset!");

// ScriptStruct M1Data.M1BoostItemMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1BoostItemMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1BoostItemMiscDataLink) == 0x000008, "Wrong alignment on FM1BoostItemMiscDataLink");
static_assert(sizeof(FM1BoostItemMiscDataLink) == 0x000030, "Wrong size on FM1BoostItemMiscDataLink");

// ScriptStruct M1Data.M1CustomizingEvolutionInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1CustomizingEvolutionInfo final
{
public:
	class FString                                 ConditionQuestId;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizingEvolutionInfo) == 0x000008, "Wrong alignment on FM1CustomizingEvolutionInfo");
static_assert(sizeof(FM1CustomizingEvolutionInfo) == 0x000010, "Wrong size on FM1CustomizingEvolutionInfo");
static_assert(offsetof(FM1CustomizingEvolutionInfo, ConditionQuestId) == 0x000000, "Member 'FM1CustomizingEvolutionInfo::ConditionQuestId' has a wrong offset!");

// ScriptStruct M1Data.M1CustomizingItemMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1CustomizingItemMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1CustomizingItemMiscDataLink) == 0x000008, "Wrong alignment on FM1CustomizingItemMiscDataLink");
static_assert(sizeof(FM1CustomizingItemMiscDataLink) == 0x000030, "Wrong size on FM1CustomizingItemMiscDataLink");

// ScriptStruct M1Data.M1InstantUseDropItemElement
// 0x0038 (0x0038 - 0x0000)
struct FM1InstantUseDropItemElement final
{
public:
	struct FM1InstantUseDropGroupDataLink         DropGroupId;                                       // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1InstantUseDropItemElement) == 0x000008, "Wrong alignment on FM1InstantUseDropItemElement");
static_assert(sizeof(FM1InstantUseDropItemElement) == 0x000038, "Wrong size on FM1InstantUseDropItemElement");
static_assert(offsetof(FM1InstantUseDropItemElement, DropGroupId) == 0x000000, "Member 'FM1InstantUseDropItemElement::DropGroupId' has a wrong offset!");
static_assert(offsetof(FM1InstantUseDropItemElement, Ratio) == 0x000030, "Member 'FM1InstantUseDropItemElement::Ratio' has a wrong offset!");

// ScriptStruct M1Data.M1CharacterDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1CharacterDataLink final : public FDataLink
{
};
static_assert(alignof(FM1CharacterDataLink) == 0x000008, "Wrong alignment on FM1CharacterDataLink");
static_assert(sizeof(FM1CharacterDataLink) == 0x000030, "Wrong size on FM1CharacterDataLink");

// ScriptStruct M1Data.M1MasteryLevelDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1MasteryLevelDataLink final : public FDataLink
{
};
static_assert(alignof(FM1MasteryLevelDataLink) == 0x000008, "Wrong alignment on FM1MasteryLevelDataLink");
static_assert(sizeof(FM1MasteryLevelDataLink) == 0x000030, "Wrong size on FM1MasteryLevelDataLink");

// ScriptStruct M1Data.M1CharacterLevelDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1CharacterLevelDataLink final : public FDataLink
{
};
static_assert(alignof(FM1CharacterLevelDataLink) == 0x000008, "Wrong alignment on FM1CharacterLevelDataLink");
static_assert(sizeof(FM1CharacterLevelDataLink) == 0x000030, "Wrong size on FM1CharacterLevelDataLink");

// ScriptStruct M1Data.M1ItemOptionStatRangeRate
// 0x0008 (0x0008 - 0x0000)
struct FM1ItemOptionStatRangeRate final
{
public:
	int32                                         UpperRange;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rate;                                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemOptionStatRangeRate) == 0x000004, "Wrong alignment on FM1ItemOptionStatRangeRate");
static_assert(sizeof(FM1ItemOptionStatRangeRate) == 0x000008, "Wrong size on FM1ItemOptionStatRangeRate");
static_assert(offsetof(FM1ItemOptionStatRangeRate, UpperRange) == 0x000000, "Member 'FM1ItemOptionStatRangeRate::UpperRange' has a wrong offset!");
static_assert(offsetof(FM1ItemOptionStatRangeRate, Rate) == 0x000004, "Member 'FM1ItemOptionStatRangeRate::Rate' has a wrong offset!");

// ScriptStruct M1Data.M1ItemOptionTierRange
// 0x0008 (0x0008 - 0x0000)
struct FM1ItemOptionTierRange final
{
public:
	EM1ItemOptionTierType                         OptionTierType;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UpperRange;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemOptionTierRange) == 0x000004, "Wrong alignment on FM1ItemOptionTierRange");
static_assert(sizeof(FM1ItemOptionTierRange) == 0x000008, "Wrong size on FM1ItemOptionTierRange");
static_assert(offsetof(FM1ItemOptionTierRange, OptionTierType) == 0x000000, "Member 'FM1ItemOptionTierRange::OptionTierType' has a wrong offset!");
static_assert(offsetof(FM1ItemOptionTierRange, UpperRange) == 0x000004, "Member 'FM1ItemOptionTierRange::UpperRange' has a wrong offset!");

// ScriptStruct M1Data.M1ItemOptionMiscData
// 0x0040 (0x0048 - 0x0008)
struct FM1ItemOptionMiscData final : public FTableRowBase
{
public:
	TArray<EM1StatType>                           RandomOptionRangedWeaponBanStatGroup;              // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EM1StatType>                           RandomOptionReactorBanStatGroup;                   // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1ItemOptionStatRangeRate>     StatValueSection;                                  // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1ItemOptionTierRange>         OptionTierSection;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemOptionMiscData) == 0x000008, "Wrong alignment on FM1ItemOptionMiscData");
static_assert(sizeof(FM1ItemOptionMiscData) == 0x000048, "Wrong size on FM1ItemOptionMiscData");
static_assert(offsetof(FM1ItemOptionMiscData, RandomOptionRangedWeaponBanStatGroup) == 0x000008, "Member 'FM1ItemOptionMiscData::RandomOptionRangedWeaponBanStatGroup' has a wrong offset!");
static_assert(offsetof(FM1ItemOptionMiscData, RandomOptionReactorBanStatGroup) == 0x000018, "Member 'FM1ItemOptionMiscData::RandomOptionReactorBanStatGroup' has a wrong offset!");
static_assert(offsetof(FM1ItemOptionMiscData, StatValueSection) == 0x000028, "Member 'FM1ItemOptionMiscData::StatValueSection' has a wrong offset!");
static_assert(offsetof(FM1ItemOptionMiscData, OptionTierSection) == 0x000038, "Member 'FM1ItemOptionMiscData::OptionTierSection' has a wrong offset!");

// ScriptStruct M1Data.M1PackageGroupDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1PackageGroupDataLink final : public FDataLink
{
};
static_assert(alignof(FM1PackageGroupDataLink) == 0x000008, "Wrong alignment on FM1PackageGroupDataLink");
static_assert(sizeof(FM1PackageGroupDataLink) == 0x000030, "Wrong size on FM1PackageGroupDataLink");

// ScriptStruct M1Data.M1RangedWeaponData
// 0x00B8 (0x01A8 - 0x00F0)
struct FM1RangedWeaponData final : public FM1EquipmentData
{
public:
	struct FSoftClassPath                         BlueprintClass;                                    // 0x00F0(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1WeaponInstanceType                         InstanceType;                                      // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ReloadType                                 ReloadType;                                        // 0x0111(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1SpreadType                                 SpreadType;                                        // 0x0112(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AddProficiency;                                    // 0x0113(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BurstCount;                                        // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangedInTime;                                      // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangedIdleHoldTime;                                // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomInHoldDelayTime;                               // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomOutHoldDelayTime;                              // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomReleaseTimeAfterFire;                          // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomOutDelayTimeAfterFire;                         // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Recoil;                                            // 0x0130(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ZoomRecoil;                                        // 0x0140(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RoundsType                                 RoundsType;                                        // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PhysicalPowerOptionKey;                            // 0x0154(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireDirectionAdjustZ;                              // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1ChargeLevelData>             ChargeLevelData;                                   // 0x0160(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1PerkDataLink                        Perk;                                              // 0x0170(0x0030)(Edit, NativeAccessSpecifierPublic)
	bool                                          ProtectedWithBorn;                                 // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RangedWeaponData) == 0x000008, "Wrong alignment on FM1RangedWeaponData");
static_assert(sizeof(FM1RangedWeaponData) == 0x0001A8, "Wrong size on FM1RangedWeaponData");
static_assert(offsetof(FM1RangedWeaponData, BlueprintClass) == 0x0000F0, "Member 'FM1RangedWeaponData::BlueprintClass' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponData, InstanceType) == 0x000110, "Member 'FM1RangedWeaponData::InstanceType' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponData, ReloadType) == 0x000111, "Member 'FM1RangedWeaponData::ReloadType' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponData, SpreadType) == 0x000112, "Member 'FM1RangedWeaponData::SpreadType' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponData, AddProficiency) == 0x000113, "Member 'FM1RangedWeaponData::AddProficiency' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponData, BurstCount) == 0x000114, "Member 'FM1RangedWeaponData::BurstCount' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponData, RangedInTime) == 0x000118, "Member 'FM1RangedWeaponData::RangedInTime' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponData, RangedIdleHoldTime) == 0x00011C, "Member 'FM1RangedWeaponData::RangedIdleHoldTime' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponData, ZoomInHoldDelayTime) == 0x000120, "Member 'FM1RangedWeaponData::ZoomInHoldDelayTime' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponData, ZoomOutHoldDelayTime) == 0x000124, "Member 'FM1RangedWeaponData::ZoomOutHoldDelayTime' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponData, ZoomReleaseTimeAfterFire) == 0x000128, "Member 'FM1RangedWeaponData::ZoomReleaseTimeAfterFire' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponData, ZoomOutDelayTimeAfterFire) == 0x00012C, "Member 'FM1RangedWeaponData::ZoomOutDelayTimeAfterFire' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponData, Recoil) == 0x000130, "Member 'FM1RangedWeaponData::Recoil' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponData, ZoomRecoil) == 0x000140, "Member 'FM1RangedWeaponData::ZoomRecoil' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponData, RoundsType) == 0x000150, "Member 'FM1RangedWeaponData::RoundsType' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponData, PhysicalPowerOptionKey) == 0x000154, "Member 'FM1RangedWeaponData::PhysicalPowerOptionKey' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponData, FireDirectionAdjustZ) == 0x00015C, "Member 'FM1RangedWeaponData::FireDirectionAdjustZ' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponData, ChargeLevelData) == 0x000160, "Member 'FM1RangedWeaponData::ChargeLevelData' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponData, Perk) == 0x000170, "Member 'FM1RangedWeaponData::Perk' has a wrong offset!");
static_assert(offsetof(FM1RangedWeaponData, ProtectedWithBorn) == 0x0001A0, "Member 'FM1RangedWeaponData::ProtectedWithBorn' has a wrong offset!");

// ScriptStruct M1Data.M1PackageItemDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1PackageItemDataLink final : public FDataLink
{
};
static_assert(alignof(FM1PackageItemDataLink) == 0x000008, "Wrong alignment on FM1PackageItemDataLink");
static_assert(sizeof(FM1PackageItemDataLink) == 0x000030, "Wrong size on FM1PackageItemDataLink");

// ScriptStruct M1Data.M1RangedWeaponDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1RangedWeaponDataLink final : public FDataLink
{
};
static_assert(alignof(FM1RangedWeaponDataLink) == 0x000008, "Wrong alignment on FM1RangedWeaponDataLink");
static_assert(sizeof(FM1RangedWeaponDataLink) == 0x000030, "Wrong size on FM1RangedWeaponDataLink");

// ScriptStruct M1Data.M1RandomOptionGroupData
// 0x0018 (0x0020 - 0x0008)
struct FM1RandomOptionGroupData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1RandomOptionGroupElement>    Elements;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RandomOptionGroupData) == 0x000008, "Wrong alignment on FM1RandomOptionGroupData");
static_assert(sizeof(FM1RandomOptionGroupData) == 0x000020, "Wrong size on FM1RandomOptionGroupData");
static_assert(offsetof(FM1RandomOptionGroupData, TemplateId) == 0x000008, "Member 'FM1RandomOptionGroupData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1RandomOptionGroupData, Elements) == 0x000010, "Member 'FM1RandomOptionGroupData::Elements' has a wrong offset!");

// ScriptStruct M1Data.M1MonsterMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1MonsterMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1MonsterMiscDataLink) == 0x000008, "Wrong alignment on FM1MonsterMiscDataLink");
static_assert(sizeof(FM1MonsterMiscDataLink) == 0x000030, "Wrong size on FM1MonsterMiscDataLink");

// ScriptStruct M1Data.M1BossMonsterDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1BossMonsterDataLink final : public FDataLink
{
};
static_assert(alignof(FM1BossMonsterDataLink) == 0x000008, "Wrong alignment on FM1BossMonsterDataLink");
static_assert(sizeof(FM1BossMonsterDataLink) == 0x000030, "Wrong size on FM1BossMonsterDataLink");

// ScriptStruct M1Data.M1AccessoryDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1AccessoryDataLink final : public FDataLink
{
};
static_assert(alignof(FM1AccessoryDataLink) == 0x000008, "Wrong alignment on FM1AccessoryDataLink");
static_assert(sizeof(FM1AccessoryDataLink) == 0x000030, "Wrong size on FM1AccessoryDataLink");

// ScriptStruct M1Data.M1FieldObjectActivateConditionParamsByDifficulty
// 0x0040 (0x0040 - 0x0000)
struct FM1FieldObjectActivateConditionParamsByDifficulty final
{
public:
	struct FM1DifficultyInfoDataLink              DifficultyId;                                      // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	TArray<class FString>                         Params;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FieldObjectActivateConditionParamsByDifficulty) == 0x000008, "Wrong alignment on FM1FieldObjectActivateConditionParamsByDifficulty");
static_assert(sizeof(FM1FieldObjectActivateConditionParamsByDifficulty) == 0x000040, "Wrong size on FM1FieldObjectActivateConditionParamsByDifficulty");
static_assert(offsetof(FM1FieldObjectActivateConditionParamsByDifficulty, DifficultyId) == 0x000000, "Member 'FM1FieldObjectActivateConditionParamsByDifficulty::DifficultyId' has a wrong offset!");
static_assert(offsetof(FM1FieldObjectActivateConditionParamsByDifficulty, Params) == 0x000030, "Member 'FM1FieldObjectActivateConditionParamsByDifficulty::Params' has a wrong offset!");

// ScriptStruct M1Data.M1ItemOptionMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1ItemOptionMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1ItemOptionMiscDataLink) == 0x000008, "Wrong alignment on FM1ItemOptionMiscDataLink");
static_assert(sizeof(FM1ItemOptionMiscDataLink) == 0x000030, "Wrong size on FM1ItemOptionMiscDataLink");

// ScriptStruct M1Data.M1RandomOptionChangeDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1RandomOptionChangeDataLink final : public FDataLink
{
};
static_assert(alignof(FM1RandomOptionChangeDataLink) == 0x000008, "Wrong alignment on FM1RandomOptionChangeDataLink");
static_assert(sizeof(FM1RandomOptionChangeDataLink) == 0x000030, "Wrong size on FM1RandomOptionChangeDataLink");

// ScriptStruct M1Data.M1MonsterSpawnGroupDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1MonsterSpawnGroupDataLink final : public FDataLink
{
};
static_assert(alignof(FM1MonsterSpawnGroupDataLink) == 0x000008, "Wrong alignment on FM1MonsterSpawnGroupDataLink");
static_assert(sizeof(FM1MonsterSpawnGroupDataLink) == 0x000030, "Wrong size on FM1MonsterSpawnGroupDataLink");

// ScriptStruct M1Data.M1CheatData
// 0x0048 (0x0050 - 0x0008)
struct FM1CheatData final : public FTableRowBase
{
public:
	class FString                                 StringId;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ParentId;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Command;                                           // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasParam;                                         // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CheatData) == 0x000008, "Wrong alignment on FM1CheatData");
static_assert(sizeof(FM1CheatData) == 0x000050, "Wrong size on FM1CheatData");
static_assert(offsetof(FM1CheatData, StringId) == 0x000008, "Member 'FM1CheatData::StringId' has a wrong offset!");
static_assert(offsetof(FM1CheatData, ParentId) == 0x000018, "Member 'FM1CheatData::ParentId' has a wrong offset!");
static_assert(offsetof(FM1CheatData, Title) == 0x000028, "Member 'FM1CheatData::Title' has a wrong offset!");
static_assert(offsetof(FM1CheatData, Command) == 0x000038, "Member 'FM1CheatData::Command' has a wrong offset!");
static_assert(offsetof(FM1CheatData, bHasParam) == 0x000048, "Member 'FM1CheatData::bHasParam' has a wrong offset!");

// ScriptStruct M1Data.M1CheatDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1CheatDataLink final : public FDataLink
{
};
static_assert(alignof(FM1CheatDataLink) == 0x000008, "Wrong alignment on FM1CheatDataLink");
static_assert(sizeof(FM1CheatDataLink) == 0x000030, "Wrong size on FM1CheatDataLink");

// ScriptStruct M1Data.M1PackageGroupUpgradeInfo
// 0x0060 (0x0060 - 0x0000)
struct FM1PackageGroupUpgradeInfo final
{
public:
	struct FM1ConsumableItemDataLink              RequiredStabilizerId;                              // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FM1PackageGroupDataLink                PackageGroupId;                                    // 0x0030(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PackageGroupUpgradeInfo) == 0x000008, "Wrong alignment on FM1PackageGroupUpgradeInfo");
static_assert(sizeof(FM1PackageGroupUpgradeInfo) == 0x000060, "Wrong size on FM1PackageGroupUpgradeInfo");
static_assert(offsetof(FM1PackageGroupUpgradeInfo, RequiredStabilizerId) == 0x000000, "Member 'FM1PackageGroupUpgradeInfo::RequiredStabilizerId' has a wrong offset!");
static_assert(offsetof(FM1PackageGroupUpgradeInfo, PackageGroupId) == 0x000030, "Member 'FM1PackageGroupUpgradeInfo::PackageGroupId' has a wrong offset!");

// ScriptStruct M1Data.M1BalanceDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1BalanceDataLink final : public FDataLink
{
};
static_assert(alignof(FM1BalanceDataLink) == 0x000008, "Wrong alignment on FM1BalanceDataLink");
static_assert(sizeof(FM1BalanceDataLink) == 0x000030, "Wrong size on FM1BalanceDataLink");

// ScriptStruct M1Data.M1PaidProductDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1PaidProductDataLink final : public FDataLink
{
};
static_assert(alignof(FM1PaidProductDataLink) == 0x000008, "Wrong alignment on FM1PaidProductDataLink");
static_assert(sizeof(FM1PaidProductDataLink) == 0x000030, "Wrong size on FM1PaidProductDataLink");

// ScriptStruct M1Data.M1BoostLimitData
// 0x0008 (0x0008 - 0x0000)
struct FM1BoostLimitData final
{
public:
	EM1BuffSubItemType                            BuffSubItemType;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LimitValue;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BoostLimitData) == 0x000004, "Wrong alignment on FM1BoostLimitData");
static_assert(sizeof(FM1BoostLimitData) == 0x000008, "Wrong size on FM1BoostLimitData");
static_assert(offsetof(FM1BoostLimitData, BuffSubItemType) == 0x000000, "Member 'FM1BoostLimitData::BuffSubItemType' has a wrong offset!");
static_assert(offsetof(FM1BoostLimitData, LimitValue) == 0x000004, "Member 'FM1BoostLimitData::LimitValue' has a wrong offset!");

// ScriptStruct M1Data.M1CommonShopDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1CommonShopDataLink final : public FDataLink
{
};
static_assert(alignof(FM1CommonShopDataLink) == 0x000008, "Wrong alignment on FM1CommonShopDataLink");
static_assert(sizeof(FM1CommonShopDataLink) == 0x000030, "Wrong size on FM1CommonShopDataLink");

// ScriptStruct M1Data.M1BoostItemMiscData
// 0x0130 (0x0138 - 0x0008)
struct FM1BoostItemMiscData final : public FTableRowBase
{
public:
	TArray<struct FM1BoostLimitData>              LimitList;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1CommonShopDataLink                  SlotIncrementShop;                                 // 0x0018(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FM1ProductDataLink                     WareHouseSlotIncrementProduct;                     // 0x0048(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FM1ProductDataLink                     EquipInventoryIncrementProduct;                    // 0x0078(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FM1ProductDataLink                     ConsumableInventoryIncrementProduct;               // 0x00A8(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FM1ProductDataLink                     CharacterSlotIncrementProduct;                     // 0x00D8(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FM1ProductDataLink                     PresetSlotIncrementProduct;                        // 0x0108(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BoostItemMiscData) == 0x000008, "Wrong alignment on FM1BoostItemMiscData");
static_assert(sizeof(FM1BoostItemMiscData) == 0x000138, "Wrong size on FM1BoostItemMiscData");
static_assert(offsetof(FM1BoostItemMiscData, LimitList) == 0x000008, "Member 'FM1BoostItemMiscData::LimitList' has a wrong offset!");
static_assert(offsetof(FM1BoostItemMiscData, SlotIncrementShop) == 0x000018, "Member 'FM1BoostItemMiscData::SlotIncrementShop' has a wrong offset!");
static_assert(offsetof(FM1BoostItemMiscData, WareHouseSlotIncrementProduct) == 0x000048, "Member 'FM1BoostItemMiscData::WareHouseSlotIncrementProduct' has a wrong offset!");
static_assert(offsetof(FM1BoostItemMiscData, EquipInventoryIncrementProduct) == 0x000078, "Member 'FM1BoostItemMiscData::EquipInventoryIncrementProduct' has a wrong offset!");
static_assert(offsetof(FM1BoostItemMiscData, ConsumableInventoryIncrementProduct) == 0x0000A8, "Member 'FM1BoostItemMiscData::ConsumableInventoryIncrementProduct' has a wrong offset!");
static_assert(offsetof(FM1BoostItemMiscData, CharacterSlotIncrementProduct) == 0x0000D8, "Member 'FM1BoostItemMiscData::CharacterSlotIncrementProduct' has a wrong offset!");
static_assert(offsetof(FM1BoostItemMiscData, PresetSlotIncrementProduct) == 0x000108, "Member 'FM1BoostItemMiscData::PresetSlotIncrementProduct' has a wrong offset!");

// ScriptStruct M1Data.M1BattlePassProductDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1BattlePassProductDataLink final : public FDataLink
{
};
static_assert(alignof(FM1BattlePassProductDataLink) == 0x000008, "Wrong alignment on FM1BattlePassProductDataLink");
static_assert(sizeof(FM1BattlePassProductDataLink) == 0x000030, "Wrong size on FM1BattlePassProductDataLink");

// ScriptStruct M1Data.M1BattlePassShopDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1BattlePassShopDataLink final : public FDataLink
{
};
static_assert(alignof(FM1BattlePassShopDataLink) == 0x000008, "Wrong alignment on FM1BattlePassShopDataLink");
static_assert(sizeof(FM1BattlePassShopDataLink) == 0x000030, "Wrong size on FM1BattlePassShopDataLink");

// ScriptStruct M1Data.M1ResearchDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1ResearchDataLink final : public FDataLink
{
};
static_assert(alignof(FM1ResearchDataLink) == 0x000008, "Wrong alignment on FM1ResearchDataLink");
static_assert(sizeof(FM1ResearchDataLink) == 0x000030, "Wrong size on FM1ResearchDataLink");

// ScriptStruct M1Data.M1RandomOptionCountInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1RandomOptionCountInfo final
{
public:
	EM1EquipmentCategoryType                      Category;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 Tier;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RandomOptionCountInfo) == 0x000008, "Wrong alignment on FM1RandomOptionCountInfo");
static_assert(sizeof(FM1RandomOptionCountInfo) == 0x000018, "Wrong size on FM1RandomOptionCountInfo");
static_assert(offsetof(FM1RandomOptionCountInfo, Category) == 0x000000, "Member 'FM1RandomOptionCountInfo::Category' has a wrong offset!");
static_assert(offsetof(FM1RandomOptionCountInfo, Tier) == 0x000008, "Member 'FM1RandomOptionCountInfo::Tier' has a wrong offset!");

// ScriptStruct M1Data.M1ResearchMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1ResearchMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1ResearchMiscDataLink) == 0x000008, "Wrong alignment on FM1ResearchMiscDataLink");
static_assert(sizeof(FM1ResearchMiscDataLink) == 0x000030, "Wrong size on FM1ResearchMiscDataLink");

// ScriptStruct M1Data.M1MissionTaskSubDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1MissionTaskSubDataLink final : public FDataLink
{
};
static_assert(alignof(FM1MissionTaskSubDataLink) == 0x000008, "Wrong alignment on FM1MissionTaskSubDataLink");
static_assert(sizeof(FM1MissionTaskSubDataLink) == 0x000030, "Wrong size on FM1MissionTaskSubDataLink");

// ScriptStruct M1Data.M1CustomizingItemMiscData
// 0x0008 (0x0010 - 0x0008)
struct FM1CustomizingItemMiscData final : public FTableRowBase
{
public:
	int32                                         MaxEmotionEquipCount;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CustomizingItemMiscData) == 0x000008, "Wrong alignment on FM1CustomizingItemMiscData");
static_assert(sizeof(FM1CustomizingItemMiscData) == 0x000010, "Wrong size on FM1CustomizingItemMiscData");
static_assert(offsetof(FM1CustomizingItemMiscData, MaxEmotionEquipCount) == 0x000008, "Member 'FM1CustomizingItemMiscData::MaxEmotionEquipCount' has a wrong offset!");

// ScriptStruct M1Data.M1MissionWaveDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1MissionWaveDataLink final : public FDataLink
{
};
static_assert(alignof(FM1MissionWaveDataLink) == 0x000008, "Wrong alignment on FM1MissionWaveDataLink");
static_assert(sizeof(FM1MissionWaveDataLink) == 0x000030, "Wrong size on FM1MissionWaveDataLink");

// ScriptStruct M1Data.M1QuestParamGroupDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1QuestParamGroupDataLink final : public FDataLink
{
};
static_assert(alignof(FM1QuestParamGroupDataLink) == 0x000008, "Wrong alignment on FM1QuestParamGroupDataLink");
static_assert(sizeof(FM1QuestParamGroupDataLink) == 0x000030, "Wrong size on FM1QuestParamGroupDataLink");

// ScriptStruct M1Data.M1ProficiencyMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1ProficiencyMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1ProficiencyMiscDataLink) == 0x000008, "Wrong alignment on FM1ProficiencyMiscDataLink");
static_assert(sizeof(FM1ProficiencyMiscDataLink) == 0x000030, "Wrong size on FM1ProficiencyMiscDataLink");

// ScriptStruct M1Data.M1RuneComposeMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1RuneComposeMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1RuneComposeMiscDataLink) == 0x000008, "Wrong alignment on FM1RuneComposeMiscDataLink");
static_assert(sizeof(FM1RuneComposeMiscDataLink) == 0x000030, "Wrong size on FM1RuneComposeMiscDataLink");

// ScriptStruct M1Data.M1ReactorDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1ReactorDataLink final : public FDataLink
{
};
static_assert(alignof(FM1ReactorDataLink) == 0x000008, "Wrong alignment on FM1ReactorDataLink");
static_assert(sizeof(FM1ReactorDataLink) == 0x000030, "Wrong size on FM1ReactorDataLink");

// ScriptStruct M1Data.M1VoidBattleMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1VoidBattleMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1VoidBattleMiscDataLink) == 0x000008, "Wrong alignment on FM1VoidBattleMiscDataLink");
static_assert(sizeof(FM1VoidBattleMiscDataLink) == 0x000030, "Wrong size on FM1VoidBattleMiscDataLink");

// ScriptStruct M1Data.M1InstanceDungeonDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1InstanceDungeonDataLink final : public FDataLink
{
};
static_assert(alignof(FM1InstanceDungeonDataLink) == 0x000008, "Wrong alignment on FM1InstanceDungeonDataLink");
static_assert(sizeof(FM1InstanceDungeonDataLink) == 0x000030, "Wrong size on FM1InstanceDungeonDataLink");

// ScriptStruct M1Data.M1InstanceDungeonRewardDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1InstanceDungeonRewardDataLink final : public FDataLink
{
};
static_assert(alignof(FM1InstanceDungeonRewardDataLink) == 0x000008, "Wrong alignment on FM1InstanceDungeonRewardDataLink");
static_assert(sizeof(FM1InstanceDungeonRewardDataLink) == 0x000030, "Wrong size on FM1InstanceDungeonRewardDataLink");

// ScriptStruct M1Data.M1InstanceDungeonMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1InstanceDungeonMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1InstanceDungeonMiscDataLink) == 0x000008, "Wrong alignment on FM1InstanceDungeonMiscDataLink");
static_assert(sizeof(FM1InstanceDungeonMiscDataLink) == 0x000030, "Wrong size on FM1InstanceDungeonMiscDataLink");

// ScriptStruct M1Data.M1CharacterDungeonDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1CharacterDungeonDataLink final : public FDataLink
{
};
static_assert(alignof(FM1CharacterDungeonDataLink) == 0x000008, "Wrong alignment on FM1CharacterDungeonDataLink");
static_assert(sizeof(FM1CharacterDungeonDataLink) == 0x000030, "Wrong size on FM1CharacterDungeonDataLink");

// ScriptStruct M1Data.M1InvasionDungeonDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1InvasionDungeonDataLink final : public FDataLink
{
};
static_assert(alignof(FM1InvasionDungeonDataLink) == 0x000008, "Wrong alignment on FM1InvasionDungeonDataLink");
static_assert(sizeof(FM1InvasionDungeonDataLink) == 0x000030, "Wrong size on FM1InvasionDungeonDataLink");

// ScriptStruct M1Data.M1InvasionDungeonMODDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1InvasionDungeonMODDataLink final : public FDataLink
{
};
static_assert(alignof(FM1InvasionDungeonMODDataLink) == 0x000008, "Wrong alignment on FM1InvasionDungeonMODDataLink");
static_assert(sizeof(FM1InvasionDungeonMODDataLink) == 0x000030, "Wrong size on FM1InvasionDungeonMODDataLink");

// ScriptStruct M1Data.M1MailMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1MailMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1MailMiscDataLink) == 0x000008, "Wrong alignment on FM1MailMiscDataLink");
static_assert(sizeof(FM1MailMiscDataLink) == 0x000030, "Wrong size on FM1MailMiscDataLink");

// ScriptStruct M1Data.M1EventMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1EventMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1EventMiscDataLink) == 0x000008, "Wrong alignment on FM1EventMiscDataLink");
static_assert(sizeof(FM1EventMiscDataLink) == 0x000030, "Wrong size on FM1EventMiscDataLink");

// ScriptStruct M1Data.M1EquipmentDecomposeDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1EquipmentDecomposeDataLink final : public FDataLink
{
};
static_assert(alignof(FM1EquipmentDecomposeDataLink) == 0x000008, "Wrong alignment on FM1EquipmentDecomposeDataLink");
static_assert(sizeof(FM1EquipmentDecomposeDataLink) == 0x000030, "Wrong size on FM1EquipmentDecomposeDataLink");

// ScriptStruct M1Data.M1TitleMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1TitleMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1TitleMiscDataLink) == 0x000008, "Wrong alignment on FM1TitleMiscDataLink");
static_assert(sizeof(FM1TitleMiscDataLink) == 0x000030, "Wrong size on FM1TitleMiscDataLink");

// ScriptStruct M1Data.M1BattlePassDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1BattlePassDataLink final : public FDataLink
{
};
static_assert(alignof(FM1BattlePassDataLink) == 0x000008, "Wrong alignment on FM1BattlePassDataLink");
static_assert(sizeof(FM1BattlePassDataLink) == 0x000030, "Wrong size on FM1BattlePassDataLink");

// ScriptStruct M1Data.M1AchievementDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1AchievementDataLink final : public FDataLink
{
};
static_assert(alignof(FM1AchievementDataLink) == 0x000008, "Wrong alignment on FM1AchievementDataLink");
static_assert(sizeof(FM1AchievementDataLink) == 0x000030, "Wrong size on FM1AchievementDataLink");

// ScriptStruct M1Data.M1RecordDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1RecordDataLink final : public FDataLink
{
};
static_assert(alignof(FM1RecordDataLink) == 0x000008, "Wrong alignment on FM1RecordDataLink");
static_assert(sizeof(FM1RecordDataLink) == 0x000030, "Wrong size on FM1RecordDataLink");

// ScriptStruct M1Data.M1EventBoostingDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1EventBoostingDataLink final : public FDataLink
{
};
static_assert(alignof(FM1EventBoostingDataLink) == 0x000008, "Wrong alignment on FM1EventBoostingDataLink");
static_assert(sizeof(FM1EventBoostingDataLink) == 0x000030, "Wrong size on FM1EventBoostingDataLink");

// ScriptStruct M1Data.M1MiniGameMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1MiniGameMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1MiniGameMiscDataLink) == 0x000008, "Wrong alignment on FM1MiniGameMiscDataLink");
static_assert(sizeof(FM1MiniGameMiscDataLink) == 0x000030, "Wrong size on FM1MiniGameMiscDataLink");

// ScriptStruct M1Data.M1PaintExtractDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1PaintExtractDataLink final : public FDataLink
{
};
static_assert(alignof(FM1PaintExtractDataLink) == 0x000008, "Wrong alignment on FM1PaintExtractDataLink");
static_assert(sizeof(FM1PaintExtractDataLink) == 0x000030, "Wrong size on FM1PaintExtractDataLink");

// ScriptStruct M1Data.M1SeasonMiscDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1SeasonMiscDataLink final : public FDataLink
{
};
static_assert(alignof(FM1SeasonMiscDataLink) == 0x000008, "Wrong alignment on FM1SeasonMiscDataLink");
static_assert(sizeof(FM1SeasonMiscDataLink) == 0x000030, "Wrong size on FM1SeasonMiscDataLink");

// ScriptStruct M1Data.M1CurrencyInternalData
// 0x0010 (0x0018 - 0x0008)
struct FM1CurrencyInternalData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1CurrencyInternalType                       CurrencyInternalType;                              // 0x000C(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Paid;                                              // 0x000E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         Platform;                                          // 0x000F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTemporary;                                       // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CurrencyInternalData) == 0x000008, "Wrong alignment on FM1CurrencyInternalData");
static_assert(sizeof(FM1CurrencyInternalData) == 0x000018, "Wrong size on FM1CurrencyInternalData");
static_assert(offsetof(FM1CurrencyInternalData, TemplateId) == 0x000008, "Member 'FM1CurrencyInternalData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1CurrencyInternalData, CurrencyInternalType) == 0x00000C, "Member 'FM1CurrencyInternalData::CurrencyInternalType' has a wrong offset!");
static_assert(offsetof(FM1CurrencyInternalData, Paid) == 0x00000E, "Member 'FM1CurrencyInternalData::Paid' has a wrong offset!");
static_assert(offsetof(FM1CurrencyInternalData, Platform) == 0x00000F, "Member 'FM1CurrencyInternalData::Platform' has a wrong offset!");
static_assert(offsetof(FM1CurrencyInternalData, IsTemporary) == 0x000010, "Member 'FM1CurrencyInternalData::IsTemporary' has a wrong offset!");

// ScriptStruct M1Data.M1CustomizingCondition
// 0x0018 (0x0018 - 0x0000)
struct FM1CustomizingCondition final
{
public:
	EM1CustomizingConditionType                   Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Params;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizingCondition) == 0x000008, "Wrong alignment on FM1CustomizingCondition");
static_assert(sizeof(FM1CustomizingCondition) == 0x000018, "Wrong size on FM1CustomizingCondition");
static_assert(offsetof(FM1CustomizingCondition, Type) == 0x000000, "Member 'FM1CustomizingCondition::Type' has a wrong offset!");
static_assert(offsetof(FM1CustomizingCondition, Params) == 0x000008, "Member 'FM1CustomizingCondition::Params' has a wrong offset!");

// ScriptStruct M1Data.M1CustomizingItemData
// 0x0130 (0x0138 - 0x0008)
struct FM1CustomizingItemData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ItemUIData                          UIData;                                            // 0x0018(0x0060)(Edit, NativeAccessSpecifierPublic)
	EM1CustomizingItemCategoryType                Category;                                          // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEvolvable;                                        // 0x0079(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x2];                                       // 0x007A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EM1CustomizingBoundType                       BoundType;                                         // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCommonItem;                                       // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemTierType                               TierType;                                          // 0x0081(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x2];                                       // 0x0082(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PaintIndices;                                      // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                AssetParams;                                       // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         AssetDataParams;                                   // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1CustomizingAbilityDataLink          AbilityParam;                                      // 0x00A8(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FM1CustomizingCondition                Condition;                                         // 0x00D8(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1CustomizingEvolutionInfo>    EvolutionInfos;                                    // 0x00F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1RewardType>                  DuplicatedRewards;                                 // 0x0100(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MasteryLevel;                                      // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxStackCount;                                     // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EM1LoginPlatformTypes>                 PlatformTypes;                                     // 0x0118(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EM1ImportanceType                             ImportanceType;                                    // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTemporary;                                       // 0x0129(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowOnlyIfOwned;                                  // 0x012A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12B[0x1];                                      // 0x012B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SortId;                                            // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemAcquireType                            AcquireType;                                       // 0x0130(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CustomizingItemData) == 0x000008, "Wrong alignment on FM1CustomizingItemData");
static_assert(sizeof(FM1CustomizingItemData) == 0x000138, "Wrong size on FM1CustomizingItemData");
static_assert(offsetof(FM1CustomizingItemData, TemplateId) == 0x000008, "Member 'FM1CustomizingItemData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, StringId) == 0x00000C, "Member 'FM1CustomizingItemData::StringId' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, UIData) == 0x000018, "Member 'FM1CustomizingItemData::UIData' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, Category) == 0x000078, "Member 'FM1CustomizingItemData::Category' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, bEvolvable) == 0x000079, "Member 'FM1CustomizingItemData::bEvolvable' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, BoundType) == 0x00007C, "Member 'FM1CustomizingItemData::BoundType' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, bCommonItem) == 0x000080, "Member 'FM1CustomizingItemData::bCommonItem' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, TierType) == 0x000081, "Member 'FM1CustomizingItemData::TierType' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, PaintIndices) == 0x000084, "Member 'FM1CustomizingItemData::PaintIndices' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, AssetParams) == 0x000088, "Member 'FM1CustomizingItemData::AssetParams' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, AssetDataParams) == 0x000098, "Member 'FM1CustomizingItemData::AssetDataParams' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, AbilityParam) == 0x0000A8, "Member 'FM1CustomizingItemData::AbilityParam' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, Condition) == 0x0000D8, "Member 'FM1CustomizingItemData::Condition' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, EvolutionInfos) == 0x0000F0, "Member 'FM1CustomizingItemData::EvolutionInfos' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, DuplicatedRewards) == 0x000100, "Member 'FM1CustomizingItemData::DuplicatedRewards' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, MasteryLevel) == 0x000110, "Member 'FM1CustomizingItemData::MasteryLevel' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, MaxStackCount) == 0x000114, "Member 'FM1CustomizingItemData::MaxStackCount' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, PlatformTypes) == 0x000118, "Member 'FM1CustomizingItemData::PlatformTypes' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, ImportanceType) == 0x000128, "Member 'FM1CustomizingItemData::ImportanceType' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, IsTemporary) == 0x000129, "Member 'FM1CustomizingItemData::IsTemporary' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, bShowOnlyIfOwned) == 0x00012A, "Member 'FM1CustomizingItemData::bShowOnlyIfOwned' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, SortId) == 0x00012C, "Member 'FM1CustomizingItemData::SortId' has a wrong offset!");
static_assert(offsetof(FM1CustomizingItemData, AcquireType) == 0x000130, "Member 'FM1CustomizingItemData::AcquireType' has a wrong offset!");

// ScriptStruct M1Data.M1PlayerData
// 0x0108 (0x01E0 - 0x00D8)
struct FM1PlayerData final : public FM1CharacterData
{
public:
	class FName                                   Name;                                              // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharacterConceptStringId;                          // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1CharacterGender                            CharacterGender;                                   // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1CharacterGrade                             CharacterGrade;                                    // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA[0x6];                                       // 0x00EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1CharacterUIData                     UIData;                                            // 0x00F0(0x0080)(Edit, NativeAccessSpecifierPublic)
	struct FM1CommonGaugeData                     CommonGauge;                                       // 0x0170(0x0048)(Edit, NativeAccessSpecifierPublic)
	int32                                         MasteryLevel;                                      // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTemporary;                                       // 0x01BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BD[0x3];                                      // 0x01BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1RewardType>                  SellRewards;                                       // 0x01C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 GroupId;                                           // 0x01D0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PlayerData) == 0x000008, "Wrong alignment on FM1PlayerData");
static_assert(sizeof(FM1PlayerData) == 0x0001E0, "Wrong size on FM1PlayerData");
static_assert(offsetof(FM1PlayerData, Name) == 0x0000D8, "Member 'FM1PlayerData::Name' has a wrong offset!");
static_assert(offsetof(FM1PlayerData, CharacterConceptStringId) == 0x0000E0, "Member 'FM1PlayerData::CharacterConceptStringId' has a wrong offset!");
static_assert(offsetof(FM1PlayerData, CharacterGender) == 0x0000E8, "Member 'FM1PlayerData::CharacterGender' has a wrong offset!");
static_assert(offsetof(FM1PlayerData, CharacterGrade) == 0x0000E9, "Member 'FM1PlayerData::CharacterGrade' has a wrong offset!");
static_assert(offsetof(FM1PlayerData, UIData) == 0x0000F0, "Member 'FM1PlayerData::UIData' has a wrong offset!");
static_assert(offsetof(FM1PlayerData, CommonGauge) == 0x000170, "Member 'FM1PlayerData::CommonGauge' has a wrong offset!");
static_assert(offsetof(FM1PlayerData, MasteryLevel) == 0x0001B8, "Member 'FM1PlayerData::MasteryLevel' has a wrong offset!");
static_assert(offsetof(FM1PlayerData, IsTemporary) == 0x0001BC, "Member 'FM1PlayerData::IsTemporary' has a wrong offset!");
static_assert(offsetof(FM1PlayerData, SellRewards) == 0x0001C0, "Member 'FM1PlayerData::SellRewards' has a wrong offset!");
static_assert(offsetof(FM1PlayerData, GroupId) == 0x0001D0, "Member 'FM1PlayerData::GroupId' has a wrong offset!");

// ScriptStruct M1Data.M1CharacterLevelData
// 0x0028 (0x0030 - 0x0008)
struct FM1CharacterLevelData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         RequiredExp;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         AccumulatedExp;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RuneCharacterCapacity;                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         RewardMasteryExp;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CharacterLevelData) == 0x000008, "Wrong alignment on FM1CharacterLevelData");
static_assert(sizeof(FM1CharacterLevelData) == 0x000030, "Wrong size on FM1CharacterLevelData");
static_assert(offsetof(FM1CharacterLevelData, TemplateId) == 0x000008, "Member 'FM1CharacterLevelData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1CharacterLevelData, RequiredExp) == 0x000010, "Member 'FM1CharacterLevelData::RequiredExp' has a wrong offset!");
static_assert(offsetof(FM1CharacterLevelData, AccumulatedExp) == 0x000018, "Member 'FM1CharacterLevelData::AccumulatedExp' has a wrong offset!");
static_assert(offsetof(FM1CharacterLevelData, RuneCharacterCapacity) == 0x000020, "Member 'FM1CharacterLevelData::RuneCharacterCapacity' has a wrong offset!");
static_assert(offsetof(FM1CharacterLevelData, RewardMasteryExp) == 0x000028, "Member 'FM1CharacterLevelData::RewardMasteryExp' has a wrong offset!");

// ScriptStruct M1Data.M1BaseItemData
// 0x00A0 (0x00A8 - 0x0008)
struct FM1BaseItemData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1PlayerDataLink                      CharacterId;                                       // 0x0010(0x0030)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1BaseWeaponItemElement>       WeaponsSlot;                                       // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1BaseWeaponItemElement>       AccessorySlot;                                     // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1BaseWeaponItemElement               ReactorSlot;                                       // 0x0060(0x0038)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1BaseCustomizeItemElement>    CustomizingList;                                   // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BaseItemData) == 0x000008, "Wrong alignment on FM1BaseItemData");
static_assert(sizeof(FM1BaseItemData) == 0x0000A8, "Wrong size on FM1BaseItemData");
static_assert(offsetof(FM1BaseItemData, TemplateId) == 0x000008, "Member 'FM1BaseItemData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1BaseItemData, CharacterId) == 0x000010, "Member 'FM1BaseItemData::CharacterId' has a wrong offset!");
static_assert(offsetof(FM1BaseItemData, WeaponsSlot) == 0x000040, "Member 'FM1BaseItemData::WeaponsSlot' has a wrong offset!");
static_assert(offsetof(FM1BaseItemData, AccessorySlot) == 0x000050, "Member 'FM1BaseItemData::AccessorySlot' has a wrong offset!");
static_assert(offsetof(FM1BaseItemData, ReactorSlot) == 0x000060, "Member 'FM1BaseItemData::ReactorSlot' has a wrong offset!");
static_assert(offsetof(FM1BaseItemData, CustomizingList) == 0x000098, "Member 'FM1BaseItemData::CustomizingList' has a wrong offset!");

// ScriptStruct M1Data.M1DropItem
// 0x0028 (0x0030 - 0x0008)
struct FM1DropItem final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1DropItemElement>             DropItemElementList;                               // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1InstantUseDropItemElement>   InstantUseDropItemElementList;                     // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DropItem) == 0x000008, "Wrong alignment on FM1DropItem");
static_assert(sizeof(FM1DropItem) == 0x000030, "Wrong size on FM1DropItem");
static_assert(offsetof(FM1DropItem, TemplateId) == 0x000008, "Member 'FM1DropItem::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1DropItem, DropItemElementList) == 0x000010, "Member 'FM1DropItem::DropItemElementList' has a wrong offset!");
static_assert(offsetof(FM1DropItem, InstantUseDropItemElementList) == 0x000020, "Member 'FM1DropItem::InstantUseDropItemElementList' has a wrong offset!");

// ScriptStruct M1Data.M1PackageGroupData
// 0x0018 (0x0020 - 0x0008)
struct FM1PackageGroupData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1PackageGroupElement>         PackageGroupElementList;                           // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PackageGroupData) == 0x000008, "Wrong alignment on FM1PackageGroupData");
static_assert(sizeof(FM1PackageGroupData) == 0x000020, "Wrong size on FM1PackageGroupData");
static_assert(offsetof(FM1PackageGroupData, TemplateId) == 0x000008, "Member 'FM1PackageGroupData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1PackageGroupData, PackageGroupElementList) == 0x000010, "Member 'FM1PackageGroupData::PackageGroupElementList' has a wrong offset!");

// ScriptStruct M1Data.M1PackageItemData
// 0x0048 (0x0050 - 0x0008)
struct FM1PackageItemData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1PackageGroupDataLink                DefaultPackageGroupId;                             // 0x0010(0x0030)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1PackageGroupUpgradeInfo>     PackageGroupUpgradeInfoList;                       // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PackageItemData) == 0x000008, "Wrong alignment on FM1PackageItemData");
static_assert(sizeof(FM1PackageItemData) == 0x000050, "Wrong size on FM1PackageItemData");
static_assert(offsetof(FM1PackageItemData, TemplateId) == 0x000008, "Member 'FM1PackageItemData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1PackageItemData, DefaultPackageGroupId) == 0x000010, "Member 'FM1PackageItemData::DefaultPackageGroupId' has a wrong offset!");
static_assert(offsetof(FM1PackageItemData, PackageGroupUpgradeInfoList) == 0x000040, "Member 'FM1PackageItemData::PackageGroupUpgradeInfoList' has a wrong offset!");

// ScriptStruct M1Data.M1AccessoryData
// 0x0030 (0x0120 - 0x00F0)
struct FM1AccessoryData final : public FM1EquipmentData
{
public:
	struct FM1SetOptionDataLink                   SetOption;                                         // 0x00F0(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AccessoryData) == 0x000008, "Wrong alignment on FM1AccessoryData");
static_assert(sizeof(FM1AccessoryData) == 0x000120, "Wrong size on FM1AccessoryData");
static_assert(offsetof(FM1AccessoryData, SetOption) == 0x0000F0, "Member 'FM1AccessoryData::SetOption' has a wrong offset!");

// ScriptStruct M1Data.M1ItemOptionData
// 0x0020 (0x0028 - 0x0008)
struct FM1ItemOptionData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemOptionType                             OptionType;                                        // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OptionGrade;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1JunkFilterCategory                         JunkFilter;                                        // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ItemOptionStat                      BaseStat;                                          // 0x0018(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemOptionData) == 0x000008, "Wrong alignment on FM1ItemOptionData");
static_assert(sizeof(FM1ItemOptionData) == 0x000028, "Wrong size on FM1ItemOptionData");
static_assert(offsetof(FM1ItemOptionData, TemplateId) == 0x000008, "Member 'FM1ItemOptionData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1ItemOptionData, OptionType) == 0x00000C, "Member 'FM1ItemOptionData::OptionType' has a wrong offset!");
static_assert(offsetof(FM1ItemOptionData, OptionGrade) == 0x000010, "Member 'FM1ItemOptionData::OptionGrade' has a wrong offset!");
static_assert(offsetof(FM1ItemOptionData, JunkFilter) == 0x000014, "Member 'FM1ItemOptionData::JunkFilter' has a wrong offset!");
static_assert(offsetof(FM1ItemOptionData, BaseStat) == 0x000018, "Member 'FM1ItemOptionData::BaseStat' has a wrong offset!");

// ScriptStruct M1Data.M1MonsterSpawnGroupData
// 0x0048 (0x0050 - 0x0008)
struct FM1MonsterSpawnGroupData final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          TemplateId;                                        // 0x0010(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterLevelMin;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterLevelMax;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterCountMin;                                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterCountMax;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MonsterSpawnInterval;                              // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterCountToRetain;                              // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RespawnDelay;                                      // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1MonsterDropInfo>             MonsterDropInfoList;                               // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1MonsterTagRatePair>          Tags;                                              // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterSpawnGroupData) == 0x000008, "Wrong alignment on FM1MonsterSpawnGroupData");
static_assert(sizeof(FM1MonsterSpawnGroupData) == 0x000050, "Wrong size on FM1MonsterSpawnGroupData");
static_assert(offsetof(FM1MonsterSpawnGroupData, Name) == 0x000008, "Member 'FM1MonsterSpawnGroupData::Name' has a wrong offset!");
static_assert(offsetof(FM1MonsterSpawnGroupData, TemplateId) == 0x000010, "Member 'FM1MonsterSpawnGroupData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1MonsterSpawnGroupData, MonsterLevelMin) == 0x000014, "Member 'FM1MonsterSpawnGroupData::MonsterLevelMin' has a wrong offset!");
static_assert(offsetof(FM1MonsterSpawnGroupData, MonsterLevelMax) == 0x000018, "Member 'FM1MonsterSpawnGroupData::MonsterLevelMax' has a wrong offset!");
static_assert(offsetof(FM1MonsterSpawnGroupData, MonsterCountMin) == 0x00001C, "Member 'FM1MonsterSpawnGroupData::MonsterCountMin' has a wrong offset!");
static_assert(offsetof(FM1MonsterSpawnGroupData, MonsterCountMax) == 0x000020, "Member 'FM1MonsterSpawnGroupData::MonsterCountMax' has a wrong offset!");
static_assert(offsetof(FM1MonsterSpawnGroupData, MonsterSpawnInterval) == 0x000024, "Member 'FM1MonsterSpawnGroupData::MonsterSpawnInterval' has a wrong offset!");
static_assert(offsetof(FM1MonsterSpawnGroupData, MonsterCountToRetain) == 0x000028, "Member 'FM1MonsterSpawnGroupData::MonsterCountToRetain' has a wrong offset!");
static_assert(offsetof(FM1MonsterSpawnGroupData, RespawnDelay) == 0x00002C, "Member 'FM1MonsterSpawnGroupData::RespawnDelay' has a wrong offset!");
static_assert(offsetof(FM1MonsterSpawnGroupData, MonsterDropInfoList) == 0x000030, "Member 'FM1MonsterSpawnGroupData::MonsterDropInfoList' has a wrong offset!");
static_assert(offsetof(FM1MonsterSpawnGroupData, Tags) == 0x000040, "Member 'FM1MonsterSpawnGroupData::Tags' has a wrong offset!");

// ScriptStruct M1Data.M1FieldObjectActivateCondition
// 0x0018 (0x0018 - 0x0000)
struct FM1FieldObjectActivateCondition final
{
public:
	EM1FieldObjectActivateConditionType           Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1FieldObjectActivateConditionParamsByDifficulty> ParamsByDifficulty;                                // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FieldObjectActivateCondition) == 0x000008, "Wrong alignment on FM1FieldObjectActivateCondition");
static_assert(sizeof(FM1FieldObjectActivateCondition) == 0x000018, "Wrong size on FM1FieldObjectActivateCondition");
static_assert(offsetof(FM1FieldObjectActivateCondition, Type) == 0x000000, "Member 'FM1FieldObjectActivateCondition::Type' has a wrong offset!");
static_assert(offsetof(FM1FieldObjectActivateCondition, ParamsByDifficulty) == 0x000008, "Member 'FM1FieldObjectActivateCondition::ParamsByDifficulty' has a wrong offset!");

// ScriptStruct M1Data.M1FieldObjectData
// 0x0090 (0x0098 - 0x0008)
struct FM1FieldObjectData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1FieldObjectType                            ObjectType;                                        // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1EciveActionType                            EciveType;                                         // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1FieldObjectActivateType                    ActivateType;                                      // 0x0016(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ActivateParams;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1FieldObjectActivateCondition> ActivateConditions;                                // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1DropItemLink                        NoneDifficultyDropItem;                            // 0x0038(0x0030)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1DifficultiesDropItem>        DifficultiesDropItem;                              // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BlueprintClass;                                    // 0x0078(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FieldObjectData) == 0x000008, "Wrong alignment on FM1FieldObjectData");
static_assert(sizeof(FM1FieldObjectData) == 0x000098, "Wrong size on FM1FieldObjectData");
static_assert(offsetof(FM1FieldObjectData, TemplateId) == 0x000008, "Member 'FM1FieldObjectData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1FieldObjectData, StringId) == 0x00000C, "Member 'FM1FieldObjectData::StringId' has a wrong offset!");
static_assert(offsetof(FM1FieldObjectData, ObjectType) == 0x000014, "Member 'FM1FieldObjectData::ObjectType' has a wrong offset!");
static_assert(offsetof(FM1FieldObjectData, EciveType) == 0x000015, "Member 'FM1FieldObjectData::EciveType' has a wrong offset!");
static_assert(offsetof(FM1FieldObjectData, ActivateType) == 0x000016, "Member 'FM1FieldObjectData::ActivateType' has a wrong offset!");
static_assert(offsetof(FM1FieldObjectData, ActivateParams) == 0x000018, "Member 'FM1FieldObjectData::ActivateParams' has a wrong offset!");
static_assert(offsetof(FM1FieldObjectData, ActivateConditions) == 0x000028, "Member 'FM1FieldObjectData::ActivateConditions' has a wrong offset!");
static_assert(offsetof(FM1FieldObjectData, NoneDifficultyDropItem) == 0x000038, "Member 'FM1FieldObjectData::NoneDifficultyDropItem' has a wrong offset!");
static_assert(offsetof(FM1FieldObjectData, DifficultiesDropItem) == 0x000068, "Member 'FM1FieldObjectData::DifficultiesDropItem' has a wrong offset!");
static_assert(offsetof(FM1FieldObjectData, BlueprintClass) == 0x000078, "Member 'FM1FieldObjectData::BlueprintClass' has a wrong offset!");

// ScriptStruct M1Data.M1PartsData
// 0x0080 (0x0088 - 0x0008)
struct FM1PartsData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringId;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanDebone;                                         // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxHpRate;                                         // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CanDeboneHPRate;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeboneDamageRate;                                  // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CancelActionOnDestruction;                         // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RecreationOnBerserkModeEnd;                        // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HpDamageRateToRoot;                                // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           NeedToPartsDestruction;                            // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          NeedToBerserkState;                                // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HitPointId;                                        // 0x004C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1StatValuePair>               Stats;                                             // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           HitBoneNames;                                      // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           WeaknessHitBoneNames;                              // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PartsData) == 0x000008, "Wrong alignment on FM1PartsData");
static_assert(sizeof(FM1PartsData) == 0x000088, "Wrong size on FM1PartsData");
static_assert(offsetof(FM1PartsData, TemplateId) == 0x000008, "Member 'FM1PartsData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1PartsData, StringId) == 0x000010, "Member 'FM1PartsData::StringId' has a wrong offset!");
static_assert(offsetof(FM1PartsData, CanDebone) == 0x000020, "Member 'FM1PartsData::CanDebone' has a wrong offset!");
static_assert(offsetof(FM1PartsData, MaxHpRate) == 0x000024, "Member 'FM1PartsData::MaxHpRate' has a wrong offset!");
static_assert(offsetof(FM1PartsData, CanDeboneHPRate) == 0x000028, "Member 'FM1PartsData::CanDeboneHPRate' has a wrong offset!");
static_assert(offsetof(FM1PartsData, DeboneDamageRate) == 0x00002C, "Member 'FM1PartsData::DeboneDamageRate' has a wrong offset!");
static_assert(offsetof(FM1PartsData, CancelActionOnDestruction) == 0x000030, "Member 'FM1PartsData::CancelActionOnDestruction' has a wrong offset!");
static_assert(offsetof(FM1PartsData, RecreationOnBerserkModeEnd) == 0x000031, "Member 'FM1PartsData::RecreationOnBerserkModeEnd' has a wrong offset!");
static_assert(offsetof(FM1PartsData, HpDamageRateToRoot) == 0x000034, "Member 'FM1PartsData::HpDamageRateToRoot' has a wrong offset!");
static_assert(offsetof(FM1PartsData, NeedToPartsDestruction) == 0x000038, "Member 'FM1PartsData::NeedToPartsDestruction' has a wrong offset!");
static_assert(offsetof(FM1PartsData, NeedToBerserkState) == 0x000048, "Member 'FM1PartsData::NeedToBerserkState' has a wrong offset!");
static_assert(offsetof(FM1PartsData, HitPointId) == 0x00004C, "Member 'FM1PartsData::HitPointId' has a wrong offset!");
static_assert(offsetof(FM1PartsData, Stats) == 0x000058, "Member 'FM1PartsData::Stats' has a wrong offset!");
static_assert(offsetof(FM1PartsData, HitBoneNames) == 0x000068, "Member 'FM1PartsData::HitBoneNames' has a wrong offset!");
static_assert(offsetof(FM1PartsData, WeaknessHitBoneNames) == 0x000078, "Member 'FM1PartsData::WeaknessHitBoneNames' has a wrong offset!");

// ScriptStruct M1Data.M1BalanceData
// 0x0158 (0x0160 - 0x0008)
struct FM1BalanceData final : public FTableRowBase
{
public:
	int32                                         MaxGeneralRounds;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxEnhancedRounds;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxImpactRounds;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHighpowerRounds;                                // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultGeneralRounds;                              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultEnhancedRounds;                             // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultImpactRounds;                               // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultHighpowerRounds;                            // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElementalAdvantageRate;                            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElementalAdvantageRateChampion;                    // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElementalAdvantageRateNamed;                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElementalAdvantageRateBoss;                        // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElementalAdvantageRateMissionTarget;               // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElementalInferiorityRate;                          // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElementalNormalRate;                               // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SocketColorBonusValue;                             // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1RandomOptionCountInfo>       RandomOptionCountInfos;                            // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         EquipmentItemMaxLv;                                // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseCharacterSlot;                                 // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterIncrementSlotByCash;                      // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConsumableIncrementSlotByCash;                     // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseRuneInventorySlot;                             // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipInventoryIncrementSlotByCash;                 // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SocialInventoryLimit;                              // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WareHouseIncrementSlotByCash;                      // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PresetIncrementSlotByCash;                         // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseLoadOutSlot;                                   // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoadoutIncrementSlotByCash;                        // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereLifeTime;                                    // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereBonusTime;                                   // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereBurningTime;                                 // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EpicBossLifeTime;                                  // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EpicBossBonusTime;                                 // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EpicBossBurningTime;                               // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RemainingMonsterMarker;                            // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Proficiency1EquipSlot;                             // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InviteHoldTime;                                    // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InviteMaxCount;                                    // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SendSupportCoolTime;                               // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SendSupportMaxCount;                               // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReceiveSupportMaxCount;                            // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReceiveSupportTime;                                // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         FieldOptionLimitedMap;                             // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         FieldOptionLimitedMapMissionID;                    // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldBreakEffectRecoverRate;                      // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 PlayerDEFInflectionVar;                            // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 MonsterDEFInflectionVar;                           // 0x00E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 PlayerAttackerLevelCnst;                           // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 MonsterAttackerLevelCnst;                          // 0x0108(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DEFScaleConst;                                     // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElementScaleConst;                                 // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DEFLimitConst;                                     // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElementLimitConst;                                 // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattleZoneCompleted;                               // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JunkDecomposeMaxCount;                             // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFriendUserCount;                                // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFriendRequestCount;                             // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBlockUserCount;                                 // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReportResetTime;                                   // 0x013C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EciveSearchMaxCountObject;                         // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EciveSearchMaxCountMoster;                         // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PresetNameLimitLength;                             // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRecentUserCount;                                // 0x014C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemTierType                               EquipmentValuableNoticeTier;                       // 0x0150(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PerkValuableNoticeLevel;                           // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReactorValuableNoticeLevel;                        // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PartyMoveDelayTime;                                // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BalanceData) == 0x000008, "Wrong alignment on FM1BalanceData");
static_assert(sizeof(FM1BalanceData) == 0x000160, "Wrong size on FM1BalanceData");
static_assert(offsetof(FM1BalanceData, MaxGeneralRounds) == 0x000008, "Member 'FM1BalanceData::MaxGeneralRounds' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, MaxEnhancedRounds) == 0x00000C, "Member 'FM1BalanceData::MaxEnhancedRounds' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, MaxImpactRounds) == 0x000010, "Member 'FM1BalanceData::MaxImpactRounds' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, MaxHighpowerRounds) == 0x000014, "Member 'FM1BalanceData::MaxHighpowerRounds' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, DefaultGeneralRounds) == 0x000018, "Member 'FM1BalanceData::DefaultGeneralRounds' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, DefaultEnhancedRounds) == 0x00001C, "Member 'FM1BalanceData::DefaultEnhancedRounds' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, DefaultImpactRounds) == 0x000020, "Member 'FM1BalanceData::DefaultImpactRounds' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, DefaultHighpowerRounds) == 0x000024, "Member 'FM1BalanceData::DefaultHighpowerRounds' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, ElementalAdvantageRate) == 0x000028, "Member 'FM1BalanceData::ElementalAdvantageRate' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, ElementalAdvantageRateChampion) == 0x00002C, "Member 'FM1BalanceData::ElementalAdvantageRateChampion' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, ElementalAdvantageRateNamed) == 0x000030, "Member 'FM1BalanceData::ElementalAdvantageRateNamed' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, ElementalAdvantageRateBoss) == 0x000034, "Member 'FM1BalanceData::ElementalAdvantageRateBoss' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, ElementalAdvantageRateMissionTarget) == 0x000038, "Member 'FM1BalanceData::ElementalAdvantageRateMissionTarget' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, ElementalInferiorityRate) == 0x00003C, "Member 'FM1BalanceData::ElementalInferiorityRate' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, ElementalNormalRate) == 0x000040, "Member 'FM1BalanceData::ElementalNormalRate' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, SocketColorBonusValue) == 0x000044, "Member 'FM1BalanceData::SocketColorBonusValue' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, RandomOptionCountInfos) == 0x000048, "Member 'FM1BalanceData::RandomOptionCountInfos' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, EquipmentItemMaxLv) == 0x000058, "Member 'FM1BalanceData::EquipmentItemMaxLv' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, BaseCharacterSlot) == 0x00005C, "Member 'FM1BalanceData::BaseCharacterSlot' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, CharacterIncrementSlotByCash) == 0x000060, "Member 'FM1BalanceData::CharacterIncrementSlotByCash' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, ConsumableIncrementSlotByCash) == 0x000064, "Member 'FM1BalanceData::ConsumableIncrementSlotByCash' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, BaseRuneInventorySlot) == 0x000068, "Member 'FM1BalanceData::BaseRuneInventorySlot' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, EquipInventoryIncrementSlotByCash) == 0x00006C, "Member 'FM1BalanceData::EquipInventoryIncrementSlotByCash' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, SocialInventoryLimit) == 0x000070, "Member 'FM1BalanceData::SocialInventoryLimit' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, WareHouseIncrementSlotByCash) == 0x000074, "Member 'FM1BalanceData::WareHouseIncrementSlotByCash' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, PresetIncrementSlotByCash) == 0x000078, "Member 'FM1BalanceData::PresetIncrementSlotByCash' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, BaseLoadOutSlot) == 0x00007C, "Member 'FM1BalanceData::BaseLoadOutSlot' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, LoadoutIncrementSlotByCash) == 0x000080, "Member 'FM1BalanceData::LoadoutIncrementSlotByCash' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, SphereLifeTime) == 0x000084, "Member 'FM1BalanceData::SphereLifeTime' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, SphereBonusTime) == 0x000088, "Member 'FM1BalanceData::SphereBonusTime' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, SphereBurningTime) == 0x00008C, "Member 'FM1BalanceData::SphereBurningTime' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, EpicBossLifeTime) == 0x000090, "Member 'FM1BalanceData::EpicBossLifeTime' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, EpicBossBonusTime) == 0x000094, "Member 'FM1BalanceData::EpicBossBonusTime' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, EpicBossBurningTime) == 0x000098, "Member 'FM1BalanceData::EpicBossBurningTime' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, RemainingMonsterMarker) == 0x00009C, "Member 'FM1BalanceData::RemainingMonsterMarker' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, Proficiency1EquipSlot) == 0x0000A0, "Member 'FM1BalanceData::Proficiency1EquipSlot' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, InviteHoldTime) == 0x0000A4, "Member 'FM1BalanceData::InviteHoldTime' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, InviteMaxCount) == 0x0000A8, "Member 'FM1BalanceData::InviteMaxCount' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, SendSupportCoolTime) == 0x0000AC, "Member 'FM1BalanceData::SendSupportCoolTime' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, SendSupportMaxCount) == 0x0000B0, "Member 'FM1BalanceData::SendSupportMaxCount' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, ReceiveSupportMaxCount) == 0x0000B4, "Member 'FM1BalanceData::ReceiveSupportMaxCount' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, ReceiveSupportTime) == 0x0000B8, "Member 'FM1BalanceData::ReceiveSupportTime' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, FieldOptionLimitedMap) == 0x0000C0, "Member 'FM1BalanceData::FieldOptionLimitedMap' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, FieldOptionLimitedMapMissionID) == 0x0000C8, "Member 'FM1BalanceData::FieldOptionLimitedMapMissionID' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, ShieldBreakEffectRecoverRate) == 0x0000D0, "Member 'FM1BalanceData::ShieldBreakEffectRecoverRate' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, PlayerDEFInflectionVar) == 0x0000D8, "Member 'FM1BalanceData::PlayerDEFInflectionVar' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, MonsterDEFInflectionVar) == 0x0000E8, "Member 'FM1BalanceData::MonsterDEFInflectionVar' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, PlayerAttackerLevelCnst) == 0x0000F8, "Member 'FM1BalanceData::PlayerAttackerLevelCnst' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, MonsterAttackerLevelCnst) == 0x000108, "Member 'FM1BalanceData::MonsterAttackerLevelCnst' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, DEFScaleConst) == 0x000118, "Member 'FM1BalanceData::DEFScaleConst' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, ElementScaleConst) == 0x00011C, "Member 'FM1BalanceData::ElementScaleConst' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, DEFLimitConst) == 0x000120, "Member 'FM1BalanceData::DEFLimitConst' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, ElementLimitConst) == 0x000124, "Member 'FM1BalanceData::ElementLimitConst' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, BattleZoneCompleted) == 0x000128, "Member 'FM1BalanceData::BattleZoneCompleted' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, JunkDecomposeMaxCount) == 0x00012C, "Member 'FM1BalanceData::JunkDecomposeMaxCount' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, MaxFriendUserCount) == 0x000130, "Member 'FM1BalanceData::MaxFriendUserCount' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, MaxFriendRequestCount) == 0x000134, "Member 'FM1BalanceData::MaxFriendRequestCount' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, MaxBlockUserCount) == 0x000138, "Member 'FM1BalanceData::MaxBlockUserCount' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, ReportResetTime) == 0x00013C, "Member 'FM1BalanceData::ReportResetTime' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, EciveSearchMaxCountObject) == 0x000140, "Member 'FM1BalanceData::EciveSearchMaxCountObject' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, EciveSearchMaxCountMoster) == 0x000144, "Member 'FM1BalanceData::EciveSearchMaxCountMoster' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, PresetNameLimitLength) == 0x000148, "Member 'FM1BalanceData::PresetNameLimitLength' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, MaxRecentUserCount) == 0x00014C, "Member 'FM1BalanceData::MaxRecentUserCount' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, EquipmentValuableNoticeTier) == 0x000150, "Member 'FM1BalanceData::EquipmentValuableNoticeTier' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, PerkValuableNoticeLevel) == 0x000154, "Member 'FM1BalanceData::PerkValuableNoticeLevel' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, ReactorValuableNoticeLevel) == 0x000158, "Member 'FM1BalanceData::ReactorValuableNoticeLevel' has a wrong offset!");
static_assert(offsetof(FM1BalanceData, PartyMoveDelayTime) == 0x00015C, "Member 'FM1BalanceData::PartyMoveDelayTime' has a wrong offset!");

// ScriptStruct M1Data.M1MapTargetInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1MapTargetInfo final
{
public:
	EM1MapTargetType                              TargetType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TargetId;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressValue;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEssential;                                        // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MapTargetInfo) == 0x000008, "Wrong alignment on FM1MapTargetInfo");
static_assert(sizeof(FM1MapTargetInfo) == 0x000020, "Wrong size on FM1MapTargetInfo");
static_assert(offsetof(FM1MapTargetInfo, TargetType) == 0x000000, "Member 'FM1MapTargetInfo::TargetType' has a wrong offset!");
static_assert(offsetof(FM1MapTargetInfo, TargetId) == 0x000008, "Member 'FM1MapTargetInfo::TargetId' has a wrong offset!");
static_assert(offsetof(FM1MapTargetInfo, ProgressValue) == 0x000018, "Member 'FM1MapTargetInfo::ProgressValue' has a wrong offset!");
static_assert(offsetof(FM1MapTargetInfo, bEssential) == 0x00001C, "Member 'FM1MapTargetInfo::bEssential' has a wrong offset!");

// ScriptStruct M1Data.M1MapBattleZoneData
// 0x0058 (0x0060 - 0x0008)
struct FM1MapBattleZoneData final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          TemplateId;                                        // 0x0010(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringId;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortId;                                            // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1MapBattleZoneOpenCondition>  BattleZoneOpenCondition;                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1MapTargetInfo>               TargetInfo;                                        // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1MapGoalInfo>                 GoalInfo;                                          // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MapBattleZoneData) == 0x000008, "Wrong alignment on FM1MapBattleZoneData");
static_assert(sizeof(FM1MapBattleZoneData) == 0x000060, "Wrong size on FM1MapBattleZoneData");
static_assert(offsetof(FM1MapBattleZoneData, Name) == 0x000008, "Member 'FM1MapBattleZoneData::Name' has a wrong offset!");
static_assert(offsetof(FM1MapBattleZoneData, TemplateId) == 0x000010, "Member 'FM1MapBattleZoneData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1MapBattleZoneData, StringId) == 0x000018, "Member 'FM1MapBattleZoneData::StringId' has a wrong offset!");
static_assert(offsetof(FM1MapBattleZoneData, SortId) == 0x000028, "Member 'FM1MapBattleZoneData::SortId' has a wrong offset!");
static_assert(offsetof(FM1MapBattleZoneData, BattleZoneOpenCondition) == 0x000030, "Member 'FM1MapBattleZoneData::BattleZoneOpenCondition' has a wrong offset!");
static_assert(offsetof(FM1MapBattleZoneData, TargetInfo) == 0x000040, "Member 'FM1MapBattleZoneData::TargetInfo' has a wrong offset!");
static_assert(offsetof(FM1MapBattleZoneData, GoalInfo) == 0x000050, "Member 'FM1MapBattleZoneData::GoalInfo' has a wrong offset!");

// ScriptStruct M1Data.M1BunchItemData
// 0x0078 (0x01A8 - 0x0130)
struct FM1BunchItemData final : public FM1ConsumableItemData
{
public:
	struct FM1ItemDataBox                         PriceType;                                         // 0x0130(0x0038)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1BunchItemDetailData>         SubItemList;                                       // 0x0168(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1MailDataLink                        Mail;                                              // 0x0178(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BunchItemData) == 0x000008, "Wrong alignment on FM1BunchItemData");
static_assert(sizeof(FM1BunchItemData) == 0x0001A8, "Wrong size on FM1BunchItemData");
static_assert(offsetof(FM1BunchItemData, PriceType) == 0x000130, "Member 'FM1BunchItemData::PriceType' has a wrong offset!");
static_assert(offsetof(FM1BunchItemData, SubItemList) == 0x000168, "Member 'FM1BunchItemData::SubItemList' has a wrong offset!");
static_assert(offsetof(FM1BunchItemData, Mail) == 0x000178, "Member 'FM1BunchItemData::Mail' has a wrong offset!");

// ScriptStruct M1Data.M1BattlePassProductData
// 0x0008 (0x0198 - 0x0190)
struct FM1BattlePassProductData final : public FM1ProductData
{
public:
	bool                                          Premium;                                           // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LargeSize;                                         // 0x0191(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_192[0x6];                                      // 0x0192(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1BattlePassProductData) == 0x000008, "Wrong alignment on FM1BattlePassProductData");
static_assert(sizeof(FM1BattlePassProductData) == 0x000198, "Wrong size on FM1BattlePassProductData");
static_assert(offsetof(FM1BattlePassProductData, Premium) == 0x000190, "Member 'FM1BattlePassProductData::Premium' has a wrong offset!");
static_assert(offsetof(FM1BattlePassProductData, LargeSize) == 0x000191, "Member 'FM1BattlePassProductData::LargeSize' has a wrong offset!");

// ScriptStruct M1Data.M1ResearchCurrency
// 0x0008 (0x0008 - 0x0000)
struct FM1ResearchCurrency final
{
public:
	EM1CurrencyType                               Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Price;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ResearchCurrency) == 0x000004, "Wrong alignment on FM1ResearchCurrency");
static_assert(sizeof(FM1ResearchCurrency) == 0x000008, "Wrong size on FM1ResearchCurrency");
static_assert(offsetof(FM1ResearchCurrency, Type) == 0x000000, "Member 'FM1ResearchCurrency::Type' has a wrong offset!");
static_assert(offsetof(FM1ResearchCurrency, Price) == 0x000004, "Member 'FM1ResearchCurrency::Price' has a wrong offset!");

// ScriptStruct M1Data.M1ResearchResultItem
// 0x0040 (0x0040 - 0x0000)
struct FM1ResearchResultItem final
{
public:
	struct FM1ItemDataBox                         Item;                                              // 0x0000(0x0038)(Edit, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ResearchResultItem) == 0x000008, "Wrong alignment on FM1ResearchResultItem");
static_assert(sizeof(FM1ResearchResultItem) == 0x000040, "Wrong size on FM1ResearchResultItem");
static_assert(offsetof(FM1ResearchResultItem, Item) == 0x000000, "Member 'FM1ResearchResultItem::Item' has a wrong offset!");
static_assert(offsetof(FM1ResearchResultItem, Amount) == 0x000038, "Member 'FM1ResearchResultItem::Amount' has a wrong offset!");
static_assert(offsetof(FM1ResearchResultItem, Level) == 0x00003C, "Member 'FM1ResearchResultItem::Level' has a wrong offset!");

// ScriptStruct M1Data.M1ResearchData
// 0x0088 (0x0090 - 0x0008)
struct FM1ResearchData final : public FTableRowBase
{
public:
	class FName                                   GroupId;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          TemplateId;                                        // 0x0010(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortId;                                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResearchTime;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Repeatable;                                        // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVisible;                                         // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ResearchCurrency                    ResearchCurrency;                                  // 0x0020(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1ResearchResultItem                  ResearchResultItem;                                // 0x0028(0x0040)(Edit, NativeAccessSpecifierPublic)
	TArray<int32>                                 RepeatCount;                                       // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1ResearchResourceItem>        ResearchResourceItems;                             // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EM1ResearchType                               Type;                                              // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNew;                                              // 0x0089(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ImportanceType                             Importance;                                        // 0x008A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B[0x5];                                       // 0x008B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ResearchData) == 0x000008, "Wrong alignment on FM1ResearchData");
static_assert(sizeof(FM1ResearchData) == 0x000090, "Wrong size on FM1ResearchData");
static_assert(offsetof(FM1ResearchData, GroupId) == 0x000008, "Member 'FM1ResearchData::GroupId' has a wrong offset!");
static_assert(offsetof(FM1ResearchData, TemplateId) == 0x000010, "Member 'FM1ResearchData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1ResearchData, SortId) == 0x000014, "Member 'FM1ResearchData::SortId' has a wrong offset!");
static_assert(offsetof(FM1ResearchData, ResearchTime) == 0x000018, "Member 'FM1ResearchData::ResearchTime' has a wrong offset!");
static_assert(offsetof(FM1ResearchData, Repeatable) == 0x00001C, "Member 'FM1ResearchData::Repeatable' has a wrong offset!");
static_assert(offsetof(FM1ResearchData, IsVisible) == 0x00001D, "Member 'FM1ResearchData::IsVisible' has a wrong offset!");
static_assert(offsetof(FM1ResearchData, ResearchCurrency) == 0x000020, "Member 'FM1ResearchData::ResearchCurrency' has a wrong offset!");
static_assert(offsetof(FM1ResearchData, ResearchResultItem) == 0x000028, "Member 'FM1ResearchData::ResearchResultItem' has a wrong offset!");
static_assert(offsetof(FM1ResearchData, RepeatCount) == 0x000068, "Member 'FM1ResearchData::RepeatCount' has a wrong offset!");
static_assert(offsetof(FM1ResearchData, ResearchResourceItems) == 0x000078, "Member 'FM1ResearchData::ResearchResourceItems' has a wrong offset!");
static_assert(offsetof(FM1ResearchData, Type) == 0x000088, "Member 'FM1ResearchData::Type' has a wrong offset!");
static_assert(offsetof(FM1ResearchData, bNew) == 0x000089, "Member 'FM1ResearchData::bNew' has a wrong offset!");
static_assert(offsetof(FM1ResearchData, Importance) == 0x00008A, "Member 'FM1ResearchData::Importance' has a wrong offset!");

// ScriptStruct M1Data.M1MissionTaskSubData
// 0x0068 (0x0070 - 0x0008)
struct FM1MissionTaskSubData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OptionalStringId;                                  // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1MonsterDropInfo>             MonsterDropInfoList;                               // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         TaskSuccessScore;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskDropCollection;                                // 0x0034(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskDropSupply;                                    // 0x003C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EliteApperanceChance;                              // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EliteMonsterSpawnMax;                              // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EliteMonsterSpawnChance;                           // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1EliteAbilityGroup>           EliteAbilityGroup;                                 // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1EliteMonsterSkillGroupDataLink> DefaultEliteAbilityGroup;                          // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionTaskSubData) == 0x000008, "Wrong alignment on FM1MissionTaskSubData");
static_assert(sizeof(FM1MissionTaskSubData) == 0x000070, "Wrong size on FM1MissionTaskSubData");
static_assert(offsetof(FM1MissionTaskSubData, TemplateId) == 0x000008, "Member 'FM1MissionTaskSubData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskSubData, StringId) == 0x00000C, "Member 'FM1MissionTaskSubData::StringId' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskSubData, OptionalStringId) == 0x000014, "Member 'FM1MissionTaskSubData::OptionalStringId' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskSubData, MonsterDropInfoList) == 0x000020, "Member 'FM1MissionTaskSubData::MonsterDropInfoList' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskSubData, TaskSuccessScore) == 0x000030, "Member 'FM1MissionTaskSubData::TaskSuccessScore' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskSubData, TaskDropCollection) == 0x000034, "Member 'FM1MissionTaskSubData::TaskDropCollection' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskSubData, TaskDropSupply) == 0x00003C, "Member 'FM1MissionTaskSubData::TaskDropSupply' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskSubData, EliteApperanceChance) == 0x000044, "Member 'FM1MissionTaskSubData::EliteApperanceChance' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskSubData, EliteMonsterSpawnMax) == 0x000048, "Member 'FM1MissionTaskSubData::EliteMonsterSpawnMax' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskSubData, EliteMonsterSpawnChance) == 0x00004C, "Member 'FM1MissionTaskSubData::EliteMonsterSpawnChance' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskSubData, EliteAbilityGroup) == 0x000050, "Member 'FM1MissionTaskSubData::EliteAbilityGroup' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskSubData, DefaultEliteAbilityGroup) == 0x000060, "Member 'FM1MissionTaskSubData::DefaultEliteAbilityGroup' has a wrong offset!");

// ScriptStruct M1Data.M1MissionWaveData
// 0x00B0 (0x00B8 - 0x0008)
struct FM1MissionWaveData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WaveMonsterLevel;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1MonsterDropInfo>             DropItems;                                         // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1MissionRewards                      WaveRewards;                                       // 0x0028(0x0060)(Edit, NativeAccessSpecifierPublic)
	float                                         EliteApperanceChance;                              // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EliteMonsterSpawnMax;                              // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EliteMonsterSpawnChance;                           // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1EliteAbilityGroup>           EliteAbilityGroup;                                 // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1EliteMonsterSkillGroupDataLink> DefaultEliteAbilityGroup;                          // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionWaveData) == 0x000008, "Wrong alignment on FM1MissionWaveData");
static_assert(sizeof(FM1MissionWaveData) == 0x0000B8, "Wrong size on FM1MissionWaveData");
static_assert(offsetof(FM1MissionWaveData, TemplateId) == 0x000008, "Member 'FM1MissionWaveData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveData, StringId) == 0x00000C, "Member 'FM1MissionWaveData::StringId' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveData, WaveMonsterLevel) == 0x000014, "Member 'FM1MissionWaveData::WaveMonsterLevel' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveData, DropItems) == 0x000018, "Member 'FM1MissionWaveData::DropItems' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveData, WaveRewards) == 0x000028, "Member 'FM1MissionWaveData::WaveRewards' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveData, EliteApperanceChance) == 0x000088, "Member 'FM1MissionWaveData::EliteApperanceChance' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveData, EliteMonsterSpawnMax) == 0x00008C, "Member 'FM1MissionWaveData::EliteMonsterSpawnMax' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveData, EliteMonsterSpawnChance) == 0x000090, "Member 'FM1MissionWaveData::EliteMonsterSpawnChance' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveData, EliteAbilityGroup) == 0x000098, "Member 'FM1MissionWaveData::EliteAbilityGroup' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveData, DefaultEliteAbilityGroup) == 0x0000A8, "Member 'FM1MissionWaveData::DefaultEliteAbilityGroup' has a wrong offset!");

// ScriptStruct M1Data.M1QuestParamGroupData
// 0x0020 (0x0028 - 0x0008)
struct FM1QuestParamGroupData final : public FTableRowBase
{
public:
	class FName                                   StringIdName;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1QuestParamType                             QuestParamType;                                    // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Ids;                                               // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1QuestParamGroupData) == 0x000008, "Wrong alignment on FM1QuestParamGroupData");
static_assert(sizeof(FM1QuestParamGroupData) == 0x000028, "Wrong size on FM1QuestParamGroupData");
static_assert(offsetof(FM1QuestParamGroupData, StringIdName) == 0x000008, "Member 'FM1QuestParamGroupData::StringIdName' has a wrong offset!");
static_assert(offsetof(FM1QuestParamGroupData, QuestParamType) == 0x000010, "Member 'FM1QuestParamGroupData::QuestParamType' has a wrong offset!");
static_assert(offsetof(FM1QuestParamGroupData, Ids) == 0x000018, "Member 'FM1QuestParamGroupData::Ids' has a wrong offset!");

// ScriptStruct M1Data.M1RuneClassTypeData
// 0x0018 (0x0020 - 0x0008)
struct FM1RuneClassTypeData final : public FTableRowBase
{
public:
	EM1RuneClassType                              RuneClassType;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WeaponBook;                                        // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EM1EquipItemClassType>                 WeaponClassType;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneClassTypeData) == 0x000008, "Wrong alignment on FM1RuneClassTypeData");
static_assert(sizeof(FM1RuneClassTypeData) == 0x000020, "Wrong size on FM1RuneClassTypeData");
static_assert(offsetof(FM1RuneClassTypeData, RuneClassType) == 0x000008, "Member 'FM1RuneClassTypeData::RuneClassType' has a wrong offset!");
static_assert(offsetof(FM1RuneClassTypeData, WeaponBook) == 0x000009, "Member 'FM1RuneClassTypeData::WeaponBook' has a wrong offset!");
static_assert(offsetof(FM1RuneClassTypeData, WeaponClassType) == 0x000010, "Member 'FM1RuneClassTypeData::WeaponClassType' has a wrong offset!");

// ScriptStruct M1Data.M1RuneLvData
// 0x0040 (0x0040 - 0x0000)
struct FM1RuneLvData final
{
public:
	struct FM1StatusEffectDataLink                StatusEffect;                                      // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1StatValuePair>               BaseStats;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneLvData) == 0x000008, "Wrong alignment on FM1RuneLvData");
static_assert(sizeof(FM1RuneLvData) == 0x000040, "Wrong size on FM1RuneLvData");
static_assert(offsetof(FM1RuneLvData, StatusEffect) == 0x000000, "Member 'FM1RuneLvData::StatusEffect' has a wrong offset!");
static_assert(offsetof(FM1RuneLvData, BaseStats) == 0x000030, "Member 'FM1RuneLvData::BaseStats' has a wrong offset!");

// ScriptStruct M1Data.M1DecomposeRewardCurrencyData
// 0x0008 (0x0008 - 0x0000)
struct FM1DecomposeRewardCurrencyData final
{
public:
	EM1CurrencyType                               Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DecomposeRewardCurrencyData) == 0x000004, "Wrong alignment on FM1DecomposeRewardCurrencyData");
static_assert(sizeof(FM1DecomposeRewardCurrencyData) == 0x000008, "Wrong size on FM1DecomposeRewardCurrencyData");
static_assert(offsetof(FM1DecomposeRewardCurrencyData, Type) == 0x000000, "Member 'FM1DecomposeRewardCurrencyData::Type' has a wrong offset!");
static_assert(offsetof(FM1DecomposeRewardCurrencyData, Value) == 0x000004, "Member 'FM1DecomposeRewardCurrencyData::Value' has a wrong offset!");

// ScriptStruct M1Data.M1RuneDetailData
// 0x00A0 (0x00A0 - 0x0000)
struct FM1RuneDetailData final
{
public:
	int32                                         EnchantLevel;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1RuneAbilityDataLink                 Ability;                                           // 0x0008(0x0030)(Edit, NativeAccessSpecifierPublic)
	class FString                                 StringId;                                          // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RuneCost;                                          // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CapacityIncrement;                                 // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbilityCooltime;                                   // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbilityProbability;                                // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1AbilityParamData>            Params;                                            // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1TaggedAbilityParamData>      TaggedParams;                                      // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1EnchantRequiredCurrencyData> EnchantRequiredCurrencies;                         // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1DecomposeRewardCurrencyData> DecomposeRewardCurrencies;                         // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         RequiredMasteryLevel;                              // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RuneDetailData) == 0x000008, "Wrong alignment on FM1RuneDetailData");
static_assert(sizeof(FM1RuneDetailData) == 0x0000A0, "Wrong size on FM1RuneDetailData");
static_assert(offsetof(FM1RuneDetailData, EnchantLevel) == 0x000000, "Member 'FM1RuneDetailData::EnchantLevel' has a wrong offset!");
static_assert(offsetof(FM1RuneDetailData, Ability) == 0x000008, "Member 'FM1RuneDetailData::Ability' has a wrong offset!");
static_assert(offsetof(FM1RuneDetailData, StringId) == 0x000038, "Member 'FM1RuneDetailData::StringId' has a wrong offset!");
static_assert(offsetof(FM1RuneDetailData, RuneCost) == 0x000048, "Member 'FM1RuneDetailData::RuneCost' has a wrong offset!");
static_assert(offsetof(FM1RuneDetailData, CapacityIncrement) == 0x00004C, "Member 'FM1RuneDetailData::CapacityIncrement' has a wrong offset!");
static_assert(offsetof(FM1RuneDetailData, AbilityCooltime) == 0x000050, "Member 'FM1RuneDetailData::AbilityCooltime' has a wrong offset!");
static_assert(offsetof(FM1RuneDetailData, AbilityProbability) == 0x000054, "Member 'FM1RuneDetailData::AbilityProbability' has a wrong offset!");
static_assert(offsetof(FM1RuneDetailData, Params) == 0x000058, "Member 'FM1RuneDetailData::Params' has a wrong offset!");
static_assert(offsetof(FM1RuneDetailData, TaggedParams) == 0x000068, "Member 'FM1RuneDetailData::TaggedParams' has a wrong offset!");
static_assert(offsetof(FM1RuneDetailData, EnchantRequiredCurrencies) == 0x000078, "Member 'FM1RuneDetailData::EnchantRequiredCurrencies' has a wrong offset!");
static_assert(offsetof(FM1RuneDetailData, DecomposeRewardCurrencies) == 0x000088, "Member 'FM1RuneDetailData::DecomposeRewardCurrencies' has a wrong offset!");
static_assert(offsetof(FM1RuneDetailData, RequiredMasteryLevel) == 0x000098, "Member 'FM1RuneDetailData::RequiredMasteryLevel' has a wrong offset!");

// ScriptStruct M1Data.M1RuneData
// 0x0150 (0x0158 - 0x0008)
struct FM1RuneData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RuneGroupId;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RuneClassType                              RuneClassType;                                     // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RuneSubClassType                           RuneSubClassType;                                  // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1EquipItemClassType                         LimitedEquipItemClassType;                         // 0x002A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1PlayerDataLink>              RequireCharacterClassTypes;                        // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EM1ItemTierType                               RuneTierType;                                      // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RuneSocketType                             RuneSocketType;                                    // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1CurrencyType                               SellingType;                                       // 0x0042(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x1];                                       // 0x0043(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SellingPrice;                                      // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1RuneLvData>                  Lv;                                                // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1ItemUIData                          UIData;                                            // 0x0058(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FM1RuneAbilityDataLink                 Ability;                                           // 0x00B8(0x0030)(Edit, NativeAccessSpecifierPublic)
	float                                         Probability;                                       // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1AbilityParamData>            Params;                                            // 0x00F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1TaggedAbilityParamData>      TaggedParams;                                      // 0x0100(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1RuneDetailData>              DetailDataList;                                    // 0x0110(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Enchantable;                                       // 0x0120(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Decomposable;                                      // 0x0121(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Composable;                                        // 0x0122(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_123[0x5];                                      // 0x0123(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         PropClass;                                         // 0x0128(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ImportantPriority;                                 // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ImportanceType                             ImportanceType;                                    // 0x014C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D[0x3];                                      // 0x014D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MasteryLevel;                                      // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTemporary;                                       // 0x0154(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RuneData) == 0x000008, "Wrong alignment on FM1RuneData");
static_assert(sizeof(FM1RuneData) == 0x000158, "Wrong size on FM1RuneData");
static_assert(offsetof(FM1RuneData, TemplateId) == 0x000008, "Member 'FM1RuneData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1RuneData, StringId) == 0x00000C, "Member 'FM1RuneData::StringId' has a wrong offset!");
static_assert(offsetof(FM1RuneData, RuneGroupId) == 0x000018, "Member 'FM1RuneData::RuneGroupId' has a wrong offset!");
static_assert(offsetof(FM1RuneData, RuneClassType) == 0x000028, "Member 'FM1RuneData::RuneClassType' has a wrong offset!");
static_assert(offsetof(FM1RuneData, RuneSubClassType) == 0x000029, "Member 'FM1RuneData::RuneSubClassType' has a wrong offset!");
static_assert(offsetof(FM1RuneData, LimitedEquipItemClassType) == 0x00002A, "Member 'FM1RuneData::LimitedEquipItemClassType' has a wrong offset!");
static_assert(offsetof(FM1RuneData, RequireCharacterClassTypes) == 0x000030, "Member 'FM1RuneData::RequireCharacterClassTypes' has a wrong offset!");
static_assert(offsetof(FM1RuneData, RuneTierType) == 0x000040, "Member 'FM1RuneData::RuneTierType' has a wrong offset!");
static_assert(offsetof(FM1RuneData, RuneSocketType) == 0x000041, "Member 'FM1RuneData::RuneSocketType' has a wrong offset!");
static_assert(offsetof(FM1RuneData, SellingType) == 0x000042, "Member 'FM1RuneData::SellingType' has a wrong offset!");
static_assert(offsetof(FM1RuneData, SellingPrice) == 0x000044, "Member 'FM1RuneData::SellingPrice' has a wrong offset!");
static_assert(offsetof(FM1RuneData, Lv) == 0x000048, "Member 'FM1RuneData::Lv' has a wrong offset!");
static_assert(offsetof(FM1RuneData, UIData) == 0x000058, "Member 'FM1RuneData::UIData' has a wrong offset!");
static_assert(offsetof(FM1RuneData, Ability) == 0x0000B8, "Member 'FM1RuneData::Ability' has a wrong offset!");
static_assert(offsetof(FM1RuneData, Probability) == 0x0000E8, "Member 'FM1RuneData::Probability' has a wrong offset!");
static_assert(offsetof(FM1RuneData, Params) == 0x0000F0, "Member 'FM1RuneData::Params' has a wrong offset!");
static_assert(offsetof(FM1RuneData, TaggedParams) == 0x000100, "Member 'FM1RuneData::TaggedParams' has a wrong offset!");
static_assert(offsetof(FM1RuneData, DetailDataList) == 0x000110, "Member 'FM1RuneData::DetailDataList' has a wrong offset!");
static_assert(offsetof(FM1RuneData, Enchantable) == 0x000120, "Member 'FM1RuneData::Enchantable' has a wrong offset!");
static_assert(offsetof(FM1RuneData, Decomposable) == 0x000121, "Member 'FM1RuneData::Decomposable' has a wrong offset!");
static_assert(offsetof(FM1RuneData, Composable) == 0x000122, "Member 'FM1RuneData::Composable' has a wrong offset!");
static_assert(offsetof(FM1RuneData, PropClass) == 0x000128, "Member 'FM1RuneData::PropClass' has a wrong offset!");
static_assert(offsetof(FM1RuneData, ImportantPriority) == 0x000148, "Member 'FM1RuneData::ImportantPriority' has a wrong offset!");
static_assert(offsetof(FM1RuneData, ImportanceType) == 0x00014C, "Member 'FM1RuneData::ImportanceType' has a wrong offset!");
static_assert(offsetof(FM1RuneData, MasteryLevel) == 0x000150, "Member 'FM1RuneData::MasteryLevel' has a wrong offset!");
static_assert(offsetof(FM1RuneData, IsTemporary) == 0x000154, "Member 'FM1RuneData::IsTemporary' has a wrong offset!");

// ScriptStruct M1Data.M1RuneMiscData
// 0x0180 (0x0188 - 0x0008)
struct FM1RuneMiscData final : public FTableRowBase
{
public:
	int32                                         RuneWeapontMaxCount;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RuneCharacterMaxCount;                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RuneCostReduceValue;                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RuneCostIncreaseValue;                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemTierType                               RuneDecomposeNoticeTier;                           // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RuneDecomposeNoticeEnchantLevel;                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1RuneCostIncreaseResource            CharacterRuneCostIncreaseResource;                 // 0x0020(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FM1RuneCostIncreaseResource            WeaponRuneCostIncreaseResource;                    // 0x0058(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FM1ConsumableItemDataLink              RuneSocketGrantItem;                               // 0x0090(0x0030)(Edit, NativeAccessSpecifierPublic)
	int32                                         CharacterAddRuneCapacity;                          // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponAddRuneCapacity;                             // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapacityIncreaseCorrection;                        // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapacityReduceCorrection;                          // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ValidRuneGroupIds;                                 // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1RequiredItemData                    LoadoutSlotExpandRequiredItem;                     // 0x00E0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         LoadoutNameLimitLength;                            // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1CommonShopDataLink                  RuneShop;                                          // 0x00F8(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FM1ProductDataLink                     RuneCapacityExtendProduct;                         // 0x0128(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FM1ProductDataLink                     RuneSocketTypeProduct;                             // 0x0158(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneMiscData) == 0x000008, "Wrong alignment on FM1RuneMiscData");
static_assert(sizeof(FM1RuneMiscData) == 0x000188, "Wrong size on FM1RuneMiscData");
static_assert(offsetof(FM1RuneMiscData, RuneWeapontMaxCount) == 0x000008, "Member 'FM1RuneMiscData::RuneWeapontMaxCount' has a wrong offset!");
static_assert(offsetof(FM1RuneMiscData, RuneCharacterMaxCount) == 0x00000C, "Member 'FM1RuneMiscData::RuneCharacterMaxCount' has a wrong offset!");
static_assert(offsetof(FM1RuneMiscData, RuneCostReduceValue) == 0x000010, "Member 'FM1RuneMiscData::RuneCostReduceValue' has a wrong offset!");
static_assert(offsetof(FM1RuneMiscData, RuneCostIncreaseValue) == 0x000014, "Member 'FM1RuneMiscData::RuneCostIncreaseValue' has a wrong offset!");
static_assert(offsetof(FM1RuneMiscData, RuneDecomposeNoticeTier) == 0x000018, "Member 'FM1RuneMiscData::RuneDecomposeNoticeTier' has a wrong offset!");
static_assert(offsetof(FM1RuneMiscData, RuneDecomposeNoticeEnchantLevel) == 0x00001C, "Member 'FM1RuneMiscData::RuneDecomposeNoticeEnchantLevel' has a wrong offset!");
static_assert(offsetof(FM1RuneMiscData, CharacterRuneCostIncreaseResource) == 0x000020, "Member 'FM1RuneMiscData::CharacterRuneCostIncreaseResource' has a wrong offset!");
static_assert(offsetof(FM1RuneMiscData, WeaponRuneCostIncreaseResource) == 0x000058, "Member 'FM1RuneMiscData::WeaponRuneCostIncreaseResource' has a wrong offset!");
static_assert(offsetof(FM1RuneMiscData, RuneSocketGrantItem) == 0x000090, "Member 'FM1RuneMiscData::RuneSocketGrantItem' has a wrong offset!");
static_assert(offsetof(FM1RuneMiscData, CharacterAddRuneCapacity) == 0x0000C0, "Member 'FM1RuneMiscData::CharacterAddRuneCapacity' has a wrong offset!");
static_assert(offsetof(FM1RuneMiscData, WeaponAddRuneCapacity) == 0x0000C4, "Member 'FM1RuneMiscData::WeaponAddRuneCapacity' has a wrong offset!");
static_assert(offsetof(FM1RuneMiscData, CapacityIncreaseCorrection) == 0x0000C8, "Member 'FM1RuneMiscData::CapacityIncreaseCorrection' has a wrong offset!");
static_assert(offsetof(FM1RuneMiscData, CapacityReduceCorrection) == 0x0000CC, "Member 'FM1RuneMiscData::CapacityReduceCorrection' has a wrong offset!");
static_assert(offsetof(FM1RuneMiscData, ValidRuneGroupIds) == 0x0000D0, "Member 'FM1RuneMiscData::ValidRuneGroupIds' has a wrong offset!");
static_assert(offsetof(FM1RuneMiscData, LoadoutSlotExpandRequiredItem) == 0x0000E0, "Member 'FM1RuneMiscData::LoadoutSlotExpandRequiredItem' has a wrong offset!");
static_assert(offsetof(FM1RuneMiscData, LoadoutNameLimitLength) == 0x0000F0, "Member 'FM1RuneMiscData::LoadoutNameLimitLength' has a wrong offset!");
static_assert(offsetof(FM1RuneMiscData, RuneShop) == 0x0000F8, "Member 'FM1RuneMiscData::RuneShop' has a wrong offset!");
static_assert(offsetof(FM1RuneMiscData, RuneCapacityExtendProduct) == 0x000128, "Member 'FM1RuneMiscData::RuneCapacityExtendProduct' has a wrong offset!");
static_assert(offsetof(FM1RuneMiscData, RuneSocketTypeProduct) == 0x000158, "Member 'FM1RuneMiscData::RuneSocketTypeProduct' has a wrong offset!");

// ScriptStruct M1Data.M1RuneSocketGrantDetailData
// 0x0038 (0x0038 - 0x0000)
struct FM1RuneSocketGrantDetailData final
{
public:
	struct FM1ConsumableItemDataLink              ItemId;                                            // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	int32                                         Order;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RuneSocketGrantDetailData) == 0x000008, "Wrong alignment on FM1RuneSocketGrantDetailData");
static_assert(sizeof(FM1RuneSocketGrantDetailData) == 0x000038, "Wrong size on FM1RuneSocketGrantDetailData");
static_assert(offsetof(FM1RuneSocketGrantDetailData, ItemId) == 0x000000, "Member 'FM1RuneSocketGrantDetailData::ItemId' has a wrong offset!");
static_assert(offsetof(FM1RuneSocketGrantDetailData, Order) == 0x000030, "Member 'FM1RuneSocketGrantDetailData::Order' has a wrong offset!");

// ScriptStruct M1Data.M1RuneSocketGrantData
// 0x0018 (0x0020 - 0x0008)
struct FM1RuneSocketGrantData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RuneClassType                              ClassType;                                         // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RuneSocketType                             SocketType;                                        // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1RuneSocketGrantDetailData>   DetailDatas;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneSocketGrantData) == 0x000008, "Wrong alignment on FM1RuneSocketGrantData");
static_assert(sizeof(FM1RuneSocketGrantData) == 0x000020, "Wrong size on FM1RuneSocketGrantData");
static_assert(offsetof(FM1RuneSocketGrantData, TemplateId) == 0x000008, "Member 'FM1RuneSocketGrantData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1RuneSocketGrantData, ClassType) == 0x00000C, "Member 'FM1RuneSocketGrantData::ClassType' has a wrong offset!");
static_assert(offsetof(FM1RuneSocketGrantData, SocketType) == 0x00000D, "Member 'FM1RuneSocketGrantData::SocketType' has a wrong offset!");
static_assert(offsetof(FM1RuneSocketGrantData, DetailDatas) == 0x000010, "Member 'FM1RuneSocketGrantData::DetailDatas' has a wrong offset!");

// ScriptStruct M1Data.M1ProficiencyAdditionalData
// 0x0008 (0x0008 - 0x0000)
struct FM1ProficiencyAdditionalData final
{
public:
	EM1ItemTierType                               Tier;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RewardMasteryExpRate;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ProficiencyAdditionalData) == 0x000004, "Wrong alignment on FM1ProficiencyAdditionalData");
static_assert(sizeof(FM1ProficiencyAdditionalData) == 0x000008, "Wrong size on FM1ProficiencyAdditionalData");
static_assert(offsetof(FM1ProficiencyAdditionalData, Tier) == 0x000000, "Member 'FM1ProficiencyAdditionalData::Tier' has a wrong offset!");
static_assert(offsetof(FM1ProficiencyAdditionalData, RewardMasteryExpRate) == 0x000004, "Member 'FM1ProficiencyAdditionalData::RewardMasteryExpRate' has a wrong offset!");

// ScriptStruct M1Data.M1ProficiencyMiscData
// 0x0010 (0x0018 - 0x0008)
struct FM1ProficiencyMiscData final : public FTableRowBase
{
public:
	TArray<struct FM1ProficiencyAdditionalData>   AdditionalDataList;                                // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ProficiencyMiscData) == 0x000008, "Wrong alignment on FM1ProficiencyMiscData");
static_assert(sizeof(FM1ProficiencyMiscData) == 0x000018, "Wrong size on FM1ProficiencyMiscData");
static_assert(offsetof(FM1ProficiencyMiscData, AdditionalDataList) == 0x000008, "Member 'FM1ProficiencyMiscData::AdditionalDataList' has a wrong offset!");

// ScriptStruct M1Data.M1RuneComposeResourceData
// 0x0008 (0x0008 - 0x0000)
struct FM1RuneComposeResourceData final
{
public:
	EM1ItemTierType                               Tier;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GroupWeight;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneComposeResourceData) == 0x000004, "Wrong alignment on FM1RuneComposeResourceData");
static_assert(sizeof(FM1RuneComposeResourceData) == 0x000008, "Wrong size on FM1RuneComposeResourceData");
static_assert(offsetof(FM1RuneComposeResourceData, Tier) == 0x000000, "Member 'FM1RuneComposeResourceData::Tier' has a wrong offset!");
static_assert(offsetof(FM1RuneComposeResourceData, GroupWeight) == 0x000004, "Member 'FM1RuneComposeResourceData::GroupWeight' has a wrong offset!");

// ScriptStruct M1Data.M1RuneComposeRewardData
// 0x0018 (0x0018 - 0x0000)
struct FM1RuneComposeRewardData final
{
public:
	int32                                         RewardWeight;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RuneClassType                              ClassType;                                         // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RuneSocketType                             SocketType;                                        // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1RuneIdData>                  RuneIdList;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneComposeRewardData) == 0x000008, "Wrong alignment on FM1RuneComposeRewardData");
static_assert(sizeof(FM1RuneComposeRewardData) == 0x000018, "Wrong size on FM1RuneComposeRewardData");
static_assert(offsetof(FM1RuneComposeRewardData, RewardWeight) == 0x000000, "Member 'FM1RuneComposeRewardData::RewardWeight' has a wrong offset!");
static_assert(offsetof(FM1RuneComposeRewardData, ClassType) == 0x000004, "Member 'FM1RuneComposeRewardData::ClassType' has a wrong offset!");
static_assert(offsetof(FM1RuneComposeRewardData, SocketType) == 0x000005, "Member 'FM1RuneComposeRewardData::SocketType' has a wrong offset!");
static_assert(offsetof(FM1RuneComposeRewardData, RuneIdList) == 0x000008, "Member 'FM1RuneComposeRewardData::RuneIdList' has a wrong offset!");

// ScriptStruct M1Data.M1RuneComposeData
// 0x0028 (0x0030 - 0x0008)
struct FM1RuneComposeData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1RuneComposeResourceData>     ResourceWeightList;                                // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1RuneComposeRewardData>       RewardDataList;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneComposeData) == 0x000008, "Wrong alignment on FM1RuneComposeData");
static_assert(sizeof(FM1RuneComposeData) == 0x000030, "Wrong size on FM1RuneComposeData");
static_assert(offsetof(FM1RuneComposeData, TemplateId) == 0x000008, "Member 'FM1RuneComposeData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1RuneComposeData, ResourceWeightList) == 0x000010, "Member 'FM1RuneComposeData::ResourceWeightList' has a wrong offset!");
static_assert(offsetof(FM1RuneComposeData, RewardDataList) == 0x000020, "Member 'FM1RuneComposeData::RewardDataList' has a wrong offset!");

// ScriptStruct M1Data.M1PlatformAchievementPlatformInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1PlatformAchievementPlatformInfo final
{
public:
	EM1ContentsPlatformType                       Platform;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlreadyAchieved;                                  // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ID;                                                // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PlatformAchievementPlatformInfo) == 0x000008, "Wrong alignment on FM1PlatformAchievementPlatformInfo");
static_assert(sizeof(FM1PlatformAchievementPlatformInfo) == 0x000018, "Wrong size on FM1PlatformAchievementPlatformInfo");
static_assert(offsetof(FM1PlatformAchievementPlatformInfo, Platform) == 0x000000, "Member 'FM1PlatformAchievementPlatformInfo::Platform' has a wrong offset!");
static_assert(offsetof(FM1PlatformAchievementPlatformInfo, bAlreadyAchieved) == 0x000001, "Member 'FM1PlatformAchievementPlatformInfo::bAlreadyAchieved' has a wrong offset!");
static_assert(offsetof(FM1PlatformAchievementPlatformInfo, ID) == 0x000008, "Member 'FM1PlatformAchievementPlatformInfo::ID' has a wrong offset!");

// ScriptStruct M1Data.M1PlatformAchievementData
// 0x0030 (0x0038 - 0x0008)
struct FM1PlatformAchievementData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1PlatformAchievementPlatformInfo> PlatformAchievementInfos;                          // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EM1PlatformAchievementObjectiveCondition      ObjectiveCondition;                                // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ObjectiveParams;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PlatformAchievementData) == 0x000008, "Wrong alignment on FM1PlatformAchievementData");
static_assert(sizeof(FM1PlatformAchievementData) == 0x000038, "Wrong size on FM1PlatformAchievementData");
static_assert(offsetof(FM1PlatformAchievementData, TemplateId) == 0x000008, "Member 'FM1PlatformAchievementData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1PlatformAchievementData, PlatformAchievementInfos) == 0x000010, "Member 'FM1PlatformAchievementData::PlatformAchievementInfos' has a wrong offset!");
static_assert(offsetof(FM1PlatformAchievementData, ObjectiveCondition) == 0x000020, "Member 'FM1PlatformAchievementData::ObjectiveCondition' has a wrong offset!");
static_assert(offsetof(FM1PlatformAchievementData, ObjectiveParams) == 0x000028, "Member 'FM1PlatformAchievementData::ObjectiveParams' has a wrong offset!");

// ScriptStruct M1Data.M1ReactorMiscData
// 0x0010 (0x0018 - 0x0008)
struct FM1ReactorMiscData final : public FTableRowBase
{
public:
	TArray<struct FM1ReactorOptimizedValueByTier> OptimizedValueByTierList;                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ReactorMiscData) == 0x000008, "Wrong alignment on FM1ReactorMiscData");
static_assert(sizeof(FM1ReactorMiscData) == 0x000018, "Wrong size on FM1ReactorMiscData");
static_assert(offsetof(FM1ReactorMiscData, OptimizedValueByTierList) == 0x000008, "Member 'FM1ReactorMiscData::OptimizedValueByTierList' has a wrong offset!");

// ScriptStruct M1Data.M1SpecValue
// 0x0004 (0x0004 - 0x0000)
struct FM1SpecValue final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SpecValue) == 0x000004, "Wrong alignment on FM1SpecValue");
static_assert(sizeof(FM1SpecValue) == 0x000004, "Wrong size on FM1SpecValue");
static_assert(offsetof(FM1SpecValue, Value) == 0x000000, "Member 'FM1SpecValue::Value' has a wrong offset!");

// ScriptStruct M1Data.M1RecommendSpecsUIData
// 0x0018 (0x0020 - 0x0008)
struct FM1RecommendSpecsUIData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1SpecValue>                   RecommendSpec;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RecommendSpecsUIData) == 0x000008, "Wrong alignment on FM1RecommendSpecsUIData");
static_assert(sizeof(FM1RecommendSpecsUIData) == 0x000020, "Wrong size on FM1RecommendSpecsUIData");
static_assert(offsetof(FM1RecommendSpecsUIData, TemplateId) == 0x000008, "Member 'FM1RecommendSpecsUIData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1RecommendSpecsUIData, RecommendSpec) == 0x000010, "Member 'FM1RecommendSpecsUIData::RecommendSpec' has a wrong offset!");

// ScriptStruct M1Data.M1VoidBattleMiscData
// 0x0010 (0x0018 - 0x0008)
struct FM1VoidBattleMiscData final : public FTableRowBase
{
public:
	int32                                         ForcedExitTimeInVoid;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ForcedRestartTimeVoid;                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartyVaultSelectionTimeInVoid;                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1VoidBattleMiscData) == 0x000008, "Wrong alignment on FM1VoidBattleMiscData");
static_assert(sizeof(FM1VoidBattleMiscData) == 0x000018, "Wrong size on FM1VoidBattleMiscData");
static_assert(offsetof(FM1VoidBattleMiscData, ForcedExitTimeInVoid) == 0x000008, "Member 'FM1VoidBattleMiscData::ForcedExitTimeInVoid' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleMiscData, ForcedRestartTimeVoid) == 0x00000C, "Member 'FM1VoidBattleMiscData::ForcedRestartTimeVoid' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleMiscData, PartyVaultSelectionTimeInVoid) == 0x000010, "Member 'FM1VoidBattleMiscData::PartyVaultSelectionTimeInVoid' has a wrong offset!");

// ScriptStruct M1Data.M1WorldMissionData
// 0x0040 (0x0048 - 0x0008)
struct FM1WorldMissionData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1MapDataLink                         MapId;                                             // 0x0010(0x0030)(Edit, NativeAccessSpecifierPublic)
	class FName                                   EnterWorldMissionToast;                            // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WorldMissionData) == 0x000008, "Wrong alignment on FM1WorldMissionData");
static_assert(sizeof(FM1WorldMissionData) == 0x000048, "Wrong size on FM1WorldMissionData");
static_assert(offsetof(FM1WorldMissionData, TemplateId) == 0x000008, "Member 'FM1WorldMissionData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1WorldMissionData, MapId) == 0x000010, "Member 'FM1WorldMissionData::MapId' has a wrong offset!");
static_assert(offsetof(FM1WorldMissionData, EnterWorldMissionToast) == 0x000040, "Member 'FM1WorldMissionData::EnterWorldMissionToast' has a wrong offset!");

// ScriptStruct M1Data.M1WorldMissionMiscData
// 0x0000 (0x0008 - 0x0008)
struct FM1WorldMissionMiscData final : public FTableRowBase
{
};
static_assert(alignof(FM1WorldMissionMiscData) == 0x000008, "Wrong alignment on FM1WorldMissionMiscData");
static_assert(sizeof(FM1WorldMissionMiscData) == 0x000008, "Wrong size on FM1WorldMissionMiscData");

// ScriptStruct M1Data.M1InstanceDungeonData
// 0x00B8 (0x0148 - 0x0090)
struct FM1InstanceDungeonData final : public FM1InstanceFieldContentsDataBase
{
public:
	struct FSoftObjectPath                        BGImagePath;                                       // 0x0090(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Group;                                             // 0x00B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1InstanceDungeonDifficulty                  Difficulty;                                        // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinMembers;                                        // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1CurrencyPair                        SelectMODChangeCost;                               // 0x00C8(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FM1InstanceDungeonFixedMODDataLink> FixedMODData;                                      // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1InstanceDungeonRewardDataLink> RewardGroups;                                      // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1InstanceDungeonSelectionMODGroupDataLink SelectionMODData;                                  // 0x00F0(0x0030)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1InstanceDungeonModifierPresetDataLink> ModifierPresets;                                   // 0x0120(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1InstanceDungeonScoreInfo            ScoreInfo;                                         // 0x0130(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceDungeonData) == 0x000008, "Wrong alignment on FM1InstanceDungeonData");
static_assert(sizeof(FM1InstanceDungeonData) == 0x000148, "Wrong size on FM1InstanceDungeonData");
static_assert(offsetof(FM1InstanceDungeonData, BGImagePath) == 0x000090, "Member 'FM1InstanceDungeonData::BGImagePath' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonData, Group) == 0x0000B0, "Member 'FM1InstanceDungeonData::Group' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonData, Difficulty) == 0x0000C0, "Member 'FM1InstanceDungeonData::Difficulty' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonData, MinMembers) == 0x0000C4, "Member 'FM1InstanceDungeonData::MinMembers' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonData, SelectMODChangeCost) == 0x0000C8, "Member 'FM1InstanceDungeonData::SelectMODChangeCost' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonData, FixedMODData) == 0x0000D0, "Member 'FM1InstanceDungeonData::FixedMODData' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonData, RewardGroups) == 0x0000E0, "Member 'FM1InstanceDungeonData::RewardGroups' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonData, SelectionMODData) == 0x0000F0, "Member 'FM1InstanceDungeonData::SelectionMODData' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonData, ModifierPresets) == 0x000120, "Member 'FM1InstanceDungeonData::ModifierPresets' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonData, ScoreInfo) == 0x000130, "Member 'FM1InstanceDungeonData::ScoreInfo' has a wrong offset!");

// ScriptStruct M1Data.M1InstanceDungeonReward
// 0x0050 (0x0050 - 0x0000)
struct FM1InstanceDungeonReward final
{
public:
	struct FM1RewardType                          Item;                                              // 0x0000(0x0040)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1InstanceDungeonScoreSection> ScoreSection;                                      // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceDungeonReward) == 0x000008, "Wrong alignment on FM1InstanceDungeonReward");
static_assert(sizeof(FM1InstanceDungeonReward) == 0x000050, "Wrong size on FM1InstanceDungeonReward");
static_assert(offsetof(FM1InstanceDungeonReward, Item) == 0x000000, "Member 'FM1InstanceDungeonReward::Item' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonReward, ScoreSection) == 0x000040, "Member 'FM1InstanceDungeonReward::ScoreSection' has a wrong offset!");

// ScriptStruct M1Data.M1InstanceDungeonRewardData
// 0x0028 (0x0030 - 0x0008)
struct FM1InstanceDungeonRewardData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringId;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1InstanceDungeonReward>       Rewards;                                           // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceDungeonRewardData) == 0x000008, "Wrong alignment on FM1InstanceDungeonRewardData");
static_assert(sizeof(FM1InstanceDungeonRewardData) == 0x000030, "Wrong size on FM1InstanceDungeonRewardData");
static_assert(offsetof(FM1InstanceDungeonRewardData, TemplateId) == 0x000008, "Member 'FM1InstanceDungeonRewardData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonRewardData, StringId) == 0x000010, "Member 'FM1InstanceDungeonRewardData::StringId' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonRewardData, Rewards) == 0x000020, "Member 'FM1InstanceDungeonRewardData::Rewards' has a wrong offset!");

// ScriptStruct M1Data.M1InstanceDungeonModifierPresetData
// 0x0010 (0x0030 - 0x0020)
struct FM1InstanceDungeonModifierPresetData final : public FM1InstanceDungeonMODData
{
public:
	TArray<struct FM1InstanceDungeonAbilityDataLink> AbilityData;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceDungeonModifierPresetData) == 0x000008, "Wrong alignment on FM1InstanceDungeonModifierPresetData");
static_assert(sizeof(FM1InstanceDungeonModifierPresetData) == 0x000030, "Wrong size on FM1InstanceDungeonModifierPresetData");
static_assert(offsetof(FM1InstanceDungeonModifierPresetData, AbilityData) == 0x000020, "Member 'FM1InstanceDungeonModifierPresetData::AbilityData' has a wrong offset!");

// ScriptStruct M1Data.M1InstanceDungeonMiscData
// 0x0010 (0x0018 - 0x0008)
struct FM1InstanceDungeonMiscData final : public FTableRowBase
{
public:
	TArray<struct FM1InstanceDungeonModifierPresetCommonInfo> ModifierPresetCommonInfo;                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceDungeonMiscData) == 0x000008, "Wrong alignment on FM1InstanceDungeonMiscData");
static_assert(sizeof(FM1InstanceDungeonMiscData) == 0x000018, "Wrong size on FM1InstanceDungeonMiscData");
static_assert(offsetof(FM1InstanceDungeonMiscData, ModifierPresetCommonInfo) == 0x000008, "Member 'FM1InstanceDungeonMiscData::ModifierPresetCommonInfo' has a wrong offset!");

// ScriptStruct M1Data.M1InstanceDungeonFixedMODData
// 0x0020 (0x0040 - 0x0020)
struct FM1InstanceDungeonFixedMODData final : public FM1InstanceDungeonMODData
{
public:
	TArray<struct FM1InstanceDungeonAbilityDataLink> AbilityData;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1InstanceDungeonReward>       Rewards;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceDungeonFixedMODData) == 0x000008, "Wrong alignment on FM1InstanceDungeonFixedMODData");
static_assert(sizeof(FM1InstanceDungeonFixedMODData) == 0x000040, "Wrong size on FM1InstanceDungeonFixedMODData");
static_assert(offsetof(FM1InstanceDungeonFixedMODData, AbilityData) == 0x000020, "Member 'FM1InstanceDungeonFixedMODData::AbilityData' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonFixedMODData, Rewards) == 0x000030, "Member 'FM1InstanceDungeonFixedMODData::Rewards' has a wrong offset!");

// ScriptStruct M1Data.M1InstanceDungeonSelectionMODData
// 0x0040 (0x0060 - 0x0020)
struct FM1InstanceDungeonSelectionMODData final : public FM1InstanceDungeonMODData
{
public:
	int32                                         Category;                                          // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CategoryRatio;                                     // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScoreBonus;                                        // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1InstanceDungeonAbilityDataLink      AbilityData;                                       // 0x0030(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceDungeonSelectionMODData) == 0x000008, "Wrong alignment on FM1InstanceDungeonSelectionMODData");
static_assert(sizeof(FM1InstanceDungeonSelectionMODData) == 0x000060, "Wrong size on FM1InstanceDungeonSelectionMODData");
static_assert(offsetof(FM1InstanceDungeonSelectionMODData, Category) == 0x000020, "Member 'FM1InstanceDungeonSelectionMODData::Category' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonSelectionMODData, CategoryRatio) == 0x000024, "Member 'FM1InstanceDungeonSelectionMODData::CategoryRatio' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonSelectionMODData, ScoreBonus) == 0x000028, "Member 'FM1InstanceDungeonSelectionMODData::ScoreBonus' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonSelectionMODData, AbilityData) == 0x000030, "Member 'FM1InstanceDungeonSelectionMODData::AbilityData' has a wrong offset!");

// ScriptStruct M1Data.M1InstanceDungeonSelectionMODGroupData
// 0x0020 (0x0028 - 0x0008)
struct FM1InstanceDungeonSelectionMODGroupData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectionMaxCount;                                 // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1InstanceDungeonSelectionMODInfo> MODInfo;                                           // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceDungeonSelectionMODGroupData) == 0x000008, "Wrong alignment on FM1InstanceDungeonSelectionMODGroupData");
static_assert(sizeof(FM1InstanceDungeonSelectionMODGroupData) == 0x000028, "Wrong size on FM1InstanceDungeonSelectionMODGroupData");
static_assert(offsetof(FM1InstanceDungeonSelectionMODGroupData, TemplateId) == 0x000008, "Member 'FM1InstanceDungeonSelectionMODGroupData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonSelectionMODGroupData, Name) == 0x00000C, "Member 'FM1InstanceDungeonSelectionMODGroupData::Name' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonSelectionMODGroupData, SelectionMaxCount) == 0x000014, "Member 'FM1InstanceDungeonSelectionMODGroupData::SelectionMaxCount' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonSelectionMODGroupData, MODInfo) == 0x000018, "Member 'FM1InstanceDungeonSelectionMODGroupData::MODInfo' has a wrong offset!");

// ScriptStruct M1Data.M1InvasionDungeonTimeAttackGroup
// 0x0020 (0x0028 - 0x0008)
struct FM1InvasionDungeonTimeAttackGroup final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ratio;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1ItemDef>                     Items;                                             // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InvasionDungeonTimeAttackGroup) == 0x000008, "Wrong alignment on FM1InvasionDungeonTimeAttackGroup");
static_assert(sizeof(FM1InvasionDungeonTimeAttackGroup) == 0x000028, "Wrong size on FM1InvasionDungeonTimeAttackGroup");
static_assert(offsetof(FM1InvasionDungeonTimeAttackGroup, Name) == 0x000008, "Member 'FM1InvasionDungeonTimeAttackGroup::Name' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonTimeAttackGroup, Ratio) == 0x000010, "Member 'FM1InvasionDungeonTimeAttackGroup::Ratio' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonTimeAttackGroup, Items) == 0x000018, "Member 'FM1InvasionDungeonTimeAttackGroup::Items' has a wrong offset!");

// ScriptStruct M1Data.M1InvasionDungeonRewardInfo
// 0x0028 (0x0028 - 0x0000)
struct FM1InvasionDungeonRewardInfo final
{
public:
	int32                                         SeasonExp;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1ItemDef>                     Items;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1InvasionDungeonTimeAttackReward> TimeAttack;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InvasionDungeonRewardInfo) == 0x000008, "Wrong alignment on FM1InvasionDungeonRewardInfo");
static_assert(sizeof(FM1InvasionDungeonRewardInfo) == 0x000028, "Wrong size on FM1InvasionDungeonRewardInfo");
static_assert(offsetof(FM1InvasionDungeonRewardInfo, SeasonExp) == 0x000000, "Member 'FM1InvasionDungeonRewardInfo::SeasonExp' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonRewardInfo, Items) == 0x000008, "Member 'FM1InvasionDungeonRewardInfo::Items' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonRewardInfo, TimeAttack) == 0x000018, "Member 'FM1InvasionDungeonRewardInfo::TimeAttack' has a wrong offset!");

// ScriptStruct M1Data.M1InvasionDungeonData
// 0x0080 (0x0110 - 0x0090)
struct FM1InvasionDungeonData final : public FM1InstanceFieldContentsDataBase
{
public:
	struct FSoftObjectPath                        BGImagePath;                                       // 0x0090(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1InstanceDungeonDataLink             InstanceDungeon;                                   // 0x00B0(0x0030)(Edit, NativeAccessSpecifierPublic)
	int32                                         SeasonExpLimit;                                    // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1InvasionDungeonRewardInfo           RewardInfo;                                        // 0x00E8(0x0028)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InvasionDungeonData) == 0x000008, "Wrong alignment on FM1InvasionDungeonData");
static_assert(sizeof(FM1InvasionDungeonData) == 0x000110, "Wrong size on FM1InvasionDungeonData");
static_assert(offsetof(FM1InvasionDungeonData, BGImagePath) == 0x000090, "Member 'FM1InvasionDungeonData::BGImagePath' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonData, InstanceDungeon) == 0x0000B0, "Member 'FM1InvasionDungeonData::InstanceDungeon' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonData, SeasonExpLimit) == 0x0000E0, "Member 'FM1InvasionDungeonData::SeasonExpLimit' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonData, RewardInfo) == 0x0000E8, "Member 'FM1InvasionDungeonData::RewardInfo' has a wrong offset!");

// ScriptStruct M1Data.M1InvasionDungeonMiscData
// 0x0060 (0x0068 - 0x0008)
struct FM1InvasionDungeonMiscData final : public FTableRowBase
{
public:
	struct FM1QuestDataLink                       UnlockQuest;                                       // 0x0008(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FM1InstanceFieldContentsDataBaseLink   UnlockDungeon;                                     // 0x0038(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InvasionDungeonMiscData) == 0x000008, "Wrong alignment on FM1InvasionDungeonMiscData");
static_assert(sizeof(FM1InvasionDungeonMiscData) == 0x000068, "Wrong size on FM1InvasionDungeonMiscData");
static_assert(offsetof(FM1InvasionDungeonMiscData, UnlockQuest) == 0x000008, "Member 'FM1InvasionDungeonMiscData::UnlockQuest' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonMiscData, UnlockDungeon) == 0x000038, "Member 'FM1InvasionDungeonMiscData::UnlockDungeon' has a wrong offset!");

// ScriptStruct M1Data.M1MailData
// 0x0028 (0x0030 - 0x0008)
struct FM1MailData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MailType                                   MailType;                                          // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MailStringId;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NarrativePriority;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EM1LoginPlatformTypes>                 PlatformTypes;                                     // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MailData) == 0x000008, "Wrong alignment on FM1MailData");
static_assert(sizeof(FM1MailData) == 0x000030, "Wrong size on FM1MailData");
static_assert(offsetof(FM1MailData, TemplateId) == 0x000008, "Member 'FM1MailData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1MailData, MailType) == 0x00000C, "Member 'FM1MailData::MailType' has a wrong offset!");
static_assert(offsetof(FM1MailData, MailStringId) == 0x000010, "Member 'FM1MailData::MailStringId' has a wrong offset!");
static_assert(offsetof(FM1MailData, NarrativePriority) == 0x000018, "Member 'FM1MailData::NarrativePriority' has a wrong offset!");
static_assert(offsetof(FM1MailData, PlatformTypes) == 0x000020, "Member 'FM1MailData::PlatformTypes' has a wrong offset!");

// ScriptStruct M1Data.M1MailMiscData
// 0x0010 (0x0018 - 0x0008)
struct FM1MailMiscData final : public FTableRowBase
{
public:
	int32                                         MailLostHoldCount;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MailLostExpiredTime;                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MailItemCountMax;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MailOpReloadPeriodSec;                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MailMiscData) == 0x000008, "Wrong alignment on FM1MailMiscData");
static_assert(sizeof(FM1MailMiscData) == 0x000018, "Wrong size on FM1MailMiscData");
static_assert(offsetof(FM1MailMiscData, MailLostHoldCount) == 0x000008, "Member 'FM1MailMiscData::MailLostHoldCount' has a wrong offset!");
static_assert(offsetof(FM1MailMiscData, MailLostExpiredTime) == 0x00000C, "Member 'FM1MailMiscData::MailLostExpiredTime' has a wrong offset!");
static_assert(offsetof(FM1MailMiscData, MailItemCountMax) == 0x000010, "Member 'FM1MailMiscData::MailItemCountMax' has a wrong offset!");
static_assert(offsetof(FM1MailMiscData, MailOpReloadPeriodSec) == 0x000014, "Member 'FM1MailMiscData::MailOpReloadPeriodSec' has a wrong offset!");

// ScriptStruct M1Data.M1EventMiscData
// 0x0030 (0x0038 - 0x0008)
struct FM1EventMiscData final : public FTableRowBase
{
public:
	int32                                         DailyResetTime;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1DayOfWeek                                  WeeklyResetDate;                                   // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         EventWidgetClass;                                  // 0x0010(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OntimeEventCheckPeriodSec;                         // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1EventMiscData) == 0x000008, "Wrong alignment on FM1EventMiscData");
static_assert(sizeof(FM1EventMiscData) == 0x000038, "Wrong size on FM1EventMiscData");
static_assert(offsetof(FM1EventMiscData, DailyResetTime) == 0x000008, "Member 'FM1EventMiscData::DailyResetTime' has a wrong offset!");
static_assert(offsetof(FM1EventMiscData, WeeklyResetDate) == 0x00000C, "Member 'FM1EventMiscData::WeeklyResetDate' has a wrong offset!");
static_assert(offsetof(FM1EventMiscData, EventWidgetClass) == 0x000010, "Member 'FM1EventMiscData::EventWidgetClass' has a wrong offset!");
static_assert(offsetof(FM1EventMiscData, OntimeEventCheckPeriodSec) == 0x000030, "Member 'FM1EventMiscData::OntimeEventCheckPeriodSec' has a wrong offset!");

// ScriptStruct M1Data.M1MaterialData
// 0x0018 (0x0018 - 0x0000)
struct FM1MaterialData final
{
public:
	EM1ItemTierType                               MaterialTier;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1RequiredItemData>            RequiredItems;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MaterialData) == 0x000008, "Wrong alignment on FM1MaterialData");
static_assert(sizeof(FM1MaterialData) == 0x000018, "Wrong size on FM1MaterialData");
static_assert(offsetof(FM1MaterialData, MaterialTier) == 0x000000, "Member 'FM1MaterialData::MaterialTier' has a wrong offset!");
static_assert(offsetof(FM1MaterialData, RequiredItems) == 0x000008, "Member 'FM1MaterialData::RequiredItems' has a wrong offset!");

// ScriptStruct M1Data.M1ItemLevelUpgradeData
// 0x0018 (0x0020 - 0x0008)
struct FM1ItemLevelUpgradeData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemTierType                               TargetTier;                                        // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1MaterialData>                MaterialDataList;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemLevelUpgradeData) == 0x000008, "Wrong alignment on FM1ItemLevelUpgradeData");
static_assert(sizeof(FM1ItemLevelUpgradeData) == 0x000020, "Wrong size on FM1ItemLevelUpgradeData");
static_assert(offsetof(FM1ItemLevelUpgradeData, TemplateId) == 0x000008, "Member 'FM1ItemLevelUpgradeData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1ItemLevelUpgradeData, TargetTier) == 0x00000C, "Member 'FM1ItemLevelUpgradeData::TargetTier' has a wrong offset!");
static_assert(offsetof(FM1ItemLevelUpgradeData, MaterialDataList) == 0x000010, "Member 'FM1ItemLevelUpgradeData::MaterialDataList' has a wrong offset!");

// ScriptStruct M1Data.M1DecomposeRewardItemInfo
// 0x0014 (0x0014 - 0x0000)
struct FM1DecomposeRewardItemInfo final
{
public:
	EM1ItemType                                   Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinValue;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxValue;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DecomposeRewardItemInfo) == 0x000004, "Wrong alignment on FM1DecomposeRewardItemInfo");
static_assert(sizeof(FM1DecomposeRewardItemInfo) == 0x000014, "Wrong size on FM1DecomposeRewardItemInfo");
static_assert(offsetof(FM1DecomposeRewardItemInfo, Type) == 0x000000, "Member 'FM1DecomposeRewardItemInfo::Type' has a wrong offset!");
static_assert(offsetof(FM1DecomposeRewardItemInfo, Name) == 0x000004, "Member 'FM1DecomposeRewardItemInfo::Name' has a wrong offset!");
static_assert(offsetof(FM1DecomposeRewardItemInfo, MinValue) == 0x00000C, "Member 'FM1DecomposeRewardItemInfo::MinValue' has a wrong offset!");
static_assert(offsetof(FM1DecomposeRewardItemInfo, MaxValue) == 0x000010, "Member 'FM1DecomposeRewardItemInfo::MaxValue' has a wrong offset!");

// ScriptStruct M1Data.M1DecomposeRewardInfoPerLevel
// 0x0018 (0x0018 - 0x0000)
struct FM1DecomposeRewardInfoPerLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1DecomposeRewardItemInfo>     Rewards;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DecomposeRewardInfoPerLevel) == 0x000008, "Wrong alignment on FM1DecomposeRewardInfoPerLevel");
static_assert(sizeof(FM1DecomposeRewardInfoPerLevel) == 0x000018, "Wrong size on FM1DecomposeRewardInfoPerLevel");
static_assert(offsetof(FM1DecomposeRewardInfoPerLevel, Level) == 0x000000, "Member 'FM1DecomposeRewardInfoPerLevel::Level' has a wrong offset!");
static_assert(offsetof(FM1DecomposeRewardInfoPerLevel, Rewards) == 0x000008, "Member 'FM1DecomposeRewardInfoPerLevel::Rewards' has a wrong offset!");

// ScriptStruct M1Data.M1EquipmentDecomposeData
// 0x0028 (0x0030 - 0x0008)
struct FM1EquipmentDecomposeData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1DecomposeTargetType                        CategoryType;                                      // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CategoryParam;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1DecomposeRewardInfoPerLevel> RewardsPerLevel;                                   // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EquipmentDecomposeData) == 0x000008, "Wrong alignment on FM1EquipmentDecomposeData");
static_assert(sizeof(FM1EquipmentDecomposeData) == 0x000030, "Wrong size on FM1EquipmentDecomposeData");
static_assert(offsetof(FM1EquipmentDecomposeData, TemplateId) == 0x000008, "Member 'FM1EquipmentDecomposeData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1EquipmentDecomposeData, CategoryType) == 0x00000C, "Member 'FM1EquipmentDecomposeData::CategoryType' has a wrong offset!");
static_assert(offsetof(FM1EquipmentDecomposeData, CategoryParam) == 0x000010, "Member 'FM1EquipmentDecomposeData::CategoryParam' has a wrong offset!");
static_assert(offsetof(FM1EquipmentDecomposeData, RewardsPerLevel) == 0x000020, "Member 'FM1EquipmentDecomposeData::RewardsPerLevel' has a wrong offset!");

// ScriptStruct M1Data.M1SetOptionDetailData
// 0x0040 (0x0040 - 0x0000)
struct FM1SetOptionDetailData final
{
public:
	int32                                         RequiredEquipAmount;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1SetOptionAbilityDataLink            Ability;                                           // 0x0010(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SetOptionDetailData) == 0x000008, "Wrong alignment on FM1SetOptionDetailData");
static_assert(sizeof(FM1SetOptionDetailData) == 0x000040, "Wrong size on FM1SetOptionDetailData");
static_assert(offsetof(FM1SetOptionDetailData, RequiredEquipAmount) == 0x000000, "Member 'FM1SetOptionDetailData::RequiredEquipAmount' has a wrong offset!");
static_assert(offsetof(FM1SetOptionDetailData, StringId) == 0x000004, "Member 'FM1SetOptionDetailData::StringId' has a wrong offset!");
static_assert(offsetof(FM1SetOptionDetailData, Ability) == 0x000010, "Member 'FM1SetOptionDetailData::Ability' has a wrong offset!");

// ScriptStruct M1Data.M1SetOptionData
// 0x0030 (0x0038 - 0x0008)
struct FM1SetOptionData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EM1EquipmentSlotType>                  EquipmentSlotList;                                 // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1SetOptionDetailData>         DetailDataList;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SetOptionData) == 0x000008, "Wrong alignment on FM1SetOptionData");
static_assert(sizeof(FM1SetOptionData) == 0x000038, "Wrong size on FM1SetOptionData");
static_assert(offsetof(FM1SetOptionData, TemplateId) == 0x000008, "Member 'FM1SetOptionData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1SetOptionData, StringId) == 0x00000C, "Member 'FM1SetOptionData::StringId' has a wrong offset!");
static_assert(offsetof(FM1SetOptionData, EquipmentSlotList) == 0x000018, "Member 'FM1SetOptionData::EquipmentSlotList' has a wrong offset!");
static_assert(offsetof(FM1SetOptionData, DetailDataList) == 0x000028, "Member 'FM1SetOptionData::DetailDataList' has a wrong offset!");

// ScriptStruct M1Data.M1DropItemLevelWeightDetailData
// 0x0008 (0x0008 - 0x0000)
struct FM1DropItemLevelWeightDetailData final
{
public:
	int32                                         Diff;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DropItemLevelWeightDetailData) == 0x000004, "Wrong alignment on FM1DropItemLevelWeightDetailData");
static_assert(sizeof(FM1DropItemLevelWeightDetailData) == 0x000008, "Wrong size on FM1DropItemLevelWeightDetailData");
static_assert(offsetof(FM1DropItemLevelWeightDetailData, Diff) == 0x000000, "Member 'FM1DropItemLevelWeightDetailData::Diff' has a wrong offset!");
static_assert(offsetof(FM1DropItemLevelWeightDetailData, Weight) == 0x000004, "Member 'FM1DropItemLevelWeightDetailData::Weight' has a wrong offset!");

// ScriptStruct M1Data.M1DropItemLevelWeightData
// 0x0018 (0x0020 - 0x0008)
struct FM1DropItemLevelWeightData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 WeightList;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DropItemLevelWeightData) == 0x000008, "Wrong alignment on FM1DropItemLevelWeightData");
static_assert(sizeof(FM1DropItemLevelWeightData) == 0x000020, "Wrong size on FM1DropItemLevelWeightData");
static_assert(offsetof(FM1DropItemLevelWeightData, TemplateId) == 0x000008, "Member 'FM1DropItemLevelWeightData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1DropItemLevelWeightData, WeightList) == 0x000010, "Member 'FM1DropItemLevelWeightData::WeightList' has a wrong offset!");

// ScriptStruct M1Data.M1TitleData
// 0x0030 (0x0038 - 0x0008)
struct FM1TitleData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Title;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TitleFemale;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1TitleType                                  Type;                                              // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1TitleData) == 0x000008, "Wrong alignment on FM1TitleData");
static_assert(sizeof(FM1TitleData) == 0x000038, "Wrong size on FM1TitleData");
static_assert(offsetof(FM1TitleData, TemplateId) == 0x000008, "Member 'FM1TitleData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1TitleData, Title) == 0x000010, "Member 'FM1TitleData::Title' has a wrong offset!");
static_assert(offsetof(FM1TitleData, TitleFemale) == 0x000020, "Member 'FM1TitleData::TitleFemale' has a wrong offset!");
static_assert(offsetof(FM1TitleData, Type) == 0x000030, "Member 'FM1TitleData::Type' has a wrong offset!");

// ScriptStruct M1Data.M1TitleMiscData
// 0x0030 (0x0038 - 0x0008)
struct FM1TitleMiscData final : public FTableRowBase
{
public:
	TArray<class FString>                         ReverseOrderList;                                  // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0018(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TitleMiscData) == 0x000008, "Wrong alignment on FM1TitleMiscData");
static_assert(sizeof(FM1TitleMiscData) == 0x000038, "Wrong size on FM1TitleMiscData");
static_assert(offsetof(FM1TitleMiscData, ReverseOrderList) == 0x000008, "Member 'FM1TitleMiscData::ReverseOrderList' has a wrong offset!");
static_assert(offsetof(FM1TitleMiscData, IconPath) == 0x000018, "Member 'FM1TitleMiscData::IconPath' has a wrong offset!");

// ScriptStruct M1Data.M1BattlePassChallengeReward
// 0x0040 (0x0040 - 0x0000)
struct FM1BattlePassChallengeReward final
{
public:
	struct FM1ItemDataBox                         Item;                                              // 0x0000(0x0038)(Edit, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattlePassChallengeReward) == 0x000008, "Wrong alignment on FM1BattlePassChallengeReward");
static_assert(sizeof(FM1BattlePassChallengeReward) == 0x000040, "Wrong size on FM1BattlePassChallengeReward");
static_assert(offsetof(FM1BattlePassChallengeReward, Item) == 0x000000, "Member 'FM1BattlePassChallengeReward::Item' has a wrong offset!");
static_assert(offsetof(FM1BattlePassChallengeReward, Count) == 0x000038, "Member 'FM1BattlePassChallengeReward::Count' has a wrong offset!");
static_assert(offsetof(FM1BattlePassChallengeReward, Level) == 0x00003C, "Member 'FM1BattlePassChallengeReward::Level' has a wrong offset!");

// ScriptStruct M1Data.M1BattlePassLevelDetail
// 0x0028 (0x0028 - 0x0000)
struct FM1BattlePassLevelDetail final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredExp;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalRequiredExp;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1RewardType>                  RewardDataList;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          PremiumExclusive;                                  // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1BattlePassLevelDetail) == 0x000008, "Wrong alignment on FM1BattlePassLevelDetail");
static_assert(sizeof(FM1BattlePassLevelDetail) == 0x000028, "Wrong size on FM1BattlePassLevelDetail");
static_assert(offsetof(FM1BattlePassLevelDetail, Level) == 0x000000, "Member 'FM1BattlePassLevelDetail::Level' has a wrong offset!");
static_assert(offsetof(FM1BattlePassLevelDetail, RequiredExp) == 0x000004, "Member 'FM1BattlePassLevelDetail::RequiredExp' has a wrong offset!");
static_assert(offsetof(FM1BattlePassLevelDetail, TotalRequiredExp) == 0x000008, "Member 'FM1BattlePassLevelDetail::TotalRequiredExp' has a wrong offset!");
static_assert(offsetof(FM1BattlePassLevelDetail, RewardDataList) == 0x000010, "Member 'FM1BattlePassLevelDetail::RewardDataList' has a wrong offset!");
static_assert(offsetof(FM1BattlePassLevelDetail, PremiumExclusive) == 0x000020, "Member 'FM1BattlePassLevelDetail::PremiumExclusive' has a wrong offset!");

// ScriptStruct M1Data.M1BattlePassLevelData
// 0x0048 (0x0050 - 0x0008)
struct FM1BattlePassLevelData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1BattlePassLevelDetail>       LevelList;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1MailDataLink                        RewardMail;                                        // 0x0020(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattlePassLevelData) == 0x000008, "Wrong alignment on FM1BattlePassLevelData");
static_assert(sizeof(FM1BattlePassLevelData) == 0x000050, "Wrong size on FM1BattlePassLevelData");
static_assert(offsetof(FM1BattlePassLevelData, TemplateId) == 0x000008, "Member 'FM1BattlePassLevelData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1BattlePassLevelData, LevelList) == 0x000010, "Member 'FM1BattlePassLevelData::LevelList' has a wrong offset!");
static_assert(offsetof(FM1BattlePassLevelData, RewardMail) == 0x000020, "Member 'FM1BattlePassLevelData::RewardMail' has a wrong offset!");

// ScriptStruct M1Data.M1BattlePassDetailData
// 0x0038 (0x0038 - 0x0000)
struct FM1BattlePassDetailData final
{
public:
	EM1BattlePassType                             Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1BattlePassShopDataLink              ShopData;                                          // 0x0008(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattlePassDetailData) == 0x000008, "Wrong alignment on FM1BattlePassDetailData");
static_assert(sizeof(FM1BattlePassDetailData) == 0x000038, "Wrong size on FM1BattlePassDetailData");
static_assert(offsetof(FM1BattlePassDetailData, Type) == 0x000000, "Member 'FM1BattlePassDetailData::Type' has a wrong offset!");
static_assert(offsetof(FM1BattlePassDetailData, ShopData) == 0x000008, "Member 'FM1BattlePassDetailData::ShopData' has a wrong offset!");

// ScriptStruct M1Data.M1BattlePassChallengeDetailData
// 0x0080 (0x0080 - 0x0000)
struct FM1BattlePassChallengeDetailData final
{
public:
	struct FM1ChallengeDetailData                 ChallengeData;                                     // 0x0000(0x0068)(Edit, NativeAccessSpecifierPublic)
	int32                                         RewardBattlePassExp;                               // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1BattlePassChallengeReward>   Rewards;                                           // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattlePassChallengeDetailData) == 0x000008, "Wrong alignment on FM1BattlePassChallengeDetailData");
static_assert(sizeof(FM1BattlePassChallengeDetailData) == 0x000080, "Wrong size on FM1BattlePassChallengeDetailData");
static_assert(offsetof(FM1BattlePassChallengeDetailData, ChallengeData) == 0x000000, "Member 'FM1BattlePassChallengeDetailData::ChallengeData' has a wrong offset!");
static_assert(offsetof(FM1BattlePassChallengeDetailData, RewardBattlePassExp) == 0x000068, "Member 'FM1BattlePassChallengeDetailData::RewardBattlePassExp' has a wrong offset!");
static_assert(offsetof(FM1BattlePassChallengeDetailData, Rewards) == 0x000070, "Member 'FM1BattlePassChallengeDetailData::Rewards' has a wrong offset!");

// ScriptStruct M1Data.M1BattlePassChallengeData
// 0x0060 (0x0068 - 0x0008)
struct FM1BattlePassChallengeData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ChallengeDataType                          Type;                                              // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              OpenTime;                                          // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              CloseTime;                                         // 0x0020(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1BattlePassChallengeDetailData> DetailDataList;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1BattlePassChallengeDataLink         NextWeekId;                                        // 0x0038(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattlePassChallengeData) == 0x000008, "Wrong alignment on FM1BattlePassChallengeData");
static_assert(sizeof(FM1BattlePassChallengeData) == 0x000068, "Wrong size on FM1BattlePassChallengeData");
static_assert(offsetof(FM1BattlePassChallengeData, TemplateId) == 0x000008, "Member 'FM1BattlePassChallengeData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1BattlePassChallengeData, StringId) == 0x00000C, "Member 'FM1BattlePassChallengeData::StringId' has a wrong offset!");
static_assert(offsetof(FM1BattlePassChallengeData, Type) == 0x000014, "Member 'FM1BattlePassChallengeData::Type' has a wrong offset!");
static_assert(offsetof(FM1BattlePassChallengeData, OpenTime) == 0x000018, "Member 'FM1BattlePassChallengeData::OpenTime' has a wrong offset!");
static_assert(offsetof(FM1BattlePassChallengeData, CloseTime) == 0x000020, "Member 'FM1BattlePassChallengeData::CloseTime' has a wrong offset!");
static_assert(offsetof(FM1BattlePassChallengeData, DetailDataList) == 0x000028, "Member 'FM1BattlePassChallengeData::DetailDataList' has a wrong offset!");
static_assert(offsetof(FM1BattlePassChallengeData, NextWeekId) == 0x000038, "Member 'FM1BattlePassChallengeData::NextWeekId' has a wrong offset!");

// ScriptStruct M1Data.M1BattlePassChallengeMiscData
// 0x0048 (0x0050 - 0x0008)
struct FM1BattlePassChallengeMiscData final : public FTableRowBase
{
public:
	int32                                         TrackingChallengeCount;                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        BattlePassXPIconPath;                              // 0x0010(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         ChallengeWidgetClass;                              // 0x0030(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattlePassChallengeMiscData) == 0x000008, "Wrong alignment on FM1BattlePassChallengeMiscData");
static_assert(sizeof(FM1BattlePassChallengeMiscData) == 0x000050, "Wrong size on FM1BattlePassChallengeMiscData");
static_assert(offsetof(FM1BattlePassChallengeMiscData, TrackingChallengeCount) == 0x000008, "Member 'FM1BattlePassChallengeMiscData::TrackingChallengeCount' has a wrong offset!");
static_assert(offsetof(FM1BattlePassChallengeMiscData, BattlePassXPIconPath) == 0x000010, "Member 'FM1BattlePassChallengeMiscData::BattlePassXPIconPath' has a wrong offset!");
static_assert(offsetof(FM1BattlePassChallengeMiscData, ChallengeWidgetClass) == 0x000030, "Member 'FM1BattlePassChallengeMiscData::ChallengeWidgetClass' has a wrong offset!");

// ScriptStruct M1Data.M1BattlePassData
// 0x00A0 (0x00A8 - 0x0008)
struct FM1BattlePassData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1SeasonDataLink                      Season;                                            // 0x0018(0x0030)(Edit, NativeAccessSpecifierPublic)
	int32                                         MonsterKillExp;                                    // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1BattlePassDetailData>        DetailList;                                        // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1BattlePassChallengeDataLink> ChallengeData;                                     // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1BattlePassLevelDataLink             LevelData;                                         // 0x0070(0x0030)(Edit, NativeAccessSpecifierPublic)
	class FName                                   BGId;                                              // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattlePassData) == 0x000008, "Wrong alignment on FM1BattlePassData");
static_assert(sizeof(FM1BattlePassData) == 0x0000A8, "Wrong size on FM1BattlePassData");
static_assert(offsetof(FM1BattlePassData, TemplateId) == 0x000008, "Member 'FM1BattlePassData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1BattlePassData, StringId) == 0x00000C, "Member 'FM1BattlePassData::StringId' has a wrong offset!");
static_assert(offsetof(FM1BattlePassData, Season) == 0x000018, "Member 'FM1BattlePassData::Season' has a wrong offset!");
static_assert(offsetof(FM1BattlePassData, MonsterKillExp) == 0x000048, "Member 'FM1BattlePassData::MonsterKillExp' has a wrong offset!");
static_assert(offsetof(FM1BattlePassData, DetailList) == 0x000050, "Member 'FM1BattlePassData::DetailList' has a wrong offset!");
static_assert(offsetof(FM1BattlePassData, ChallengeData) == 0x000060, "Member 'FM1BattlePassData::ChallengeData' has a wrong offset!");
static_assert(offsetof(FM1BattlePassData, LevelData) == 0x000070, "Member 'FM1BattlePassData::LevelData' has a wrong offset!");
static_assert(offsetof(FM1BattlePassData, BGId) == 0x0000A0, "Member 'FM1BattlePassData::BGId' has a wrong offset!");

// ScriptStruct M1Data.M1BattlePassMiscData
// 0x00A0 (0x00A8 - 0x0008)
struct FM1BattlePassMiscData final : public FTableRowBase
{
public:
	struct FM1ItemDataBox                         PremiumResource;                                   // 0x0008(0x0038)(Edit, NativeAccessSpecifierPublic)
	int32                                         PremiumResourceAmount;                             // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ItemDataBox                         LevelUpResource;                                   // 0x0048(0x0038)(Edit, NativeAccessSpecifierPublic)
	int32                                         LevelUpResourceAmount;                             // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BundleUnitCount;                                   // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BundleDiscountRate;                                // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CompileRate;                                       // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        AlertRemainSeconds;                                // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MissionRepeatExp;                                  // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MissionWaveExp;                                    // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VoidBattleExp;                                     // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdjustmentRandTime;                                // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattlePassMiscData) == 0x000008, "Wrong alignment on FM1BattlePassMiscData");
static_assert(sizeof(FM1BattlePassMiscData) == 0x0000A8, "Wrong size on FM1BattlePassMiscData");
static_assert(offsetof(FM1BattlePassMiscData, PremiumResource) == 0x000008, "Member 'FM1BattlePassMiscData::PremiumResource' has a wrong offset!");
static_assert(offsetof(FM1BattlePassMiscData, PremiumResourceAmount) == 0x000040, "Member 'FM1BattlePassMiscData::PremiumResourceAmount' has a wrong offset!");
static_assert(offsetof(FM1BattlePassMiscData, LevelUpResource) == 0x000048, "Member 'FM1BattlePassMiscData::LevelUpResource' has a wrong offset!");
static_assert(offsetof(FM1BattlePassMiscData, LevelUpResourceAmount) == 0x000080, "Member 'FM1BattlePassMiscData::LevelUpResourceAmount' has a wrong offset!");
static_assert(offsetof(FM1BattlePassMiscData, BundleUnitCount) == 0x000084, "Member 'FM1BattlePassMiscData::BundleUnitCount' has a wrong offset!");
static_assert(offsetof(FM1BattlePassMiscData, BundleDiscountRate) == 0x000088, "Member 'FM1BattlePassMiscData::BundleDiscountRate' has a wrong offset!");
static_assert(offsetof(FM1BattlePassMiscData, CompileRate) == 0x00008C, "Member 'FM1BattlePassMiscData::CompileRate' has a wrong offset!");
static_assert(offsetof(FM1BattlePassMiscData, AlertRemainSeconds) == 0x000090, "Member 'FM1BattlePassMiscData::AlertRemainSeconds' has a wrong offset!");
static_assert(offsetof(FM1BattlePassMiscData, MissionRepeatExp) == 0x000098, "Member 'FM1BattlePassMiscData::MissionRepeatExp' has a wrong offset!");
static_assert(offsetof(FM1BattlePassMiscData, MissionWaveExp) == 0x00009C, "Member 'FM1BattlePassMiscData::MissionWaveExp' has a wrong offset!");
static_assert(offsetof(FM1BattlePassMiscData, VoidBattleExp) == 0x0000A0, "Member 'FM1BattlePassMiscData::VoidBattleExp' has a wrong offset!");
static_assert(offsetof(FM1BattlePassMiscData, AdjustmentRandTime) == 0x0000A4, "Member 'FM1BattlePassMiscData::AdjustmentRandTime' has a wrong offset!");

// ScriptStruct M1Data.M1AchievementData
// 0x0028 (0x0110 - 0x00E8)
struct FM1AchievementData final : public FM1QuestData
{
public:
	struct FSoftObjectPath                        IconPath;                                          // 0x00E8(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AchievementPoint;                                  // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AchievementData) == 0x000008, "Wrong alignment on FM1AchievementData");
static_assert(sizeof(FM1AchievementData) == 0x000110, "Wrong size on FM1AchievementData");
static_assert(offsetof(FM1AchievementData, IconPath) == 0x0000E8, "Member 'FM1AchievementData::IconPath' has a wrong offset!");
static_assert(offsetof(FM1AchievementData, AchievementPoint) == 0x000108, "Member 'FM1AchievementData::AchievementPoint' has a wrong offset!");

// ScriptStruct M1Data.M1AchievementCategoryData
// 0x0050 (0x0058 - 0x0008)
struct FM1AchievementCategoryData final : public FTableRowBase
{
public:
	int32                                         CategoryId;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringId;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0020(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1AchievementDataLink>         AchievementList;                                   // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AchievementCategoryData) == 0x000008, "Wrong alignment on FM1AchievementCategoryData");
static_assert(sizeof(FM1AchievementCategoryData) == 0x000058, "Wrong size on FM1AchievementCategoryData");
static_assert(offsetof(FM1AchievementCategoryData, CategoryId) == 0x000008, "Member 'FM1AchievementCategoryData::CategoryId' has a wrong offset!");
static_assert(offsetof(FM1AchievementCategoryData, StringId) == 0x000010, "Member 'FM1AchievementCategoryData::StringId' has a wrong offset!");
static_assert(offsetof(FM1AchievementCategoryData, IconPath) == 0x000020, "Member 'FM1AchievementCategoryData::IconPath' has a wrong offset!");
static_assert(offsetof(FM1AchievementCategoryData, AchievementList) == 0x000040, "Member 'FM1AchievementCategoryData::AchievementList' has a wrong offset!");
static_assert(offsetof(FM1AchievementCategoryData, SortOrder) == 0x000050, "Member 'FM1AchievementCategoryData::SortOrder' has a wrong offset!");

// ScriptStruct M1Data.M1RecordData
// 0x0068 (0x0070 - 0x0008)
struct FM1RecordData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RecordTypeParam;                                   // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0028(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SeqAssetPath;                                      // 0x0048(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RecordType                                 RecordType;                                        // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RecordData) == 0x000008, "Wrong alignment on FM1RecordData");
static_assert(sizeof(FM1RecordData) == 0x000070, "Wrong size on FM1RecordData");
static_assert(offsetof(FM1RecordData, TemplateId) == 0x000008, "Member 'FM1RecordData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1RecordData, StringId) == 0x00000C, "Member 'FM1RecordData::StringId' has a wrong offset!");
static_assert(offsetof(FM1RecordData, RecordTypeParam) == 0x000018, "Member 'FM1RecordData::RecordTypeParam' has a wrong offset!");
static_assert(offsetof(FM1RecordData, IconPath) == 0x000028, "Member 'FM1RecordData::IconPath' has a wrong offset!");
static_assert(offsetof(FM1RecordData, SeqAssetPath) == 0x000048, "Member 'FM1RecordData::SeqAssetPath' has a wrong offset!");
static_assert(offsetof(FM1RecordData, RecordType) == 0x000068, "Member 'FM1RecordData::RecordType' has a wrong offset!");

// ScriptStruct M1Data.M1EventBoostTargetContent
// 0x0018 (0x0018 - 0x0000)
struct FM1EventBoostTargetContent final
{
public:
	EM1EventBoostContentType                      ContentType;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ConditionList;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EventBoostTargetContent) == 0x000008, "Wrong alignment on FM1EventBoostTargetContent");
static_assert(sizeof(FM1EventBoostTargetContent) == 0x000018, "Wrong size on FM1EventBoostTargetContent");
static_assert(offsetof(FM1EventBoostTargetContent, ContentType) == 0x000000, "Member 'FM1EventBoostTargetContent::ContentType' has a wrong offset!");
static_assert(offsetof(FM1EventBoostTargetContent, ConditionList) == 0x000008, "Member 'FM1EventBoostTargetContent::ConditionList' has a wrong offset!");

// ScriptStruct M1Data.M1EventBoostRewardType
// 0x0040 (0x0040 - 0x0000)
struct FM1EventBoostRewardType final
{
public:
	struct FM1ItemDataBox                         RewardItem;                                        // 0x0000(0x0038)(Edit, NativeAccessSpecifierPublic)
	int64                                         Coefficient;                                       // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EventBoostRewardType) == 0x000008, "Wrong alignment on FM1EventBoostRewardType");
static_assert(sizeof(FM1EventBoostRewardType) == 0x000040, "Wrong size on FM1EventBoostRewardType");
static_assert(offsetof(FM1EventBoostRewardType, RewardItem) == 0x000000, "Member 'FM1EventBoostRewardType::RewardItem' has a wrong offset!");
static_assert(offsetof(FM1EventBoostRewardType, Coefficient) == 0x000038, "Member 'FM1EventBoostRewardType::Coefficient' has a wrong offset!");

// ScriptStruct M1Data.M1EventBoostingDetailData
// 0x0038 (0x0038 - 0x0000)
struct FM1EventBoostingDetailData final
{
public:
	EM1EventBoostType                             BoostType;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1MapDataLink>                 FieldList;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1EventBoostTargetContent>     ContentList;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1EventBoostRewardType>        RewardTypeList;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EventBoostingDetailData) == 0x000008, "Wrong alignment on FM1EventBoostingDetailData");
static_assert(sizeof(FM1EventBoostingDetailData) == 0x000038, "Wrong size on FM1EventBoostingDetailData");
static_assert(offsetof(FM1EventBoostingDetailData, BoostType) == 0x000000, "Member 'FM1EventBoostingDetailData::BoostType' has a wrong offset!");
static_assert(offsetof(FM1EventBoostingDetailData, FieldList) == 0x000008, "Member 'FM1EventBoostingDetailData::FieldList' has a wrong offset!");
static_assert(offsetof(FM1EventBoostingDetailData, ContentList) == 0x000018, "Member 'FM1EventBoostingDetailData::ContentList' has a wrong offset!");
static_assert(offsetof(FM1EventBoostingDetailData, RewardTypeList) == 0x000028, "Member 'FM1EventBoostingDetailData::RewardTypeList' has a wrong offset!");

// ScriptStruct M1Data.M1EventBoostingData
// 0x0018 (0x0090 - 0x0078)
struct FM1EventBoostingData final : public FM1EventData
{
public:
	int32                                         BoostLimitMasteryRank;                             // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1EventBoostingDetailData>     BoostDataList;                                     // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EventBoostingData) == 0x000008, "Wrong alignment on FM1EventBoostingData");
static_assert(sizeof(FM1EventBoostingData) == 0x000090, "Wrong size on FM1EventBoostingData");
static_assert(offsetof(FM1EventBoostingData, BoostLimitMasteryRank) == 0x000078, "Member 'FM1EventBoostingData::BoostLimitMasteryRank' has a wrong offset!");
static_assert(offsetof(FM1EventBoostingData, BoostDataList) == 0x000080, "Member 'FM1EventBoostingData::BoostDataList' has a wrong offset!");

// ScriptStruct M1Data.M1MiniGameParam
// 0x0020 (0x0020 - 0x0000)
struct FM1MiniGameParam final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MiniGameParam) == 0x000008, "Wrong alignment on FM1MiniGameParam");
static_assert(sizeof(FM1MiniGameParam) == 0x000020, "Wrong size on FM1MiniGameParam");
static_assert(offsetof(FM1MiniGameParam, Key) == 0x000000, "Member 'FM1MiniGameParam::Key' has a wrong offset!");
static_assert(offsetof(FM1MiniGameParam, Value) == 0x000010, "Member 'FM1MiniGameParam::Value' has a wrong offset!");

// ScriptStruct M1Data.M1MiniGameDetailData
// 0x0070 (0x0070 - 0x0000)
struct FM1MiniGameDetailData final
{
public:
	struct FM1DifficultyInfoDataLink              FieldDifficulty;                                   // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1MiniGameParam>               Params;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1DropItemLink                        Reward;                                            // 0x0040(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MiniGameDetailData) == 0x000008, "Wrong alignment on FM1MiniGameDetailData");
static_assert(sizeof(FM1MiniGameDetailData) == 0x000070, "Wrong size on FM1MiniGameDetailData");
static_assert(offsetof(FM1MiniGameDetailData, FieldDifficulty) == 0x000000, "Member 'FM1MiniGameDetailData::FieldDifficulty' has a wrong offset!");
static_assert(offsetof(FM1MiniGameDetailData, Params) == 0x000030, "Member 'FM1MiniGameDetailData::Params' has a wrong offset!");
static_assert(offsetof(FM1MiniGameDetailData, Reward) == 0x000040, "Member 'FM1MiniGameDetailData::Reward' has a wrong offset!");

// ScriptStruct M1Data.M1MiniGameData
// 0x0020 (0x0028 - 0x0008)
struct FM1MiniGameData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MiniGameType                               Type;                                              // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1MiniGameDetailData>          DetailDataList;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MiniGameData) == 0x000008, "Wrong alignment on FM1MiniGameData");
static_assert(sizeof(FM1MiniGameData) == 0x000028, "Wrong size on FM1MiniGameData");
static_assert(offsetof(FM1MiniGameData, TemplateId) == 0x000008, "Member 'FM1MiniGameData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1MiniGameData, Type) == 0x00000C, "Member 'FM1MiniGameData::Type' has a wrong offset!");
static_assert(offsetof(FM1MiniGameData, DetailDataList) == 0x000010, "Member 'FM1MiniGameData::DetailDataList' has a wrong offset!");
static_assert(offsetof(FM1MiniGameData, StringId) == 0x000020, "Member 'FM1MiniGameData::StringId' has a wrong offset!");

// ScriptStruct M1Data.M1DifficultyInfoMiscData
// 0x0010 (0x0018 - 0x0008)
struct FM1DifficultyInfoMiscData final : public FTableRowBase
{
public:
	TArray<EM1MonsterCategory>                    MonsterCategory;                                   // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DifficultyInfoMiscData) == 0x000008, "Wrong alignment on FM1DifficultyInfoMiscData");
static_assert(sizeof(FM1DifficultyInfoMiscData) == 0x000018, "Wrong size on FM1DifficultyInfoMiscData");
static_assert(offsetof(FM1DifficultyInfoMiscData, MonsterCategory) == 0x000008, "Member 'FM1DifficultyInfoMiscData::MonsterCategory' has a wrong offset!");

// ScriptStruct M1Data.M1RotationDropData
// 0x0098 (0x00A0 - 0x0008)
struct FM1RotationDropData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1MapBattleZoneDataLink               BattleZoneId;                                      // 0x0010(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FM1DifficultyInfoDataLink              DifficultyId;                                      // 0x0040(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BGImagePath;                                       // 0x0070(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1DropItemLink>                RotationDrop;                                      // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RotationDropData) == 0x000008, "Wrong alignment on FM1RotationDropData");
static_assert(sizeof(FM1RotationDropData) == 0x0000A0, "Wrong size on FM1RotationDropData");
static_assert(offsetof(FM1RotationDropData, TemplateId) == 0x000008, "Member 'FM1RotationDropData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1RotationDropData, BattleZoneId) == 0x000010, "Member 'FM1RotationDropData::BattleZoneId' has a wrong offset!");
static_assert(offsetof(FM1RotationDropData, DifficultyId) == 0x000040, "Member 'FM1RotationDropData::DifficultyId' has a wrong offset!");
static_assert(offsetof(FM1RotationDropData, BGImagePath) == 0x000070, "Member 'FM1RotationDropData::BGImagePath' has a wrong offset!");
static_assert(offsetof(FM1RotationDropData, RotationDrop) == 0x000090, "Member 'FM1RotationDropData::RotationDrop' has a wrong offset!");

// ScriptStruct M1Data.M1RotationDropRatio
// 0x0014 (0x0014 - 0x0000)
struct FM1RotationDropRatio final
{
public:
	int32                                         Normal;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Elite;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Champion;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Named;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Boss;                                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RotationDropRatio) == 0x000004, "Wrong alignment on FM1RotationDropRatio");
static_assert(sizeof(FM1RotationDropRatio) == 0x000014, "Wrong size on FM1RotationDropRatio");
static_assert(offsetof(FM1RotationDropRatio, Normal) == 0x000000, "Member 'FM1RotationDropRatio::Normal' has a wrong offset!");
static_assert(offsetof(FM1RotationDropRatio, Elite) == 0x000004, "Member 'FM1RotationDropRatio::Elite' has a wrong offset!");
static_assert(offsetof(FM1RotationDropRatio, Champion) == 0x000008, "Member 'FM1RotationDropRatio::Champion' has a wrong offset!");
static_assert(offsetof(FM1RotationDropRatio, Named) == 0x00000C, "Member 'FM1RotationDropRatio::Named' has a wrong offset!");
static_assert(offsetof(FM1RotationDropRatio, Boss) == 0x000010, "Member 'FM1RotationDropRatio::Boss' has a wrong offset!");

// ScriptStruct M1Data.M1MissionDropRatio
// 0x0008 (0x0008 - 0x0000)
struct FM1MissionDropRatio final
{
public:
	EM1MissionCategory                            MissionCategory;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DropRatio;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionDropRatio) == 0x000004, "Wrong alignment on FM1MissionDropRatio");
static_assert(sizeof(FM1MissionDropRatio) == 0x000008, "Wrong size on FM1MissionDropRatio");
static_assert(offsetof(FM1MissionDropRatio, MissionCategory) == 0x000000, "Member 'FM1MissionDropRatio::MissionCategory' has a wrong offset!");
static_assert(offsetof(FM1MissionDropRatio, DropRatio) == 0x000004, "Member 'FM1MissionDropRatio::DropRatio' has a wrong offset!");

// ScriptStruct M1Data.M1RotationDropMiscData
// 0x0038 (0x0040 - 0x0008)
struct FM1RotationDropMiscData final : public FTableRowBase
{
public:
	struct FDateTime                              RotationStartTime;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RotationDateInterval;                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RotationChangeTime;                                // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1RotationDropRatio                   RotationDropRatio;                                 // 0x0018(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1MissionDropRatio>            MissionDropRatio;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RotationDropMiscData) == 0x000008, "Wrong alignment on FM1RotationDropMiscData");
static_assert(sizeof(FM1RotationDropMiscData) == 0x000040, "Wrong size on FM1RotationDropMiscData");
static_assert(offsetof(FM1RotationDropMiscData, RotationStartTime) == 0x000008, "Member 'FM1RotationDropMiscData::RotationStartTime' has a wrong offset!");
static_assert(offsetof(FM1RotationDropMiscData, RotationDateInterval) == 0x000010, "Member 'FM1RotationDropMiscData::RotationDateInterval' has a wrong offset!");
static_assert(offsetof(FM1RotationDropMiscData, RotationChangeTime) == 0x000014, "Member 'FM1RotationDropMiscData::RotationChangeTime' has a wrong offset!");
static_assert(offsetof(FM1RotationDropMiscData, RotationDropRatio) == 0x000018, "Member 'FM1RotationDropMiscData::RotationDropRatio' has a wrong offset!");
static_assert(offsetof(FM1RotationDropMiscData, MissionDropRatio) == 0x000030, "Member 'FM1RotationDropMiscData::MissionDropRatio' has a wrong offset!");

// ScriptStruct M1Data.M1PaintExtractData
// 0x0078 (0x0080 - 0x0008)
struct FM1PaintExtractData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1RequiredItemData>            ExtractCost;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1CustomizingItemDataLink>     PaintCustomizingItemList;                          // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          LimitMarkOn;                                       // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StringId;                                          // 0x0034(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        IconPath;                                          // 0x0040(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PaintGroupImagePath;                               // 0x0060(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PaintExtractData) == 0x000008, "Wrong alignment on FM1PaintExtractData");
static_assert(sizeof(FM1PaintExtractData) == 0x000080, "Wrong size on FM1PaintExtractData");
static_assert(offsetof(FM1PaintExtractData, TemplateId) == 0x000008, "Member 'FM1PaintExtractData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1PaintExtractData, ExtractCost) == 0x000010, "Member 'FM1PaintExtractData::ExtractCost' has a wrong offset!");
static_assert(offsetof(FM1PaintExtractData, PaintCustomizingItemList) == 0x000020, "Member 'FM1PaintExtractData::PaintCustomizingItemList' has a wrong offset!");
static_assert(offsetof(FM1PaintExtractData, LimitMarkOn) == 0x000030, "Member 'FM1PaintExtractData::LimitMarkOn' has a wrong offset!");
static_assert(offsetof(FM1PaintExtractData, StringId) == 0x000034, "Member 'FM1PaintExtractData::StringId' has a wrong offset!");
static_assert(offsetof(FM1PaintExtractData, IconPath) == 0x000040, "Member 'FM1PaintExtractData::IconPath' has a wrong offset!");
static_assert(offsetof(FM1PaintExtractData, PaintGroupImagePath) == 0x000060, "Member 'FM1PaintExtractData::PaintGroupImagePath' has a wrong offset!");

// ScriptStruct M1Data.M1PaintExtractMiscData
// 0x0008 (0x0010 - 0x0008)
struct FM1PaintExtractMiscData final : public FTableRowBase
{
public:
	int32                                         MaxPaintExtractOnceCount;                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PaintExtractMiscData) == 0x000008, "Wrong alignment on FM1PaintExtractMiscData");
static_assert(sizeof(FM1PaintExtractMiscData) == 0x000010, "Wrong size on FM1PaintExtractMiscData");
static_assert(offsetof(FM1PaintExtractMiscData, MaxPaintExtractOnceCount) == 0x000008, "Member 'FM1PaintExtractMiscData::MaxPaintExtractOnceCount' has a wrong offset!");

// ScriptStruct M1Data.M1SeasonReinforceSlotData
// 0x0020 (0x0020 - 0x0000)
struct FM1SeasonReinforceSlotData final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredSeasonReinforcePoint;                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredPreUseSeasonReinforcePoint;                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1SeasonReinforceDataLink>     SeasonReinforceList;                               // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SeasonReinforceSlotData) == 0x000008, "Wrong alignment on FM1SeasonReinforceSlotData");
static_assert(sizeof(FM1SeasonReinforceSlotData) == 0x000020, "Wrong size on FM1SeasonReinforceSlotData");
static_assert(offsetof(FM1SeasonReinforceSlotData, SlotIndex) == 0x000000, "Member 'FM1SeasonReinforceSlotData::SlotIndex' has a wrong offset!");
static_assert(offsetof(FM1SeasonReinforceSlotData, RequiredSeasonReinforcePoint) == 0x000004, "Member 'FM1SeasonReinforceSlotData::RequiredSeasonReinforcePoint' has a wrong offset!");
static_assert(offsetof(FM1SeasonReinforceSlotData, RequiredPreUseSeasonReinforcePoint) == 0x000008, "Member 'FM1SeasonReinforceSlotData::RequiredPreUseSeasonReinforcePoint' has a wrong offset!");
static_assert(offsetof(FM1SeasonReinforceSlotData, SeasonReinforceList) == 0x000010, "Member 'FM1SeasonReinforceSlotData::SeasonReinforceList' has a wrong offset!");

// ScriptStruct M1Data.M1SeasonReinforceGroupData
// 0x0038 (0x0038 - 0x0000)
struct FM1SeasonReinforceGroupData final
{
public:
	EM1SeasonReinforceGroupType                   GroupType;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1SeasonReinforceDataLink             CollectionBuff;                                    // 0x0008(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SeasonReinforceGroupData) == 0x000008, "Wrong alignment on FM1SeasonReinforceGroupData");
static_assert(sizeof(FM1SeasonReinforceGroupData) == 0x000038, "Wrong size on FM1SeasonReinforceGroupData");
static_assert(offsetof(FM1SeasonReinforceGroupData, GroupType) == 0x000000, "Member 'FM1SeasonReinforceGroupData::GroupType' has a wrong offset!");
static_assert(offsetof(FM1SeasonReinforceGroupData, CollectionBuff) == 0x000008, "Member 'FM1SeasonReinforceGroupData::CollectionBuff' has a wrong offset!");

// ScriptStruct M1Data.M1SeasonLevelData
// 0x0018 (0x0018 - 0x0000)
struct FM1SeasonLevelData final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         RequiredSeasonExpToNextLv;                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SeasonReinforcePoint;                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SeasonLevelData) == 0x000008, "Wrong alignment on FM1SeasonLevelData");
static_assert(sizeof(FM1SeasonLevelData) == 0x000018, "Wrong size on FM1SeasonLevelData");
static_assert(offsetof(FM1SeasonLevelData, Level) == 0x000000, "Member 'FM1SeasonLevelData::Level' has a wrong offset!");
static_assert(offsetof(FM1SeasonLevelData, RequiredSeasonExpToNextLv) == 0x000008, "Member 'FM1SeasonLevelData::RequiredSeasonExpToNextLv' has a wrong offset!");
static_assert(offsetof(FM1SeasonLevelData, SeasonReinforcePoint) == 0x000010, "Member 'FM1SeasonLevelData::SeasonReinforcePoint' has a wrong offset!");

// ScriptStruct M1Data.M1SeasonData
// 0x00B8 (0x00C0 - 0x0008)
struct FM1SeasonData final : public FTableRowBase
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        BgImgPath;                                         // 0x0018(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              StartTime;                                         // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndTime;                                           // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              BattlePassAdjustmentTime;                          // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1QuestDataLink                       SeasonUnlockQuestId;                               // 0x0050(0x0030)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1QuestDataLink>               SeasonQuestIdList;                                 // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1SeasonLevelData>             SeasonLevelList;                                   // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1SeasonReinforceSlotData>     ReinforceSlotList;                                 // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1SeasonReinforceGroupData>    ReinforceGroupList;                                // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SeasonData) == 0x000008, "Wrong alignment on FM1SeasonData");
static_assert(sizeof(FM1SeasonData) == 0x0000C0, "Wrong size on FM1SeasonData");
static_assert(offsetof(FM1SeasonData, TemplateId) == 0x000008, "Member 'FM1SeasonData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1SeasonData, StringId) == 0x00000C, "Member 'FM1SeasonData::StringId' has a wrong offset!");
static_assert(offsetof(FM1SeasonData, BgImgPath) == 0x000018, "Member 'FM1SeasonData::BgImgPath' has a wrong offset!");
static_assert(offsetof(FM1SeasonData, StartTime) == 0x000038, "Member 'FM1SeasonData::StartTime' has a wrong offset!");
static_assert(offsetof(FM1SeasonData, EndTime) == 0x000040, "Member 'FM1SeasonData::EndTime' has a wrong offset!");
static_assert(offsetof(FM1SeasonData, BattlePassAdjustmentTime) == 0x000048, "Member 'FM1SeasonData::BattlePassAdjustmentTime' has a wrong offset!");
static_assert(offsetof(FM1SeasonData, SeasonUnlockQuestId) == 0x000050, "Member 'FM1SeasonData::SeasonUnlockQuestId' has a wrong offset!");
static_assert(offsetof(FM1SeasonData, SeasonQuestIdList) == 0x000080, "Member 'FM1SeasonData::SeasonQuestIdList' has a wrong offset!");
static_assert(offsetof(FM1SeasonData, SeasonLevelList) == 0x000090, "Member 'FM1SeasonData::SeasonLevelList' has a wrong offset!");
static_assert(offsetof(FM1SeasonData, ReinforceSlotList) == 0x0000A0, "Member 'FM1SeasonData::ReinforceSlotList' has a wrong offset!");
static_assert(offsetof(FM1SeasonData, ReinforceGroupList) == 0x0000B0, "Member 'FM1SeasonData::ReinforceGroupList' has a wrong offset!");

// ScriptStruct M1Data.M1UICloseDialogData
// 0x0038 (0x0038 - 0x0000)
struct FM1UICloseDialogData final
{
public:
	int32                                         UnlockSeasonReinforceCount;                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1DialogDataLink                      DialogId;                                          // 0x0008(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1UICloseDialogData) == 0x000008, "Wrong alignment on FM1UICloseDialogData");
static_assert(sizeof(FM1UICloseDialogData) == 0x000038, "Wrong size on FM1UICloseDialogData");
static_assert(offsetof(FM1UICloseDialogData, UnlockSeasonReinforceCount) == 0x000000, "Member 'FM1UICloseDialogData::UnlockSeasonReinforceCount' has a wrong offset!");
static_assert(offsetof(FM1UICloseDialogData, DialogId) == 0x000008, "Member 'FM1UICloseDialogData::DialogId' has a wrong offset!");

// ScriptStruct M1Data.M1SeasonMiscData
// 0x0018 (0x0020 - 0x0008)
struct FM1SeasonMiscData final : public FTableRowBase
{
public:
	int32                                         MaxEquippedReinforcePerGroup;                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxEquipReinforce;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1UICloseDialogData>           UICloseDialogDatas;                                // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SeasonMiscData) == 0x000008, "Wrong alignment on FM1SeasonMiscData");
static_assert(sizeof(FM1SeasonMiscData) == 0x000020, "Wrong size on FM1SeasonMiscData");
static_assert(offsetof(FM1SeasonMiscData, MaxEquippedReinforcePerGroup) == 0x000008, "Member 'FM1SeasonMiscData::MaxEquippedReinforcePerGroup' has a wrong offset!");
static_assert(offsetof(FM1SeasonMiscData, MaxEquipReinforce) == 0x00000C, "Member 'FM1SeasonMiscData::MaxEquipReinforce' has a wrong offset!");
static_assert(offsetof(FM1SeasonMiscData, UICloseDialogDatas) == 0x000010, "Member 'FM1SeasonMiscData::UICloseDialogDatas' has a wrong offset!");

// ScriptStruct M1Data.M1DatasheetDummyType
// 0x0001 (0x0001 - 0x0000)
struct FM1DatasheetDummyType final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1DatasheetDummyType) == 0x000001, "Wrong alignment on FM1DatasheetDummyType");
static_assert(sizeof(FM1DatasheetDummyType) == 0x000001, "Wrong size on FM1DatasheetDummyType");

// ScriptStruct M1Data.M1RuneCompact
// 0x0010 (0x0010 - 0x0000)
struct FM1RuneCompact final
{
public:
	int64                                         Uid;                                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Enchant;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         EquipCount;                                        // 0x000C(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RuneCompact) == 0x000008, "Wrong alignment on FM1RuneCompact");
static_assert(sizeof(FM1RuneCompact) == 0x000010, "Wrong size on FM1RuneCompact");
static_assert(offsetof(FM1RuneCompact, Uid) == 0x000000, "Member 'FM1RuneCompact::Uid' has a wrong offset!");
static_assert(offsetof(FM1RuneCompact, Enchant) == 0x000008, "Member 'FM1RuneCompact::Enchant' has a wrong offset!");
static_assert(offsetof(FM1RuneCompact, EquipCount) == 0x00000C, "Member 'FM1RuneCompact::EquipCount' has a wrong offset!");

// ScriptStruct M1Data.M1RunesByTid
// 0x0018 (0x0018 - 0x0000)
struct FM1RunesByTid final
{
public:
	struct FM1TemplateId                          Tid;                                               // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1RuneCompact>                 Runes;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RunesByTid) == 0x000008, "Wrong alignment on FM1RunesByTid");
static_assert(sizeof(FM1RunesByTid) == 0x000018, "Wrong size on FM1RunesByTid");
static_assert(offsetof(FM1RunesByTid, Tid) == 0x000000, "Member 'FM1RunesByTid::Tid' has a wrong offset!");
static_assert(offsetof(FM1RunesByTid, Runes) == 0x000008, "Member 'FM1RunesByTid::Runes' has a wrong offset!");

// ScriptStruct M1Data.M1EquipmentRandomOptionCompact
// 0x0010 (0x0010 - 0x0000)
struct FM1EquipmentRandomOptionCompact final
{
public:
	struct FM1TemplateId                          Tid;                                               // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ScaledInteger                       StatValue;                                         // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EquipmentRandomOptionCompact) == 0x000008, "Wrong alignment on FM1EquipmentRandomOptionCompact");
static_assert(sizeof(FM1EquipmentRandomOptionCompact) == 0x000010, "Wrong size on FM1EquipmentRandomOptionCompact");
static_assert(offsetof(FM1EquipmentRandomOptionCompact, Tid) == 0x000000, "Member 'FM1EquipmentRandomOptionCompact::Tid' has a wrong offset!");
static_assert(offsetof(FM1EquipmentRandomOptionCompact, StatValue) == 0x000008, "Member 'FM1EquipmentRandomOptionCompact::StatValue' has a wrong offset!");

// ScriptStruct M1Data.M1EquipmentRandomOptions
// 0x0020 (0x0020 - 0x0000)
struct FM1EquipmentRandomOptions final
{
public:
	int64                                         EquipmentUid;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         OptionIndexBitFlags;                               // 0x0008(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1EquipmentRandomOptionCompact> Options;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EquipmentRandomOptions) == 0x000008, "Wrong alignment on FM1EquipmentRandomOptions");
static_assert(sizeof(FM1EquipmentRandomOptions) == 0x000020, "Wrong size on FM1EquipmentRandomOptions");
static_assert(offsetof(FM1EquipmentRandomOptions, EquipmentUid) == 0x000000, "Member 'FM1EquipmentRandomOptions::EquipmentUid' has a wrong offset!");
static_assert(offsetof(FM1EquipmentRandomOptions, OptionIndexBitFlags) == 0x000008, "Member 'FM1EquipmentRandomOptions::OptionIndexBitFlags' has a wrong offset!");
static_assert(offsetof(FM1EquipmentRandomOptions, Options) == 0x000010, "Member 'FM1EquipmentRandomOptions::Options' has a wrong offset!");

// ScriptStruct M1Data.M1InventoryInfo
// 0x00B0 (0x00B0 - 0x0000)
struct FM1InventoryInfo final
{
public:
	TArray<struct FM1EquipmentBaseInfo>           Equipments;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1ConsumableInfo>              Consumables;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1RunesByTid>                  Runes;                                             // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1CharacterInfo>               Characters;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1CurrencyInfo>                Currencies;                                        // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1WeaponProficiencyInfo>       WeaponProficiencies;                               // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1EquipmentRandomOptions>      RandomOptions;                                     // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1PerkInfo>                    Perks;                                             // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1ReactorEnchantInfo>          ReactorInfos;                                      // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1TitleItemInfo>               TitleInfos;                                        // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1RecordInfo>                  RecordInfos;                                       // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InventoryInfo) == 0x000008, "Wrong alignment on FM1InventoryInfo");
static_assert(sizeof(FM1InventoryInfo) == 0x0000B0, "Wrong size on FM1InventoryInfo");
static_assert(offsetof(FM1InventoryInfo, Equipments) == 0x000000, "Member 'FM1InventoryInfo::Equipments' has a wrong offset!");
static_assert(offsetof(FM1InventoryInfo, Consumables) == 0x000010, "Member 'FM1InventoryInfo::Consumables' has a wrong offset!");
static_assert(offsetof(FM1InventoryInfo, Runes) == 0x000020, "Member 'FM1InventoryInfo::Runes' has a wrong offset!");
static_assert(offsetof(FM1InventoryInfo, Characters) == 0x000030, "Member 'FM1InventoryInfo::Characters' has a wrong offset!");
static_assert(offsetof(FM1InventoryInfo, Currencies) == 0x000040, "Member 'FM1InventoryInfo::Currencies' has a wrong offset!");
static_assert(offsetof(FM1InventoryInfo, WeaponProficiencies) == 0x000050, "Member 'FM1InventoryInfo::WeaponProficiencies' has a wrong offset!");
static_assert(offsetof(FM1InventoryInfo, RandomOptions) == 0x000060, "Member 'FM1InventoryInfo::RandomOptions' has a wrong offset!");
static_assert(offsetof(FM1InventoryInfo, Perks) == 0x000070, "Member 'FM1InventoryInfo::Perks' has a wrong offset!");
static_assert(offsetof(FM1InventoryInfo, ReactorInfos) == 0x000080, "Member 'FM1InventoryInfo::ReactorInfos' has a wrong offset!");
static_assert(offsetof(FM1InventoryInfo, TitleInfos) == 0x000090, "Member 'FM1InventoryInfo::TitleInfos' has a wrong offset!");
static_assert(offsetof(FM1InventoryInfo, RecordInfos) == 0x0000A0, "Member 'FM1InventoryInfo::RecordInfos' has a wrong offset!");

// ScriptStruct M1Data.M1AccountInfo
// 0x0198 (0x0198 - 0x0000)
struct FM1AccountInfo final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MasteryLevel;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MasteryExp;                                        // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1InventoryInfo                       Inventory;                                         // 0x0028(0x00B0)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1WearingInfo>                 WearingList;                                       // 0x00D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1UnlockedFieldInfo>           UnlockedFields;                                    // 0x00E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1VoidBattleClearInfo>         VoidBattleClearCounts;                             // 0x00F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int64                                         SelectedCharacterUid;                              // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          LastMapTemplateId;                                 // 0x0110(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          LastBattleZoneId;                                  // 0x0114(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LoginPlatformId;                                   // 0x0118(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         LoginPlatformUid;                                  // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         LoginPlatformType;                                 // 0x0130(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Npsn;                                              // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CountryName;                                       // 0x0140(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DeviceName;                                        // 0x0150(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OsType;                                            // 0x0160(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OsName;                                            // 0x0170(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TeamAssignmentID;                                  // 0x0180(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCreator;                                         // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x7];                                      // 0x0191(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AccountInfo) == 0x000008, "Wrong alignment on FM1AccountInfo");
static_assert(sizeof(FM1AccountInfo) == 0x000198, "Wrong size on FM1AccountInfo");
static_assert(offsetof(FM1AccountInfo, AccountUid) == 0x000000, "Member 'FM1AccountInfo::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1AccountInfo, Name) == 0x000008, "Member 'FM1AccountInfo::Name' has a wrong offset!");
static_assert(offsetof(FM1AccountInfo, MasteryLevel) == 0x000018, "Member 'FM1AccountInfo::MasteryLevel' has a wrong offset!");
static_assert(offsetof(FM1AccountInfo, MasteryExp) == 0x000020, "Member 'FM1AccountInfo::MasteryExp' has a wrong offset!");
static_assert(offsetof(FM1AccountInfo, Inventory) == 0x000028, "Member 'FM1AccountInfo::Inventory' has a wrong offset!");
static_assert(offsetof(FM1AccountInfo, WearingList) == 0x0000D8, "Member 'FM1AccountInfo::WearingList' has a wrong offset!");
static_assert(offsetof(FM1AccountInfo, UnlockedFields) == 0x0000E8, "Member 'FM1AccountInfo::UnlockedFields' has a wrong offset!");
static_assert(offsetof(FM1AccountInfo, VoidBattleClearCounts) == 0x0000F8, "Member 'FM1AccountInfo::VoidBattleClearCounts' has a wrong offset!");
static_assert(offsetof(FM1AccountInfo, SelectedCharacterUid) == 0x000108, "Member 'FM1AccountInfo::SelectedCharacterUid' has a wrong offset!");
static_assert(offsetof(FM1AccountInfo, LastMapTemplateId) == 0x000110, "Member 'FM1AccountInfo::LastMapTemplateId' has a wrong offset!");
static_assert(offsetof(FM1AccountInfo, LastBattleZoneId) == 0x000114, "Member 'FM1AccountInfo::LastBattleZoneId' has a wrong offset!");
static_assert(offsetof(FM1AccountInfo, LoginPlatformId) == 0x000118, "Member 'FM1AccountInfo::LoginPlatformId' has a wrong offset!");
static_assert(offsetof(FM1AccountInfo, LoginPlatformUid) == 0x000128, "Member 'FM1AccountInfo::LoginPlatformUid' has a wrong offset!");
static_assert(offsetof(FM1AccountInfo, LoginPlatformType) == 0x000130, "Member 'FM1AccountInfo::LoginPlatformType' has a wrong offset!");
static_assert(offsetof(FM1AccountInfo, Npsn) == 0x000138, "Member 'FM1AccountInfo::Npsn' has a wrong offset!");
static_assert(offsetof(FM1AccountInfo, CountryName) == 0x000140, "Member 'FM1AccountInfo::CountryName' has a wrong offset!");
static_assert(offsetof(FM1AccountInfo, DeviceName) == 0x000150, "Member 'FM1AccountInfo::DeviceName' has a wrong offset!");
static_assert(offsetof(FM1AccountInfo, OsType) == 0x000160, "Member 'FM1AccountInfo::OsType' has a wrong offset!");
static_assert(offsetof(FM1AccountInfo, OsName) == 0x000170, "Member 'FM1AccountInfo::OsName' has a wrong offset!");
static_assert(offsetof(FM1AccountInfo, TeamAssignmentID) == 0x000180, "Member 'FM1AccountInfo::TeamAssignmentID' has a wrong offset!");
static_assert(offsetof(FM1AccountInfo, IsCreator) == 0x000190, "Member 'FM1AccountInfo::IsCreator' has a wrong offset!");

// ScriptStruct M1Data.M1PlatformInfo
// 0x0028 (0x0028 - 0x0000)
struct FM1PlatformInfo final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LoginPlatformId;                                   // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         LoginPlatformUid;                                  // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         LoginPlatformType;                                 // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PlatformInfo) == 0x000008, "Wrong alignment on FM1PlatformInfo");
static_assert(sizeof(FM1PlatformInfo) == 0x000028, "Wrong size on FM1PlatformInfo");
static_assert(offsetof(FM1PlatformInfo, AccountUid) == 0x000000, "Member 'FM1PlatformInfo::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1PlatformInfo, LoginPlatformId) == 0x000008, "Member 'FM1PlatformInfo::LoginPlatformId' has a wrong offset!");
static_assert(offsetof(FM1PlatformInfo, LoginPlatformUid) == 0x000018, "Member 'FM1PlatformInfo::LoginPlatformUid' has a wrong offset!");
static_assert(offsetof(FM1PlatformInfo, LoginPlatformType) == 0x000020, "Member 'FM1PlatformInfo::LoginPlatformType' has a wrong offset!");

// ScriptStruct M1Data.M1GetAccountInfoRes
// 0x01C8 (0x01C8 - 0x0000)
struct FM1GetAccountInfoRes final
{
public:
	bool                                          Result;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServiceId;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RegionId;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ServerTimeSync;                                    // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1AccountInfo                         Account;                                           // 0x0030(0x0198)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GetAccountInfoRes) == 0x000008, "Wrong alignment on FM1GetAccountInfoRes");
static_assert(sizeof(FM1GetAccountInfoRes) == 0x0001C8, "Wrong size on FM1GetAccountInfoRes");
static_assert(offsetof(FM1GetAccountInfoRes, Result) == 0x000000, "Member 'FM1GetAccountInfoRes::Result' has a wrong offset!");
static_assert(offsetof(FM1GetAccountInfoRes, ServiceId) == 0x000008, "Member 'FM1GetAccountInfoRes::ServiceId' has a wrong offset!");
static_assert(offsetof(FM1GetAccountInfoRes, RegionId) == 0x000018, "Member 'FM1GetAccountInfoRes::RegionId' has a wrong offset!");
static_assert(offsetof(FM1GetAccountInfoRes, ServerTimeSync) == 0x000028, "Member 'FM1GetAccountInfoRes::ServerTimeSync' has a wrong offset!");
static_assert(offsetof(FM1GetAccountInfoRes, Account) == 0x000030, "Member 'FM1GetAccountInfoRes::Account' has a wrong offset!");

// ScriptStruct M1Data.M1StartServerSessionRes
// 0x0010 (0x0010 - 0x0000)
struct FM1StartServerSessionRes final
{
public:
	bool                                          Result;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         DediOid;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StartServerSessionRes) == 0x000008, "Wrong alignment on FM1StartServerSessionRes");
static_assert(sizeof(FM1StartServerSessionRes) == 0x000010, "Wrong size on FM1StartServerSessionRes");
static_assert(offsetof(FM1StartServerSessionRes, Result) == 0x000000, "Member 'FM1StartServerSessionRes::Result' has a wrong offset!");
static_assert(offsetof(FM1StartServerSessionRes, DediOid) == 0x000008, "Member 'FM1StartServerSessionRes::DediOid' has a wrong offset!");

// ScriptStruct M1Data.M1PartyMemberChangeNoti
// 0x0028 (0x0028 - 0x0000)
struct FM1PartyMemberChangeNoti final
{
public:
	bool                                          HasParty;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         PartyId;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         AccountUid;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1PartyMemberInfo>             Members;                                           // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PartyMemberChangeNoti) == 0x000008, "Wrong alignment on FM1PartyMemberChangeNoti");
static_assert(sizeof(FM1PartyMemberChangeNoti) == 0x000028, "Wrong size on FM1PartyMemberChangeNoti");
static_assert(offsetof(FM1PartyMemberChangeNoti, HasParty) == 0x000000, "Member 'FM1PartyMemberChangeNoti::HasParty' has a wrong offset!");
static_assert(offsetof(FM1PartyMemberChangeNoti, PartyId) == 0x000008, "Member 'FM1PartyMemberChangeNoti::PartyId' has a wrong offset!");
static_assert(offsetof(FM1PartyMemberChangeNoti, AccountUid) == 0x000010, "Member 'FM1PartyMemberChangeNoti::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1PartyMemberChangeNoti, Members) == 0x000018, "Member 'FM1PartyMemberChangeNoti::Members' has a wrong offset!");

// ScriptStruct M1Data.M1DediGameInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1DediGameInfo final
{
public:
	bool                                          IsPrivate;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         FieldMasterId;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         LeaveUserId;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DediGameInfo) == 0x000008, "Wrong alignment on FM1DediGameInfo");
static_assert(sizeof(FM1DediGameInfo) == 0x000018, "Wrong size on FM1DediGameInfo");
static_assert(offsetof(FM1DediGameInfo, IsPrivate) == 0x000000, "Member 'FM1DediGameInfo::IsPrivate' has a wrong offset!");
static_assert(offsetof(FM1DediGameInfo, FieldMasterId) == 0x000008, "Member 'FM1DediGameInfo::FieldMasterId' has a wrong offset!");
static_assert(offsetof(FM1DediGameInfo, LeaveUserId) == 0x000010, "Member 'FM1DediGameInfo::LeaveUserId' has a wrong offset!");

// ScriptStruct M1Data.M1FixedDungeonRewardInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1FixedDungeonRewardInfo final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardTid;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1FixedDungeonRewardInfo) == 0x000008, "Wrong alignment on FM1FixedDungeonRewardInfo");
static_assert(sizeof(FM1FixedDungeonRewardInfo) == 0x000010, "Wrong size on FM1FixedDungeonRewardInfo");
static_assert(offsetof(FM1FixedDungeonRewardInfo, AccountUid) == 0x000000, "Member 'FM1FixedDungeonRewardInfo::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1FixedDungeonRewardInfo, RewardTid) == 0x000008, "Member 'FM1FixedDungeonRewardInfo::RewardTid' has a wrong offset!");

// ScriptStruct M1Data.M1MapModifier
// 0x0004 (0x0004 - 0x0000)
struct FM1MapModifier final
{
public:
	struct FM1TemplateId                          ModifierId;                                        // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MapModifier) == 0x000004, "Wrong alignment on FM1MapModifier");
static_assert(sizeof(FM1MapModifier) == 0x000004, "Wrong size on FM1MapModifier");
static_assert(offsetof(FM1MapModifier, ModifierId) == 0x000000, "Member 'FM1MapModifier::ModifierId' has a wrong offset!");

// ScriptStruct M1Data.M1DediGameModifierInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1DediGameModifierInfo final
{
public:
	TArray<struct FM1MapModifier>                 Modifiers;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1FixedDungeonRewardInfo>      FixedRewardInfos;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DediGameModifierInfo) == 0x000008, "Wrong alignment on FM1DediGameModifierInfo");
static_assert(sizeof(FM1DediGameModifierInfo) == 0x000020, "Wrong size on FM1DediGameModifierInfo");
static_assert(offsetof(FM1DediGameModifierInfo, Modifiers) == 0x000000, "Member 'FM1DediGameModifierInfo::Modifiers' has a wrong offset!");
static_assert(offsetof(FM1DediGameModifierInfo, FixedRewardInfos) == 0x000010, "Member 'FM1DediGameModifierInfo::FixedRewardInfos' has a wrong offset!");

// ScriptStruct M1Data.M1MatchingStartInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1MatchingStartInfo final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1MapSubData                          MapSubData;                                        // 0x0008(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         EstimatedTimeSec;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPrivate;                                         // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MatchingStartInfo) == 0x000008, "Wrong alignment on FM1MatchingStartInfo");
static_assert(sizeof(FM1MatchingStartInfo) == 0x000020, "Wrong size on FM1MatchingStartInfo");
static_assert(offsetof(FM1MatchingStartInfo, AccountUid) == 0x000000, "Member 'FM1MatchingStartInfo::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1MatchingStartInfo, MapSubData) == 0x000008, "Member 'FM1MatchingStartInfo::MapSubData' has a wrong offset!");
static_assert(offsetof(FM1MatchingStartInfo, EstimatedTimeSec) == 0x000018, "Member 'FM1MatchingStartInfo::EstimatedTimeSec' has a wrong offset!");
static_assert(offsetof(FM1MatchingStartInfo, IsPrivate) == 0x00001C, "Member 'FM1MatchingStartInfo::IsPrivate' has a wrong offset!");

// ScriptStruct M1Data.M1MatchingSuccessInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1MatchingSuccessInfo final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPrivate;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MatchingSuccessInfo) == 0x000008, "Wrong alignment on FM1MatchingSuccessInfo");
static_assert(sizeof(FM1MatchingSuccessInfo) == 0x000010, "Wrong size on FM1MatchingSuccessInfo");
static_assert(offsetof(FM1MatchingSuccessInfo, AccountUid) == 0x000000, "Member 'FM1MatchingSuccessInfo::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1MatchingSuccessInfo, IsPrivate) == 0x000008, "Member 'FM1MatchingSuccessInfo::IsPrivate' has a wrong offset!");

// ScriptStruct M1Data.M1MatchingCancelInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1MatchingCancelInfo final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MatchingCancelReason                       Reason;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MatchingCancelInfo) == 0x000008, "Wrong alignment on FM1MatchingCancelInfo");
static_assert(sizeof(FM1MatchingCancelInfo) == 0x000010, "Wrong size on FM1MatchingCancelInfo");
static_assert(offsetof(FM1MatchingCancelInfo, AccountUid) == 0x000000, "Member 'FM1MatchingCancelInfo::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1MatchingCancelInfo, Reason) == 0x000008, "Member 'FM1MatchingCancelInfo::Reason' has a wrong offset!");

// ScriptStruct M1Data.M1LeaveCharacterNotiInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1LeaveCharacterNotiInfo final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ServerMove;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1LeaveCharacterNotiInfo) == 0x000008, "Wrong alignment on FM1LeaveCharacterNotiInfo");
static_assert(sizeof(FM1LeaveCharacterNotiInfo) == 0x000010, "Wrong size on FM1LeaveCharacterNotiInfo");
static_assert(offsetof(FM1LeaveCharacterNotiInfo, AccountUid) == 0x000000, "Member 'FM1LeaveCharacterNotiInfo::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1LeaveCharacterNotiInfo, ServerMove) == 0x000008, "Member 'FM1LeaveCharacterNotiInfo::ServerMove' has a wrong offset!");

// ScriptStruct M1Data.M1PartyJoinDedicatedServerParam
// 0x0030 (0x0030 - 0x0000)
struct FM1PartyJoinDedicatedServerParam final
{
public:
	int64                                         MasterUid;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MapTemplateId;                                     // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1MapSubData                          MapSubData;                                        // 0x000C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          CheckUnlock;                                       // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PrivateField;                                      // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1MapModifier>                 Modifiers;                                         // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PartyJoinDedicatedServerParam) == 0x000008, "Wrong alignment on FM1PartyJoinDedicatedServerParam");
static_assert(sizeof(FM1PartyJoinDedicatedServerParam) == 0x000030, "Wrong size on FM1PartyJoinDedicatedServerParam");
static_assert(offsetof(FM1PartyJoinDedicatedServerParam, MasterUid) == 0x000000, "Member 'FM1PartyJoinDedicatedServerParam::MasterUid' has a wrong offset!");
static_assert(offsetof(FM1PartyJoinDedicatedServerParam, MapTemplateId) == 0x000008, "Member 'FM1PartyJoinDedicatedServerParam::MapTemplateId' has a wrong offset!");
static_assert(offsetof(FM1PartyJoinDedicatedServerParam, MapSubData) == 0x00000C, "Member 'FM1PartyJoinDedicatedServerParam::MapSubData' has a wrong offset!");
static_assert(offsetof(FM1PartyJoinDedicatedServerParam, CheckUnlock) == 0x00001C, "Member 'FM1PartyJoinDedicatedServerParam::CheckUnlock' has a wrong offset!");
static_assert(offsetof(FM1PartyJoinDedicatedServerParam, PrivateField) == 0x00001D, "Member 'FM1PartyJoinDedicatedServerParam::PrivateField' has a wrong offset!");
static_assert(offsetof(FM1PartyJoinDedicatedServerParam, Modifiers) == 0x000020, "Member 'FM1PartyJoinDedicatedServerParam::Modifiers' has a wrong offset!");

// ScriptStruct M1Data.M1TrackingDataLink
// 0x0000 (0x0030 - 0x0030)
struct FM1TrackingDataLink final : public FDataLink
{
};
static_assert(alignof(FM1TrackingDataLink) == 0x000008, "Wrong alignment on FM1TrackingDataLink");
static_assert(sizeof(FM1TrackingDataLink) == 0x000030, "Wrong size on FM1TrackingDataLink");

// ScriptStruct M1Data.M1ItemPack
// 0x000C (0x000C - 0x0000)
struct FM1ItemPack final
{
public:
	struct FM1ItemTidBox                          ItemInfo;                                          // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemPack) == 0x000004, "Wrong alignment on FM1ItemPack");
static_assert(sizeof(FM1ItemPack) == 0x00000C, "Wrong size on FM1ItemPack");
static_assert(offsetof(FM1ItemPack, ItemInfo) == 0x000000, "Member 'FM1ItemPack::ItemInfo' has a wrong offset!");
static_assert(offsetof(FM1ItemPack, Count) == 0x000008, "Member 'FM1ItemPack::Count' has a wrong offset!");

// ScriptStruct M1Data.M1EquipmentRandomOptionPair
// 0x0010 (0x0010 - 0x0000)
struct FM1EquipmentRandomOptionPair final
{
public:
	struct FM1TemplateId                          Tid;                                               // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ScaledInteger                       StatValue;                                         // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EquipmentRandomOptionPair) == 0x000008, "Wrong alignment on FM1EquipmentRandomOptionPair");
static_assert(sizeof(FM1EquipmentRandomOptionPair) == 0x000010, "Wrong size on FM1EquipmentRandomOptionPair");
static_assert(offsetof(FM1EquipmentRandomOptionPair, Tid) == 0x000000, "Member 'FM1EquipmentRandomOptionPair::Tid' has a wrong offset!");
static_assert(offsetof(FM1EquipmentRandomOptionPair, StatValue) == 0x000008, "Member 'FM1EquipmentRandomOptionPair::StatValue' has a wrong offset!");

// ScriptStruct M1Data.M1CheatCreateEquipmentReq
// 0x0020 (0x0020 - 0x0000)
struct FM1CheatCreateEquipmentReq final
{
public:
	struct FM1TemplateId                          EquipmentTid;                                      // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OptionalLevel;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1EquipmentRandomOptionPair>   RandomOptions;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CheatCreateEquipmentReq) == 0x000008, "Wrong alignment on FM1CheatCreateEquipmentReq");
static_assert(sizeof(FM1CheatCreateEquipmentReq) == 0x000020, "Wrong size on FM1CheatCreateEquipmentReq");
static_assert(offsetof(FM1CheatCreateEquipmentReq, EquipmentTid) == 0x000000, "Member 'FM1CheatCreateEquipmentReq::EquipmentTid' has a wrong offset!");
static_assert(offsetof(FM1CheatCreateEquipmentReq, Level) == 0x000004, "Member 'FM1CheatCreateEquipmentReq::Level' has a wrong offset!");
static_assert(offsetof(FM1CheatCreateEquipmentReq, OptionalLevel) == 0x000008, "Member 'FM1CheatCreateEquipmentReq::OptionalLevel' has a wrong offset!");
static_assert(offsetof(FM1CheatCreateEquipmentReq, RandomOptions) == 0x000010, "Member 'FM1CheatCreateEquipmentReq::RandomOptions' has a wrong offset!");

// ScriptStruct M1Data.M1CheatCreateItemReq
// 0x0028 (0x0028 - 0x0000)
struct FM1CheatCreateItemReq final
{
public:
	struct FM1ItemTidBox                          ItemTid;                                           // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OptionalLevel;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1EquipmentRandomOptionPair>   RandomOptions;                                     // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CheatCreateItemReq) == 0x000008, "Wrong alignment on FM1CheatCreateItemReq");
static_assert(sizeof(FM1CheatCreateItemReq) == 0x000028, "Wrong size on FM1CheatCreateItemReq");
static_assert(offsetof(FM1CheatCreateItemReq, ItemTid) == 0x000000, "Member 'FM1CheatCreateItemReq::ItemTid' has a wrong offset!");
static_assert(offsetof(FM1CheatCreateItemReq, Count) == 0x000008, "Member 'FM1CheatCreateItemReq::Count' has a wrong offset!");
static_assert(offsetof(FM1CheatCreateItemReq, Level) == 0x00000C, "Member 'FM1CheatCreateItemReq::Level' has a wrong offset!");
static_assert(offsetof(FM1CheatCreateItemReq, OptionalLevel) == 0x000010, "Member 'FM1CheatCreateItemReq::OptionalLevel' has a wrong offset!");
static_assert(offsetof(FM1CheatCreateItemReq, RandomOptions) == 0x000018, "Member 'FM1CheatCreateItemReq::RandomOptions' has a wrong offset!");

// ScriptStruct M1Data.M1CheatCreateBulkEquipmentReq
// 0x0020 (0x0020 - 0x0000)
struct FM1CheatCreateBulkEquipmentReq final
{
public:
	EM1EquipmentCategoryType                      CategoryType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1EquipItemClassType                         ClassType;                                         // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemTierType                               Tier;                                              // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OptionalLevel;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1EquipmentRandomOptionPair>   RandomOptions;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CheatCreateBulkEquipmentReq) == 0x000008, "Wrong alignment on FM1CheatCreateBulkEquipmentReq");
static_assert(sizeof(FM1CheatCreateBulkEquipmentReq) == 0x000020, "Wrong size on FM1CheatCreateBulkEquipmentReq");
static_assert(offsetof(FM1CheatCreateBulkEquipmentReq, CategoryType) == 0x000000, "Member 'FM1CheatCreateBulkEquipmentReq::CategoryType' has a wrong offset!");
static_assert(offsetof(FM1CheatCreateBulkEquipmentReq, ClassType) == 0x000001, "Member 'FM1CheatCreateBulkEquipmentReq::ClassType' has a wrong offset!");
static_assert(offsetof(FM1CheatCreateBulkEquipmentReq, Tier) == 0x000002, "Member 'FM1CheatCreateBulkEquipmentReq::Tier' has a wrong offset!");
static_assert(offsetof(FM1CheatCreateBulkEquipmentReq, Level) == 0x000004, "Member 'FM1CheatCreateBulkEquipmentReq::Level' has a wrong offset!");
static_assert(offsetof(FM1CheatCreateBulkEquipmentReq, OptionalLevel) == 0x000008, "Member 'FM1CheatCreateBulkEquipmentReq::OptionalLevel' has a wrong offset!");
static_assert(offsetof(FM1CheatCreateBulkEquipmentReq, RandomOptions) == 0x000010, "Member 'FM1CheatCreateBulkEquipmentReq::RandomOptions' has a wrong offset!");

// ScriptStruct M1Data.M1InventoryUpdateNoti
// 0x00B0 (0x00B0 - 0x0000)
struct FM1InventoryUpdateNoti final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InventoryRevision;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1ItemInfoBox>                 CreatedItems;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1ItemInfoBox>                 UpdatedItems;                                      // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1ItemUidBox>                  DeletedItems;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1CurrencyInfo>                Currencies;                                        // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1WeaponProficiencyInfo>       WeaponProficiencies;                               // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1EquipmentRandomOptionInfo>   UpdatedRandomOptions;                              // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1PerkInfo>                    Perks;                                             // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1ReactorEnchantInfo>          ReactorInfos;                                      // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1TitleItemInfo>               TitleInfos;                                        // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1RecordInfo>                  RecordInfos;                                       // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InventoryUpdateNoti) == 0x000008, "Wrong alignment on FM1InventoryUpdateNoti");
static_assert(sizeof(FM1InventoryUpdateNoti) == 0x0000B0, "Wrong size on FM1InventoryUpdateNoti");
static_assert(offsetof(FM1InventoryUpdateNoti, AccountUid) == 0x000000, "Member 'FM1InventoryUpdateNoti::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1InventoryUpdateNoti, InventoryRevision) == 0x000008, "Member 'FM1InventoryUpdateNoti::InventoryRevision' has a wrong offset!");
static_assert(offsetof(FM1InventoryUpdateNoti, CreatedItems) == 0x000010, "Member 'FM1InventoryUpdateNoti::CreatedItems' has a wrong offset!");
static_assert(offsetof(FM1InventoryUpdateNoti, UpdatedItems) == 0x000020, "Member 'FM1InventoryUpdateNoti::UpdatedItems' has a wrong offset!");
static_assert(offsetof(FM1InventoryUpdateNoti, DeletedItems) == 0x000030, "Member 'FM1InventoryUpdateNoti::DeletedItems' has a wrong offset!");
static_assert(offsetof(FM1InventoryUpdateNoti, Currencies) == 0x000040, "Member 'FM1InventoryUpdateNoti::Currencies' has a wrong offset!");
static_assert(offsetof(FM1InventoryUpdateNoti, WeaponProficiencies) == 0x000050, "Member 'FM1InventoryUpdateNoti::WeaponProficiencies' has a wrong offset!");
static_assert(offsetof(FM1InventoryUpdateNoti, UpdatedRandomOptions) == 0x000060, "Member 'FM1InventoryUpdateNoti::UpdatedRandomOptions' has a wrong offset!");
static_assert(offsetof(FM1InventoryUpdateNoti, Perks) == 0x000070, "Member 'FM1InventoryUpdateNoti::Perks' has a wrong offset!");
static_assert(offsetof(FM1InventoryUpdateNoti, ReactorInfos) == 0x000080, "Member 'FM1InventoryUpdateNoti::ReactorInfos' has a wrong offset!");
static_assert(offsetof(FM1InventoryUpdateNoti, TitleInfos) == 0x000090, "Member 'FM1InventoryUpdateNoti::TitleInfos' has a wrong offset!");
static_assert(offsetof(FM1InventoryUpdateNoti, RecordInfos) == 0x0000A0, "Member 'FM1InventoryUpdateNoti::RecordInfos' has a wrong offset!");

// ScriptStruct M1Data.M1DropItemRequest
// 0x0040 (0x0040 - 0x0000)
struct FM1DropItemRequest final
{
public:
	struct FM1TemplateId                          MonsterSpawnGroupTid;                              // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MonsterUid;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterLevel;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EM1MonsterSubType>                     MonsterSubTypeList;                                // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int64>                                 AccountUidList;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EM1MonsterCategory                            MonsterCategory;                                   // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1DropItemRequest) == 0x000008, "Wrong alignment on FM1DropItemRequest");
static_assert(sizeof(FM1DropItemRequest) == 0x000040, "Wrong size on FM1DropItemRequest");
static_assert(offsetof(FM1DropItemRequest, MonsterSpawnGroupTid) == 0x000000, "Member 'FM1DropItemRequest::MonsterSpawnGroupTid' has a wrong offset!");
static_assert(offsetof(FM1DropItemRequest, MonsterUid) == 0x000008, "Member 'FM1DropItemRequest::MonsterUid' has a wrong offset!");
static_assert(offsetof(FM1DropItemRequest, MonsterLevel) == 0x000010, "Member 'FM1DropItemRequest::MonsterLevel' has a wrong offset!");
static_assert(offsetof(FM1DropItemRequest, MonsterSubTypeList) == 0x000018, "Member 'FM1DropItemRequest::MonsterSubTypeList' has a wrong offset!");
static_assert(offsetof(FM1DropItemRequest, AccountUidList) == 0x000028, "Member 'FM1DropItemRequest::AccountUidList' has a wrong offset!");
static_assert(offsetof(FM1DropItemRequest, MonsterCategory) == 0x000038, "Member 'FM1DropItemRequest::MonsterCategory' has a wrong offset!");

// ScriptStruct M1Data.M1BossKillDropItemRequest
// 0x0028 (0x0028 - 0x0000)
struct FM1BossKillDropItemRequest final
{
public:
	struct FM1TemplateId                          MonsterTid;                                        // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MonsterUid;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterLevel;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 AccountUidList;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BossKillDropItemRequest) == 0x000008, "Wrong alignment on FM1BossKillDropItemRequest");
static_assert(sizeof(FM1BossKillDropItemRequest) == 0x000028, "Wrong size on FM1BossKillDropItemRequest");
static_assert(offsetof(FM1BossKillDropItemRequest, MonsterTid) == 0x000000, "Member 'FM1BossKillDropItemRequest::MonsterTid' has a wrong offset!");
static_assert(offsetof(FM1BossKillDropItemRequest, MonsterUid) == 0x000008, "Member 'FM1BossKillDropItemRequest::MonsterUid' has a wrong offset!");
static_assert(offsetof(FM1BossKillDropItemRequest, MonsterLevel) == 0x000010, "Member 'FM1BossKillDropItemRequest::MonsterLevel' has a wrong offset!");
static_assert(offsetof(FM1BossKillDropItemRequest, AccountUidList) == 0x000018, "Member 'FM1BossKillDropItemRequest::AccountUidList' has a wrong offset!");

// ScriptStruct M1Data.M1BossPartsDropItemRequest
// 0x0030 (0x0030 - 0x0000)
struct FM1BossPartsDropItemRequest final
{
public:
	struct FM1TemplateId                          MonsterTid;                                        // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MonsterUid;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterLevel;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          PartsTid;                                          // 0x0014(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDebone;                                          // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 AccountUidList;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BossPartsDropItemRequest) == 0x000008, "Wrong alignment on FM1BossPartsDropItemRequest");
static_assert(sizeof(FM1BossPartsDropItemRequest) == 0x000030, "Wrong size on FM1BossPartsDropItemRequest");
static_assert(offsetof(FM1BossPartsDropItemRequest, MonsterTid) == 0x000000, "Member 'FM1BossPartsDropItemRequest::MonsterTid' has a wrong offset!");
static_assert(offsetof(FM1BossPartsDropItemRequest, MonsterUid) == 0x000008, "Member 'FM1BossPartsDropItemRequest::MonsterUid' has a wrong offset!");
static_assert(offsetof(FM1BossPartsDropItemRequest, MonsterLevel) == 0x000010, "Member 'FM1BossPartsDropItemRequest::MonsterLevel' has a wrong offset!");
static_assert(offsetof(FM1BossPartsDropItemRequest, PartsTid) == 0x000014, "Member 'FM1BossPartsDropItemRequest::PartsTid' has a wrong offset!");
static_assert(offsetof(FM1BossPartsDropItemRequest, IsDebone) == 0x000018, "Member 'FM1BossPartsDropItemRequest::IsDebone' has a wrong offset!");
static_assert(offsetof(FM1BossPartsDropItemRequest, AccountUidList) == 0x000020, "Member 'FM1BossPartsDropItemRequest::AccountUidList' has a wrong offset!");

// ScriptStruct M1Data.M1MonsterRequestInfoBox
// 0x0010 (0x0010 - 0x0000)
struct FM1MonsterRequestInfoBox final
{
public:
	EM1EventBoostContentType                      ContentType;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ContentId;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterRequestInfoBox) == 0x000008, "Wrong alignment on FM1MonsterRequestInfoBox");
static_assert(sizeof(FM1MonsterRequestInfoBox) == 0x000010, "Wrong size on FM1MonsterRequestInfoBox");
static_assert(offsetof(FM1MonsterRequestInfoBox, ContentType) == 0x000000, "Member 'FM1MonsterRequestInfoBox::ContentType' has a wrong offset!");
static_assert(offsetof(FM1MonsterRequestInfoBox, ContentId) == 0x000008, "Member 'FM1MonsterRequestInfoBox::ContentId' has a wrong offset!");

// ScriptStruct M1Data.M1MissionTaskDropItemRequest
// 0x0038 (0x0038 - 0x0000)
struct FM1MissionTaskDropItemRequest final
{
public:
	struct FM1TemplateId                          MissionTaskTemplateId;                             // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MonsterCategory                            MonsterCategory;                                   // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MissionCategory                            MissionCategory;                                   // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MonsterUid;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterLevel;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          PartsTid;                                          // 0x0014(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EM1MonsterSubType>                     MonsterSubTypeList;                                // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int64>                                 AccountUidList;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionTaskDropItemRequest) == 0x000008, "Wrong alignment on FM1MissionTaskDropItemRequest");
static_assert(sizeof(FM1MissionTaskDropItemRequest) == 0x000038, "Wrong size on FM1MissionTaskDropItemRequest");
static_assert(offsetof(FM1MissionTaskDropItemRequest, MissionTaskTemplateId) == 0x000000, "Member 'FM1MissionTaskDropItemRequest::MissionTaskTemplateId' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskDropItemRequest, MonsterCategory) == 0x000004, "Member 'FM1MissionTaskDropItemRequest::MonsterCategory' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskDropItemRequest, MissionCategory) == 0x000005, "Member 'FM1MissionTaskDropItemRequest::MissionCategory' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskDropItemRequest, MonsterUid) == 0x000008, "Member 'FM1MissionTaskDropItemRequest::MonsterUid' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskDropItemRequest, MonsterLevel) == 0x000010, "Member 'FM1MissionTaskDropItemRequest::MonsterLevel' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskDropItemRequest, PartsTid) == 0x000014, "Member 'FM1MissionTaskDropItemRequest::PartsTid' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskDropItemRequest, MonsterSubTypeList) == 0x000018, "Member 'FM1MissionTaskDropItemRequest::MonsterSubTypeList' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskDropItemRequest, AccountUidList) == 0x000028, "Member 'FM1MissionTaskDropItemRequest::AccountUidList' has a wrong offset!");

// ScriptStruct M1Data.M1MissionWaveDropItemRequest
// 0x0038 (0x0038 - 0x0000)
struct FM1MissionWaveDropItemRequest final
{
public:
	struct FM1TemplateId                          MissionWaveTemplateId;                             // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MonsterCategory                            MonsterCategory;                                   // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MonsterUid;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterLevel;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          PartsTid;                                          // 0x0014(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EM1MonsterSubType>                     MonsterSubTypeList;                                // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int64>                                 AccountUidList;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionWaveDropItemRequest) == 0x000008, "Wrong alignment on FM1MissionWaveDropItemRequest");
static_assert(sizeof(FM1MissionWaveDropItemRequest) == 0x000038, "Wrong size on FM1MissionWaveDropItemRequest");
static_assert(offsetof(FM1MissionWaveDropItemRequest, MissionWaveTemplateId) == 0x000000, "Member 'FM1MissionWaveDropItemRequest::MissionWaveTemplateId' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveDropItemRequest, MonsterCategory) == 0x000004, "Member 'FM1MissionWaveDropItemRequest::MonsterCategory' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveDropItemRequest, MonsterUid) == 0x000008, "Member 'FM1MissionWaveDropItemRequest::MonsterUid' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveDropItemRequest, MonsterLevel) == 0x000010, "Member 'FM1MissionWaveDropItemRequest::MonsterLevel' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveDropItemRequest, PartsTid) == 0x000014, "Member 'FM1MissionWaveDropItemRequest::PartsTid' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveDropItemRequest, MonsterSubTypeList) == 0x000018, "Member 'FM1MissionWaveDropItemRequest::MonsterSubTypeList' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveDropItemRequest, AccountUidList) == 0x000028, "Member 'FM1MissionWaveDropItemRequest::AccountUidList' has a wrong offset!");

// ScriptStruct M1Data.M1FieldObjectDropItemRequest
// 0x0018 (0x0018 - 0x0000)
struct FM1FieldObjectDropItemRequest final
{
public:
	struct FM1TemplateId                          FieldObjectTemplateId;                             // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 AccountUidList;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FieldObjectDropItemRequest) == 0x000008, "Wrong alignment on FM1FieldObjectDropItemRequest");
static_assert(sizeof(FM1FieldObjectDropItemRequest) == 0x000018, "Wrong size on FM1FieldObjectDropItemRequest");
static_assert(offsetof(FM1FieldObjectDropItemRequest, FieldObjectTemplateId) == 0x000000, "Member 'FM1FieldObjectDropItemRequest::FieldObjectTemplateId' has a wrong offset!");
static_assert(offsetof(FM1FieldObjectDropItemRequest, AccountUidList) == 0x000008, "Member 'FM1FieldObjectDropItemRequest::AccountUidList' has a wrong offset!");

// ScriptStruct M1Data.M1DropItemNotiElement
// 0x0020 (0x0020 - 0x0000)
struct FM1DropItemNotiElement final
{
public:
	int64                                         DropOid;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         AccountUid;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemTidBox                          ItemTid;                                           // 0x0010(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DropItemNotiElement) == 0x000008, "Wrong alignment on FM1DropItemNotiElement");
static_assert(sizeof(FM1DropItemNotiElement) == 0x000020, "Wrong size on FM1DropItemNotiElement");
static_assert(offsetof(FM1DropItemNotiElement, DropOid) == 0x000000, "Member 'FM1DropItemNotiElement::DropOid' has a wrong offset!");
static_assert(offsetof(FM1DropItemNotiElement, AccountUid) == 0x000008, "Member 'FM1DropItemNotiElement::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1DropItemNotiElement, ItemTid) == 0x000010, "Member 'FM1DropItemNotiElement::ItemTid' has a wrong offset!");
static_assert(offsetof(FM1DropItemNotiElement, Count) == 0x000018, "Member 'FM1DropItemNotiElement::Count' has a wrong offset!");
static_assert(offsetof(FM1DropItemNotiElement, Level) == 0x00001C, "Member 'FM1DropItemNotiElement::Level' has a wrong offset!");

// ScriptStruct M1Data.M1DropItemInfoNoti
// 0x0020 (0x0020 - 0x0000)
struct FM1DropItemInfoNoti final
{
public:
	int64                                         MosterUId;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          PartsTid;                                          // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1DropItemNotiElement>         DropItemNotiList;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DropItemInfoNoti) == 0x000008, "Wrong alignment on FM1DropItemInfoNoti");
static_assert(sizeof(FM1DropItemInfoNoti) == 0x000020, "Wrong size on FM1DropItemInfoNoti");
static_assert(offsetof(FM1DropItemInfoNoti, MosterUId) == 0x000000, "Member 'FM1DropItemInfoNoti::MosterUId' has a wrong offset!");
static_assert(offsetof(FM1DropItemInfoNoti, PartsTid) == 0x000008, "Member 'FM1DropItemInfoNoti::PartsTid' has a wrong offset!");
static_assert(offsetof(FM1DropItemInfoNoti, DropItemNotiList) == 0x000010, "Member 'FM1DropItemInfoNoti::DropItemNotiList' has a wrong offset!");

// ScriptStruct M1Data.M1ShopSellInfoNoti
// 0x0020 (0x0020 - 0x0000)
struct FM1ShopSellInfoNoti final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemUidBox                          ItemUid;                                           // 0x0008(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1CommonShopResultType                       Result;                                            // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ShopSellInfoNoti) == 0x000008, "Wrong alignment on FM1ShopSellInfoNoti");
static_assert(sizeof(FM1ShopSellInfoNoti) == 0x000020, "Wrong size on FM1ShopSellInfoNoti");
static_assert(offsetof(FM1ShopSellInfoNoti, AccountUid) == 0x000000, "Member 'FM1ShopSellInfoNoti::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1ShopSellInfoNoti, ItemUid) == 0x000008, "Member 'FM1ShopSellInfoNoti::ItemUid' has a wrong offset!");
static_assert(offsetof(FM1ShopSellInfoNoti, Count) == 0x000018, "Member 'FM1ShopSellInfoNoti::Count' has a wrong offset!");
static_assert(offsetof(FM1ShopSellInfoNoti, Result) == 0x00001C, "Member 'FM1ShopSellInfoNoti::Result' has a wrong offset!");

// ScriptStruct M1Data.M1ShopBuyAcquireInfo
// 0x000C (0x000C - 0x0000)
struct FM1ShopBuyAcquireInfo final
{
public:
	struct FM1ItemTidBox                          ItemTid;                                           // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ShopBuyAcquireInfo) == 0x000004, "Wrong alignment on FM1ShopBuyAcquireInfo");
static_assert(sizeof(FM1ShopBuyAcquireInfo) == 0x00000C, "Wrong size on FM1ShopBuyAcquireInfo");
static_assert(offsetof(FM1ShopBuyAcquireInfo, ItemTid) == 0x000000, "Member 'FM1ShopBuyAcquireInfo::ItemTid' has a wrong offset!");
static_assert(offsetof(FM1ShopBuyAcquireInfo, Count) == 0x000008, "Member 'FM1ShopBuyAcquireInfo::Count' has a wrong offset!");

// ScriptStruct M1Data.M1ShopBuyInfo
// 0x0038 (0x0038 - 0x0000)
struct FM1ShopBuyInfo final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ShopId;                                            // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ProductId;                                         // 0x000C(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1CommonShopResultType                       Result;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              BuyTime;                                           // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuyCount;                                          // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1ShopBuyAcquireInfo>          AcquireList;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ShopBuyInfo) == 0x000008, "Wrong alignment on FM1ShopBuyInfo");
static_assert(sizeof(FM1ShopBuyInfo) == 0x000038, "Wrong size on FM1ShopBuyInfo");
static_assert(offsetof(FM1ShopBuyInfo, AccountUid) == 0x000000, "Member 'FM1ShopBuyInfo::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1ShopBuyInfo, ShopId) == 0x000008, "Member 'FM1ShopBuyInfo::ShopId' has a wrong offset!");
static_assert(offsetof(FM1ShopBuyInfo, ProductId) == 0x00000C, "Member 'FM1ShopBuyInfo::ProductId' has a wrong offset!");
static_assert(offsetof(FM1ShopBuyInfo, Result) == 0x000010, "Member 'FM1ShopBuyInfo::Result' has a wrong offset!");
static_assert(offsetof(FM1ShopBuyInfo, BuyTime) == 0x000018, "Member 'FM1ShopBuyInfo::BuyTime' has a wrong offset!");
static_assert(offsetof(FM1ShopBuyInfo, BuyCount) == 0x000020, "Member 'FM1ShopBuyInfo::BuyCount' has a wrong offset!");
static_assert(offsetof(FM1ShopBuyInfo, AcquireList) == 0x000028, "Member 'FM1ShopBuyInfo::AcquireList' has a wrong offset!");

// ScriptStruct M1Data.M1ShopBuyInfoBundle
// 0x0010 (0x0010 - 0x0000)
struct FM1ShopBuyInfoBundle final
{
public:
	TArray<struct FM1ShopBuyInfo>                 BuyInfoList;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ShopBuyInfoBundle) == 0x000008, "Wrong alignment on FM1ShopBuyInfoBundle");
static_assert(sizeof(FM1ShopBuyInfoBundle) == 0x000010, "Wrong size on FM1ShopBuyInfoBundle");
static_assert(offsetof(FM1ShopBuyInfoBundle, BuyInfoList) == 0x000000, "Member 'FM1ShopBuyInfoBundle::BuyInfoList' has a wrong offset!");

// ScriptStruct M1Data.M1CheatCreateCharacterRes
// 0x0030 (0x0030 - 0x0000)
struct FM1CheatCreateCharacterRes final
{
public:
	EM1CheatCreateCharacterResultType             Result;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1CharacterInfo                       CreatedCharacter;                                  // 0x0008(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CheatCreateCharacterRes) == 0x000008, "Wrong alignment on FM1CheatCreateCharacterRes");
static_assert(sizeof(FM1CheatCreateCharacterRes) == 0x000030, "Wrong size on FM1CheatCreateCharacterRes");
static_assert(offsetof(FM1CheatCreateCharacterRes, Result) == 0x000000, "Member 'FM1CheatCreateCharacterRes::Result' has a wrong offset!");
static_assert(offsetof(FM1CheatCreateCharacterRes, CreatedCharacter) == 0x000008, "Member 'FM1CheatCreateCharacterRes::CreatedCharacter' has a wrong offset!");

// ScriptStruct M1Data.M1CheatCreateCharacterReq
// 0x0018 (0x0018 - 0x0000)
struct FM1CheatCreateCharacterReq final
{
public:
	TArray<struct FM1TemplateId>                  TemplateIds;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CheatCreateCharacterReq) == 0x000008, "Wrong alignment on FM1CheatCreateCharacterReq");
static_assert(sizeof(FM1CheatCreateCharacterReq) == 0x000018, "Wrong size on FM1CheatCreateCharacterReq");
static_assert(offsetof(FM1CheatCreateCharacterReq, TemplateIds) == 0x000000, "Member 'FM1CheatCreateCharacterReq::TemplateIds' has a wrong offset!");
static_assert(offsetof(FM1CheatCreateCharacterReq, Level) == 0x000010, "Member 'FM1CheatCreateCharacterReq::Level' has a wrong offset!");

// ScriptStruct M1Data.M1ResearchDataType
// 0x0018 (0x0018 - 0x0000)
struct FM1ResearchDataType final
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         RemainTicks;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ResearchStatus                             ResearchStatus;                                    // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RepeatCount;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ResearchDataType) == 0x000008, "Wrong alignment on FM1ResearchDataType");
static_assert(sizeof(FM1ResearchDataType) == 0x000018, "Wrong size on FM1ResearchDataType");
static_assert(offsetof(FM1ResearchDataType, TemplateId) == 0x000000, "Member 'FM1ResearchDataType::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1ResearchDataType, RemainTicks) == 0x000008, "Member 'FM1ResearchDataType::RemainTicks' has a wrong offset!");
static_assert(offsetof(FM1ResearchDataType, ResearchStatus) == 0x000010, "Member 'FM1ResearchDataType::ResearchStatus' has a wrong offset!");
static_assert(offsetof(FM1ResearchDataType, RepeatCount) == 0x000014, "Member 'FM1ResearchDataType::RepeatCount' has a wrong offset!");

// ScriptStruct M1Data.M1ResearchDataNoti
// 0x0018 (0x0018 - 0x0000)
struct FM1ResearchDataNoti final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1ResearchDataType>            ResearchDataTypeList;                              // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ResearchDataNoti) == 0x000008, "Wrong alignment on FM1ResearchDataNoti");
static_assert(sizeof(FM1ResearchDataNoti) == 0x000018, "Wrong size on FM1ResearchDataNoti");
static_assert(offsetof(FM1ResearchDataNoti, AccountUid) == 0x000000, "Member 'FM1ResearchDataNoti::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1ResearchDataNoti, ResearchDataTypeList) == 0x000008, "Member 'FM1ResearchDataNoti::ResearchDataTypeList' has a wrong offset!");

// ScriptStruct M1Data.M1ResearchResultNoti
// 0x0020 (0x0020 - 0x0000)
struct FM1ResearchResultNoti final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ResearchTemplateId;                                // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ResearchReason                             Reason;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         RemainTicks;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ResearchStatus                             ResearchStatus;                                    // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ResearchResultNoti) == 0x000008, "Wrong alignment on FM1ResearchResultNoti");
static_assert(sizeof(FM1ResearchResultNoti) == 0x000020, "Wrong size on FM1ResearchResultNoti");
static_assert(offsetof(FM1ResearchResultNoti, AccountUid) == 0x000000, "Member 'FM1ResearchResultNoti::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1ResearchResultNoti, ResearchTemplateId) == 0x000008, "Member 'FM1ResearchResultNoti::ResearchTemplateId' has a wrong offset!");
static_assert(offsetof(FM1ResearchResultNoti, Reason) == 0x00000C, "Member 'FM1ResearchResultNoti::Reason' has a wrong offset!");
static_assert(offsetof(FM1ResearchResultNoti, RemainTicks) == 0x000010, "Member 'FM1ResearchResultNoti::RemainTicks' has a wrong offset!");
static_assert(offsetof(FM1ResearchResultNoti, ResearchStatus) == 0x000018, "Member 'FM1ResearchResultNoti::ResearchStatus' has a wrong offset!");

// ScriptStruct M1Data.M1ResearchBookMarkData
// 0x0010 (0x0010 - 0x0000)
struct FM1ResearchBookMarkData final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ResearchTemplateId;                                // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ResearchBookMarkData) == 0x000008, "Wrong alignment on FM1ResearchBookMarkData");
static_assert(sizeof(FM1ResearchBookMarkData) == 0x000010, "Wrong size on FM1ResearchBookMarkData");
static_assert(offsetof(FM1ResearchBookMarkData, AccountUid) == 0x000000, "Member 'FM1ResearchBookMarkData::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1ResearchBookMarkData, ResearchTemplateId) == 0x000008, "Member 'FM1ResearchBookMarkData::ResearchTemplateId' has a wrong offset!");

// ScriptStruct M1Data.M1ResearchBookMarkDataBundle
// 0x0018 (0x0018 - 0x0000)
struct FM1ResearchBookMarkDataBundle final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1TemplateId>                  ResearchTemplateIdList;                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ResearchBookMarkDataBundle) == 0x000008, "Wrong alignment on FM1ResearchBookMarkDataBundle");
static_assert(sizeof(FM1ResearchBookMarkDataBundle) == 0x000018, "Wrong size on FM1ResearchBookMarkDataBundle");
static_assert(offsetof(FM1ResearchBookMarkDataBundle, AccountUid) == 0x000000, "Member 'FM1ResearchBookMarkDataBundle::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1ResearchBookMarkDataBundle, ResearchTemplateIdList) == 0x000008, "Member 'FM1ResearchBookMarkDataBundle::ResearchTemplateIdList' has a wrong offset!");

// ScriptStruct M1Data.M1MissionInfoList
// 0x0018 (0x0018 - 0x0000)
struct FM1MissionInfoList final
{
public:
	int64                                         LastPlayMissionId;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1MissionInfo>                 MissionInfos;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionInfoList) == 0x000008, "Wrong alignment on FM1MissionInfoList");
static_assert(sizeof(FM1MissionInfoList) == 0x000018, "Wrong size on FM1MissionInfoList");
static_assert(offsetof(FM1MissionInfoList, LastPlayMissionId) == 0x000000, "Member 'FM1MissionInfoList::LastPlayMissionId' has a wrong offset!");
static_assert(offsetof(FM1MissionInfoList, MissionInfos) == 0x000008, "Member 'FM1MissionInfoList::MissionInfos' has a wrong offset!");

// ScriptStruct M1Data.M1MissionRequest
// 0x0020 (0x0020 - 0x0000)
struct FM1MissionRequest final
{
public:
	struct FM1TemplateId                          MissionId;                                         // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         AccountUid;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ControllerType;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionRequest) == 0x000008, "Wrong alignment on FM1MissionRequest");
static_assert(sizeof(FM1MissionRequest) == 0x000020, "Wrong size on FM1MissionRequest");
static_assert(offsetof(FM1MissionRequest, MissionId) == 0x000000, "Member 'FM1MissionRequest::MissionId' has a wrong offset!");
static_assert(offsetof(FM1MissionRequest, AccountUid) == 0x000008, "Member 'FM1MissionRequest::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1MissionRequest, ControllerType) == 0x000010, "Member 'FM1MissionRequest::ControllerType' has a wrong offset!");

// ScriptStruct M1Data.M1AccountUidWithMissionGrade
// 0x0010 (0x0010 - 0x0000)
struct FM1AccountUidWithMissionGrade final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MissionGrade;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AccountUidWithMissionGrade) == 0x000008, "Wrong alignment on FM1AccountUidWithMissionGrade");
static_assert(sizeof(FM1AccountUidWithMissionGrade) == 0x000010, "Wrong size on FM1AccountUidWithMissionGrade");
static_assert(offsetof(FM1AccountUidWithMissionGrade, AccountUid) == 0x000000, "Member 'FM1AccountUidWithMissionGrade::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1AccountUidWithMissionGrade, MissionGrade) == 0x000008, "Member 'FM1AccountUidWithMissionGrade::MissionGrade' has a wrong offset!");

// ScriptStruct M1Data.M1SuccessMissionRequest
// 0x0028 (0x0028 - 0x0000)
struct FM1SuccessMissionRequest final
{
public:
	struct FM1TemplateId                          MissionId;                                         // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1AccountUidWithMissionGrade>  AccountMissionGradePairs;                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 ControllerType;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SuccessMissionRequest) == 0x000008, "Wrong alignment on FM1SuccessMissionRequest");
static_assert(sizeof(FM1SuccessMissionRequest) == 0x000028, "Wrong size on FM1SuccessMissionRequest");
static_assert(offsetof(FM1SuccessMissionRequest, MissionId) == 0x000000, "Member 'FM1SuccessMissionRequest::MissionId' has a wrong offset!");
static_assert(offsetof(FM1SuccessMissionRequest, AccountMissionGradePairs) == 0x000008, "Member 'FM1SuccessMissionRequest::AccountMissionGradePairs' has a wrong offset!");
static_assert(offsetof(FM1SuccessMissionRequest, ControllerType) == 0x000018, "Member 'FM1SuccessMissionRequest::ControllerType' has a wrong offset!");

// ScriptStruct M1Data.M1SuccessMissionResByAccount
// 0x0028 (0x0028 - 0x0000)
struct FM1SuccessMissionResByAccount final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1CurrencyInfo>                CurrencyBoost;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ExpBoost;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpBoostByEvent;                                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MasteryBoost;                                      // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SuccessMissionResByAccount) == 0x000008, "Wrong alignment on FM1SuccessMissionResByAccount");
static_assert(sizeof(FM1SuccessMissionResByAccount) == 0x000028, "Wrong size on FM1SuccessMissionResByAccount");
static_assert(offsetof(FM1SuccessMissionResByAccount, AccountUid) == 0x000000, "Member 'FM1SuccessMissionResByAccount::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1SuccessMissionResByAccount, CurrencyBoost) == 0x000008, "Member 'FM1SuccessMissionResByAccount::CurrencyBoost' has a wrong offset!");
static_assert(offsetof(FM1SuccessMissionResByAccount, ExpBoost) == 0x000018, "Member 'FM1SuccessMissionResByAccount::ExpBoost' has a wrong offset!");
static_assert(offsetof(FM1SuccessMissionResByAccount, ExpBoostByEvent) == 0x00001C, "Member 'FM1SuccessMissionResByAccount::ExpBoostByEvent' has a wrong offset!");
static_assert(offsetof(FM1SuccessMissionResByAccount, MasteryBoost) == 0x000020, "Member 'FM1SuccessMissionResByAccount::MasteryBoost' has a wrong offset!");

// ScriptStruct M1Data.M1SuccessMissionRes
// 0x0010 (0x0010 - 0x0000)
struct FM1SuccessMissionRes final
{
public:
	TArray<struct FM1SuccessMissionResByAccount>  AccountList;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SuccessMissionRes) == 0x000008, "Wrong alignment on FM1SuccessMissionRes");
static_assert(sizeof(FM1SuccessMissionRes) == 0x000010, "Wrong size on FM1SuccessMissionRes");
static_assert(offsetof(FM1SuccessMissionRes, AccountList) == 0x000000, "Member 'FM1SuccessMissionRes::AccountList' has a wrong offset!");

// ScriptStruct M1Data.M1MissionMidRewardRequest
// 0x0018 (0x0018 - 0x0000)
struct FM1MissionMidRewardRequest final
{
public:
	struct FM1TemplateId                          MissionWaveTId;                                    // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 AccountList;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionMidRewardRequest) == 0x000008, "Wrong alignment on FM1MissionMidRewardRequest");
static_assert(sizeof(FM1MissionMidRewardRequest) == 0x000018, "Wrong size on FM1MissionMidRewardRequest");
static_assert(offsetof(FM1MissionMidRewardRequest, MissionWaveTId) == 0x000000, "Member 'FM1MissionMidRewardRequest::MissionWaveTId' has a wrong offset!");
static_assert(offsetof(FM1MissionMidRewardRequest, AccountList) == 0x000008, "Member 'FM1MissionMidRewardRequest::AccountList' has a wrong offset!");

// ScriptStruct M1Data.M1MissionMidRewardResByAccount
// 0x0020 (0x0020 - 0x0000)
struct FM1MissionMidRewardResByAccount final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpBoost;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1ItemPack>                    Acquires;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionMidRewardResByAccount) == 0x000008, "Wrong alignment on FM1MissionMidRewardResByAccount");
static_assert(sizeof(FM1MissionMidRewardResByAccount) == 0x000020, "Wrong size on FM1MissionMidRewardResByAccount");
static_assert(offsetof(FM1MissionMidRewardResByAccount, AccountUid) == 0x000000, "Member 'FM1MissionMidRewardResByAccount::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1MissionMidRewardResByAccount, ExpBoost) == 0x000008, "Member 'FM1MissionMidRewardResByAccount::ExpBoost' has a wrong offset!");
static_assert(offsetof(FM1MissionMidRewardResByAccount, Acquires) == 0x000010, "Member 'FM1MissionMidRewardResByAccount::Acquires' has a wrong offset!");

// ScriptStruct M1Data.M1MissionMidRewardRes
// 0x0010 (0x0010 - 0x0000)
struct FM1MissionMidRewardRes final
{
public:
	TArray<struct FM1MissionMidRewardResByAccount> AccountList;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionMidRewardRes) == 0x000008, "Wrong alignment on FM1MissionMidRewardRes");
static_assert(sizeof(FM1MissionMidRewardRes) == 0x000010, "Wrong size on FM1MissionMidRewardRes");
static_assert(offsetof(FM1MissionMidRewardRes, AccountList) == 0x000000, "Member 'FM1MissionMidRewardRes::AccountList' has a wrong offset!");

// ScriptStruct M1Data.M1LoadoutSlotTypeAndIndex
// 0x000C (0x000C - 0x0000)
struct FM1LoadoutSlotTypeAndIndex final
{
public:
	struct FM1ItemTidBox                          OwnerTid;                                          // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         LoadoutSlotIndex;                                  // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1LoadoutSlotTypeAndIndex) == 0x000004, "Wrong alignment on FM1LoadoutSlotTypeAndIndex");
static_assert(sizeof(FM1LoadoutSlotTypeAndIndex) == 0x00000C, "Wrong size on FM1LoadoutSlotTypeAndIndex");
static_assert(offsetof(FM1LoadoutSlotTypeAndIndex, OwnerTid) == 0x000000, "Member 'FM1LoadoutSlotTypeAndIndex::OwnerTid' has a wrong offset!");
static_assert(offsetof(FM1LoadoutSlotTypeAndIndex, LoadoutSlotIndex) == 0x000008, "Member 'FM1LoadoutSlotTypeAndIndex::LoadoutSlotIndex' has a wrong offset!");

// ScriptStruct M1Data.M1CheckEnchantRuneRes
// 0x0018 (0x0018 - 0x0000)
struct FM1CheckEnchantRuneRes final
{
public:
	EM1RuneReason                                 Reason;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1LoadoutSlotTypeAndIndex>     CapacityOverSlots;                                 // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CheckEnchantRuneRes) == 0x000008, "Wrong alignment on FM1CheckEnchantRuneRes");
static_assert(sizeof(FM1CheckEnchantRuneRes) == 0x000018, "Wrong size on FM1CheckEnchantRuneRes");
static_assert(offsetof(FM1CheckEnchantRuneRes, Reason) == 0x000000, "Member 'FM1CheckEnchantRuneRes::Reason' has a wrong offset!");
static_assert(offsetof(FM1CheckEnchantRuneRes, CapacityOverSlots) == 0x000008, "Member 'FM1CheckEnchantRuneRes::CapacityOverSlots' has a wrong offset!");

// ScriptStruct M1Data.M1FieldUnlockedNoti
// 0x0040 (0x0040 - 0x0000)
struct FM1FieldUnlockedNoti final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MapTemplateId;                                     // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1MapSubData                          MapSubData;                                        // 0x000C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         CampEntryPointId;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1TemplateId>                  BattleZoneId;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FieldUnlockedNoti) == 0x000008, "Wrong alignment on FM1FieldUnlockedNoti");
static_assert(sizeof(FM1FieldUnlockedNoti) == 0x000040, "Wrong size on FM1FieldUnlockedNoti");
static_assert(offsetof(FM1FieldUnlockedNoti, AccountUid) == 0x000000, "Member 'FM1FieldUnlockedNoti::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1FieldUnlockedNoti, MapTemplateId) == 0x000008, "Member 'FM1FieldUnlockedNoti::MapTemplateId' has a wrong offset!");
static_assert(offsetof(FM1FieldUnlockedNoti, MapSubData) == 0x00000C, "Member 'FM1FieldUnlockedNoti::MapSubData' has a wrong offset!");
static_assert(offsetof(FM1FieldUnlockedNoti, CampEntryPointId) == 0x000020, "Member 'FM1FieldUnlockedNoti::CampEntryPointId' has a wrong offset!");
static_assert(offsetof(FM1FieldUnlockedNoti, BattleZoneId) == 0x000030, "Member 'FM1FieldUnlockedNoti::BattleZoneId' has a wrong offset!");

// ScriptStruct M1Data.M1QuestParam
// 0x0008 (0x0008 - 0x0000)
struct FM1QuestParam final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Complete;                                          // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1QuestParam) == 0x000004, "Wrong alignment on FM1QuestParam");
static_assert(sizeof(FM1QuestParam) == 0x000008, "Wrong size on FM1QuestParam");
static_assert(offsetof(FM1QuestParam, Count) == 0x000000, "Member 'FM1QuestParam::Count' has a wrong offset!");
static_assert(offsetof(FM1QuestParam, Complete) == 0x000004, "Member 'FM1QuestParam::Complete' has a wrong offset!");

// ScriptStruct M1Data.M1QuestInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1QuestInfo final
{
public:
	struct FM1TemplateId                          QuestId;                                           // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1QuestParam>                  QuestParams;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EM1QuestCompleteState                         CompleteState;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Restartable;                                       // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1QuestInfo) == 0x000008, "Wrong alignment on FM1QuestInfo");
static_assert(sizeof(FM1QuestInfo) == 0x000020, "Wrong size on FM1QuestInfo");
static_assert(offsetof(FM1QuestInfo, QuestId) == 0x000000, "Member 'FM1QuestInfo::QuestId' has a wrong offset!");
static_assert(offsetof(FM1QuestInfo, QuestParams) == 0x000008, "Member 'FM1QuestInfo::QuestParams' has a wrong offset!");
static_assert(offsetof(FM1QuestInfo, CompleteState) == 0x000018, "Member 'FM1QuestInfo::CompleteState' has a wrong offset!");
static_assert(offsetof(FM1QuestInfo, Restartable) == 0x00001C, "Member 'FM1QuestInfo::Restartable' has a wrong offset!");

// ScriptStruct M1Data.M1QuestStartMultiple
// 0x0010 (0x0010 - 0x0000)
struct FM1QuestStartMultiple final
{
public:
	TArray<struct FM1TemplateId>                  StartRequestQuestIds;                              // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1QuestStartMultiple) == 0x000008, "Wrong alignment on FM1QuestStartMultiple");
static_assert(sizeof(FM1QuestStartMultiple) == 0x000010, "Wrong size on FM1QuestStartMultiple");
static_assert(offsetof(FM1QuestStartMultiple, StartRequestQuestIds) == 0x000000, "Member 'FM1QuestStartMultiple::StartRequestQuestIds' has a wrong offset!");

// ScriptStruct M1Data.M1IncQuestProgressReq
// 0x000C (0x000C - 0x0000)
struct FM1IncQuestProgressReq final
{
public:
	struct FM1TemplateId                          QuestTid;                                          // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParamIndex;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IncCount;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1IncQuestProgressReq) == 0x000004, "Wrong alignment on FM1IncQuestProgressReq");
static_assert(sizeof(FM1IncQuestProgressReq) == 0x00000C, "Wrong size on FM1IncQuestProgressReq");
static_assert(offsetof(FM1IncQuestProgressReq, QuestTid) == 0x000000, "Member 'FM1IncQuestProgressReq::QuestTid' has a wrong offset!");
static_assert(offsetof(FM1IncQuestProgressReq, ParamIndex) == 0x000004, "Member 'FM1IncQuestProgressReq::ParamIndex' has a wrong offset!");
static_assert(offsetof(FM1IncQuestProgressReq, IncCount) == 0x000008, "Member 'FM1IncQuestProgressReq::IncCount' has a wrong offset!");

// ScriptStruct M1Data.M1IncQuestProgressReqList
// 0x0010 (0x0010 - 0x0000)
struct FM1IncQuestProgressReqList final
{
public:
	TArray<struct FM1IncQuestProgressReq>         Requests;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1IncQuestProgressReqList) == 0x000008, "Wrong alignment on FM1IncQuestProgressReqList");
static_assert(sizeof(FM1IncQuestProgressReqList) == 0x000010, "Wrong size on FM1IncQuestProgressReqList");
static_assert(offsetof(FM1IncQuestProgressReqList, Requests) == 0x000000, "Member 'FM1IncQuestProgressReqList::Requests' has a wrong offset!");

// ScriptStruct M1Data.M1IncQuestProgressRes
// 0x0010 (0x0010 - 0x0000)
struct FM1IncQuestProgressRes final
{
public:
	EM1IncQuestProgressReason                     Reason;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1QuestParam                          Param;                                             // 0x0004(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          CompleteAll;                                       // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1IncQuestProgressRes) == 0x000004, "Wrong alignment on FM1IncQuestProgressRes");
static_assert(sizeof(FM1IncQuestProgressRes) == 0x000010, "Wrong size on FM1IncQuestProgressRes");
static_assert(offsetof(FM1IncQuestProgressRes, Reason) == 0x000000, "Member 'FM1IncQuestProgressRes::Reason' has a wrong offset!");
static_assert(offsetof(FM1IncQuestProgressRes, Param) == 0x000004, "Member 'FM1IncQuestProgressRes::Param' has a wrong offset!");
static_assert(offsetof(FM1IncQuestProgressRes, CompleteAll) == 0x00000C, "Member 'FM1IncQuestProgressRes::CompleteAll' has a wrong offset!");

// ScriptStruct M1Data.M1IncQuestProgressResList
// 0x0010 (0x0010 - 0x0000)
struct FM1IncQuestProgressResList final
{
public:
	TArray<struct FM1IncQuestProgressRes>         Responses;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1IncQuestProgressResList) == 0x000008, "Wrong alignment on FM1IncQuestProgressResList");
static_assert(sizeof(FM1IncQuestProgressResList) == 0x000010, "Wrong size on FM1IncQuestProgressResList");
static_assert(offsetof(FM1IncQuestProgressResList, Responses) == 0x000000, "Member 'FM1IncQuestProgressResList::Responses' has a wrong offset!");

// ScriptStruct M1Data.M1QuestInfoList
// 0x0028 (0x0028 - 0x0000)
struct FM1QuestInfoList final
{
public:
	TArray<struct FM1TracingQuestInfo>            TracingQuestInfos;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1QuestInfo>                   QuestInfos;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          DailyChallengeId;                                  // 0x0020(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          WeeklyChallengeId;                                 // 0x0024(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1QuestInfoList) == 0x000008, "Wrong alignment on FM1QuestInfoList");
static_assert(sizeof(FM1QuestInfoList) == 0x000028, "Wrong size on FM1QuestInfoList");
static_assert(offsetof(FM1QuestInfoList, TracingQuestInfos) == 0x000000, "Member 'FM1QuestInfoList::TracingQuestInfos' has a wrong offset!");
static_assert(offsetof(FM1QuestInfoList, QuestInfos) == 0x000010, "Member 'FM1QuestInfoList::QuestInfos' has a wrong offset!");
static_assert(offsetof(FM1QuestInfoList, DailyChallengeId) == 0x000020, "Member 'FM1QuestInfoList::DailyChallengeId' has a wrong offset!");
static_assert(offsetof(FM1QuestInfoList, WeeklyChallengeId) == 0x000024, "Member 'FM1QuestInfoList::WeeklyChallengeId' has a wrong offset!");

// ScriptStruct M1Data.M1SetQuestTrackerNoti
// 0x0010 (0x0010 - 0x0000)
struct FM1SetQuestTrackerNoti final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TracingQuestInfo                    QuestInfo;                                         // 0x0008(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SetQuestTrackerNoti) == 0x000008, "Wrong alignment on FM1SetQuestTrackerNoti");
static_assert(sizeof(FM1SetQuestTrackerNoti) == 0x000010, "Wrong size on FM1SetQuestTrackerNoti");
static_assert(offsetof(FM1SetQuestTrackerNoti, AccountUid) == 0x000000, "Member 'FM1SetQuestTrackerNoti::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1SetQuestTrackerNoti, QuestInfo) == 0x000008, "Member 'FM1SetQuestTrackerNoti::QuestInfo' has a wrong offset!");

// ScriptStruct M1Data.M1MainQuestJumpResult
// 0x0010 (0x0010 - 0x0000)
struct FM1MainQuestJumpResult final
{
public:
	TArray<struct FM1TemplateId>                  CompleteQuestIds;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MainQuestJumpResult) == 0x000008, "Wrong alignment on FM1MainQuestJumpResult");
static_assert(sizeof(FM1MainQuestJumpResult) == 0x000010, "Wrong size on FM1MainQuestJumpResult");
static_assert(offsetof(FM1MainQuestJumpResult, CompleteQuestIds) == 0x000000, "Member 'FM1MainQuestJumpResult::CompleteQuestIds' has a wrong offset!");

// ScriptStruct M1Data.M1WeaponProficiencyBoostInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1WeaponProficiencyBoostInfo final
{
public:
	struct FM1TemplateId                          WeaponUid;                                         // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Boost;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Exp;                                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponProficiencyBoostInfo) == 0x000008, "Wrong alignment on FM1WeaponProficiencyBoostInfo");
static_assert(sizeof(FM1WeaponProficiencyBoostInfo) == 0x000010, "Wrong size on FM1WeaponProficiencyBoostInfo");
static_assert(offsetof(FM1WeaponProficiencyBoostInfo, WeaponUid) == 0x000000, "Member 'FM1WeaponProficiencyBoostInfo::WeaponUid' has a wrong offset!");
static_assert(offsetof(FM1WeaponProficiencyBoostInfo, Boost) == 0x000004, "Member 'FM1WeaponProficiencyBoostInfo::Boost' has a wrong offset!");
static_assert(offsetof(FM1WeaponProficiencyBoostInfo, Exp) == 0x000008, "Member 'FM1WeaponProficiencyBoostInfo::Exp' has a wrong offset!");

// ScriptStruct M1Data.M1AddWeaponProficiencyPointRes
// 0x0018 (0x0018 - 0x0000)
struct FM1AddWeaponProficiencyPointRes final
{
public:
	TArray<struct FM1WeaponProficiencyBoostInfo>  WeaponProficiencyBoostList;                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MasteryBoost;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AddWeaponProficiencyPointRes) == 0x000008, "Wrong alignment on FM1AddWeaponProficiencyPointRes");
static_assert(sizeof(FM1AddWeaponProficiencyPointRes) == 0x000018, "Wrong size on FM1AddWeaponProficiencyPointRes");
static_assert(offsetof(FM1AddWeaponProficiencyPointRes, WeaponProficiencyBoostList) == 0x000000, "Member 'FM1AddWeaponProficiencyPointRes::WeaponProficiencyBoostList' has a wrong offset!");
static_assert(offsetof(FM1AddWeaponProficiencyPointRes, MasteryBoost) == 0x000010, "Member 'FM1AddWeaponProficiencyPointRes::MasteryBoost' has a wrong offset!");

// ScriptStruct M1Data.M1WeapnProficiencyPoint
// 0x0010 (0x0010 - 0x0000)
struct FM1WeapnProficiencyPoint final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          WeaponTemplateId;                                  // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MonsterTemplateId;                                 // 0x000C(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeapnProficiencyPoint) == 0x000008, "Wrong alignment on FM1WeapnProficiencyPoint");
static_assert(sizeof(FM1WeapnProficiencyPoint) == 0x000010, "Wrong size on FM1WeapnProficiencyPoint");
static_assert(offsetof(FM1WeapnProficiencyPoint, AccountUid) == 0x000000, "Member 'FM1WeapnProficiencyPoint::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1WeapnProficiencyPoint, WeaponTemplateId) == 0x000008, "Member 'FM1WeapnProficiencyPoint::WeaponTemplateId' has a wrong offset!");
static_assert(offsetof(FM1WeapnProficiencyPoint, MonsterTemplateId) == 0x00000C, "Member 'FM1WeapnProficiencyPoint::MonsterTemplateId' has a wrong offset!");

// ScriptStruct M1Data.M1CheatMasteryExpUp
// 0x0008 (0x0008 - 0x0000)
struct FM1CheatMasteryExpUp final
{
public:
	int64                                         Exp;                                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CheatMasteryExpUp) == 0x000008, "Wrong alignment on FM1CheatMasteryExpUp");
static_assert(sizeof(FM1CheatMasteryExpUp) == 0x000008, "Wrong size on FM1CheatMasteryExpUp");
static_assert(offsetof(FM1CheatMasteryExpUp, Exp) == 0x000000, "Member 'FM1CheatMasteryExpUp::Exp' has a wrong offset!");

// ScriptStruct M1Data.M1RuneComposeResult
// 0x0008 (0x0008 - 0x0000)
struct FM1RuneComposeResult final
{
public:
	EM1RuneReason                                 Result;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          RewardTemplateId;                                  // 0x0004(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RuneComposeResult) == 0x000004, "Wrong alignment on FM1RuneComposeResult");
static_assert(sizeof(FM1RuneComposeResult) == 0x000008, "Wrong size on FM1RuneComposeResult");
static_assert(offsetof(FM1RuneComposeResult, Result) == 0x000000, "Member 'FM1RuneComposeResult::Result' has a wrong offset!");
static_assert(offsetof(FM1RuneComposeResult, RewardTemplateId) == 0x000004, "Member 'FM1RuneComposeResult::RewardTemplateId' has a wrong offset!");

// ScriptStruct M1Data.M1VoidBattleEntranceInfoByAccount
// 0x0018 (0x0018 - 0x0000)
struct FM1VoidBattleEntranceInfoByAccount final
{
public:
	int64                                         AccId;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1VoidBattleEntranceInfo>      EntranceInfos;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1VoidBattleEntranceInfoByAccount) == 0x000008, "Wrong alignment on FM1VoidBattleEntranceInfoByAccount");
static_assert(sizeof(FM1VoidBattleEntranceInfoByAccount) == 0x000018, "Wrong size on FM1VoidBattleEntranceInfoByAccount");
static_assert(offsetof(FM1VoidBattleEntranceInfoByAccount, AccId) == 0x000000, "Member 'FM1VoidBattleEntranceInfoByAccount::AccId' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleEntranceInfoByAccount, EntranceInfos) == 0x000008, "Member 'FM1VoidBattleEntranceInfoByAccount::EntranceInfos' has a wrong offset!");

// ScriptStruct M1Data.M1VoidBattleEntranceInfoList
// 0x0028 (0x0028 - 0x0000)
struct FM1VoidBattleEntranceInfoList final
{
public:
	TArray<struct FM1VoidBattleEntranceInfoByAccount> EntranceInfos;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1VoidBattleStartConditionByTid> StartConditions;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          NoTimeCheck;                                       // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1VoidBattleEntranceInfoList) == 0x000008, "Wrong alignment on FM1VoidBattleEntranceInfoList");
static_assert(sizeof(FM1VoidBattleEntranceInfoList) == 0x000028, "Wrong size on FM1VoidBattleEntranceInfoList");
static_assert(offsetof(FM1VoidBattleEntranceInfoList, EntranceInfos) == 0x000000, "Member 'FM1VoidBattleEntranceInfoList::EntranceInfos' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleEntranceInfoList, StartConditions) == 0x000010, "Member 'FM1VoidBattleEntranceInfoList::StartConditions' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleEntranceInfoList, NoTimeCheck) == 0x000020, "Member 'FM1VoidBattleEntranceInfoList::NoTimeCheck' has a wrong offset!");

// ScriptStruct M1Data.M1InvasionEntranceInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1InvasionEntranceInfo final
{
public:
	int32                                         TotalRewardExp;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          InvasionDungeon;                                   // 0x0004(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1TemplateId>                  AbilityDataList;                                   // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InvasionEntranceInfo) == 0x000008, "Wrong alignment on FM1InvasionEntranceInfo");
static_assert(sizeof(FM1InvasionEntranceInfo) == 0x000018, "Wrong size on FM1InvasionEntranceInfo");
static_assert(offsetof(FM1InvasionEntranceInfo, TotalRewardExp) == 0x000000, "Member 'FM1InvasionEntranceInfo::TotalRewardExp' has a wrong offset!");
static_assert(offsetof(FM1InvasionEntranceInfo, InvasionDungeon) == 0x000004, "Member 'FM1InvasionEntranceInfo::InvasionDungeon' has a wrong offset!");
static_assert(offsetof(FM1InvasionEntranceInfo, AbilityDataList) == 0x000008, "Member 'FM1InvasionEntranceInfo::AbilityDataList' has a wrong offset!");

// ScriptStruct M1Data.M1InvasionEntranceInfoList
// 0x0020 (0x0020 - 0x0000)
struct FM1InvasionEntranceInfoList final
{
public:
	bool                                          NoEntrant;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ScheduleIdx;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RemainTimeSec;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1InvasionEntranceInfo>        EntranceInfos;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InvasionEntranceInfoList) == 0x000008, "Wrong alignment on FM1InvasionEntranceInfoList");
static_assert(sizeof(FM1InvasionEntranceInfoList) == 0x000020, "Wrong size on FM1InvasionEntranceInfoList");
static_assert(offsetof(FM1InvasionEntranceInfoList, NoEntrant) == 0x000000, "Member 'FM1InvasionEntranceInfoList::NoEntrant' has a wrong offset!");
static_assert(offsetof(FM1InvasionEntranceInfoList, ScheduleIdx) == 0x000004, "Member 'FM1InvasionEntranceInfoList::ScheduleIdx' has a wrong offset!");
static_assert(offsetof(FM1InvasionEntranceInfoList, RemainTimeSec) == 0x000008, "Member 'FM1InvasionEntranceInfoList::RemainTimeSec' has a wrong offset!");
static_assert(offsetof(FM1InvasionEntranceInfoList, EntranceInfos) == 0x000010, "Member 'FM1InvasionEntranceInfoList::EntranceInfos' has a wrong offset!");

// ScriptStruct M1Data.M1RequestMatchingResult
// 0x000C (0x000C - 0x0000)
struct FM1RequestMatchingResult final
{
public:
	EM1MatchingReason                             Reason;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPrivateMatching;                                 // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EstimatedTimeSec;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RequestMatchingResult) == 0x000004, "Wrong alignment on FM1RequestMatchingResult");
static_assert(sizeof(FM1RequestMatchingResult) == 0x00000C, "Wrong size on FM1RequestMatchingResult");
static_assert(offsetof(FM1RequestMatchingResult, Reason) == 0x000000, "Member 'FM1RequestMatchingResult::Reason' has a wrong offset!");
static_assert(offsetof(FM1RequestMatchingResult, IsPrivateMatching) == 0x000004, "Member 'FM1RequestMatchingResult::IsPrivateMatching' has a wrong offset!");
static_assert(offsetof(FM1RequestMatchingResult, EstimatedTimeSec) == 0x000008, "Member 'FM1RequestMatchingResult::EstimatedTimeSec' has a wrong offset!");

// ScriptStruct M1Data.M1MatchingStartPlayerAttribute
// 0x0048 (0x0048 - 0x0000)
struct FM1MatchingStartPlayerAttribute final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxClearRound;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ControllerType;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CountryName;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerWeaponAtk;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerSkillAtk;                                    // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerDefense;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerMaxShield;                                   // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerMaxHp;                                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerMaxMentality;                                // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MatchingStartPlayerAttribute) == 0x000008, "Wrong alignment on FM1MatchingStartPlayerAttribute");
static_assert(sizeof(FM1MatchingStartPlayerAttribute) == 0x000048, "Wrong size on FM1MatchingStartPlayerAttribute");
static_assert(offsetof(FM1MatchingStartPlayerAttribute, AccountUid) == 0x000000, "Member 'FM1MatchingStartPlayerAttribute::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1MatchingStartPlayerAttribute, MaxClearRound) == 0x000008, "Member 'FM1MatchingStartPlayerAttribute::MaxClearRound' has a wrong offset!");
static_assert(offsetof(FM1MatchingStartPlayerAttribute, ControllerType) == 0x000010, "Member 'FM1MatchingStartPlayerAttribute::ControllerType' has a wrong offset!");
static_assert(offsetof(FM1MatchingStartPlayerAttribute, CountryName) == 0x000020, "Member 'FM1MatchingStartPlayerAttribute::CountryName' has a wrong offset!");
static_assert(offsetof(FM1MatchingStartPlayerAttribute, PlayerWeaponAtk) == 0x000030, "Member 'FM1MatchingStartPlayerAttribute::PlayerWeaponAtk' has a wrong offset!");
static_assert(offsetof(FM1MatchingStartPlayerAttribute, PlayerSkillAtk) == 0x000034, "Member 'FM1MatchingStartPlayerAttribute::PlayerSkillAtk' has a wrong offset!");
static_assert(offsetof(FM1MatchingStartPlayerAttribute, PlayerDefense) == 0x000038, "Member 'FM1MatchingStartPlayerAttribute::PlayerDefense' has a wrong offset!");
static_assert(offsetof(FM1MatchingStartPlayerAttribute, PlayerMaxShield) == 0x00003C, "Member 'FM1MatchingStartPlayerAttribute::PlayerMaxShield' has a wrong offset!");
static_assert(offsetof(FM1MatchingStartPlayerAttribute, PlayerMaxHp) == 0x000040, "Member 'FM1MatchingStartPlayerAttribute::PlayerMaxHp' has a wrong offset!");
static_assert(offsetof(FM1MatchingStartPlayerAttribute, PlayerMaxMentality) == 0x000044, "Member 'FM1MatchingStartPlayerAttribute::PlayerMaxMentality' has a wrong offset!");

// ScriptStruct M1Data.M1MatchingStartAttribute
// 0x0040 (0x0040 - 0x0000)
struct FM1MatchingStartAttribute final
{
public:
	TArray<struct FM1MapModifier>                 Modifiers;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          InstanceDungeonRewardTid;                          // 0x0010(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          SelectionMODGroupTid;                              // 0x0014(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          InstancedDungeonPresetTid;                         // 0x0018(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1MatchingStartPlayerAttribute> PlayerAttributes;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1InstanceDungeonStartAttribute> InstanceDungeonAttributes;                         // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MatchingStartAttribute) == 0x000008, "Wrong alignment on FM1MatchingStartAttribute");
static_assert(sizeof(FM1MatchingStartAttribute) == 0x000040, "Wrong size on FM1MatchingStartAttribute");
static_assert(offsetof(FM1MatchingStartAttribute, Modifiers) == 0x000000, "Member 'FM1MatchingStartAttribute::Modifiers' has a wrong offset!");
static_assert(offsetof(FM1MatchingStartAttribute, InstanceDungeonRewardTid) == 0x000010, "Member 'FM1MatchingStartAttribute::InstanceDungeonRewardTid' has a wrong offset!");
static_assert(offsetof(FM1MatchingStartAttribute, SelectionMODGroupTid) == 0x000014, "Member 'FM1MatchingStartAttribute::SelectionMODGroupTid' has a wrong offset!");
static_assert(offsetof(FM1MatchingStartAttribute, InstancedDungeonPresetTid) == 0x000018, "Member 'FM1MatchingStartAttribute::InstancedDungeonPresetTid' has a wrong offset!");
static_assert(offsetof(FM1MatchingStartAttribute, PlayerAttributes) == 0x000020, "Member 'FM1MatchingStartAttribute::PlayerAttributes' has a wrong offset!");
static_assert(offsetof(FM1MatchingStartAttribute, InstanceDungeonAttributes) == 0x000030, "Member 'FM1MatchingStartAttribute::InstanceDungeonAttributes' has a wrong offset!");

// ScriptStruct M1Data.M1MatchingGameEndPlayerAttribute
// 0x0020 (0x0020 - 0x0000)
struct FM1MatchingGameEndPlayerAttribute final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecordRevive;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecordDeath;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecordDamagegive;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecordElapsedtime;                                 // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecordFinalClearRound;                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MatchingGameEndPlayerAttribute) == 0x000008, "Wrong alignment on FM1MatchingGameEndPlayerAttribute");
static_assert(sizeof(FM1MatchingGameEndPlayerAttribute) == 0x000020, "Wrong size on FM1MatchingGameEndPlayerAttribute");
static_assert(offsetof(FM1MatchingGameEndPlayerAttribute, AccountUid) == 0x000000, "Member 'FM1MatchingGameEndPlayerAttribute::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1MatchingGameEndPlayerAttribute, RecordRevive) == 0x000008, "Member 'FM1MatchingGameEndPlayerAttribute::RecordRevive' has a wrong offset!");
static_assert(offsetof(FM1MatchingGameEndPlayerAttribute, RecordDeath) == 0x00000C, "Member 'FM1MatchingGameEndPlayerAttribute::RecordDeath' has a wrong offset!");
static_assert(offsetof(FM1MatchingGameEndPlayerAttribute, RecordDamagegive) == 0x000010, "Member 'FM1MatchingGameEndPlayerAttribute::RecordDamagegive' has a wrong offset!");
static_assert(offsetof(FM1MatchingGameEndPlayerAttribute, RecordElapsedtime) == 0x000014, "Member 'FM1MatchingGameEndPlayerAttribute::RecordElapsedtime' has a wrong offset!");
static_assert(offsetof(FM1MatchingGameEndPlayerAttribute, RecordFinalClearRound) == 0x000018, "Member 'FM1MatchingGameEndPlayerAttribute::RecordFinalClearRound' has a wrong offset!");

// ScriptStruct M1Data.M1MatchingGameEndAttribute
// 0x0028 (0x0028 - 0x0000)
struct FM1MatchingGameEndAttribute final
{
public:
	int32                                         MatchRecordDeath;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchRecordDamagegive;                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchElapsedtime;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchFinalRound;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchVoidBattleID;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchWorldMissionID;                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1MatchingGameEndPlayerAttribute> PlayerAttributes;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MatchingGameEndAttribute) == 0x000008, "Wrong alignment on FM1MatchingGameEndAttribute");
static_assert(sizeof(FM1MatchingGameEndAttribute) == 0x000028, "Wrong size on FM1MatchingGameEndAttribute");
static_assert(offsetof(FM1MatchingGameEndAttribute, MatchRecordDeath) == 0x000000, "Member 'FM1MatchingGameEndAttribute::MatchRecordDeath' has a wrong offset!");
static_assert(offsetof(FM1MatchingGameEndAttribute, MatchRecordDamagegive) == 0x000004, "Member 'FM1MatchingGameEndAttribute::MatchRecordDamagegive' has a wrong offset!");
static_assert(offsetof(FM1MatchingGameEndAttribute, MatchElapsedtime) == 0x000008, "Member 'FM1MatchingGameEndAttribute::MatchElapsedtime' has a wrong offset!");
static_assert(offsetof(FM1MatchingGameEndAttribute, MatchFinalRound) == 0x00000C, "Member 'FM1MatchingGameEndAttribute::MatchFinalRound' has a wrong offset!");
static_assert(offsetof(FM1MatchingGameEndAttribute, MatchVoidBattleID) == 0x000010, "Member 'FM1MatchingGameEndAttribute::MatchVoidBattleID' has a wrong offset!");
static_assert(offsetof(FM1MatchingGameEndAttribute, MatchWorldMissionID) == 0x000014, "Member 'FM1MatchingGameEndAttribute::MatchWorldMissionID' has a wrong offset!");
static_assert(offsetof(FM1MatchingGameEndAttribute, PlayerAttributes) == 0x000018, "Member 'FM1MatchingGameEndAttribute::PlayerAttributes' has a wrong offset!");

// ScriptStruct M1Data.M1InstanceDungeonSelectMODRerollRequest
// 0x0004 (0x0004 - 0x0000)
struct FM1InstanceDungeonSelectMODRerollRequest final
{
public:
	struct FM1TemplateId                          Tid;                                               // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceDungeonSelectMODRerollRequest) == 0x000004, "Wrong alignment on FM1InstanceDungeonSelectMODRerollRequest");
static_assert(sizeof(FM1InstanceDungeonSelectMODRerollRequest) == 0x000004, "Wrong size on FM1InstanceDungeonSelectMODRerollRequest");
static_assert(offsetof(FM1InstanceDungeonSelectMODRerollRequest, Tid) == 0x000000, "Member 'FM1InstanceDungeonSelectMODRerollRequest::Tid' has a wrong offset!");

// ScriptStruct M1Data.M1InstanceDungeonCompleteResult
// 0x0004 (0x0004 - 0x0000)
struct FM1InstanceDungeonCompleteResult final
{
public:
	EM1InstanceDungeonCompleteReason              Reason;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceDungeonCompleteResult) == 0x000004, "Wrong alignment on FM1InstanceDungeonCompleteResult");
static_assert(sizeof(FM1InstanceDungeonCompleteResult) == 0x000004, "Wrong size on FM1InstanceDungeonCompleteResult");
static_assert(offsetof(FM1InstanceDungeonCompleteResult, Reason) == 0x000000, "Member 'FM1InstanceDungeonCompleteResult::Reason' has a wrong offset!");

// ScriptStruct M1Data.M1InstanceDungeonCompleteRequest
// 0x000C (0x000C - 0x0000)
struct FM1InstanceDungeonCompleteRequest final
{
public:
	struct FM1TemplateId                          Tid;                                               // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          FixedModifier;                                     // 0x0004(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Score;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceDungeonCompleteRequest) == 0x000004, "Wrong alignment on FM1InstanceDungeonCompleteRequest");
static_assert(sizeof(FM1InstanceDungeonCompleteRequest) == 0x00000C, "Wrong size on FM1InstanceDungeonCompleteRequest");
static_assert(offsetof(FM1InstanceDungeonCompleteRequest, Tid) == 0x000000, "Member 'FM1InstanceDungeonCompleteRequest::Tid' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonCompleteRequest, FixedModifier) == 0x000004, "Member 'FM1InstanceDungeonCompleteRequest::FixedModifier' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonCompleteRequest, Score) == 0x000008, "Member 'FM1InstanceDungeonCompleteRequest::Score' has a wrong offset!");

// ScriptStruct M1Data.M1InvasionDungeonCompleteRequest
// 0x0008 (0x0008 - 0x0000)
struct FM1InvasionDungeonCompleteRequest final
{
public:
	struct FM1TemplateId                          Tid;                                               // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClearTimeSec;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InvasionDungeonCompleteRequest) == 0x000004, "Wrong alignment on FM1InvasionDungeonCompleteRequest");
static_assert(sizeof(FM1InvasionDungeonCompleteRequest) == 0x000008, "Wrong size on FM1InvasionDungeonCompleteRequest");
static_assert(offsetof(FM1InvasionDungeonCompleteRequest, Tid) == 0x000000, "Member 'FM1InvasionDungeonCompleteRequest::Tid' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonCompleteRequest, ClearTimeSec) == 0x000004, "Member 'FM1InvasionDungeonCompleteRequest::ClearTimeSec' has a wrong offset!");

// ScriptStruct M1Data.M1VoidBattleCompleteResult
// 0x0008 (0x0008 - 0x0000)
struct FM1VoidBattleCompleteResult final
{
public:
	struct FM1VoidBattleRewards                   Rewards;                                           // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1VoidBattleCompleteResult) == 0x000004, "Wrong alignment on FM1VoidBattleCompleteResult");
static_assert(sizeof(FM1VoidBattleCompleteResult) == 0x000008, "Wrong size on FM1VoidBattleCompleteResult");
static_assert(offsetof(FM1VoidBattleCompleteResult, Rewards) == 0x000000, "Member 'FM1VoidBattleCompleteResult::Rewards' has a wrong offset!");

// ScriptStruct M1Data.M1MatchingAuidList
// 0x0010 (0x0010 - 0x0000)
struct FM1MatchingAuidList final
{
public:
	TArray<int64>                                 Auids;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MatchingAuidList) == 0x000008, "Wrong alignment on FM1MatchingAuidList");
static_assert(sizeof(FM1MatchingAuidList) == 0x000010, "Wrong size on FM1MatchingAuidList");
static_assert(offsetof(FM1MatchingAuidList, Auids) == 0x000000, "Member 'FM1MatchingAuidList::Auids' has a wrong offset!");

// ScriptStruct M1Data.M1MailMultiRequestInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1MailMultiRequestInfo final
{
public:
	TArray<int64>                                 MailIdList;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MailMultiRequestInfo) == 0x000008, "Wrong alignment on FM1MailMultiRequestInfo");
static_assert(sizeof(FM1MailMultiRequestInfo) == 0x000010, "Wrong size on FM1MailMultiRequestInfo");
static_assert(offsetof(FM1MailMultiRequestInfo, MailIdList) == 0x000000, "Member 'FM1MailMultiRequestInfo::MailIdList' has a wrong offset!");

// ScriptStruct M1Data.M1MailDeleteAllInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1MailDeleteAllInfo final
{
public:
	EM1MailReason                                 Reason;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 RemainMailList;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MailDeleteAllInfo) == 0x000008, "Wrong alignment on FM1MailDeleteAllInfo");
static_assert(sizeof(FM1MailDeleteAllInfo) == 0x000018, "Wrong size on FM1MailDeleteAllInfo");
static_assert(offsetof(FM1MailDeleteAllInfo, Reason) == 0x000000, "Member 'FM1MailDeleteAllInfo::Reason' has a wrong offset!");
static_assert(offsetof(FM1MailDeleteAllInfo, RemainMailList) == 0x000008, "Member 'FM1MailDeleteAllInfo::RemainMailList' has a wrong offset!");

// ScriptStruct M1Data.M1MailDeletePushInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1MailDeletePushInfo final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int64>                                 DeleteMailList;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MailDeletePushInfo) == 0x000008, "Wrong alignment on FM1MailDeletePushInfo");
static_assert(sizeof(FM1MailDeletePushInfo) == 0x000018, "Wrong size on FM1MailDeletePushInfo");
static_assert(offsetof(FM1MailDeletePushInfo, AccountUid) == 0x000000, "Member 'FM1MailDeletePushInfo::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1MailDeletePushInfo, DeleteMailList) == 0x000008, "Member 'FM1MailDeletePushInfo::DeleteMailList' has a wrong offset!");

// ScriptStruct M1Data.M1RequestCustomizingCharacter
// 0x0008 (0x0008 - 0x0000)
struct FM1RequestCustomizingCharacter final
{
public:
	struct FM1TemplateId                          PlayerTid;                                         // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          CustomizeTid;                                      // 0x0004(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RequestCustomizingCharacter) == 0x000004, "Wrong alignment on FM1RequestCustomizingCharacter");
static_assert(sizeof(FM1RequestCustomizingCharacter) == 0x000008, "Wrong size on FM1RequestCustomizingCharacter");
static_assert(offsetof(FM1RequestCustomizingCharacter, PlayerTid) == 0x000000, "Member 'FM1RequestCustomizingCharacter::PlayerTid' has a wrong offset!");
static_assert(offsetof(FM1RequestCustomizingCharacter, CustomizeTid) == 0x000004, "Member 'FM1RequestCustomizingCharacter::CustomizeTid' has a wrong offset!");

// ScriptStruct M1Data.M1RequestCustomizingWeapon
// 0x0008 (0x0008 - 0x0000)
struct FM1RequestCustomizingWeapon final
{
public:
	struct FM1TemplateId                          WeaponTid;                                         // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          CustomizeTid;                                      // 0x0004(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RequestCustomizingWeapon) == 0x000004, "Wrong alignment on FM1RequestCustomizingWeapon");
static_assert(sizeof(FM1RequestCustomizingWeapon) == 0x000008, "Wrong size on FM1RequestCustomizingWeapon");
static_assert(offsetof(FM1RequestCustomizingWeapon, WeaponTid) == 0x000000, "Member 'FM1RequestCustomizingWeapon::WeaponTid' has a wrong offset!");
static_assert(offsetof(FM1RequestCustomizingWeapon, CustomizeTid) == 0x000004, "Member 'FM1RequestCustomizingWeapon::CustomizeTid' has a wrong offset!");

// ScriptStruct M1Data.M1RequestCustomizingSkinPaint
// 0x000C (0x000C - 0x0000)
struct FM1RequestCustomizingSkinPaint final
{
public:
	struct FM1TemplateId                          SkinTid;                                           // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          CustomizeTid;                                      // 0x0004(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Slot;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RequestCustomizingSkinPaint) == 0x000004, "Wrong alignment on FM1RequestCustomizingSkinPaint");
static_assert(sizeof(FM1RequestCustomizingSkinPaint) == 0x00000C, "Wrong size on FM1RequestCustomizingSkinPaint");
static_assert(offsetof(FM1RequestCustomizingSkinPaint, SkinTid) == 0x000000, "Member 'FM1RequestCustomizingSkinPaint::SkinTid' has a wrong offset!");
static_assert(offsetof(FM1RequestCustomizingSkinPaint, CustomizeTid) == 0x000004, "Member 'FM1RequestCustomizingSkinPaint::CustomizeTid' has a wrong offset!");
static_assert(offsetof(FM1RequestCustomizingSkinPaint, Slot) == 0x000008, "Member 'FM1RequestCustomizingSkinPaint::Slot' has a wrong offset!");

// ScriptStruct M1Data.M1RequestCustomizingSkinPaints
// 0x0018 (0x0018 - 0x0000)
struct FM1RequestCustomizingSkinPaints final
{
public:
	struct FM1TemplateId                          SkinTid;                                           // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1PaintData>                   Paints;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RequestCustomizingSkinPaints) == 0x000008, "Wrong alignment on FM1RequestCustomizingSkinPaints");
static_assert(sizeof(FM1RequestCustomizingSkinPaints) == 0x000018, "Wrong size on FM1RequestCustomizingSkinPaints");
static_assert(offsetof(FM1RequestCustomizingSkinPaints, SkinTid) == 0x000000, "Member 'FM1RequestCustomizingSkinPaints::SkinTid' has a wrong offset!");
static_assert(offsetof(FM1RequestCustomizingSkinPaints, Paints) == 0x000008, "Member 'FM1RequestCustomizingSkinPaints::Paints' has a wrong offset!");

// ScriptStruct M1Data.M1UpdateCustomizingSkinPaints
// 0x0018 (0x0018 - 0x0000)
struct FM1UpdateCustomizingSkinPaints final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1CustomizePaintInventory>     Inventory;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1UpdateCustomizingSkinPaints) == 0x000008, "Wrong alignment on FM1UpdateCustomizingSkinPaints");
static_assert(sizeof(FM1UpdateCustomizingSkinPaints) == 0x000018, "Wrong size on FM1UpdateCustomizingSkinPaints");
static_assert(offsetof(FM1UpdateCustomizingSkinPaints, AccountUid) == 0x000000, "Member 'FM1UpdateCustomizingSkinPaints::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1UpdateCustomizingSkinPaints, Inventory) == 0x000008, "Member 'FM1UpdateCustomizingSkinPaints::Inventory' has a wrong offset!");

// ScriptStruct M1Data.M1RequestCustomizingRingSlot
// 0x0008 (0x0008 - 0x0000)
struct FM1RequestCustomizingRingSlot final
{
public:
	struct FM1TemplateId                          CustomizeTid;                                      // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Slot;                                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RequestCustomizingRingSlot) == 0x000004, "Wrong alignment on FM1RequestCustomizingRingSlot");
static_assert(sizeof(FM1RequestCustomizingRingSlot) == 0x000008, "Wrong size on FM1RequestCustomizingRingSlot");
static_assert(offsetof(FM1RequestCustomizingRingSlot, CustomizeTid) == 0x000000, "Member 'FM1RequestCustomizingRingSlot::CustomizeTid' has a wrong offset!");
static_assert(offsetof(FM1RequestCustomizingRingSlot, Slot) == 0x000004, "Member 'FM1RequestCustomizingRingSlot::Slot' has a wrong offset!");

// ScriptStruct M1Data.M1RequestCustomizingEtc
// 0x0008 (0x0008 - 0x0000)
struct FM1RequestCustomizingEtc final
{
public:
	EM1CustomizingItemCategoryType                CustomizeType;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1TemplateId                          CustomizeTid;                                      // 0x0004(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RequestCustomizingEtc) == 0x000004, "Wrong alignment on FM1RequestCustomizingEtc");
static_assert(sizeof(FM1RequestCustomizingEtc) == 0x000008, "Wrong size on FM1RequestCustomizingEtc");
static_assert(offsetof(FM1RequestCustomizingEtc, CustomizeType) == 0x000000, "Member 'FM1RequestCustomizingEtc::CustomizeType' has a wrong offset!");
static_assert(offsetof(FM1RequestCustomizingEtc, CustomizeTid) == 0x000004, "Member 'FM1RequestCustomizingEtc::CustomizeTid' has a wrong offset!");

// ScriptStruct M1Data.M1RequestCustomizingEvolution
// 0x0008 (0x0008 - 0x0000)
struct FM1RequestCustomizingEvolution final
{
public:
	struct FM1TemplateId                          SkinTid;                                           // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EvolutionIndex;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RequestCustomizingEvolution) == 0x000004, "Wrong alignment on FM1RequestCustomizingEvolution");
static_assert(sizeof(FM1RequestCustomizingEvolution) == 0x000008, "Wrong size on FM1RequestCustomizingEvolution");
static_assert(offsetof(FM1RequestCustomizingEvolution, SkinTid) == 0x000000, "Member 'FM1RequestCustomizingEvolution::SkinTid' has a wrong offset!");
static_assert(offsetof(FM1RequestCustomizingEvolution, EvolutionIndex) == 0x000004, "Member 'FM1RequestCustomizingEvolution::EvolutionIndex' has a wrong offset!");

// ScriptStruct M1Data.M1ResponseBoundedCharacter
// 0x0020 (0x0020 - 0x0000)
struct FM1ResponseBoundedCharacter final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          PlayerTid;                                         // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1TemplateId>                  BindTids;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ResponseBoundedCharacter) == 0x000008, "Wrong alignment on FM1ResponseBoundedCharacter");
static_assert(sizeof(FM1ResponseBoundedCharacter) == 0x000020, "Wrong size on FM1ResponseBoundedCharacter");
static_assert(offsetof(FM1ResponseBoundedCharacter, AccountUid) == 0x000000, "Member 'FM1ResponseBoundedCharacter::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1ResponseBoundedCharacter, PlayerTid) == 0x000008, "Member 'FM1ResponseBoundedCharacter::PlayerTid' has a wrong offset!");
static_assert(offsetof(FM1ResponseBoundedCharacter, BindTids) == 0x000010, "Member 'FM1ResponseBoundedCharacter::BindTids' has a wrong offset!");

// ScriptStruct M1Data.M1ResponseBoundedWeapon
// 0x0020 (0x0020 - 0x0000)
struct FM1ResponseBoundedWeapon final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          WeaponTid;                                         // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1TemplateId>                  BindTids;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ResponseBoundedWeapon) == 0x000008, "Wrong alignment on FM1ResponseBoundedWeapon");
static_assert(sizeof(FM1ResponseBoundedWeapon) == 0x000020, "Wrong size on FM1ResponseBoundedWeapon");
static_assert(offsetof(FM1ResponseBoundedWeapon, AccountUid) == 0x000000, "Member 'FM1ResponseBoundedWeapon::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1ResponseBoundedWeapon, WeaponTid) == 0x000008, "Member 'FM1ResponseBoundedWeapon::WeaponTid' has a wrong offset!");
static_assert(offsetof(FM1ResponseBoundedWeapon, BindTids) == 0x000010, "Member 'FM1ResponseBoundedWeapon::BindTids' has a wrong offset!");

// ScriptStruct M1Data.M1ResponseBoundedSkin
// 0x0020 (0x0020 - 0x0000)
struct FM1ResponseBoundedSkin final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          SkinTid;                                           // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1TemplateId>                  BindTids;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ResponseBoundedSkin) == 0x000008, "Wrong alignment on FM1ResponseBoundedSkin");
static_assert(sizeof(FM1ResponseBoundedSkin) == 0x000020, "Wrong size on FM1ResponseBoundedSkin");
static_assert(offsetof(FM1ResponseBoundedSkin, AccountUid) == 0x000000, "Member 'FM1ResponseBoundedSkin::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1ResponseBoundedSkin, SkinTid) == 0x000008, "Member 'FM1ResponseBoundedSkin::SkinTid' has a wrong offset!");
static_assert(offsetof(FM1ResponseBoundedSkin, BindTids) == 0x000010, "Member 'FM1ResponseBoundedSkin::BindTids' has a wrong offset!");

// ScriptStruct M1Data.M1EquipEncyclopediaUpdateNoti
// 0x0004 (0x0004 - 0x0000)
struct FM1EquipEncyclopediaUpdateNoti final
{
public:
	struct FM1TemplateId                          EquipTemplateId;                                   // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EquipEncyclopediaUpdateNoti) == 0x000004, "Wrong alignment on FM1EquipEncyclopediaUpdateNoti");
static_assert(sizeof(FM1EquipEncyclopediaUpdateNoti) == 0x000004, "Wrong size on FM1EquipEncyclopediaUpdateNoti");
static_assert(offsetof(FM1EquipEncyclopediaUpdateNoti, EquipTemplateId) == 0x000000, "Member 'FM1EquipEncyclopediaUpdateNoti::EquipTemplateId' has a wrong offset!");

// ScriptStruct M1Data.M1FilterOption
// 0x0003 (0x0003 - 0x0000)
struct FM1FilterOption final
{
public:
	EM1ItemTierType                               ItemTierType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RoundsType                                 RoundsType;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1EquipItemClassType                         ClassType;                                         // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FilterOption) == 0x000001, "Wrong alignment on FM1FilterOption");
static_assert(sizeof(FM1FilterOption) == 0x000003, "Wrong size on FM1FilterOption");
static_assert(offsetof(FM1FilterOption, ItemTierType) == 0x000000, "Member 'FM1FilterOption::ItemTierType' has a wrong offset!");
static_assert(offsetof(FM1FilterOption, RoundsType) == 0x000001, "Member 'FM1FilterOption::RoundsType' has a wrong offset!");
static_assert(offsetof(FM1FilterOption, ClassType) == 0x000002, "Member 'FM1FilterOption::ClassType' has a wrong offset!");

// ScriptStruct M1Data.M1EquipmentCategoryTypes
// 0x0010 (0x0010 - 0x0000)
struct FM1EquipmentCategoryTypes final
{
public:
	TArray<EM1EquipmentCategoryType>              DataList;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EquipmentCategoryTypes) == 0x000008, "Wrong alignment on FM1EquipmentCategoryTypes");
static_assert(sizeof(FM1EquipmentCategoryTypes) == 0x000010, "Wrong size on FM1EquipmentCategoryTypes");
static_assert(offsetof(FM1EquipmentCategoryTypes, DataList) == 0x000000, "Member 'FM1EquipmentCategoryTypes::DataList' has a wrong offset!");

// ScriptStruct M1Data.M1BattlePassLevelNoti
// 0x0020 (0x0020 - 0x0000)
struct FM1BattlePassLevelNoti final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          BattlePassTid;                                     // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattlePassLevel;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         BattlePassExp;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1BattlePassLevelReason                      Reason;                                            // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1BattlePassLevelNoti) == 0x000008, "Wrong alignment on FM1BattlePassLevelNoti");
static_assert(sizeof(FM1BattlePassLevelNoti) == 0x000020, "Wrong size on FM1BattlePassLevelNoti");
static_assert(offsetof(FM1BattlePassLevelNoti, AccountUid) == 0x000000, "Member 'FM1BattlePassLevelNoti::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1BattlePassLevelNoti, BattlePassTid) == 0x000008, "Member 'FM1BattlePassLevelNoti::BattlePassTid' has a wrong offset!");
static_assert(offsetof(FM1BattlePassLevelNoti, BattlePassLevel) == 0x00000C, "Member 'FM1BattlePassLevelNoti::BattlePassLevel' has a wrong offset!");
static_assert(offsetof(FM1BattlePassLevelNoti, BattlePassExp) == 0x000010, "Member 'FM1BattlePassLevelNoti::BattlePassExp' has a wrong offset!");
static_assert(offsetof(FM1BattlePassLevelNoti, Reason) == 0x000018, "Member 'FM1BattlePassLevelNoti::Reason' has a wrong offset!");

// ScriptStruct M1Data.M1KilledMonsterInfo
// 0x0014 (0x0014 - 0x0000)
struct FM1KilledMonsterInfo final
{
public:
	EM1EquipmentSlotType                          ProficiencySlotType;                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1TemplateId                          MonsterTid;                                        // 0x0004(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1EventBoostContentType                      ContentType;                                       // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ContentTemplateId;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1KilledMonsterInfo) == 0x000004, "Wrong alignment on FM1KilledMonsterInfo");
static_assert(sizeof(FM1KilledMonsterInfo) == 0x000014, "Wrong size on FM1KilledMonsterInfo");
static_assert(offsetof(FM1KilledMonsterInfo, ProficiencySlotType) == 0x000000, "Member 'FM1KilledMonsterInfo::ProficiencySlotType' has a wrong offset!");
static_assert(offsetof(FM1KilledMonsterInfo, MonsterTid) == 0x000004, "Member 'FM1KilledMonsterInfo::MonsterTid' has a wrong offset!");
static_assert(offsetof(FM1KilledMonsterInfo, Level) == 0x000008, "Member 'FM1KilledMonsterInfo::Level' has a wrong offset!");
static_assert(offsetof(FM1KilledMonsterInfo, ContentType) == 0x00000C, "Member 'FM1KilledMonsterInfo::ContentType' has a wrong offset!");
static_assert(offsetof(FM1KilledMonsterInfo, ContentTemplateId) == 0x000010, "Member 'FM1KilledMonsterInfo::ContentTemplateId' has a wrong offset!");

// ScriptStruct M1Data.M1BattlePassSeasonInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1BattlePassSeasonInfo final
{
public:
	struct FM1TemplateId                          BattlePassId;                                      // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardMaxLevel;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Exp;                                               // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Premium;                                           // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LevelUpgrade;                                      // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1BattlePassSeasonInfo) == 0x000008, "Wrong alignment on FM1BattlePassSeasonInfo");
static_assert(sizeof(FM1BattlePassSeasonInfo) == 0x000020, "Wrong size on FM1BattlePassSeasonInfo");
static_assert(offsetof(FM1BattlePassSeasonInfo, BattlePassId) == 0x000000, "Member 'FM1BattlePassSeasonInfo::BattlePassId' has a wrong offset!");
static_assert(offsetof(FM1BattlePassSeasonInfo, Level) == 0x000004, "Member 'FM1BattlePassSeasonInfo::Level' has a wrong offset!");
static_assert(offsetof(FM1BattlePassSeasonInfo, RewardMaxLevel) == 0x000008, "Member 'FM1BattlePassSeasonInfo::RewardMaxLevel' has a wrong offset!");
static_assert(offsetof(FM1BattlePassSeasonInfo, Exp) == 0x000010, "Member 'FM1BattlePassSeasonInfo::Exp' has a wrong offset!");
static_assert(offsetof(FM1BattlePassSeasonInfo, Premium) == 0x000018, "Member 'FM1BattlePassSeasonInfo::Premium' has a wrong offset!");
static_assert(offsetof(FM1BattlePassSeasonInfo, LevelUpgrade) == 0x000019, "Member 'FM1BattlePassSeasonInfo::LevelUpgrade' has a wrong offset!");

// ScriptStruct M1Data.M1BattlePassSeasonInfoBundle
// 0x0018 (0x0018 - 0x0000)
struct FM1BattlePassSeasonInfoBundle final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1BattlePassSeasonInfo>        Bundles;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattlePassSeasonInfoBundle) == 0x000008, "Wrong alignment on FM1BattlePassSeasonInfoBundle");
static_assert(sizeof(FM1BattlePassSeasonInfoBundle) == 0x000018, "Wrong size on FM1BattlePassSeasonInfoBundle");
static_assert(offsetof(FM1BattlePassSeasonInfoBundle, AccountUid) == 0x000000, "Member 'FM1BattlePassSeasonInfoBundle::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1BattlePassSeasonInfoBundle, Bundles) == 0x000008, "Member 'FM1BattlePassSeasonInfoBundle::Bundles' has a wrong offset!");

// ScriptStruct M1Data.M1FixedOptionIndexes
// 0x0010 (0x0010 - 0x0000)
struct FM1FixedOptionIndexes final
{
public:
	TArray<int16>                                 OptionIndexes;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FixedOptionIndexes) == 0x000008, "Wrong alignment on FM1FixedOptionIndexes");
static_assert(sizeof(FM1FixedOptionIndexes) == 0x000010, "Wrong size on FM1FixedOptionIndexes");
static_assert(offsetof(FM1FixedOptionIndexes, OptionIndexes) == 0x000000, "Member 'FM1FixedOptionIndexes::OptionIndexes' has a wrong offset!");

// ScriptStruct M1Data.M1ShopBuyData
// 0x0010 (0x0010 - 0x0000)
struct FM1ShopBuyData final
{
public:
	int32                                         ProductTid;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuyCount;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              BuyDate;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ShopBuyData) == 0x000008, "Wrong alignment on FM1ShopBuyData");
static_assert(sizeof(FM1ShopBuyData) == 0x000010, "Wrong size on FM1ShopBuyData");
static_assert(offsetof(FM1ShopBuyData, ProductTid) == 0x000000, "Member 'FM1ShopBuyData::ProductTid' has a wrong offset!");
static_assert(offsetof(FM1ShopBuyData, BuyCount) == 0x000004, "Member 'FM1ShopBuyData::BuyCount' has a wrong offset!");
static_assert(offsetof(FM1ShopBuyData, BuyDate) == 0x000008, "Member 'FM1ShopBuyData::BuyDate' has a wrong offset!");

// ScriptStruct M1Data.M1ShopBuyBundleData
// 0x0010 (0x0010 - 0x0000)
struct FM1ShopBuyBundleData final
{
public:
	TArray<struct FM1ShopBuyData>                 DataList;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ShopBuyBundleData) == 0x000008, "Wrong alignment on FM1ShopBuyBundleData");
static_assert(sizeof(FM1ShopBuyBundleData) == 0x000010, "Wrong size on FM1ShopBuyBundleData");
static_assert(offsetof(FM1ShopBuyBundleData, DataList) == 0x000000, "Member 'FM1ShopBuyBundleData::DataList' has a wrong offset!");

// ScriptStruct M1Data.M1BattleShopCompileUnit
// 0x0018 (0x0018 - 0x0000)
struct FM1BattleShopCompileUnit final
{
public:
	struct FM1TemplateId                          BattlePassTid;                                     // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ShopTid;                                           // 0x0004(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1TemplateId>                  ProductTidList;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattleShopCompileUnit) == 0x000008, "Wrong alignment on FM1BattleShopCompileUnit");
static_assert(sizeof(FM1BattleShopCompileUnit) == 0x000018, "Wrong size on FM1BattleShopCompileUnit");
static_assert(offsetof(FM1BattleShopCompileUnit, BattlePassTid) == 0x000000, "Member 'FM1BattleShopCompileUnit::BattlePassTid' has a wrong offset!");
static_assert(offsetof(FM1BattleShopCompileUnit, ShopTid) == 0x000004, "Member 'FM1BattleShopCompileUnit::ShopTid' has a wrong offset!");
static_assert(offsetof(FM1BattleShopCompileUnit, ProductTidList) == 0x000008, "Member 'FM1BattleShopCompileUnit::ProductTidList' has a wrong offset!");

// ScriptStruct M1Data.M1BattleShopCompileUnitBundle
// 0x0018 (0x0018 - 0x0000)
struct FM1BattleShopCompileUnitBundle final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1BattleShopCompileUnit>       DataList;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattleShopCompileUnitBundle) == 0x000008, "Wrong alignment on FM1BattleShopCompileUnitBundle");
static_assert(sizeof(FM1BattleShopCompileUnitBundle) == 0x000018, "Wrong size on FM1BattleShopCompileUnitBundle");
static_assert(offsetof(FM1BattleShopCompileUnitBundle, AccountUid) == 0x000000, "Member 'FM1BattleShopCompileUnitBundle::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1BattleShopCompileUnitBundle, DataList) == 0x000008, "Member 'FM1BattleShopCompileUnitBundle::DataList' has a wrong offset!");

// ScriptStruct M1Data.M1CurrencyInternalTran
// 0x0010 (0x0010 - 0x0000)
struct FM1CurrencyInternalTran final
{
public:
	EM1CurrencyInternalType                       Type;                                              // 0x0000(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Count;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CurrencyInternalTran) == 0x000008, "Wrong alignment on FM1CurrencyInternalTran");
static_assert(sizeof(FM1CurrencyInternalTran) == 0x000010, "Wrong size on FM1CurrencyInternalTran");
static_assert(offsetof(FM1CurrencyInternalTran, Type) == 0x000000, "Member 'FM1CurrencyInternalTran::Type' has a wrong offset!");
static_assert(offsetof(FM1CurrencyInternalTran, Count) == 0x000008, "Member 'FM1CurrencyInternalTran::Count' has a wrong offset!");

// ScriptStruct M1Data.M1CurrencyInternalTranBundle
// 0x0018 (0x0018 - 0x0000)
struct FM1CurrencyInternalTranBundle final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1CurrencyInternalTran>        DataList;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CurrencyInternalTranBundle) == 0x000008, "Wrong alignment on FM1CurrencyInternalTranBundle");
static_assert(sizeof(FM1CurrencyInternalTranBundle) == 0x000018, "Wrong size on FM1CurrencyInternalTranBundle");
static_assert(offsetof(FM1CurrencyInternalTranBundle, AccountUid) == 0x000000, "Member 'FM1CurrencyInternalTranBundle::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1CurrencyInternalTranBundle, DataList) == 0x000008, "Member 'FM1CurrencyInternalTranBundle::DataList' has a wrong offset!");

// ScriptStruct M1Data.M1TrackingData
// 0x0000 (0x0008 - 0x0008)
struct FM1TrackingData final : public FTableRowBase
{
};
static_assert(alignof(FM1TrackingData) == 0x000008, "Wrong alignment on FM1TrackingData");
static_assert(sizeof(FM1TrackingData) == 0x000008, "Wrong size on FM1TrackingData");

// ScriptStruct M1Data.M1PresetInfoBundle
// 0x0010 (0x0010 - 0x0000)
struct FM1PresetInfoBundle final
{
public:
	TArray<struct FM1PresetInfo>                  Presets;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PresetInfoBundle) == 0x000008, "Wrong alignment on FM1PresetInfoBundle");
static_assert(sizeof(FM1PresetInfoBundle) == 0x000010, "Wrong size on FM1PresetInfoBundle");
static_assert(offsetof(FM1PresetInfoBundle, Presets) == 0x000000, "Member 'FM1PresetInfoBundle::Presets' has a wrong offset!");

// ScriptStruct M1Data.M1ItemShortIndexBundle
// 0x0010 (0x0010 - 0x0000)
struct FM1ItemShortIndexBundle final
{
public:
	TArray<int16>                                 ItemShortIndexList;                                // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemShortIndexBundle) == 0x000008, "Wrong alignment on FM1ItemShortIndexBundle");
static_assert(sizeof(FM1ItemShortIndexBundle) == 0x000010, "Wrong size on FM1ItemShortIndexBundle");
static_assert(offsetof(FM1ItemShortIndexBundle, ItemShortIndexList) == 0x000000, "Member 'FM1ItemShortIndexBundle::ItemShortIndexList' has a wrong offset!");

// ScriptStruct M1Data.M1ExtractPaintRes
// 0x0018 (0x0018 - 0x0000)
struct FM1ExtractPaintRes final
{
public:
	EM1ItemReason                                 Result;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1TemplateId>                  PaintList;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ExtractPaintRes) == 0x000008, "Wrong alignment on FM1ExtractPaintRes");
static_assert(sizeof(FM1ExtractPaintRes) == 0x000018, "Wrong size on FM1ExtractPaintRes");
static_assert(offsetof(FM1ExtractPaintRes, Result) == 0x000000, "Member 'FM1ExtractPaintRes::Result' has a wrong offset!");
static_assert(offsetof(FM1ExtractPaintRes, PaintList) == 0x000008, "Member 'FM1ExtractPaintRes::PaintList' has a wrong offset!");

// ScriptStruct M1Data.M1ItemSelectorInfo
// 0x0008 (0x0008 - 0x0000)
struct FM1ItemSelectorInfo final
{
public:
	struct FM1TemplateId                          SelectorTid;                                       // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemSelectorInfo) == 0x000004, "Wrong alignment on FM1ItemSelectorInfo");
static_assert(sizeof(FM1ItemSelectorInfo) == 0x000008, "Wrong size on FM1ItemSelectorInfo");
static_assert(offsetof(FM1ItemSelectorInfo, SelectorTid) == 0x000000, "Member 'FM1ItemSelectorInfo::SelectorTid' has a wrong offset!");
static_assert(offsetof(FM1ItemSelectorInfo, Index) == 0x000004, "Member 'FM1ItemSelectorInfo::Index' has a wrong offset!");

// ScriptStruct M1Data.M1BuyAdditionalData
// 0x0018 (0x0018 - 0x0000)
struct FM1BuyAdditionalData final
{
public:
	struct FM1TemplateId                          TicketDataId;                                      // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1ItemSelectorInfo>            SelectorData;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BuyAdditionalData) == 0x000008, "Wrong alignment on FM1BuyAdditionalData");
static_assert(sizeof(FM1BuyAdditionalData) == 0x000018, "Wrong size on FM1BuyAdditionalData");
static_assert(offsetof(FM1BuyAdditionalData, TicketDataId) == 0x000000, "Member 'FM1BuyAdditionalData::TicketDataId' has a wrong offset!");
static_assert(offsetof(FM1BuyAdditionalData, SelectorData) == 0x000008, "Member 'FM1BuyAdditionalData::SelectorData' has a wrong offset!");

// ScriptStruct M1Data.M1SeasonInfo
// 0x0030 (0x0030 - 0x0000)
struct FM1SeasonInfo final
{
public:
	int32                                         SeasonId;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Exp;                                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1SeasonReinforceInfo                 SeasonReinforceInfo;                               // 0x0010(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SeasonInfo) == 0x000008, "Wrong alignment on FM1SeasonInfo");
static_assert(sizeof(FM1SeasonInfo) == 0x000030, "Wrong size on FM1SeasonInfo");
static_assert(offsetof(FM1SeasonInfo, SeasonId) == 0x000000, "Member 'FM1SeasonInfo::SeasonId' has a wrong offset!");
static_assert(offsetof(FM1SeasonInfo, Level) == 0x000004, "Member 'FM1SeasonInfo::Level' has a wrong offset!");
static_assert(offsetof(FM1SeasonInfo, Exp) == 0x000008, "Member 'FM1SeasonInfo::Exp' has a wrong offset!");
static_assert(offsetof(FM1SeasonInfo, SeasonReinforceInfo) == 0x000010, "Member 'FM1SeasonInfo::SeasonReinforceInfo' has a wrong offset!");

// ScriptStruct M1Data.M1BuyItemDataUnit
// 0x0028 (0x0028 - 0x0000)
struct FM1BuyItemDataUnit final
{
public:
	struct FM1TemplateId                          ShopTemplateId;                                    // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ProductTid;                                        // 0x0004(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1BuyAdditionalData                   AdditionalData;                                    // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BuyItemDataUnit) == 0x000008, "Wrong alignment on FM1BuyItemDataUnit");
static_assert(sizeof(FM1BuyItemDataUnit) == 0x000028, "Wrong size on FM1BuyItemDataUnit");
static_assert(offsetof(FM1BuyItemDataUnit, ShopTemplateId) == 0x000000, "Member 'FM1BuyItemDataUnit::ShopTemplateId' has a wrong offset!");
static_assert(offsetof(FM1BuyItemDataUnit, ProductTid) == 0x000004, "Member 'FM1BuyItemDataUnit::ProductTid' has a wrong offset!");
static_assert(offsetof(FM1BuyItemDataUnit, Count) == 0x000008, "Member 'FM1BuyItemDataUnit::Count' has a wrong offset!");
static_assert(offsetof(FM1BuyItemDataUnit, AdditionalData) == 0x000010, "Member 'FM1BuyItemDataUnit::AdditionalData' has a wrong offset!");

// ScriptStruct M1Data.M1BuyItemDataBundle
// 0x0010 (0x0010 - 0x0000)
struct FM1BuyItemDataBundle final
{
public:
	TArray<struct FM1BuyItemDataUnit>             DataList;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BuyItemDataBundle) == 0x000008, "Wrong alignment on FM1BuyItemDataBundle");
static_assert(sizeof(FM1BuyItemDataBundle) == 0x000010, "Wrong size on FM1BuyItemDataBundle");
static_assert(offsetof(FM1BuyItemDataBundle, DataList) == 0x000000, "Member 'FM1BuyItemDataBundle::DataList' has a wrong offset!");

// ScriptStruct M1Data.M1ItemPackBundle
// 0x0010 (0x0010 - 0x0000)
struct FM1ItemPackBundle final
{
public:
	TArray<struct FM1ItemPack>                    ItemPacks;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemPackBundle) == 0x000008, "Wrong alignment on FM1ItemPackBundle");
static_assert(sizeof(FM1ItemPackBundle) == 0x000010, "Wrong size on FM1ItemPackBundle");
static_assert(offsetof(FM1ItemPackBundle, ItemPacks) == 0x000000, "Member 'FM1ItemPackBundle::ItemPacks' has a wrong offset!");

// ScriptStruct M1Data.M1MultipleMailResult
// 0x0010 (0x0010 - 0x0000)
struct FM1MultipleMailResult final
{
public:
	EM1MailReason                                 Reason;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MailId;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MultipleMailResult) == 0x000008, "Wrong alignment on FM1MultipleMailResult");
static_assert(sizeof(FM1MultipleMailResult) == 0x000010, "Wrong size on FM1MultipleMailResult");
static_assert(offsetof(FM1MultipleMailResult, Reason) == 0x000000, "Member 'FM1MultipleMailResult::Reason' has a wrong offset!");
static_assert(offsetof(FM1MultipleMailResult, MailId) == 0x000008, "Member 'FM1MultipleMailResult::MailId' has a wrong offset!");

// ScriptStruct M1Data.M1MultipleMailResultBundle
// 0x0010 (0x0010 - 0x0000)
struct FM1MultipleMailResultBundle final
{
public:
	TArray<struct FM1MultipleMailResult>          Results;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MultipleMailResultBundle) == 0x000008, "Wrong alignment on FM1MultipleMailResultBundle");
static_assert(sizeof(FM1MultipleMailResultBundle) == 0x000010, "Wrong size on FM1MultipleMailResultBundle");
static_assert(offsetof(FM1MultipleMailResultBundle, Results) == 0x000000, "Member 'FM1MultipleMailResultBundle::Results' has a wrong offset!");

// ScriptStruct M1Data.M1ExternalParticipateInfo
// 0x0028 (0x0028 - 0x0000)
struct FM1ExternalParticipateInfo final
{
public:
	class FString                                 ParticipateUserName;                               // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ServerIndex;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServerVersion;                                     // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ExternalParticipateInfo) == 0x000008, "Wrong alignment on FM1ExternalParticipateInfo");
static_assert(sizeof(FM1ExternalParticipateInfo) == 0x000028, "Wrong size on FM1ExternalParticipateInfo");
static_assert(offsetof(FM1ExternalParticipateInfo, ParticipateUserName) == 0x000000, "Member 'FM1ExternalParticipateInfo::ParticipateUserName' has a wrong offset!");
static_assert(offsetof(FM1ExternalParticipateInfo, ServerIndex) == 0x000010, "Member 'FM1ExternalParticipateInfo::ServerIndex' has a wrong offset!");
static_assert(offsetof(FM1ExternalParticipateInfo, ServerVersion) == 0x000018, "Member 'FM1ExternalParticipateInfo::ServerVersion' has a wrong offset!");

// ScriptStruct M1Data.M1PSOptionData
// 0x0001 (0x0001 - 0x0000)
struct FM1PSOptionData final
{
public:
	bool                                          CrossPlayOn;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PSOptionData) == 0x000001, "Wrong alignment on FM1PSOptionData");
static_assert(sizeof(FM1PSOptionData) == 0x000001, "Wrong size on FM1PSOptionData");
static_assert(offsetof(FM1PSOptionData, CrossPlayOn) == 0x000000, "Member 'FM1PSOptionData::CrossPlayOn' has a wrong offset!");

// ScriptStruct M1Data.M1XBOXOptionData
// 0x000C (0x000C - 0x0000)
struct FM1XBOXOptionData final
{
public:
	bool                                          CrossPlayOn;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EM1XBOXInnerOptionType                        InnerSocialOption;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1XBOXOuterOptionType                        OuterSocialOption;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1XBOXOptionData) == 0x000004, "Wrong alignment on FM1XBOXOptionData");
static_assert(sizeof(FM1XBOXOptionData) == 0x00000C, "Wrong size on FM1XBOXOptionData");
static_assert(offsetof(FM1XBOXOptionData, CrossPlayOn) == 0x000000, "Member 'FM1XBOXOptionData::CrossPlayOn' has a wrong offset!");
static_assert(offsetof(FM1XBOXOptionData, InnerSocialOption) == 0x000004, "Member 'FM1XBOXOptionData::InnerSocialOption' has a wrong offset!");
static_assert(offsetof(FM1XBOXOptionData, OuterSocialOption) == 0x000008, "Member 'FM1XBOXOptionData::OuterSocialOption' has a wrong offset!");

// ScriptStruct M1Data.M1CrossPlayOptionData
// 0x0010 (0x0010 - 0x0000)
struct FM1CrossPlayOptionData final
{
public:
	struct FM1PSOptionData                        PS;                                                // 0x0000(0x0001)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1XBOXOptionData                      XBOX;                                              // 0x0004(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CrossPlayOptionData) == 0x000004, "Wrong alignment on FM1CrossPlayOptionData");
static_assert(sizeof(FM1CrossPlayOptionData) == 0x000010, "Wrong size on FM1CrossPlayOptionData");
static_assert(offsetof(FM1CrossPlayOptionData, PS) == 0x000000, "Member 'FM1CrossPlayOptionData::PS' has a wrong offset!");
static_assert(offsetof(FM1CrossPlayOptionData, XBOX) == 0x000004, "Member 'FM1CrossPlayOptionData::XBOX' has a wrong offset!");

// ScriptStruct M1Data.M1LoginRequestInfo
// 0x0130 (0x0130 - 0x0000)
struct FM1LoginRequestInfo final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ExternalLinkerType                         ExternalLinkerType;                                // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ExternalLinkerData;                                // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CountryName;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SignCountry;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DeviceName;                                        // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1OsTypes                                    OsType;                                            // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OsName;                                            // 0x0060(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OsLanguage;                                        // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1Locale                                     Locale;                                            // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LoginPlatformId;                                   // 0x0088(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         LoginPlatformUid;                                  // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         LoginPlatform;                                     // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1RegionLatencyInfosMs                RegionLatencyInfos;                                // 0x00A8(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FM1CrossPlayOptionData                 CrossPlayOptionData;                               // 0x00B8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1ExternalParticipateInfo             ParticipateInfo;                                   // 0x00C8(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          Boosting;                                          // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Revision;                                          // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCreator;                                         // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ClientChecksum                      Checksum;                                          // 0x0100(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1LoginRequestInfo) == 0x000008, "Wrong alignment on FM1LoginRequestInfo");
static_assert(sizeof(FM1LoginRequestInfo) == 0x000130, "Wrong size on FM1LoginRequestInfo");
static_assert(offsetof(FM1LoginRequestInfo, Name) == 0x000000, "Member 'FM1LoginRequestInfo::Name' has a wrong offset!");
static_assert(offsetof(FM1LoginRequestInfo, ExternalLinkerType) == 0x000010, "Member 'FM1LoginRequestInfo::ExternalLinkerType' has a wrong offset!");
static_assert(offsetof(FM1LoginRequestInfo, ExternalLinkerData) == 0x000018, "Member 'FM1LoginRequestInfo::ExternalLinkerData' has a wrong offset!");
static_assert(offsetof(FM1LoginRequestInfo, CountryName) == 0x000028, "Member 'FM1LoginRequestInfo::CountryName' has a wrong offset!");
static_assert(offsetof(FM1LoginRequestInfo, SignCountry) == 0x000038, "Member 'FM1LoginRequestInfo::SignCountry' has a wrong offset!");
static_assert(offsetof(FM1LoginRequestInfo, DeviceName) == 0x000048, "Member 'FM1LoginRequestInfo::DeviceName' has a wrong offset!");
static_assert(offsetof(FM1LoginRequestInfo, OsType) == 0x000058, "Member 'FM1LoginRequestInfo::OsType' has a wrong offset!");
static_assert(offsetof(FM1LoginRequestInfo, OsName) == 0x000060, "Member 'FM1LoginRequestInfo::OsName' has a wrong offset!");
static_assert(offsetof(FM1LoginRequestInfo, OsLanguage) == 0x000070, "Member 'FM1LoginRequestInfo::OsLanguage' has a wrong offset!");
static_assert(offsetof(FM1LoginRequestInfo, Locale) == 0x000080, "Member 'FM1LoginRequestInfo::Locale' has a wrong offset!");
static_assert(offsetof(FM1LoginRequestInfo, LoginPlatformId) == 0x000088, "Member 'FM1LoginRequestInfo::LoginPlatformId' has a wrong offset!");
static_assert(offsetof(FM1LoginRequestInfo, LoginPlatformUid) == 0x000098, "Member 'FM1LoginRequestInfo::LoginPlatformUid' has a wrong offset!");
static_assert(offsetof(FM1LoginRequestInfo, LoginPlatform) == 0x0000A0, "Member 'FM1LoginRequestInfo::LoginPlatform' has a wrong offset!");
static_assert(offsetof(FM1LoginRequestInfo, RegionLatencyInfos) == 0x0000A8, "Member 'FM1LoginRequestInfo::RegionLatencyInfos' has a wrong offset!");
static_assert(offsetof(FM1LoginRequestInfo, CrossPlayOptionData) == 0x0000B8, "Member 'FM1LoginRequestInfo::CrossPlayOptionData' has a wrong offset!");
static_assert(offsetof(FM1LoginRequestInfo, ParticipateInfo) == 0x0000C8, "Member 'FM1LoginRequestInfo::ParticipateInfo' has a wrong offset!");
static_assert(offsetof(FM1LoginRequestInfo, Boosting) == 0x0000F0, "Member 'FM1LoginRequestInfo::Boosting' has a wrong offset!");
static_assert(offsetof(FM1LoginRequestInfo, Revision) == 0x0000F4, "Member 'FM1LoginRequestInfo::Revision' has a wrong offset!");
static_assert(offsetof(FM1LoginRequestInfo, IsCreator) == 0x0000F8, "Member 'FM1LoginRequestInfo::IsCreator' has a wrong offset!");
static_assert(offsetof(FM1LoginRequestInfo, Checksum) == 0x000100, "Member 'FM1LoginRequestInfo::Checksum' has a wrong offset!");

// ScriptStruct M1Data.M1LoginResponseInfo
// 0x0068 (0x0068 - 0x0000)
struct FM1LoginResponseInfo final
{
public:
	EM1LoginResultType                            LoginResultType;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GameServerAddr;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         Port;                                              // 0x0018(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GameServerIndex;                                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameServerVersion;                                 // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SessionToken;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         AccountUid;                                        // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccountName;                                       // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForcedCrossPlayOff;                                // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         QueueNumber;                                       // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1LoginResponseInfo) == 0x000008, "Wrong alignment on FM1LoginResponseInfo");
static_assert(sizeof(FM1LoginResponseInfo) == 0x000068, "Wrong size on FM1LoginResponseInfo");
static_assert(offsetof(FM1LoginResponseInfo, LoginResultType) == 0x000000, "Member 'FM1LoginResponseInfo::LoginResultType' has a wrong offset!");
static_assert(offsetof(FM1LoginResponseInfo, GameServerAddr) == 0x000008, "Member 'FM1LoginResponseInfo::GameServerAddr' has a wrong offset!");
static_assert(offsetof(FM1LoginResponseInfo, Port) == 0x000018, "Member 'FM1LoginResponseInfo::Port' has a wrong offset!");
static_assert(offsetof(FM1LoginResponseInfo, GameServerIndex) == 0x00001C, "Member 'FM1LoginResponseInfo::GameServerIndex' has a wrong offset!");
static_assert(offsetof(FM1LoginResponseInfo, GameServerVersion) == 0x000020, "Member 'FM1LoginResponseInfo::GameServerVersion' has a wrong offset!");
static_assert(offsetof(FM1LoginResponseInfo, SessionToken) == 0x000030, "Member 'FM1LoginResponseInfo::SessionToken' has a wrong offset!");
static_assert(offsetof(FM1LoginResponseInfo, AccountUid) == 0x000040, "Member 'FM1LoginResponseInfo::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1LoginResponseInfo, AccountName) == 0x000048, "Member 'FM1LoginResponseInfo::AccountName' has a wrong offset!");
static_assert(offsetof(FM1LoginResponseInfo, ForcedCrossPlayOff) == 0x000058, "Member 'FM1LoginResponseInfo::ForcedCrossPlayOff' has a wrong offset!");
static_assert(offsetof(FM1LoginResponseInfo, QueueNumber) == 0x000060, "Member 'FM1LoginResponseInfo::QueueNumber' has a wrong offset!");

// ScriptStruct M1Data.M1ScaledIntegerRange
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FM1ScaledIntegerRange final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ScaledIntegerRange) == 0x000008, "Wrong alignment on FM1ScaledIntegerRange");
static_assert(sizeof(FM1ScaledIntegerRange) == 0x000010, "Wrong size on FM1ScaledIntegerRange");

// ScriptStruct M1Data.M1JoinDedicatedServerParam
// 0x0028 (0x0028 - 0x0000)
struct FM1JoinDedicatedServerParam final
{
public:
	struct FM1TemplateId                          MapTemplateId;                                     // 0x0000(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1MapSubData                          MapSubData;                                        // 0x0004(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          CheckUnlock;                                       // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PrivateField;                                      // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1MapModifier>                 Modifiers;                                         // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1JoinDedicatedServerParam) == 0x000008, "Wrong alignment on FM1JoinDedicatedServerParam");
static_assert(sizeof(FM1JoinDedicatedServerParam) == 0x000028, "Wrong size on FM1JoinDedicatedServerParam");
static_assert(offsetof(FM1JoinDedicatedServerParam, MapTemplateId) == 0x000000, "Member 'FM1JoinDedicatedServerParam::MapTemplateId' has a wrong offset!");
static_assert(offsetof(FM1JoinDedicatedServerParam, MapSubData) == 0x000004, "Member 'FM1JoinDedicatedServerParam::MapSubData' has a wrong offset!");
static_assert(offsetof(FM1JoinDedicatedServerParam, CheckUnlock) == 0x000014, "Member 'FM1JoinDedicatedServerParam::CheckUnlock' has a wrong offset!");
static_assert(offsetof(FM1JoinDedicatedServerParam, PrivateField) == 0x000015, "Member 'FM1JoinDedicatedServerParam::PrivateField' has a wrong offset!");
static_assert(offsetof(FM1JoinDedicatedServerParam, Modifiers) == 0x000018, "Member 'FM1JoinDedicatedServerParam::Modifiers' has a wrong offset!");

// ScriptStruct M1Data.M1JoinDedicatedServerOid
// 0x0010 (0x0010 - 0x0000)
struct FM1JoinDedicatedServerOid final
{
public:
	int64                                         DediOid;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckUnlock;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1JoinDedicatedServerOid) == 0x000008, "Wrong alignment on FM1JoinDedicatedServerOid");
static_assert(sizeof(FM1JoinDedicatedServerOid) == 0x000010, "Wrong size on FM1JoinDedicatedServerOid");
static_assert(offsetof(FM1JoinDedicatedServerOid, DediOid) == 0x000000, "Member 'FM1JoinDedicatedServerOid::DediOid' has a wrong offset!");
static_assert(offsetof(FM1JoinDedicatedServerOid, CheckUnlock) == 0x000008, "Member 'FM1JoinDedicatedServerOid::CheckUnlock' has a wrong offset!");

// ScriptStruct M1Data.M1JoinDedicatedServerAccounts
// 0x0010 (0x0010 - 0x0000)
struct FM1JoinDedicatedServerAccounts final
{
public:
	TArray<int64>                                 Accounts;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1JoinDedicatedServerAccounts) == 0x000008, "Wrong alignment on FM1JoinDedicatedServerAccounts");
static_assert(sizeof(FM1JoinDedicatedServerAccounts) == 0x000010, "Wrong size on FM1JoinDedicatedServerAccounts");
static_assert(offsetof(FM1JoinDedicatedServerAccounts, Accounts) == 0x000000, "Member 'FM1JoinDedicatedServerAccounts::Accounts' has a wrong offset!");

// ScriptStruct M1Data.M1JoinDedicatedServerRes
// 0x00B0 (0x00B0 - 0x0000)
struct FM1JoinDedicatedServerRes final
{
public:
	EM1JoinDedicatedServerReason                  Reason;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1DedicatedServerInfo                 SelectedDedicatedServerInfo;                       // 0x0008(0x00A0)(Edit, NativeAccessSpecifierPublic)
	bool                                          ForcedOverWrite;                                   // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MovePosition;                                      // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1JoinDedicatedServerRes) == 0x000008, "Wrong alignment on FM1JoinDedicatedServerRes");
static_assert(sizeof(FM1JoinDedicatedServerRes) == 0x0000B0, "Wrong size on FM1JoinDedicatedServerRes");
static_assert(offsetof(FM1JoinDedicatedServerRes, Reason) == 0x000000, "Member 'FM1JoinDedicatedServerRes::Reason' has a wrong offset!");
static_assert(offsetof(FM1JoinDedicatedServerRes, SelectedDedicatedServerInfo) == 0x000008, "Member 'FM1JoinDedicatedServerRes::SelectedDedicatedServerInfo' has a wrong offset!");
static_assert(offsetof(FM1JoinDedicatedServerRes, ForcedOverWrite) == 0x0000A8, "Member 'FM1JoinDedicatedServerRes::ForcedOverWrite' has a wrong offset!");
static_assert(offsetof(FM1JoinDedicatedServerRes, MovePosition) == 0x0000A9, "Member 'FM1JoinDedicatedServerRes::MovePosition' has a wrong offset!");

// ScriptStruct M1Data.M1SearchResponse
// 0x0068 (0x0068 - 0x0000)
struct FM1SearchResponse final
{
public:
	EM1SearchType                                 Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1SearchErrorCode                            ErrorCode;                                         // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AccountName;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MapTemplatedId;                                    // 0x0018(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MasteryLevel;                                      // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          CharacterTid;                                      // 0x0028(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         CharacterLevel;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LoginPlatformId;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         LoginPlatformUid;                                  // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         LoginPlatform;                                     // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ExternAuthValue;                                   // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCreator;                                         // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SearchResponse) == 0x000008, "Wrong alignment on FM1SearchResponse");
static_assert(sizeof(FM1SearchResponse) == 0x000068, "Wrong size on FM1SearchResponse");
static_assert(offsetof(FM1SearchResponse, Type) == 0x000000, "Member 'FM1SearchResponse::Type' has a wrong offset!");
static_assert(offsetof(FM1SearchResponse, ErrorCode) == 0x000001, "Member 'FM1SearchResponse::ErrorCode' has a wrong offset!");
static_assert(offsetof(FM1SearchResponse, AccountName) == 0x000008, "Member 'FM1SearchResponse::AccountName' has a wrong offset!");
static_assert(offsetof(FM1SearchResponse, MapTemplatedId) == 0x000018, "Member 'FM1SearchResponse::MapTemplatedId' has a wrong offset!");
static_assert(offsetof(FM1SearchResponse, MasteryLevel) == 0x000020, "Member 'FM1SearchResponse::MasteryLevel' has a wrong offset!");
static_assert(offsetof(FM1SearchResponse, CharacterTid) == 0x000028, "Member 'FM1SearchResponse::CharacterTid' has a wrong offset!");
static_assert(offsetof(FM1SearchResponse, CharacterLevel) == 0x000030, "Member 'FM1SearchResponse::CharacterLevel' has a wrong offset!");
static_assert(offsetof(FM1SearchResponse, LoginPlatformId) == 0x000038, "Member 'FM1SearchResponse::LoginPlatformId' has a wrong offset!");
static_assert(offsetof(FM1SearchResponse, LoginPlatformUid) == 0x000048, "Member 'FM1SearchResponse::LoginPlatformUid' has a wrong offset!");
static_assert(offsetof(FM1SearchResponse, LoginPlatform) == 0x000050, "Member 'FM1SearchResponse::LoginPlatform' has a wrong offset!");
static_assert(offsetof(FM1SearchResponse, ExternAuthValue) == 0x000058, "Member 'FM1SearchResponse::ExternAuthValue' has a wrong offset!");
static_assert(offsetof(FM1SearchResponse, IsCreator) == 0x000060, "Member 'FM1SearchResponse::IsCreator' has a wrong offset!");

// ScriptStruct M1Data.M1RecentPlayerNoti
// 0x0030 (0x0030 - 0x0000)
struct FM1RecentPlayerNoti final
{
public:
	class FString                                 AccountName;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LoginPlatformId;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         LoginPlatformUid;                                  // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         LoginPlatformType;                                 // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RecentPlayerNoti) == 0x000008, "Wrong alignment on FM1RecentPlayerNoti");
static_assert(sizeof(FM1RecentPlayerNoti) == 0x000030, "Wrong size on FM1RecentPlayerNoti");
static_assert(offsetof(FM1RecentPlayerNoti, AccountName) == 0x000000, "Member 'FM1RecentPlayerNoti::AccountName' has a wrong offset!");
static_assert(offsetof(FM1RecentPlayerNoti, LoginPlatformId) == 0x000010, "Member 'FM1RecentPlayerNoti::LoginPlatformId' has a wrong offset!");
static_assert(offsetof(FM1RecentPlayerNoti, LoginPlatformUid) == 0x000020, "Member 'FM1RecentPlayerNoti::LoginPlatformUid' has a wrong offset!");
static_assert(offsetof(FM1RecentPlayerNoti, LoginPlatformType) == 0x000028, "Member 'FM1RecentPlayerNoti::LoginPlatformType' has a wrong offset!");

// ScriptStruct M1Data.M1PartyErrorMessageNoti
// 0x0048 (0x0048 - 0x0000)
struct FM1PartyErrorMessageNoti final
{
public:
	class FString                                 SeqId;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1PartyContentsType                          ContensType;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ReceiverUid;                                       // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SenderName;                                        // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SenderPlatformId;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1PartyErrorCode                             SenderMessage;                                     // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PartyErrorMessageNoti) == 0x000008, "Wrong alignment on FM1PartyErrorMessageNoti");
static_assert(sizeof(FM1PartyErrorMessageNoti) == 0x000048, "Wrong size on FM1PartyErrorMessageNoti");
static_assert(offsetof(FM1PartyErrorMessageNoti, SeqId) == 0x000000, "Member 'FM1PartyErrorMessageNoti::SeqId' has a wrong offset!");
static_assert(offsetof(FM1PartyErrorMessageNoti, ContensType) == 0x000010, "Member 'FM1PartyErrorMessageNoti::ContensType' has a wrong offset!");
static_assert(offsetof(FM1PartyErrorMessageNoti, ReceiverUid) == 0x000018, "Member 'FM1PartyErrorMessageNoti::ReceiverUid' has a wrong offset!");
static_assert(offsetof(FM1PartyErrorMessageNoti, SenderName) == 0x000020, "Member 'FM1PartyErrorMessageNoti::SenderName' has a wrong offset!");
static_assert(offsetof(FM1PartyErrorMessageNoti, SenderPlatformId) == 0x000030, "Member 'FM1PartyErrorMessageNoti::SenderPlatformId' has a wrong offset!");
static_assert(offsetof(FM1PartyErrorMessageNoti, SenderMessage) == 0x000040, "Member 'FM1PartyErrorMessageNoti::SenderMessage' has a wrong offset!");

// ScriptStruct M1Data.M1FriendErrorMessageNoti
// 0x0030 (0x0030 - 0x0000)
struct FM1FriendErrorMessageNoti final
{
public:
	int64                                         ReceiverUid;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetName;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetPlatformId;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1FriendContentsType                         ContentsType;                                      // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1FriendErrorCode                            ErrorCode;                                         // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FriendErrorMessageNoti) == 0x000008, "Wrong alignment on FM1FriendErrorMessageNoti");
static_assert(sizeof(FM1FriendErrorMessageNoti) == 0x000030, "Wrong size on FM1FriendErrorMessageNoti");
static_assert(offsetof(FM1FriendErrorMessageNoti, ReceiverUid) == 0x000000, "Member 'FM1FriendErrorMessageNoti::ReceiverUid' has a wrong offset!");
static_assert(offsetof(FM1FriendErrorMessageNoti, TargetName) == 0x000008, "Member 'FM1FriendErrorMessageNoti::TargetName' has a wrong offset!");
static_assert(offsetof(FM1FriendErrorMessageNoti, TargetPlatformId) == 0x000018, "Member 'FM1FriendErrorMessageNoti::TargetPlatformId' has a wrong offset!");
static_assert(offsetof(FM1FriendErrorMessageNoti, ContentsType) == 0x000028, "Member 'FM1FriendErrorMessageNoti::ContentsType' has a wrong offset!");
static_assert(offsetof(FM1FriendErrorMessageNoti, ErrorCode) == 0x00002C, "Member 'FM1FriendErrorMessageNoti::ErrorCode' has a wrong offset!");

// ScriptStruct M1Data.M1BlockErrorMessageNoti
// 0x0010 (0x0010 - 0x0000)
struct FM1BlockErrorMessageNoti final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1BlockErrorCode                             ErrorCode;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1BlockErrorMessageNoti) == 0x000008, "Wrong alignment on FM1BlockErrorMessageNoti");
static_assert(sizeof(FM1BlockErrorMessageNoti) == 0x000010, "Wrong size on FM1BlockErrorMessageNoti");
static_assert(offsetof(FM1BlockErrorMessageNoti, AccountUid) == 0x000000, "Member 'FM1BlockErrorMessageNoti::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1BlockErrorMessageNoti, ErrorCode) == 0x000008, "Member 'FM1BlockErrorMessageNoti::ErrorCode' has a wrong offset!");

// ScriptStruct M1Data.M1WorldChattingNoti
// 0x0010 (0x0010 - 0x0000)
struct FM1WorldChattingNoti final
{
public:
	TArray<struct FM1WorldChattingMessage>        Messages;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WorldChattingNoti) == 0x000008, "Wrong alignment on FM1WorldChattingNoti");
static_assert(sizeof(FM1WorldChattingNoti) == 0x000010, "Wrong size on FM1WorldChattingNoti");
static_assert(offsetof(FM1WorldChattingNoti, Messages) == 0x000000, "Member 'FM1WorldChattingNoti::Messages' has a wrong offset!");

// ScriptStruct M1Data.M1ChattingMessage
// 0x0070 (0x0070 - 0x0000)
struct FM1ChattingMessage final
{
public:
	EM1ChattingType                               Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReceiverName;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SenderLanguage;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SenderName;                                        // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SenderMessage;                                     // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              SendTime;                                          // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SenderPlatformId;                                  // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         SenderPlatformUid;                                 // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         SenderPlatformType;                                // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ChattingMessage) == 0x000008, "Wrong alignment on FM1ChattingMessage");
static_assert(sizeof(FM1ChattingMessage) == 0x000070, "Wrong size on FM1ChattingMessage");
static_assert(offsetof(FM1ChattingMessage, Type) == 0x000000, "Member 'FM1ChattingMessage::Type' has a wrong offset!");
static_assert(offsetof(FM1ChattingMessage, ReceiverName) == 0x000008, "Member 'FM1ChattingMessage::ReceiverName' has a wrong offset!");
static_assert(offsetof(FM1ChattingMessage, SenderLanguage) == 0x000018, "Member 'FM1ChattingMessage::SenderLanguage' has a wrong offset!");
static_assert(offsetof(FM1ChattingMessage, SenderName) == 0x000028, "Member 'FM1ChattingMessage::SenderName' has a wrong offset!");
static_assert(offsetof(FM1ChattingMessage, SenderMessage) == 0x000038, "Member 'FM1ChattingMessage::SenderMessage' has a wrong offset!");
static_assert(offsetof(FM1ChattingMessage, SendTime) == 0x000048, "Member 'FM1ChattingMessage::SendTime' has a wrong offset!");
static_assert(offsetof(FM1ChattingMessage, SenderPlatformId) == 0x000050, "Member 'FM1ChattingMessage::SenderPlatformId' has a wrong offset!");
static_assert(offsetof(FM1ChattingMessage, SenderPlatformUid) == 0x000060, "Member 'FM1ChattingMessage::SenderPlatformUid' has a wrong offset!");
static_assert(offsetof(FM1ChattingMessage, SenderPlatformType) == 0x000068, "Member 'FM1ChattingMessage::SenderPlatformType' has a wrong offset!");

// ScriptStruct M1Data.M1SupportErrorMessageNoti
// 0x0020 (0x0020 - 0x0000)
struct FM1SupportErrorMessageNoti final
{
public:
	class FString                                 SeqId;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReceiverUid;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1SupportReason                              ErrorCode;                                         // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SupportErrorMessageNoti) == 0x000008, "Wrong alignment on FM1SupportErrorMessageNoti");
static_assert(sizeof(FM1SupportErrorMessageNoti) == 0x000020, "Wrong size on FM1SupportErrorMessageNoti");
static_assert(offsetof(FM1SupportErrorMessageNoti, SeqId) == 0x000000, "Member 'FM1SupportErrorMessageNoti::SeqId' has a wrong offset!");
static_assert(offsetof(FM1SupportErrorMessageNoti, ReceiverUid) == 0x000010, "Member 'FM1SupportErrorMessageNoti::ReceiverUid' has a wrong offset!");
static_assert(offsetof(FM1SupportErrorMessageNoti, ErrorCode) == 0x000018, "Member 'FM1SupportErrorMessageNoti::ErrorCode' has a wrong offset!");

// ScriptStruct M1Data.M1UpdateDediInfo
// 0x0038 (0x0038 - 0x0000)
struct FM1UpdateDediInfo final
{
public:
	class FString                                 ContainerName;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BlobPath;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ConnectionString;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SaveUpdatedDedi;                                   // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DediRevision;                                      // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1UpdateDediInfo) == 0x000008, "Wrong alignment on FM1UpdateDediInfo");
static_assert(sizeof(FM1UpdateDediInfo) == 0x000038, "Wrong size on FM1UpdateDediInfo");
static_assert(offsetof(FM1UpdateDediInfo, ContainerName) == 0x000000, "Member 'FM1UpdateDediInfo::ContainerName' has a wrong offset!");
static_assert(offsetof(FM1UpdateDediInfo, BlobPath) == 0x000010, "Member 'FM1UpdateDediInfo::BlobPath' has a wrong offset!");
static_assert(offsetof(FM1UpdateDediInfo, ConnectionString) == 0x000020, "Member 'FM1UpdateDediInfo::ConnectionString' has a wrong offset!");
static_assert(offsetof(FM1UpdateDediInfo, SaveUpdatedDedi) == 0x000030, "Member 'FM1UpdateDediInfo::SaveUpdatedDedi' has a wrong offset!");
static_assert(offsetof(FM1UpdateDediInfo, DediRevision) == 0x000034, "Member 'FM1UpdateDediInfo::DediRevision' has a wrong offset!");

// ScriptStruct M1Data.M1StopDediInfo
// 0x0004 (0x0004 - 0x0000)
struct FM1StopDediInfo final
{
public:
	int32                                         MapId;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StopDediInfo) == 0x000004, "Wrong alignment on FM1StopDediInfo");
static_assert(sizeof(FM1StopDediInfo) == 0x000004, "Wrong size on FM1StopDediInfo");
static_assert(offsetof(FM1StopDediInfo, MapId) == 0x000000, "Member 'FM1StopDediInfo::MapId' has a wrong offset!");

// ScriptStruct M1Data.M1ReserveUserInfo
// 0x01A0 (0x01A0 - 0x0000)
struct FM1ReserveUserInfo final
{
public:
	int64                                         AccountID;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShardKey;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name;                                              // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SessionToken;                                      // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ServerIndex;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServerPrivateIp;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NearestRegion;                                     // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerVersion;                                     // 0x0058(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LinkerSystem;                                      // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         AuthValue;                                         // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClientRevision;                                    // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CountryName;                                       // 0x0080(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SignCountry;                                       // 0x0090(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DeviceName;                                        // 0x00A0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1OsTypes                                    OsType;                                            // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OsName;                                            // 0x00B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OsLanguage;                                        // 0x00C8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1Locale                                     Locale;                                            // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LoginPlatformId;                                   // 0x00E0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         LoginPlatformUid;                                  // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         LoginPlatform;                                     // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ToyServiceId;                                      // 0x0100(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Moved;                                             // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         LastDediOid;                                       // 0x0118(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          LastMapTid;                                        // 0x0120(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1MapSubData                          LastMapSubData;                                    // 0x0124(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          LastMissionTid;                                    // 0x0134(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         LastPartyId;                                       // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1PartyMemberInfo>             LastPartyMember;                                   // 0x0140(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1CrossPlayOptionData                 CrossPlayData;                                     // 0x0150(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 ParticipateUserName;                               // 0x0160(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldId;                                           // 0x0170(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldUid;                                          // 0x0180(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ChatBannedTime;                                    // 0x0190(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Boosting;                                          // 0x0198(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCreator;                                         // 0x0199(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A[0x6];                                      // 0x019A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ReserveUserInfo) == 0x000008, "Wrong alignment on FM1ReserveUserInfo");
static_assert(sizeof(FM1ReserveUserInfo) == 0x0001A0, "Wrong size on FM1ReserveUserInfo");
static_assert(offsetof(FM1ReserveUserInfo, AccountID) == 0x000000, "Member 'FM1ReserveUserInfo::AccountID' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, ShardKey) == 0x000008, "Member 'FM1ReserveUserInfo::ShardKey' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, Name) == 0x000010, "Member 'FM1ReserveUserInfo::Name' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, SessionToken) == 0x000020, "Member 'FM1ReserveUserInfo::SessionToken' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, ServerIndex) == 0x000030, "Member 'FM1ReserveUserInfo::ServerIndex' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, ServerPrivateIp) == 0x000038, "Member 'FM1ReserveUserInfo::ServerPrivateIp' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, NearestRegion) == 0x000048, "Member 'FM1ReserveUserInfo::NearestRegion' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, ServerVersion) == 0x000058, "Member 'FM1ReserveUserInfo::ServerVersion' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, LinkerSystem) == 0x000068, "Member 'FM1ReserveUserInfo::LinkerSystem' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, AuthValue) == 0x000070, "Member 'FM1ReserveUserInfo::AuthValue' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, ClientRevision) == 0x000078, "Member 'FM1ReserveUserInfo::ClientRevision' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, CountryName) == 0x000080, "Member 'FM1ReserveUserInfo::CountryName' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, SignCountry) == 0x000090, "Member 'FM1ReserveUserInfo::SignCountry' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, DeviceName) == 0x0000A0, "Member 'FM1ReserveUserInfo::DeviceName' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, OsType) == 0x0000B0, "Member 'FM1ReserveUserInfo::OsType' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, OsName) == 0x0000B8, "Member 'FM1ReserveUserInfo::OsName' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, OsLanguage) == 0x0000C8, "Member 'FM1ReserveUserInfo::OsLanguage' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, Locale) == 0x0000D8, "Member 'FM1ReserveUserInfo::Locale' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, LoginPlatformId) == 0x0000E0, "Member 'FM1ReserveUserInfo::LoginPlatformId' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, LoginPlatformUid) == 0x0000F0, "Member 'FM1ReserveUserInfo::LoginPlatformUid' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, LoginPlatform) == 0x0000F8, "Member 'FM1ReserveUserInfo::LoginPlatform' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, ToyServiceId) == 0x000100, "Member 'FM1ReserveUserInfo::ToyServiceId' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, Moved) == 0x000110, "Member 'FM1ReserveUserInfo::Moved' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, LastDediOid) == 0x000118, "Member 'FM1ReserveUserInfo::LastDediOid' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, LastMapTid) == 0x000120, "Member 'FM1ReserveUserInfo::LastMapTid' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, LastMapSubData) == 0x000124, "Member 'FM1ReserveUserInfo::LastMapSubData' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, LastMissionTid) == 0x000134, "Member 'FM1ReserveUserInfo::LastMissionTid' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, LastPartyId) == 0x000138, "Member 'FM1ReserveUserInfo::LastPartyId' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, LastPartyMember) == 0x000140, "Member 'FM1ReserveUserInfo::LastPartyMember' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, CrossPlayData) == 0x000150, "Member 'FM1ReserveUserInfo::CrossPlayData' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, ParticipateUserName) == 0x000160, "Member 'FM1ReserveUserInfo::ParticipateUserName' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, FieldId) == 0x000170, "Member 'FM1ReserveUserInfo::FieldId' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, FieldUid) == 0x000180, "Member 'FM1ReserveUserInfo::FieldUid' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, ChatBannedTime) == 0x000190, "Member 'FM1ReserveUserInfo::ChatBannedTime' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, Boosting) == 0x000198, "Member 'FM1ReserveUserInfo::Boosting' has a wrong offset!");
static_assert(offsetof(FM1ReserveUserInfo, IsCreator) == 0x000199, "Member 'FM1ReserveUserInfo::IsCreator' has a wrong offset!");

// ScriptStruct M1Data.M1KickInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1KickInfo final
{
public:
	EM1KickType                                   KickType;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Reason;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1KickInfo) == 0x000008, "Wrong alignment on FM1KickInfo");
static_assert(sizeof(FM1KickInfo) == 0x000018, "Wrong size on FM1KickInfo");
static_assert(offsetof(FM1KickInfo, KickType) == 0x000000, "Member 'FM1KickInfo::KickType' has a wrong offset!");
static_assert(offsetof(FM1KickInfo, Reason) == 0x000008, "Member 'FM1KickInfo::Reason' has a wrong offset!");

// ScriptStruct M1Data.M1KickUserInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1KickUserInfo final
{
public:
	int64                                         AccountID;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1KickInfo                            KickInfo;                                          // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1KickUserInfo) == 0x000008, "Wrong alignment on FM1KickUserInfo");
static_assert(sizeof(FM1KickUserInfo) == 0x000020, "Wrong size on FM1KickUserInfo");
static_assert(offsetof(FM1KickUserInfo, AccountID) == 0x000000, "Member 'FM1KickUserInfo::AccountID' has a wrong offset!");
static_assert(offsetof(FM1KickUserInfo, KickInfo) == 0x000008, "Member 'FM1KickUserInfo::KickInfo' has a wrong offset!");

// ScriptStruct M1Data.M1MailLanguageInfo
// 0x0038 (0x0038 - 0x0000)
struct FM1MailLanguageInfo final
{
public:
	EM1Locale                                     Code;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Sender;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Content;                                           // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MailLanguageInfo) == 0x000008, "Wrong alignment on FM1MailLanguageInfo");
static_assert(sizeof(FM1MailLanguageInfo) == 0x000038, "Wrong size on FM1MailLanguageInfo");
static_assert(offsetof(FM1MailLanguageInfo, Code) == 0x000000, "Member 'FM1MailLanguageInfo::Code' has a wrong offset!");
static_assert(offsetof(FM1MailLanguageInfo, Sender) == 0x000008, "Member 'FM1MailLanguageInfo::Sender' has a wrong offset!");
static_assert(offsetof(FM1MailLanguageInfo, Title) == 0x000018, "Member 'FM1MailLanguageInfo::Title' has a wrong offset!");
static_assert(offsetof(FM1MailLanguageInfo, Content) == 0x000028, "Member 'FM1MailLanguageInfo::Content' has a wrong offset!");

// ScriptStruct M1Data.M1OntimeEventItem
// 0x0010 (0x0010 - 0x0000)
struct FM1OntimeEventItem final
{
public:
	EM1ItemType                                   ItemType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ItemTemplateId;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Amount;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1OntimeEventItem) == 0x000008, "Wrong alignment on FM1OntimeEventItem");
static_assert(sizeof(FM1OntimeEventItem) == 0x000010, "Wrong size on FM1OntimeEventItem");
static_assert(offsetof(FM1OntimeEventItem, ItemType) == 0x000000, "Member 'FM1OntimeEventItem::ItemType' has a wrong offset!");
static_assert(offsetof(FM1OntimeEventItem, ItemTemplateId) == 0x000004, "Member 'FM1OntimeEventItem::ItemTemplateId' has a wrong offset!");
static_assert(offsetof(FM1OntimeEventItem, Amount) == 0x000008, "Member 'FM1OntimeEventItem::Amount' has a wrong offset!");

// ScriptStruct M1Data.M1OntimeEvent
// 0x0040 (0x0040 - 0x0000)
struct FM1OntimeEvent final
{
public:
	int64                                         EventId;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              StartTime;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndTime;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ExpireTime;                                        // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1MailLanguageInfo>            LanguageList;                                      // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1OntimeEventItem>             ItemList;                                          // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1OntimeEvent) == 0x000008, "Wrong alignment on FM1OntimeEvent");
static_assert(sizeof(FM1OntimeEvent) == 0x000040, "Wrong size on FM1OntimeEvent");
static_assert(offsetof(FM1OntimeEvent, EventId) == 0x000000, "Member 'FM1OntimeEvent::EventId' has a wrong offset!");
static_assert(offsetof(FM1OntimeEvent, StartTime) == 0x000008, "Member 'FM1OntimeEvent::StartTime' has a wrong offset!");
static_assert(offsetof(FM1OntimeEvent, EndTime) == 0x000010, "Member 'FM1OntimeEvent::EndTime' has a wrong offset!");
static_assert(offsetof(FM1OntimeEvent, ExpireTime) == 0x000018, "Member 'FM1OntimeEvent::ExpireTime' has a wrong offset!");
static_assert(offsetof(FM1OntimeEvent, LanguageList) == 0x000020, "Member 'FM1OntimeEvent::LanguageList' has a wrong offset!");
static_assert(offsetof(FM1OntimeEvent, ItemList) == 0x000030, "Member 'FM1OntimeEvent::ItemList' has a wrong offset!");

// ScriptStruct M1Data.M1OntimeEventBundle
// 0x0010 (0x0010 - 0x0000)
struct FM1OntimeEventBundle final
{
public:
	TArray<struct FM1OntimeEvent>                 OntimeEventList;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1OntimeEventBundle) == 0x000008, "Wrong alignment on FM1OntimeEventBundle");
static_assert(sizeof(FM1OntimeEventBundle) == 0x000010, "Wrong size on FM1OntimeEventBundle");
static_assert(offsetof(FM1OntimeEventBundle, OntimeEventList) == 0x000000, "Member 'FM1OntimeEventBundle::OntimeEventList' has a wrong offset!");

// ScriptStruct M1Data.M1AccountList
// 0x0010 (0x0010 - 0x0000)
struct FM1AccountList final
{
public:
	TArray<int64>                                 Accounts;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AccountList) == 0x000008, "Wrong alignment on FM1AccountList");
static_assert(sizeof(FM1AccountList) == 0x000010, "Wrong size on FM1AccountList");
static_assert(offsetof(FM1AccountList, Accounts) == 0x000000, "Member 'FM1AccountList::Accounts' has a wrong offset!");

// ScriptStruct M1Data.M1CommunityReportInfo
// 0x0038 (0x0038 - 0x0000)
struct FM1CommunityReportInfo final
{
public:
	class FString                                 ReporteeName;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ReportReasonType                           ReportType;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Comment;                                           // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReporterCountry;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CommunityReportInfo) == 0x000008, "Wrong alignment on FM1CommunityReportInfo");
static_assert(sizeof(FM1CommunityReportInfo) == 0x000038, "Wrong size on FM1CommunityReportInfo");
static_assert(offsetof(FM1CommunityReportInfo, ReporteeName) == 0x000000, "Member 'FM1CommunityReportInfo::ReporteeName' has a wrong offset!");
static_assert(offsetof(FM1CommunityReportInfo, ReportType) == 0x000010, "Member 'FM1CommunityReportInfo::ReportType' has a wrong offset!");
static_assert(offsetof(FM1CommunityReportInfo, Comment) == 0x000018, "Member 'FM1CommunityReportInfo::Comment' has a wrong offset!");
static_assert(offsetof(FM1CommunityReportInfo, ReporterCountry) == 0x000028, "Member 'FM1CommunityReportInfo::ReporterCountry' has a wrong offset!");

// ScriptStruct M1Data.M1BuyPayItemInfo
// 0x0008 (0x0008 - 0x0000)
struct FM1BuyPayItemInfo final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BuyPayItemInfo) == 0x000008, "Wrong alignment on FM1BuyPayItemInfo");
static_assert(sizeof(FM1BuyPayItemInfo) == 0x000008, "Wrong size on FM1BuyPayItemInfo");
static_assert(offsetof(FM1BuyPayItemInfo, AccountUid) == 0x000000, "Member 'FM1BuyPayItemInfo::AccountUid' has a wrong offset!");

}

