#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: M1

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "M1Data_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "NetCore_structs.hpp"
#include "AIModule_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"
#include "AnimationCore_structs.hpp"
#include "SlateCore_structs.hpp"
#include "Slate_structs.hpp"
#include "InputCore_structs.hpp"
#include "MovieScene_structs.hpp"
#include "CinematicCamera_structs.hpp"


namespace SDK
{

// Enum M1.EM1AdvantageCalcResult
// NumValues: 0x0004
enum class EM1AdvantageCalcResult : uint8
{
	None                                     = 0,
	Advantage                                = 1,
	Inferiority                              = 2,
	EM1AdvantageCalcResult_MAX               = 3,
};

// Enum M1.EM1WeaponDamageType
// NumValues: 0x0004
enum class EM1WeaponDamageType : uint8
{
	None                                     = 0,
	HitScan                                  = 1,
	Explosion                                = 2,
	EM1WeaponDamageType_MAX                  = 3,
};

// Enum M1.EM1CharacterMeshSlotType
// NumValues: 0x0008
enum class EM1CharacterMeshSlotType : uint8
{
	None                                     = 0,
	Head                                     = 1,
	Body                                     = 2,
	Face                                     = 3,
	Spawn                                    = 4,
	Back                                     = 5,
	Chest                                    = 6,
	EM1CharacterMeshSlotType_MAX             = 7,
};

// Enum M1.EM1AbilityNiagaraParamBindType
// NumValues: 0x0004
enum class EM1AbilityNiagaraParamBindType : uint8
{
	None                                     = 0,
	Sphere                                   = 1,
	Box                                      = 2,
	EM1AbilityNiagaraParamBindType_MAX       = 3,
};

// Enum M1.EM1AimTargetMode
// NumValues: 0x0004
enum class EM1AimTargetMode : uint8
{
	Self                                     = 0,
	Instigator                               = 1,
	AttachParentActor                        = 2,
	EM1AimTargetMode_MAX                     = 3,
};

// Enum M1.EM1ResetType
// NumValues: 0x0004
enum class EM1ResetType : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Quick                                    = 2,
	EM1ResetType_MAX                         = 3,
};

// Enum M1.EM1TaskDependantState
// NumValues: 0x000D
enum class EM1TaskDependantState : uint8
{
	None                                     = 0,
	Spawn_01                                 = 1,
	Spawn_02                                 = 2,
	Spawn_03                                 = 3,
	Idle_01                                  = 4,
	Idle_02                                  = 5,
	Idle_03                                  = 6,
	Despawn_01                               = 7,
	Despawn_02                               = 8,
	Despawn_03                               = 9,
	Activated                                = 10,
	Deactivated                              = 11,
	Max                                      = 12,
};

// Enum M1.EM1WireState
// NumValues: 0x0007
enum class EM1WireState : uint8
{
	None                                     = 0,
	ReadyToFire                              = 1,
	Firing                                   = 2,
	ReadyToPull                              = 3,
	Pulling                                  = 4,
	Cancel                                   = 5,
	EM1WireState_MAX                         = 6,
};

// Enum M1.EM1MiniGameResult
// NumValues: 0x0006
enum class EM1MiniGameResult : uint8
{
	Unknown                                  = 0,
	Fail                                     = 1,
	Success                                  = 2,
	Cancel                                   = 3,
	ForceCancel                              = 4,
	EM1MiniGameResult_MAX                    = 5,
};

// Enum M1.EM1OnlineServiceConnectionState
// NumValues: 0x000C
enum class EM1OnlineServiceConnectionState : uint8
{
	NotLoggedIn                              = 0,
	RequestedLogIn                           = 1,
	ReceivedLogInButNotJoined                = 2,
	RequestedJoinGame                        = 3,
	InTransitionMapToJoinGame                = 4,
	ReceivedJoinGame                         = 5,
	JoinedDedicatedServer                    = 6,
	ReceivedLoginIdFromDedicatedServer       = 7,
	RequestedPlayerCharacterInfoByLoginId    = 8,
	SentPlayerPawnToClient                   = 9,
	ReceivedPawnAndOkay                      = 10,
	EM1OnlineServiceConnectionState_MAX      = 11,
};

// Enum M1.EM1ItemUidCompressionMethod
// NumValues: 0x0004
enum class EM1ItemUidCompressionMethod : uint8
{
	WithUids                                 = 0,
	WithIndexBytes                           = 1,
	WithIndexList                            = 2,
	EM1ItemUidCompressionMethod_MAX          = 3,
};

// Enum M1.EM1PlayableCharacter
// NumValues: 0x0004
enum class EM1PlayableCharacter : uint8
{
	Lepic                                    = 0,
	Viessa                                   = 1,
	Ajax                                     = 2,
	EM1PlayableCharacter_MAX                 = 3,
};

// Enum M1.EM1WaitingForNetwork
// NumValues: 0x0003
enum class EM1WaitingForNetwork : uint8
{
	Trivial                                  = 0,
	TryConnectToAnotherServer                = 1,
	EM1WaitingForNetwork_MAX                 = 2,
};

// Enum M1.EM1CheckDirection
// NumValues: 0x0005
enum class EM1CheckDirection : uint32
{
	Forward                                  = 0,
	Backward                                 = 1,
	Left                                     = 2,
	Right                                    = 3,
	EM1CheckDirection_MAX                    = 4,
};

// Enum M1.EM1BTBlackboardOperation
// NumValues: 0x0003
enum class EM1BTBlackboardOperation : uint8
{
	And                                      = 0,
	Or                                       = 1,
	EM1BTBlackboardOperation_MAX             = 2,
};

// Enum M1.EM1BTBlackboardCondition
// NumValues: 0x0003
enum class EM1BTBlackboardCondition : uint8
{
	BBKey                                    = 0,
	QueryState                               = 1,
	EM1BTBlackboardCondition_MAX             = 2,
};

// Enum M1.EM1ObjectConditionType
// NumValues: 0x0006
enum class EM1ObjectConditionType : uint32
{
	Distance                                 = 0,
	MissionRelated                           = 1,
	Relations                                = 2,
	Random                                   = 3,
	SeekerCount                              = 4,
	EM1ObjectConditionType_MAX               = 5,
};

// Enum M1.EM1WayPointUpdateRule
// NumValues: 0x0004
enum class EM1WayPointUpdateRule : uint32
{
	Next                                     = 0,
	Prev                                     = 1,
	NearestDist                              = 2,
	EM1WayPointUpdateRule_MAX                = 3,
};

// Enum M1.EM1WireDestinationType
// NumValues: 0x0006
enum class EM1WireDestinationType : uint8
{
	Invalid                                  = 0,
	Terrain                                  = 1,
	DebonableParts                           = 2,
	TaggedActor                              = 3,
	InAir                                    = 4,
	EM1WireDestinationType_MAX               = 5,
};

// Enum M1.EM1RecoveryType
// NumValues: 0x0004
enum class EM1RecoveryType : uint8
{
	Value                                    = 0,
	MaxRatio                                 = 1,
	MaxPercent                               = 2,
	EM1RecoveryType_MAX                      = 3,
};

// Enum M1.EM1AbilityTaskWaitState
// NumValues: 0x0004
enum class EM1AbilityTaskWaitState : uint8
{
	WaitingOnGame                            = 1,
	WaitingOnUser                            = 2,
	WaitingOnAvatar                          = 4,
	EM1AbilityTaskWaitState_MAX              = 5,
};

// Enum M1.EM1WaitQueryTagEventType
// NumValues: 0x0005
enum class EM1WaitQueryTagEventType : uint8
{
	None                                     = 0,
	Add                                      = 1,
	Remove                                   = 2,
	AddOrRemove                              = 3,
	EM1WaitQueryTagEventType_MAX             = 4,
};

// Enum M1.EM1AbilityInstancingPolicy
// NumValues: 0x0004
enum class EM1AbilityInstancingPolicy : uint8
{
	Invalid                                  = 0,
	InstancedPerExecution                    = 1,
	InstancedPerActor                        = 2,
	EM1AbilityInstancingPolicy_MAX           = 3,
};

// Enum M1.EM1AbilityActivationMode
// NumValues: 0x0004
enum class EM1AbilityActivationMode : uint8
{
	Deactivated                              = 0,
	Activated                                = 1,
	Canceled                                 = 2,
	EM1AbilityActivationMode_MAX             = 3,
};

// Enum M1.EM1SkillCommitEventSendTimingPolicy
// NumValues: 0x0004
enum class EM1SkillCommitEventSendTimingPolicy : uint8
{
	SkillActivated                           = 0,
	AppliedActiveCost                        = 1,
	AppliedCooltime                          = 2,
	EM1SkillCommitEventSendTimingPolicy_MAX  = 3,
};

// Enum M1.EM1SeasonReinforceSlotState
// NumValues: 0x0006
enum class EM1SeasonReinforceSlotState : uint8
{
	None                                     = 0,
	Locked_LockedRow                         = 1,
	Locked_UnlockedRow                       = 2,
	Unlocked                                 = 3,
	Equipped                                 = 4,
	Max                                      = 5,
};

// Enum M1.EM1PlayerAction
// NumValues: 0x0003
enum class EM1PlayerAction : uint8
{
	Unknown                                  = 0,
	ChangeCharacter                          = 1,
	EM1PlayerAction_MAX                      = 2,
};

// Enum M1.EM1AIMovePurpose
// NumValues: 0x0007
enum class EM1AIMovePurpose : uint8
{
	Stop                                     = 0,
	Search                                   = 1,
	Chase                                    = 2,
	Hide                                     = 3,
	BackMoving                               = 4,
	OtherDuringBattle                        = 5,
	EM1AIMovePurpose_MAX                     = 6,
};

// Enum M1.EM1AIMoveTarget
// NumValues: 0x000B
enum class EM1AIMoveTarget : uint8
{
	None                                     = 0,
	SelfActor                                = 1,
	PrimaryTarget                            = 2,
	ObjectTarget                             = 3,
	HomeLocation                             = 4,
	GoalLocation                             = 5,
	TargetLastLocation                       = 6,
	WayPoint                                 = 7,
	Leader                                   = 8,
	ProtectTarget                            = 9,
	EM1AIMoveTarget_MAX                      = 10,
};

// Enum M1.EM1AIMoveResult
// NumValues: 0x0009
enum class EM1AIMoveResult : uint8
{
	Success                                  = 0,
	SelfActorNotOnNavmesh                    = 1,
	CannotFindPath                           = 2,
	CannotFindTargetVisibleLocation          = 3,
	CannotFindEQSLocation                    = 4,
	AlreadyAtGoal                            = 5,
	MoveRequestFailed                        = 6,
	Unknown                                  = 7,
	EM1AIMoveResult_MAX                      = 8,
};

// Enum M1.EM1ActorPerceivedType
// NumValues: 0x0004
enum class EM1ActorPerceivedType : uint8
{
	None                                     = 0,
	Visible                                  = 1,
	NotVisible                               = 2,
	EM1ActorPerceivedType_MAX                = 3,
};

// Enum M1.EM1AIEventType
// NumValues: 0x000A
enum class EM1AIEventType : uint8
{
	None                                     = 0,
	HomeLocation                             = 1,
	MoveLimitRadius                          = 2,
	MissionLocation                          = 3,
	MoveRange                                = 4,
	WayPoints                                = 5,
	SetAdditionalObjects                     = 6,
	AddAdditionalObjects                     = 7,
	RemoveAdditionalObjects                  = 8,
	EM1AIEventType_MAX                       = 9,
};

// Enum M1.EUIEventType
// NumValues: 0x0010
enum class EUIEventType : uint8
{
	None                                     = 0,
	HitMarker_OnHit                          = 1,
	HitMarker_OnKill                         = 2,
	HitMarker_OnKillByWeakness               = 3,
	Button_OnClicked                         = 4,
	Button_OnHold                            = 5,
	Button_OnPressed                         = 6,
	Button_OnReleased                        = 7,
	Button_OnHovered                         = 8,
	Button_OnUnHovered                       = 9,
	Widget_OnOpened                          = 10,
	Widget_OnClosed                          = 11,
	Widget_OnSelected                        = 12,
	Text_OnChanged                           = 13,
	TaskEvent                                = 14,
	EUIEventType_MAX                         = 15,
};

// Enum M1.EM1MonsterMontageSoundType
// NumValues: 0x0008
enum class EM1MonsterMontageSoundType : uint8
{
	None                                     = 0,
	Threat                                   = 1,
	ThreatOnTargetLost                       = 2,
	Reload                                   = 3,
	Evade                                    = 4,
	StartJump                                = 5,
	Land                                     = 6,
	EM1MonsterMontageSoundType_MAX           = 7,
};

// Enum M1.EValidOutputPin
// NumValues: 0x0003
enum class EValidOutputPin : uint8
{
	IsValid                                  = 1,
	IsNotValid                               = 0,
	EValidOutputPin_MAX                      = 2,
};

// Enum M1.EM1AudioMix
// NumValues: 0x0003
enum class EM1AudioMix : uint8
{
	StudioReference                          = 0,
	HeadPhone                                = 1,
	EM1AudioMix_MAX                          = 2,
};

// Enum M1.EM1AudioPlayContext
// NumValues: 0x0006
enum class EM1AudioPlayContext : uint8
{
	Default                                  = 0,
	MissionDialog                            = 1,
	QuestDialog                              = 2,
	RecordDialog                             = 3,
	SeasonReinforceDialog                    = 4,
	EM1AudioPlayContext_MAX                  = 5,
};

// Enum M1.EM1PlayerAnimType
// NumValues: 0x0006
enum class EM1PlayerAnimType : uint8
{
	Light_0H                                 = 0,
	Light_2H                                 = 1,
	Heavy_0H                                 = 2,
	Heavy_1H                                 = 3,
	Heavy_2H                                 = 4,
	Max                                      = 5,
};

// Enum M1.EM1AnimLocomotionType
// NumValues: 0x0005
enum class EM1AnimLocomotionType : uint8
{
	Default                                  = 0,
	Heavy                                    = 1,
	HandGun                                  = 2,
	BareHand                                 = 3,
	EM1AnimLocomotionType_MAX                = 4,
};

// Enum M1.EM1FootstepTransitionState
// NumValues: 0x0006
enum class EM1FootstepTransitionState : uint8
{
	Default                                  = 0,
	Plant                                    = 1,
	IdleToIdle                               = 2,
	LeftFooting                              = 3,
	RightFooting                             = 4,
	EM1FootstepTransitionState_MAX           = 5,
};

// Enum M1.EM1PlayerInteractionAnimType
// NumValues: 0x000E
enum class EM1PlayerInteractionAnimType : uint8
{
	None                                     = 0,
	PickUp                                   = 1,
	Repair                                   = 2,
	PanelTouch                               = 3,
	PushButton_Horizontal                    = 4,
	PushButton_Vertical                      = 5,
	Scan                                     = 6,
	BioScan                                  = 7,
	VoidScan                                 = 8,
	CutOff                                   = 9,
	Searching                                = 10,
	Kicking                                  = 11,
	EjectingIronHeart                        = 12,
	EM1PlayerInteractionAnimType_MAX         = 13,
};

// Enum M1.EM1AimOffset
// NumValues: 0x0006
enum class EM1AimOffset : uint8
{
	NoAOMode                                 = 0,
	IdleAOMode                               = 1,
	RangedAOMode                             = 2,
	RangedZoomAOMode                         = 3,
	SkillAOMode                              = 4,
	EM1AimOffset_MAX                         = 5,
};

// Enum M1.EM1LayerAnimSetType
// NumValues: 0x0006
enum class EM1LayerAnimSetType : uint8
{
	None                                     = 0,
	Locomotion                               = 1,
	Ability                                  = 2,
	Wire                                     = 3,
	Slot                                     = 4,
	EM1LayerAnimSetType_MAX                  = 5,
};

// Enum M1.EM1TurnInPlaceType
// NumValues: 0x0006
enum class EM1TurnInPlaceType : uint8
{
	None                                     = 0,
	TurnInPlace45L                           = 1,
	TurnInPlace45R                           = 2,
	TurnInPlace90R                           = 3,
	TurnInPlace90L                           = 4,
	EM1TurnInPlaceType_MAX                   = 5,
};

// Enum M1.EComponentActivationControl
// NumValues: 0x0006
enum class EComponentActivationControl : uint8
{
	None                                     = 0,
	Activate                                 = 1,
	Deactivate                               = 2,
	KeepActivate                             = 3,
	KeepDeactivate                           = 4,
	EComponentActivationControl_MAX          = 5,
};

// Enum M1.EM1MeleeAOEType
// NumValues: 0x0003
enum class EM1MeleeAOEType : uint32
{
	Sphere                                   = 0,
	AngularCylinder                          = 1,
	EM1MeleeAOEType_MAX                      = 2,
};

// Enum M1.EM1AssetPreloadPolicy
// NumValues: 0x0004
enum class EM1AssetPreloadPolicy : uint8
{
	Minimum                                  = 0,
	Basic                                    = 1,
	Maximum                                  = 2,
	EM1AssetPreloadPolicy_MAX                = 3,
};

// Enum M1.EM1BattlePassPreviewStageCameraType
// NumValues: 0x0002
enum class EM1BattlePassPreviewStageCameraType : uint8
{
	None                                     = 0,
	EM1BattlePassPreviewStageCameraType_MAX  = 1,
};

// Enum M1.EM1BattleState
// NumValues: 0x0004
enum class EM1BattleState : uint8
{
	NonBattle                                = 0,
	BattleEnd                                = 1,
	InBattle                                 = 2,
	EM1BattleState_MAX                       = 3,
};

// Enum M1.EM1BeamPenetrableType
// NumValues: 0x0004
enum class EM1BeamPenetrableType : uint8
{
	None                                     = 0,
	Character                                = 1,
	All                                      = 2,
	EM1BeamPenetrableType_MAX                = 3,
};

// Enum M1.EM1BeamAimType
// NumValues: 0x0006
enum class EM1BeamAimType : uint8
{
	None                                     = 0,
	Horizontal                               = 1,
	Vertical                                 = 2,
	Both                                     = 3,
	Target                                   = 4,
	EM1BeamAimType_MAX                       = 5,
};

// Enum M1.EM1CampState
// NumValues: 0x0004
enum class EM1CampState : uint8
{
	None                                     = 0,
	NewlyActivated                           = 1,
	AlreadyActivated                         = 2,
	EM1CampState_MAX                         = 3,
};

// Enum M1.EM1CharacterExistanceState
// NumValues: 0x0006
enum class EM1CharacterExistanceState : uint8
{
	None                                     = 0,
	Ghost                                    = 1,
	JustSpawned                              = 2,
	AlreadySpawned                           = 3,
	CustomSpawned                            = 4,
	EM1CharacterExistanceState_MAX           = 5,
};

// Enum M1.EM1CharacterCameraType
// NumValues: 0x0008
enum class EM1CharacterCameraType : uint8
{
	None                                     = 0,
	CenterMale                               = 1,
	CenterFemale                             = 2,
	LeftMale                                 = 3,
	LeftFemale                               = 4,
	RightMale                                = 5,
	RightFemale                              = 6,
	EM1CharacterCameraType_MAX               = 7,
};

// Enum M1.EM1ShowAbilityActorStatType
// NumValues: 0x0004
enum class EM1ShowAbilityActorStatType : uint8
{
	None                                     = 0,
	All                                      = 1,
	Damageable                               = 2,
	EM1ShowAbilityActorStatType_MAX          = 3,
};

// Enum M1.EM1CommuicationPolicy
// NumValues: 0x0004
enum class EM1CommuicationPolicy : uint8
{
	AllowEveryone                            = 0,
	OnlyFriends                              = 1,
	BlockEveryone                            = 2,
	EM1CommuicationPolicy_MAX                = 3,
};

// Enum M1.EM1BackAttachmentAnimType
// NumValues: 0x0005
enum class EM1BackAttachmentAnimType : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Random                                   = 2,
	Jump                                     = 3,
	EM1BackAttachmentAnimType_MAX            = 4,
};

// Enum M1.EM1CustomizeCharacterCamearaType
// NumValues: 0x0009
enum class EM1CustomizeCharacterCamearaType : uint8
{
	None                                     = 0,
	Head                                     = 1,
	Body                                     = 2,
	BackAttachment                           = 3,
	ChestAttachment                          = 4,
	MakeUp                                   = 5,
	SpawnSkin                                = 6,
	Ecive                                    = 205,
	EM1CustomizeCharacterCamearaType_MAX     = 206,
};

// Enum M1.EM1CustomizeCamearaReason
// NumValues: 0x0004
enum class EM1CustomizeCamearaReason : uint8
{
	None                                     = 0,
	Input                                    = 1,
	ZeroVelocity                             = 2,
	EM1CustomizeCamearaReason_MAX            = 3,
};

// Enum M1.EM1CustomizeCharacterParts
// NumValues: 0x0008
enum class EM1CustomizeCharacterParts : uint8
{
	None                                     = 0,
	HeadSkin                                 = 1,
	BodySkin                                 = 2,
	MakeupSkin                               = 3,
	SpawnSkin                                = 4,
	BackAttachment                           = 5,
	ChestAttachment                          = 6,
	EM1CustomizeCharacterParts_MAX           = 7,
};

// Enum M1.EM1CustomizeWeaponCameraType
// NumValues: 0x0005
enum class EM1CustomizeWeaponCameraType : uint8
{
	None                                     = 0,
	Skin                                     = 1,
	SkinPaint                                = 2,
	SkinPaintList                            = 3,
	EM1CustomizeWeaponCameraType_MAX         = 4,
};

// Enum M1.EM1DamagedEffectType
// NumValues: 0x0006
enum class EM1DamagedEffectType : uint8
{
	None                                     = 0,
	HPLoss                                   = 1,
	ShieldLoss                               = 2,
	ShieldBroken                             = 3,
	DeathWarning                             = 4,
	EM1DamagedEffectType_MAX                 = 5,
};

// Enum M1.EM1DamageEventType
// NumValues: 0x0007
enum class EM1DamageEventType : uint8
{
	Default                                  = 0,
	Point                                    = 1,
	Radial                                   = 2,
	Fixed                                    = 3,
	Explosion                                = 4,
	Melee                                    = 5,
	EM1DamageEventType_MAX                   = 6,
};

// Enum M1.EM1DamageTrackingReferenceAxis
// NumValues: 0x0003
enum class EM1DamageTrackingReferenceAxis : uint8
{
	Camera                                   = 0,
	Character                                = 1,
	EM1DamageTrackingReferenceAxis_MAX       = 2,
};

// Enum M1.EM1DamageType
// NumValues: 0x0003
enum class EM1DamageType : uint8
{
	HP                                       = 0,
	Shield                                   = 1,
	EM1DamageType_MAX                        = 2,
};

// Enum M1.EM1MissionSubType
// NumValues: 0x0014
enum class EM1MissionSubType : uint8
{
	Default                                  = 0,
	Destruction                              = 1,
	Defense                                  = 2,
	Supply                                   = 3,
	Collection                               = 4,
	Assasination                             = 5,
	Extermination                            = 6,
	Occupation                               = 7,
	WaveDefense                              = 8,
	ContinuousSurvival                       = 9,
	DataCollection                           = 10,
	Explosion                                = 11,
	Steal                                    = 12,
	Escort                                   = 13,
	MultiCollection                          = 14,
	MultiAssasination                        = 15,
	VoidFragment                             = 16,
	VoidFusion                               = 17,
	DestructionVulgusPost                    = 18,
	EM1MissionSubType_MAX                    = 19,
};

// Enum M1.EM1DataVisualFXTransformRule
// NumValues: 0x0003
enum class EM1DataVisualFXTransformRule : uint8
{
	AttachParent                             = 0,
	HoverParent                              = 1,
	EM1DataVisualFXTransformRule_MAX         = 2,
};

// Enum M1.EM1DestructibleNavAreaType
// NumValues: 0x0003
enum class EM1DestructibleNavAreaType : uint8
{
	Pillar                                   = 0,
	Bridge                                   = 1,
	EM1DestructibleNavAreaType_MAX           = 2,
};

// Enum M1.EM1DoorState
// NumValues: 0x0004
enum class EM1DoorState : uint8
{
	Initial                                  = 0,
	Closed                                   = 1,
	Opened                                   = 2,
	EM1DoorState_MAX                         = 3,
};

// Enum M1.EM1DoorTiming
// NumValues: 0x0003
enum class EM1DoorTiming : uint8
{
	Start                                    = 0,
	End                                      = 1,
	EM1DoorTiming_MAX                        = 2,
};

// Enum M1.EM1DropContainerState
// NumValues: 0x0005
enum class EM1DropContainerState : uint8
{
	NotLaunched                              = 0,
	InSimulating                             = 1,
	Grounded                                 = 2,
	Obtained                                 = 3,
	EM1DropContainerState_MAX                = 4,
};

// Enum M1.EM1DropContainerTryObtainReason
// NumValues: 0x0004
enum class EM1DropContainerTryObtainReason : uint8
{
	NoNavigationFound                        = 0,
	StayTooLongInAir                         = 1,
	EndPlay                                  = 2,
	EM1DropContainerTryObtainReason_MAX      = 3,
};

// Enum M1.EM1DropContainerLocalVisibility
// NumValues: 0x0004
enum class EM1DropContainerLocalVisibility : uint8
{
	NotDetermined                            = 0,
	Visible                                  = 1,
	NotVisible                               = 2,
	EM1DropContainerLocalVisibility_MAX      = 3,
};

// Enum M1.EM1VoidVaultStabilzerState
// NumValues: 0x0006
enum class EM1VoidVaultStabilzerState : uint8
{
	None                                     = 0,
	Spawn                                    = 1,
	Activated                                = 2,
	Despawing                                = 3,
	Despawned                                = 4,
	EM1VoidVaultStabilzerState_MAX           = 5,
};

// Enum M1.EM1MonsterContentType
// NumValues: 0x0005
enum class EM1MonsterContentType : uint8
{
	None                                     = 0,
	FieldSpawn                               = 1,
	MissionTask                              = 2,
	MissionWave                              = 3,
	EM1MonsterContentType_MAX                = 4,
};

// Enum M1.EM1BuildEnvironment
// NumValues: 0x0007
enum class EM1BuildEnvironment : uint8
{
	None                                     = 0,
	Dev                                      = 1,
	Stage                                    = 2,
	Stage2                                   = 3,
	Live                                     = 4,
	Live2                                    = 5,
	EM1BuildEnvironment_MAX                  = 6,
};

// Enum M1.EM1ToyLoginState
// NumValues: 0x0004
enum class EM1ToyLoginState : uint8
{
	NotLogined                               = 0,
	Guest                                    = 1,
	Linked                                   = 2,
	EM1ToyLoginState_MAX                     = 3,
};

// Enum M1.EM1InteractionMethod
// NumValues: 0x0008
enum class EM1InteractionMethod : uint8
{
	FootStep                                 = 0,
	WireCaster                               = 1,
	WireCasterFail                           = 2,
	WireCasterMiss                           = 3,
	MeleeHit                                 = 4,
	InstantHit                               = 5,
	Explosion                                = 6,
	EM1InteractionMethod_MAX                 = 7,
};

// Enum M1.EM1InputKeyCategory
// NumValues: 0x0005
enum class EM1InputKeyCategory : uint8
{
	None                                     = 0,
	SystemKey                                = 1,
	BattleKey                                = 2,
	FKey                                     = 3,
	EM1InputKeyCategory_MAX                  = 4,
};

// Enum M1.EM1SystemKey
// NumValues: 0x00D1
enum class EM1SystemKey : uint8
{
	None                                     = 0,
	Confirm                                  = 1,
	Confirm2                                 = 2,
	Cancel                                   = 3,
	MainTabToLeft                            = 4,
	MainTabToRight                           = 5,
	MainTabToUp                              = 6,
	MainTabToDown                            = 7,
	SubTabToLeft                             = 8,
	SubTabToRight                            = 9,
	ThirdTabToLeft                           = 10,
	ThirdTabToRight                          = 11,
	PageRotation                             = 12,
	PageLeft                                 = 13,
	PageRight                                = 14,
	PageLeftOnlyGamepad                      = 15,
	PageRightOnlyGamepad                     = 16,
	PageLeftOnlyGamepad2                     = 17,
	PageRightOnlyGamepad2                    = 18,
	MVPModeAction                            = 19,
	SwitchToMap                              = 20,
	SwitchToInven                            = 21,
	Pick                                     = 22,
	Equip                                    = 23,
	Unequip                                  = 24,
	MoreInfo                                 = 25,
	DeleteItem                               = 26,
	SocialMotionEquip                        = 27,
	GameStart                                = 28,
	OpenCredit                               = 29,
	ChangeCharacter                          = 30,
	SellCharacter                            = 31,
	OpenOption                               = 32,
	Logout                                   = 33,
	Interaction                              = 34,
	OpenInventoryAfterPurchase               = 35,
	Buy                                      = 36,
	Sell                                     = 37,
	RadialMenuApply                          = 38,
	RadialMenu                               = 39,
	ChangeWeapon                             = 40,
	MoveToCharacter                          = 41,
	MoveToInventory                          = 42,
	MoveToRune                               = 43,
	OpenMasteryRankBenefit                   = 44,
	OpenRuneBoard                            = 45,
	Character                                = 46,
	Liked                                    = 47,
	CaptureMode                              = 48,
	CharacterDetail                          = 49,
	ToggleStatGraph                          = 50,
	CharacterPrevSlot                        = 51,
	CharacterNextSlot                        = 52,
	CharacterSlotChange                      = 53,
	MenuHold                                 = 54,
	Inventory                                = 55,
	JunkSelect                               = 56,
	JunkDelete                               = 57,
	JunkSell                                 = 58,
	JunkDecompose                            = 59,
	SelectAllAsJunk                          = 60,
	ReleaseAllJunk                           = 61,
	ToggleCompareStat                        = 62,
	TooltipScroll                            = 63,
	InvPageUp                                = 64,
	InvPageDown                              = 65,
	InvPageLeft                              = 66,
	InvPageRight                             = 67,
	ItemBookmark                             = 68,
	RemoveItemBookmark                       = 69,
	HPrevSlot                                = 70,
	HNextSlot                                = 71,
	VPrevSlot                                = 72,
	VNextSlot                                = 73,
	ToggleApplyRuneStatInToolTip             = 74,
	ChangeSkin                               = 75,
	Consumable                               = 76,
	BattlePass                               = 77,
	CashShop                                 = 78,
	ShowItemHistory                          = 79,
	RotateItemPreview                        = 80,
	ResetItemPreviewRotation                 = 81,
	StartResearch                            = 82,
	BoostResearch                            = 83,
	StopResearch                             = 84,
	CompleteResearch                         = 85,
	BookmarkResearch                         = 86,
	TraceItem                                = 87,
	ShowResearchDetails                      = 88,
	UnsetAllBookmarks                        = 89,
	PresetApply                              = 90,
	PresetDelete                             = 91,
	WorldMap                                 = 92,
	LocalMap                                 = 93,
	SelectDifficulty                         = 94,
	ToggleNotes                              = 95,
	TeleportToCity                           = 96,
	OpenWorldMap                             = 97,
	OpenLocalMap                             = 98,
	OpenRotationDrop                         = 99,
	SetWayPoint                              = 100,
	Teleport                                 = 101,
	ZoomInOut                                = 102,
	MoveMap                                  = 103,
	ToggleMissionInfo                        = 104,
	OpenMissionInfo                          = 105,
	OpenInvasionMissionInfo                  = 106,
	Quest                                    = 107,
	TrackQuest                               = 108,
	RuneEquipInfoSearch                      = 109,
	ShowOnlyAttachedRunes                    = 110,
	RuneEnchantLevelUp                       = 111,
	RuneEnchantLevelDown                     = 112,
	RuneDecomposeSelectAllDuplicatedRunes    = 113,
	RuneDetachAll                            = 114,
	RuneSave                                 = 115,
	RuneSwitchStatInfo                       = 116,
	ToggleRuneViewType                       = 117,
	PopupSelectFirstOption                   = 118,
	PopupSelectSecondOption                  = 119,
	PlayerMove                               = 120,
	PlayerMoveFront                          = 121,
	PlayerMoveBackward                       = 122,
	PlayerMoveLeft                           = 123,
	PlayerMoveRight                          = 124,
	SelectKeySetting                         = 125,
	DeleteCurrentMail                        = 126,
	DeleteAllReadMail                        = 127,
	ReceiveAttachmentInMail                  = 128,
	ReceiveAllAttachmentsInMail              = 129,
	VoidBattleStart                          = 130,
	VoidBattleCancel                         = 131,
	VoidBattleShowLinkedContents             = 132,
	VoidBattleShowLinkedStabilizer           = 133,
	ResetOption                              = 134,
	ApplyOption                              = 135,
	ResetKeyOption                           = 136,
	ConfirmOptionPopup                       = 137,
	ExitWithoutApply                         = 138,
	SkipDialogHold                           = 139,
	SkipDialogInstant                        = 140,
	SearchUser                               = 141,
	EventPageOpen                            = 142,
	Chatting                                 = 143,
	Chatting_ChangeTab                       = 144,
	Chatting_ChangeType                      = 145,
	Pause                                    = 146,
	CreditScroll                             = 147,
	MissionResult_RestartMission             = 148,
	MissionResult_RestartTogether            = 149,
	MissionResult_RestartAlone               = 150,
	MissionResult_ShowStatistics             = 151,
	MissionResult_ShowRewarded               = 152,
	RegisterItem                             = 153,
	UnregisterItem                           = 154,
	CustomizeTransition                      = 155,
	CustomizeRotation                        = 156,
	CustomizeZoom                            = 157,
	CustomizeReset                           = 158,
	CustomizeItemPreview                     = 159,
	CustomizeChangePaint                     = 160,
	CustomizeApplyPaint                      = 161,
	CustomizeUseInformation                  = 162,
	GuideHoldButton                          = 163,
	Report                                   = 164,
	BattlePassPageBuy                        = 165,
	BattlePassDetailView                     = 166,
	StartTrackingChallenge                   = 167,
	StopTrackingChallenge                    = 168,
	ToggleTrackingChallenge                  = 169,
	MinusTen                                 = 170,
	MinusOne                                 = 171,
	PlusOne                                  = 172,
	PlusTen                                  = 173,
	TitleUnequip                             = 174,
	TitleApply                               = 175,
	BuySlotExpansion                         = 176,
	CurrencyInternal                         = 177,
	ToggleDetails                            = 178,
	SubBundlePreview                         = 179,
	SubBundleDetail                          = 180,
	MiniGameTimingRing_StopNeedle_Left       = 181,
	MiniGameTimingRing_StopNeedle_Right      = 182,
	Codex_DetailInfo                         = 183,
	Codex_ToggleTracking                     = 184,
	OpenGroupQuestList                       = 185,
	ShowSchedule                             = 186,
	ApplyChange                              = 187,
	ShowPaintGroup                           = 188,
	ChangePaintGroup                         = 189,
	ChangeToPrevPaintGroup                   = 190,
	ChangeToNextPaintGroup                   = 191,
	ClosePaintExtractPopup                   = 192,
	SkipRandomOptionChangeAnim               = 193,
	ShowProb                                 = 194,
	RequestSupportAll                        = 195,
	RequestSupportFriend                     = 196,
	ToCharacterShortcut                      = 197,
	ClearReinforceAll                        = 198,
	UnlockReinforceSlot                      = 199,
	EquipReinforceSlot                       = 200,
	UnEquipReinforceSlot                     = 201,
	PurchasePaint                            = 202,
	Trace_Back                               = 203,
	Trace_Close                              = 204,
	Codex                                    = 205,
	Journal                                  = 206,
	Social                                   = 207,
	Max                                      = 208,
};

// Enum M1.EM1BattleKey
// NumValues: 0x0031
enum class EM1BattleKey : uint8
{
	None                                     = 0,
	Sprint                                   = 1,
	Jump                                     = 2,
	Evade                                    = 3,
	Skill1                                   = 4,
	Skill2                                   = 5,
	Skill3                                   = 6,
	Skill4                                   = 7,
	SubSkill                                 = 8,
	Action1                                  = 9,
	Action2                                  = 10,
	Reload                                   = 11,
	NextWeapon                               = 12,
	PrevWeapon                               = 13,
	WeaponShortcut1                          = 14,
	WeaponShortcut2                          = 15,
	WeaponShortcut3                          = 16,
	WeaponChangeHold                         = 17,
	WireAction                               = 18,
	Rescue                                   = 19,
	GiveUpRescue                             = 20,
	WorldMap                                 = 21,
	LocalMap                                 = 22,
	Inventory                                = 23,
	Character                                = 24,
	Quest                                    = 25,
	Menu                                     = 26,
	MenuHold                                 = 27,
	Help                                     = 28,
	Interaction                              = 29,
	InteractionWithPlayer                    = 30,
	Chatting                                 = 31,
	ToastHoldButton                          = 32,
	RadialMenu                               = 33,
	ToggleObjectivePanel                     = 34,
	Matching                                 = 35,
	Consumable                               = 36,
	BattlePass                               = 37,
	CashShop                                 = 38,
	Codex                                    = 39,
	Journal                                  = 40,
	Social                                   = 41,
	Detecting                                = 42,
	IncreaseMouseSensitivity                 = 43,
	DecreaseMouseSensitivity                 = 44,
	PushToTalk                               = 45,
	CompositeSettingsOnly                    = 46,
	TeleportToCity                           = 47,
	Max                                      = 48,
};

// Enum M1.EM1BattleAxis
// NumValues: 0x0008
enum class EM1BattleAxis : uint8
{
	None                                     = 0,
	MoveForward                              = 1,
	MoveRight                                = 2,
	Move                                     = 3,
	Turn                                     = 4,
	LookUp                                   = 5,
	CameraRate                               = 6,
	EM1BattleAxis_MAX                        = 7,
};

// Enum M1.EM1InputBindActorPriority
// NumValues: 0x0005
enum class EM1InputBindActorPriority : uint8
{
	None                                     = 0,
	Bottom                                   = 1,
	Ability                                  = 2,
	UI                                       = 3,
	MAX                                      = 4,
};

// Enum M1.EM1BannerType
// NumValues: 0x0005
enum class EM1BannerType : uint8
{
	None                                     = 0,
	MaintenanceNotice                        = 1,
	LobbyEnter                               = 2,
	NoticeButton                             = 3,
	EM1BannerType_MAX                        = 4,
};

// Enum M1.EM1UIPlatform
// NumValues: 0x0005
enum class EM1UIPlatform : uint8
{
	None                                     = 0,
	PC                                       = 1,
	PS                                       = 2,
	XBOX                                     = 3,
	EM1UIPlatform_MAX                        = 4,
};

// Enum M1.EM1Platform
// NumValues: 0x000C
enum class EM1Platform : uint8
{
	None                                     = 0,
	PC                                       = 1,
	PS4_Normal                               = 2,
	PS4_Pro                                  = 3,
	PS5                                      = 4,
	PS5_Trinity                              = 5,
	XB1                                      = 6,
	XB1S                                     = 7,
	XB1X                                     = 8,
	XSS                                      = 9,
	XSX                                      = 10,
	EM1Platform_MAX                          = 11,
};

// Enum M1.EM1PlatformSimple
// NumValues: 0x0004
enum class EM1PlatformSimple : uint8
{
	WINDOWS                                  = 0,
	PS                                       = 1,
	XBOX                                     = 2,
	EM1PlatformSimple_MAX                    = 3,
};

// Enum M1.EM1GamepadPlatform
// NumValues: 0x0005
enum class EM1GamepadPlatform : uint8
{
	None                                     = 0,
	XBox                                     = 1,
	DualSense                                = 2,
	DualShock                                = 3,
	EM1GamepadPlatform_MAX                   = 4,
};

// Enum M1.EM1MatchingStatus
// NumValues: 0x0007
enum class EM1MatchingStatus : uint8
{
	None                                     = 0,
	RequestStart                             = 1,
	RequestDone                              = 2,
	Start                                    = 3,
	Success                                  = 4,
	MoveToDedi                               = 5,
	EM1MatchingStatus_MAX                    = 6,
};

// Enum M1.EM1MatchType
// NumValues: 0x0005
enum class EM1MatchType : uint8
{
	None                                     = 0,
	VoidBattle                               = 1,
	WorldMission                             = 2,
	InstanceDungeon                          = 3,
	EM1MatchType_MAX                         = 4,
};

// Enum M1.EM1PartyEntranceReason
// NumValues: 0x0009
enum class EM1PartyEntranceReason : uint8
{
	Success                                  = 0,
	FailedToLocalPlayerConditionMetForMission = 1,
	FailedToPartyMemberConditionMetForMission = 2,
	FailedToPartyMemberInvasionExpReachesToLimit = 3,
	CannotFoundLocalPlayerControlComponent   = 4,
	CannotFoundPartyMemberPC                 = 5,
	CannotFoundPartyMemberPCInGame           = 6,
	ETC                                      = 7,
	EM1PartyEntranceReason_MAX               = 8,
};

// Enum M1.EM1HangOnType
// NumValues: 0x0004
enum class EM1HangOnType : uint8
{
	None                                     = 0,
	Vertical                                 = 1,
	Horizon                                  = 2,
	EM1HangOnType_MAX                        = 3,
};

// Enum M1.EM1RespawnMode
// NumValues: 0x0005
enum class EM1RespawnMode : uint8
{
	None                                     = 0,
	Prologue                                 = 1,
	VoidBattle                               = 2,
	MissionWaveSurvival                      = 3,
	EM1RespawnMode_MAX                       = 4,
};

// Enum M1.EM1RecoverSupplyType
// NumValues: 0x0007
enum class EM1RecoverSupplyType : uint8
{
	Recover                                  = 0,
	Resurrect                                = 1,
	Respawn                                  = 2,
	LevelUp                                  = 3,
	RefillSpareRounds                        = 4,
	MissionCheckPoint                        = 5,
	MAX                                      = 6,
};

// Enum M1.EM1BossGameGuideCondition
// NumValues: 0x0004
enum class EM1BossGameGuideCondition : uint8
{
	CanDebone                                = 0,
	PartsDestruction                         = 1,
	Debone                                   = 2,
	EM1BossGameGuideCondition_MAX            = 3,
};

// Enum M1.EM1ElementSelectType
// NumValues: 0x0004
enum class EM1ElementSelectType : uint8
{
	Random                                   = 0,
	Lowest                                   = 1,
	Highest                                  = 2,
	EM1ElementSelectType_MAX                 = 3,
};

// Enum M1.EM1DynamicDialogueStimulus
// NumValues: 0x0023
enum class EM1DynamicDialogueStimulus : uint8
{
	SkillOffensive                           = 0,
	SkillCrowdControl                        = 1,
	SkillBuff                                = 2,
	SkillSpecial                             = 3,
	SkillOffensive_Mod                       = 4,
	SkillCrowdControl_Mod                    = 5,
	SkillBuff_Mod                            = 6,
	SkillSpecial_Mod                         = 7,
	Shout                                    = 8,
	Reload                                   = 9,
	Death                                    = 10,
	DBNO                                     = 11,
	Rescue                                   = 12,
	Revive                                   = 13,
	JoinMission                              = 14,
	RegisteredCamp                           = 15,
	WireFired                                = 16,
	SelectHero                               = 17,
	Debone                                   = 18,
	DeboneSuccess                            = 19,
	EpicMonsterFinalBlow                     = 20,
	EmptyRounds_General                      = 21,
	EmptyRounds_Enhanced                     = 22,
	EmptyRounds_Impact                       = 23,
	EmptyRounds_Highpower                    = 24,
	Damaged_Common                           = 25,
	Damaged_ShieldBroken                     = 26,
	Damaged_DeathWarning                     = 27,
	EnteringArea                             = 28,
	Melee_S                                  = 29,
	Melee_M                                  = 30,
	Jump                                     = 31,
	Land_H                                   = 32,
	SocialMotion                             = 33,
	EM1DynamicDialogueStimulus_MAX           = 34,
};

// Enum M1.EM1SortDirection
// NumValues: 0x0003
enum class EM1SortDirection : uint8
{
	Descending                               = 0,
	Ascending                                = 1,
	EM1SortDirection_MAX                     = 2,
};

// Enum M1.EM1SortOption
// NumValues: 0x0019
enum class EM1SortOption : uint8
{
	None                                     = 0,
	Basic                                    = 1,
	Latest                                   = 2,
	Level                                    = 3,
	Tier                                     = 4,
	Category                                 = 5,
	Junks                                    = 6,
	Name                                     = 7,
	DPS                                      = 8,
	Tid                                      = 9,
	RuneCost                                 = 10,
	Quantity                                 = 11,
	Enchant                                  = 12,
	Socket                                   = 13,
	Progress                                 = 14,
	Unread                                   = 15,
	Attachment                               = 16,
	PerkLevel                                = 17,
	Enchant_Reactor                          = 18,
	BattleZone                               = 19,
	Bounding                                 = 20,
	Proficiency                              = 21,
	RuneCount                                = 22,
	RuneCapacity                             = 23,
	Max                                      = 24,
};

// Enum M1.EM1FilterOption
// NumValues: 0x0011
enum class EM1FilterOption : uint8
{
	None                                     = 0,
	Tier                                     = 1,
	EquipmentCategory                        = 2,
	SocketType                               = 3,
	RoundType                                = 4,
	EquipItemClassType                       = 5,
	ResearchStatus                           = 6,
	RuneClassType                            = 7,
	QuestState                               = 8,
	CustomizingCategory                      = 9,
	EventType                                = 10,
	ElementType                              = 11,
	ArcheType                                = 12,
	Bounding                                 = 13,
	SkillType                                = 14,
	BasicOption                              = 15,
	EM1FilterOption_MAX                      = 16,
};

// Enum M1.EM1JunkFilterOption
// NumValues: 0x0013
enum class EM1JunkFilterOption : uint8
{
	None                                     = 0,
	WeaponTier                               = 1,
	WeaponLevel                              = 2,
	WeaponPerkEnchant                        = 3,
	ReactorTier                              = 4,
	ReactorLevel                             = 5,
	ReactorEnhance                           = 6,
	AccessoryTier                            = 7,
	AccessoryLevel                           = 8,
	AccessorySetOption                       = 9,
	ReactorUseRandomOption                   = 10,
	ReactorRandomOptionTier_All              = 11,
	ReactorRandomOptionTier_Each             = 12,
	AccessoryUseRandomOption                 = 13,
	AccessoryRandomOptionTier_All            = 14,
	AccessoryRandomOptionTier_Each           = 15,
	ReactorMatchedOptionCount                = 16,
	AccessoryMatchedOptionCount              = 17,
	EM1JunkFilterOption_MAX                  = 18,
};

// Enum M1.EM1AlignmentType
// NumValues: 0x0006
enum class EM1AlignmentType : uint8
{
	Center                                   = 0,
	Left                                     = 1,
	Right                                    = 2,
	Top                                      = 3,
	Bottom                                   = 4,
	EM1AlignmentType_MAX                     = 5,
};

// Enum M1.EM1PositionType
// NumValues: 0x0006
enum class EM1PositionType : uint8
{
	None                                     = 0,
	Top                                      = 1,
	Bottom                                   = 2,
	Left                                     = 3,
	Right                                    = 4,
	EM1PositionType_MAX                      = 5,
};

// Enum M1.EM1DBNOContentsType
// NumValues: 0x0005
enum class EM1DBNOContentsType : uint8
{
	Default                                  = 0,
	VoidBattle                               = 1,
	MissionWaveSurvival                      = 2,
	RetriableTask                            = 3,
	Max                                      = 255,
};

// Enum M1.EM1AimAssistType
// NumValues: 0x0006
enum class EM1AimAssistType : uint8
{
	None                                     = 0,
	AimMagnet                                = 1,
	StickyAim                                = 2,
	AimRotate                                = 3,
	AimSlowdown                              = 4,
	EM1AimAssistType_MAX                     = 5,
};

// Enum M1.EM1MouseVisibilityFlag
// NumValues: 0x000A
enum class EM1MouseVisibilityFlag : uint8
{
	None                                     = 0,
	VirtualCursor                            = 1,
	GameContentSelector                      = 2,
	Cinematic                                = 4,
	RingMenuOnGamepad                        = 8,
	LoginMenuWaitInput                       = 16,
	Navigation                               = 32,
	UICaptureMode                            = 64,
	Visible                                  = 127,
	EM1MouseVisibilityFlag_MAX               = 128,
};

// Enum M1.EM1MouseCursorStateFlag
// NumValues: 0x0004
enum class EM1MouseCursorStateFlag : uint8
{
	Default                                  = 0,
	Hover                                    = 1,
	PickAndDrag                              = 2,
	EM1MouseCursorStateFlag_MAX              = 3,
};

// Enum M1.EM1MouseCursorState
// NumValues: 0x0004
enum class EM1MouseCursorState : uint8
{
	Default                                  = 0,
	Hover                                    = 1,
	PickAndDrag                              = 2,
	EM1MouseCursorState_MAX                  = 3,
};

// Enum M1.EM1CommunicationType
// NumValues: 0x0006
enum class EM1CommunicationType : uint8
{
	Chatting                                 = 0,
	VoiceChatting                            = 1,
	InviteFriend                             = 2,
	InviteParty                              = 3,
	RequestSupport                           = 4,
	EM1CommunicationType_MAX                 = 5,
};

// Enum M1.EM1CommunicateCheckResult
// NumValues: 0x0006
enum class EM1CommunicateCheckResult : uint8
{
	CanCommunicate                           = 0,
	CannotCommunicate                        = 1,
	CannotCommunicateDueToPlatformQuery      = 2,
	Pending                                  = 3,
	None                                     = 4,
	EM1CommunicateCheckResult_MAX            = 5,
};

// Enum M1.EM1FriendInviteOption
// NumValues: 0x0004
enum class EM1FriendInviteOption : uint8
{
	None                                     = 0,
	AllPossible                              = 1,
	Impossible                               = 2,
	EM1FriendInviteOption_MAX                = 3,
};

// Enum M1.EM1RequestSupportOption
// NumValues: 0x0005
enum class EM1RequestSupportOption : uint8
{
	None                                     = 0,
	AllPossible                              = 1,
	FriendOnly                               = 2,
	Impossible                               = 3,
	EM1RequestSupportOption_MAX              = 4,
};

// Enum M1.EM1ChatRangeOption
// NumValues: 0x0005
enum class EM1ChatRangeOption : uint8
{
	None                                     = 0,
	AllPossible                              = 1,
	FriendOnly                               = 2,
	Impossible                               = 3,
	EM1ChatRangeOption_MAX                   = 4,
};

// Enum M1.EM1CrossPlatformChatRangeOption
// NumValues: 0x0005
enum class EM1CrossPlatformChatRangeOption : uint8
{
	None                                     = 0,
	AllPossible                              = 1,
	FriendOnly                               = 2,
	Impossible                               = 3,
	EM1CrossPlatformChatRangeOption_MAX      = 4,
};

// Enum M1.EM1RuneSocketOwnerType
// NumValues: 0x0004
enum class EM1RuneSocketOwnerType : uint8
{
	None                                     = 0,
	Character                                = 1,
	Weapon                                   = 2,
	EM1RuneSocketOwnerType_MAX               = 3,
};

// Enum M1.EM1CustomizePageType
// NumValues: 0x0011
enum class EM1CustomizePageType : uint8
{
	None                                     = 0,
	Character                                = 1,
	CharacterSkin                            = 2,
	CharacterSkinPaint                       = 3,
	WeaponList                               = 4,
	WeaponSkin                               = 5,
	WeaponSkinPaint                          = 6,
	GrapplingHook                            = 7,
	Spawn                                    = 8,
	UITheme                                  = 9,
	NameCard                                 = 10,
	SocialMotion                             = 11,
	LobbyMotion                              = 12,
	CharacterSkinPaintList                   = 13,
	WeaponSkinPaintList                      = 14,
	Ecive                                    = 15,
	EM1CustomizePageType_MAX                 = 16,
};

// Enum M1.EM1ItemBoundStatus
// NumValues: 0x0006
enum class EM1ItemBoundStatus : uint8
{
	NoBoundable                              = 0,
	BeforeBounded                            = 1,
	AlreadyBounded                           = 2,
	AlreadyBoundedAndZero                    = 3,
	FreelyAvailable                          = 4,
	EM1ItemBoundStatus_MAX                   = 5,
};

// Enum M1.EM1MiniGameDifficulty
// NumValues: 0x0005
enum class EM1MiniGameDifficulty : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Hard                                     = 2,
	VeryHard                                 = 3,
	EM1MiniGameDifficulty_MAX                = 4,
};

// Enum M1.EM1MissionScoreType
// NumValues: 0x0005
enum class EM1MissionScoreType : uint8
{
	None                                     = 0,
	TaskSuccess                              = 1,
	MonsterKill                              = 2,
	Bonus                                    = 3,
	EM1MissionScoreType_MAX                  = 4,
};

// Enum M1.EM1QuestDirection_NpcDialogType
// NumValues: 0x0005
enum class EM1QuestDirection_NpcDialogType : uint8
{
	None                                     = 0,
	BeforeStart                              = 1,
	Begin                                    = 2,
	Complete                                 = 3,
	EM1QuestDirection_MAX                    = 4,
};

// Enum M1.EM1ItemStatus
// NumValues: 0x0004
enum class EM1ItemStatus : uint8
{
	Unknown                                  = 0,
	Normal                                   = 1,
	NewlyObtained                            = 2,
	EM1ItemStatus_MAX                        = 3,
};

// Enum M1.EM1EnvTestDistance
// NumValues: 0x0005
enum class EM1EnvTestDistance : uint8
{
	Distance3D                               = 0,
	Distance2D                               = 1,
	DistanceZ                                = 2,
	DistanceAbsoluteZ                        = 3,
	EM1EnvTestDistance_MAX                   = 4,
};

// Enum M1.EM1EpicMonsterCrowdControlState
// NumValues: 0x0004
enum class EM1EpicMonsterCrowdControlState : uint8
{
	None                                     = 0,
	BigGroggy                                = 1,
	SmallGroggy                              = 2,
	EM1EpicMonsterCrowdControlState_MAX      = 3,
};

// Enum M1.EM1EpicMonsterState
// NumValues: 0x0007
enum class EM1EpicMonsterState : uint8
{
	SphereSpawning                           = 0,
	VoidSpawning                             = 1,
	CustomSpawning                           = 2,
	Alive                                    = 3,
	Despawning                               = 4,
	Dead                                     = 5,
	EM1EpicMonsterState_MAX                  = 6,
};

// Enum M1.EM1EpicMonsterSphereState
// NumValues: 0x0007
enum class EM1EpicMonsterSphereState : uint8
{
	None                                     = 0,
	SphereSpawning                           = 1,
	SphereAlive                              = 2,
	SphereFading                             = 3,
	SphereDespawning                         = 4,
	SphereDead                               = 5,
	EM1EpicMonsterSphereState_MAX            = 6,
};

// Enum M1.EM1FieldInteractableState
// NumValues: 0x0005
enum class EM1FieldInteractableState : uint8
{
	Spawned                                  = 0,
	Activated                                = 1,
	Despawning                               = 2,
	Despawned                                = 3,
	EM1FieldInteractableState_MAX            = 4,
};

// Enum M1.EM1SkillFTestTrigger
// NumValues: 0x0007
enum class EM1SkillFTestTrigger : uint8
{
	SimulateBattleKey                        = 0,
	Wait                                     = 1,
	TakeAmountDamage                         = 2,
	FireRangedWeapon                         = 3,
	MonsterAttack                            = 4,
	MoveFoward                               = 5,
	EM1SkillFTestTrigger_MAX                 = 6,
};

// Enum M1.EM1SkillFTestCase
// NumValues: 0x000D
enum class EM1SkillFTestCase : uint8
{
	DamageOnMonster                          = 0,
	DamageOnPlayer                           = 1,
	DamageOnAbilityActor                     = 2,
	WatchMonsterStat                         = 3,
	WatchPlayerStat                          = 4,
	StatusEffectOnPlayer                     = 5,
	StatusEffectOnMonster                    = 6,
	StatusEffectOnSummons                    = 7,
	SpawnAbilityActor                        = 8,
	SpawnSummons                             = 9,
	AltWeapon                                = 10,
	AbilityEventTags                         = 11,
	EM1SkillFTestCase_MAX                    = 12,
};

// Enum M1.EM1SkillFTestLockOnType
// NumValues: 0x0006
enum class EM1SkillFTestLockOnType : uint8
{
	None                                     = 0,
	TestMonster                              = 1,
	TestMonster_Ground                       = 2,
	SpawnedAbilityActor                      = 3,
	SpawnedSummons                           = 4,
	EM1SkillFTestLockOnType_MAX              = 5,
};

// Enum M1.EM1SkillFTestExpected
// NumValues: 0x0005
enum class EM1SkillFTestExpected : uint8
{
	ChangedOrNotEquals                       = 0,
	NotChangedOrEquals                       = 1,
	Increased                                = 2,
	Decreased                                = 3,
	EM1SkillFTestExpected_MAX                = 4,
};

// Enum M1.EM1CameraSensitivityType
// NumValues: 0x0004
enum class EM1CameraSensitivityType : uint8
{
	Mouse                                    = 1,
	GamePad                                  = 2,
	All                                      = 255,
	EM1CameraSensitivityType_MAX             = 256,
};

// Enum M1.EM1AimAssistAdditionalOperation
// NumValues: 0x0002
enum class EM1AimAssistAdditionalOperation : uint8
{
	IgnoreImmune                             = 0,
	EM1AimAssistAdditionalOperation_MAX      = 1,
};

// Enum M1.EM1MissionTaskDropType
// NumValues: 0x0007
enum class EM1MissionTaskDropType : uint8
{
	None                                     = 0,
	Collect                                  = 1,
	Supply                                   = 2,
	WaveSurvivalFilter                       = 3,
	WaveSurvivalTank                         = 4,
	Explosive                                = 5,
	EM1MissionTaskDropType_MAX               = 6,
};

// Enum M1.EM1GameGuideType
// NumValues: 0x0004
enum class EM1GameGuideType : uint8
{
	Game                                     = 0,
	Meta                                     = 1,
	Video                                    = 2,
	EM1GameGuideType_MAX                     = 3,
};

// Enum M1.EM1GameGuideStartConditionType
// NumValues: 0x000A
enum class EM1GameGuideStartConditionType : uint8
{
	None                                     = 0,
	InArea                                   = 1,
	CheckConditionManually                   = 2,
	QuestClear                               = 3,
	OpenWidget                               = 4,
	GetItem                                  = 5,
	MissionClear                             = 6,
	ResearchClear                            = 7,
	BattlePassLevel                          = 8,
	EM1GameGuideStartConditionType_MAX       = 9,
};

// Enum M1.EM1GameGuideEndConditionType
// NumValues: 0x0008
enum class EM1GameGuideEndConditionType : uint8
{
	None                                     = 0,
	TimeOut                                  = 1,
	PressSystemKey                           = 2,
	PressBattleKey                           = 3,
	OpenWidget                               = 4,
	CloseWidget                              = 5,
	EquipItem                                = 6,
	EM1GameGuideEndConditionType_MAX         = 7,
};

// Enum M1.EM1ResearchClearType
// NumValues: 0x0004
enum class EM1ResearchClearType : uint8
{
	All                                      = 0,
	Type                                     = 1,
	Target                                   = 2,
	EM1ResearchClearType_MAX                 = 3,
};

// Enum M1.EM1ConsolePlatform
// NumValues: 0x0005
enum class EM1ConsolePlatform : uint8
{
	None                                     = 0,
	XSX                                      = 1,
	PS4                                      = 2,
	PS5                                      = 3,
	EM1ConsolePlatform_MAX                   = 4,
};

// Enum M1.EM1AxisScaleSign
// NumValues: 0x0004
enum class EM1AxisScaleSign : uint8
{
	None                                     = 0,
	Positive                                 = 1,
	Negative                                 = 2,
	EM1AxisScaleSign_MAX                     = 3,
};

// Enum M1.EM1KeyDuplicateReason
// NumValues: 0x0005
enum class EM1KeyDuplicateReason : uint8
{
	None                                     = 0,
	BySystemKey                              = 1,
	ByBattleKey                              = 2,
	ByOptionKey                              = 3,
	EM1KeyDuplicateReason_MAX                = 4,
};

// Enum M1.EM1OptionValueKeySettingType
// NumValues: 0x0005
enum class EM1OptionValueKeySettingType : uint8
{
	None                                     = 0,
	Main                                     = 1,
	Sub                                      = 2,
	Both                                     = 3,
	EM1OptionValueKeySettingType_MAX         = 4,
};

// Enum M1.EM1ItemRemoveFailureType
// NumValues: 0x0003
enum class EM1ItemRemoveFailureType : uint8
{
	Equipped                                 = 0,
	Undeletable                              = 1,
	EM1ItemRemoveFailureType_MAX             = 2,
};

// Enum M1.EM1ClientDataStorageType
// NumValues: 0x0004
enum class EM1ClientDataStorageType : uint8
{
	Common                                   = 0,
	Player                                   = 1,
	Test                                     = 2,
	EM1ClientDataStorageType_MAX             = 3,
};

// Enum M1.EM1GameplayDebuggerShape
// NumValues: 0x000C
enum class EM1GameplayDebuggerShape : uint8
{
	Invalid                                  = 0,
	Point                                    = 1,
	Segment                                  = 2,
	Box                                      = 3,
	Cone                                     = 4,
	Cylinder                                 = 5,
	Circle                                   = 6,
	Capsule                                  = 7,
	Polygon                                  = 8,
	Arrow                                    = 9,
	Sphere                                   = 10,
	EM1GameplayDebuggerShape_MAX             = 11,
};

// Enum M1.EM1QualityPreset
// NumValues: 0x0007
enum class EM1QualityPreset : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Highest                                  = 3,
	Auto                                     = 4,
	Customized                               = 5,
	EM1QualityPreset_MAX                     = 6,
};

// Enum M1.EM1ConsoleQuality
// NumValues: 0x0006
enum class EM1ConsoleQuality : uint8
{
	None                                     = 0,
	FidelityMode                             = 1,
	Balanced                                 = 2,
	PerformanceMode                          = 3,
	HighFrameRatePerformance                 = 4,
	EM1ConsoleQuality_MAX                    = 5,
};

// Enum M1.EM1TSRQuality
// NumValues: 0x0005
enum class EM1TSRQuality : uint8
{
	Quality                                  = 0,
	Balanced                                 = 1,
	Performance                              = 2,
	UltraPerformance                         = 3,
	EM1TSRQuality_MAX                        = 4,
};

// Enum M1.EM1FSRQuality
// NumValues: 0x0006
enum class EM1FSRQuality : uint8
{
	NativeAA                                 = 0,
	Quality                                  = 1,
	Balanced                                 = 2,
	Performance                              = 3,
	UltraPerformance                         = 4,
	EM1FSRQuality_MAX                        = 5,
};

// Enum M1.EM1Upscaler
// NumValues: 0x0006
enum class EM1Upscaler : uint8
{
	None                                     = 0,
	DLSS                                     = 1,
	FSR                                      = 2,
	XESS                                     = 3,
	TSR                                      = 4,
	EM1Upscaler_MAX                          = 5,
};

// Enum M1.EM1FollowSocialMotionOccupationRule
// NumValues: 0x0003
enum class EM1FollowSocialMotionOccupationRule : uint32
{
	DirectAccess                             = 0,
	SequentialAccess                         = 1,
	EM1FollowSocialMotionOccupationRule_MAX  = 2,
};

// Enum M1.EM1FollowSocialMotionOccupationState
// NumValues: 0x0009
enum class EM1FollowSocialMotionOccupationState : uint8
{
	None                                     = 0,
	P1                                       = 1,
	P2                                       = 2,
	P3                                       = 4,
	P1_P2                                    = 3,
	P1_P3                                    = 5,
	P2_P3                                    = 6,
	P1_P2_P3                                 = 7,
	EM1FollowSocialMotionOccupationState_MAX = 8,
};

// Enum M1.EM1CollectPingStatus
// NumValues: 0x0005
enum class EM1CollectPingStatus : uint8
{
	Idle                                     = 0,
	Collecting                               = 1,
	Success                                  = 2,
	Fail                                     = 3,
	EM1CollectPingStatus_MAX                 = 4,
};

// Enum M1.EM1BattleKeyPreset
// NumValues: 0x0004
enum class EM1BattleKeyPreset : uint8
{
	Default                                  = 0,
	LeftHanded                               = 1,
	Customized                               = 2,
	EM1BattleKeyPreset_MAX                   = 3,
};

// Enum M1.EM1BattleAxisPreset
// NumValues: 0x0003
enum class EM1BattleAxisPreset : uint8
{
	Default                                  = 0,
	LeftHanded                               = 1,
	EM1BattleAxisPreset_MAX                  = 2,
};

// Enum M1.EM1InstanceDungeonScoreType
// NumValues: 0x0005
enum class EM1InstanceDungeonScoreType : uint8
{
	None                                     = 0,
	TaskSuccess                              = 1,
	MonsterKill                              = 2,
	Bonus                                    = 3,
	EM1InstanceDungeonScoreType_MAX          = 4,
};

// Enum M1.EM1ConsumeResult
// NumValues: 0x0009
enum class EM1ConsumeResult : uint8
{
	Unknown                                  = 0,
	Success                                  = 1,
	NotUsable                                = 2,
	EquipmentSlotIsAlreadyMax                = 3,
	WarehouseSlotIsAlreadyMax                = 4,
	CharacterSlotIsAlreadyMax                = 5,
	ConsumableSlotIsAlreadyMax               = 6,
	PresetSlotIsAlreadyMax                   = 7,
	EM1ConsumeResult_MAX                     = 8,
};

// Enum M1.EM1RunePopupType
// NumValues: 0x0006
enum class EM1RunePopupType : uint8
{
	None                                     = 0,
	CapacityExceeded                         = 1,
	DuplicatedRune                           = 2,
	SubTypeMismatched                        = 3,
	Others                                   = 4,
	EM1RunePopupType_MAX                     = 5,
};

// Enum M1.EM1VisibilityFilter
// NumValues: 0x0009
enum class EM1VisibilityFilter : uint8
{
	None                                     = 0,
	HidePlayers                              = 1,
	HideMonsters                             = 2,
	HideAllNPCs                              = 4,
	HideAllAbilities                         = 8,
	HideAllFieldObjects                      = 16,
	HideAllCharacters                        = 7,
	HideAll                                  = 31,
	Max                                      = 32,
};

// Enum M1.EM1JumpLand
// NumValues: 0x0005
enum class EM1JumpLand : uint8
{
	Idle                                     = 0,
	Run                                      = 1,
	Hard                                     = 2,
	Slip                                     = 3,
	EM1JumpLand_MAX                          = 4,
};

// Enum M1.EM1MissionType
// NumValues: 0x0005
enum class EM1MissionType : uint8
{
	None                                     = 0,
	Mission                                  = 1,
	WorldMission                             = 2,
	InstanceDungeon                          = 3,
	EM1MissionType_MAX                       = 4,
};

// Enum M1.EM1MapObjectType
// NumValues: 0x0012
enum class EM1MapObjectType : uint8
{
	None                                     = 0,
	Axis                                     = 1,
	Camp                                     = 2,
	Npc                                      = 3,
	Mission                                  = 4,
	Player                                   = 5,
	Squad                                    = 6,
	EpicMonsterSphere                        = 7,
	EpicMonster                              = 8,
	DroppedItem                              = 9,
	Party                                    = 10,
	FieldObjectSpawner                       = 11,
	MonsterSpawner                           = 12,
	Portal                                   = 13,
	VoidFragment                             = 14,
	VulgusPost                               = 15,
	Invasion                                 = 16,
	EM1MapObjectType_MAX                     = 17,
};

// Enum M1.EM1DropShipState
// NumValues: 0x0007
enum class EM1DropShipState : uint8
{
	Falling                                  = 0,
	Landing                                  = 1,
	JustLanded                               = 2,
	DoorOpen                                 = 3,
	Grounded                                 = 4,
	Despawn                                  = 5,
	EM1DropShipState_MAX                     = 6,
};

// Enum M1.EM1QueryStateToMissionResult
// NumValues: 0x0008
enum class EM1QueryStateToMissionResult : uint8
{
	None                                     = 0,
	NotValid                                 = 1,
	JoinedAnother                            = 2,
	CannotActivateOrJoin                     = 3,
	CanActivate                              = 4,
	ActivatedAndCanJoin                      = 5,
	AlreadyJoined                            = 6,
	EM1QueryStateToMissionResult_MAX         = 7,
};

// Enum M1.EM1MissionCondition
// NumValues: 0x0006
enum class EM1MissionCondition : uint8
{
	Startable                                = 0,
	Startable_InProgress                     = 1,
	Replayable                               = 2,
	Replayable_InProgress                    = 3,
	Disabled                                 = 4,
	MAX                                      = 5,
};

// Enum M1.EM1MissionTaskAreaState
// NumValues: 0x0004
enum class EM1MissionTaskAreaState : uint8
{
	None                                     = 0,
	InArea                                   = 1,
	OutOfArea                                = 2,
	MAX                                      = 3,
};

// Enum M1.EM1MissionTaskState
// NumValues: 0x0005
enum class EM1MissionTaskState : uint8
{
	None                                     = 0,
	Activated                                = 1,
	Succeeded                                = 2,
	Failed                                   = 3,
	EM1MissionTaskState_MAX                  = 4,
};

// Enum M1.EM1MissionActorState
// NumValues: 0x0004
enum class EM1MissionActorState : uint8
{
	None                                     = 0,
	Activated                                = 1,
	Deactivated                              = 2,
	EM1MissionActorState_MAX                 = 3,
};

// Enum M1.EM1MissionTaskStatus
// NumValues: 0x0005
enum class EM1MissionTaskStatus : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Failed                                   = 2,
	Succeeded                                = 3,
	EM1MissionTaskStatus_MAX                 = 4,
};

// Enum M1.EM1MissionStatus
// NumValues: 0x0004
enum class EM1MissionStatus : uint8
{
	None                                     = 0,
	Failed                                   = 1,
	Succeeded                                = 2,
	EM1MissionStatus_MAX                     = 3,
};

// Enum M1.EM1MissionDifficulty
// NumValues: 0x0004
enum class EM1MissionDifficulty : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Hard                                     = 2,
	EM1MissionDifficulty_MAX                 = 3,
};

// Enum M1.EM1MissionEndReason
// NumValues: 0x000A
enum class EM1MissionEndReason : uint8
{
	None                                     = 0,
	Completed                                = 1,
	ByTaskFailure                            = 2,
	ConnectionClose                          = 3,
	ExplicitGiveUp                           = 4,
	OutOfPlayableArea                        = 5,
	EndPlayByDataLayerUnload                 = 6,
	InterruptedByOtherMission                = 7,
	LeaveMissionByTeleport                   = 8,
	EM1MissionEndReason_MAX                  = 9,
};

// Enum M1.EM1MissionJoinContext
// NumValues: 0x0005
enum class EM1MissionJoinContext : uint8
{
	None                                     = 0,
	Intentionally                            = 1,
	ByChance                                 = 2,
	ByReserved                               = 3,
	EM1MissionJoinContext_MAX                = 4,
};

// Enum M1.EM1MissionActivateFailureReason
// NumValues: 0x000A
enum class EM1MissionActivateFailureReason : uint8
{
	None                                     = 0,
	AccountIsNotValid                        = 1,
	MissionIsNotValid                        = 2,
	NotReachedRequiredMateryRank             = 3,
	NotReachedRequiredProgress               = 4,
	ShouldCompletedPrerequisiteMissions      = 5,
	ShouldCompletedPrerequisiteQuest         = 6,
	VoidFragmentIsNotEnough                  = 7,
	InvasionExpReachesToLimit                = 8,
	EM1MissionActivateFailureReason_MAX      = 9,
};

// Enum M1.EM1MissionActivateCheckerFailureReason
// NumValues: 0x0004
enum class EM1MissionActivateCheckerFailureReason : uint8
{
	Unknown                                  = 0,
	CanActivate                              = 1,
	VoidFragmentIsNotEnough                  = 2,
	EM1MissionActivateCheckerFailureReason_MAX = 3,
};

// Enum M1.EM1MissionTargetState
// NumValues: 0x000A
enum class EM1MissionTargetState : uint8
{
	Default                                  = 0,
	BeingSpawned                             = 1,
	Spawned                                  = 2,
	Destructed                               = 3,
	BeingDespawned                           = 4,
	Interaction                              = 5,
	Idle                                     = 6,
	Respawn                                  = 7,
	Deactivated                              = 8,
	EM1MissionTargetState_MAX                = 9,
};

// Enum M1.EM1MissionInstantDeathState
// NumValues: 0x0010
enum class EM1MissionInstantDeathState : uint8
{
	None                                     = 0,
	Spawn                                    = 1,
	Phase01                                  = 2,
	Phase02                                  = 3,
	Phase03                                  = 4,
	Phase04                                  = 5,
	Phase05                                  = 6,
	Phase06                                  = 7,
	Phase07                                  = 8,
	Phase08                                  = 9,
	Phase09                                  = 10,
	Phase10                                  = 11,
	Alert                                    = 12,
	Explosion                                = 13,
	Completed                                = 14,
	MAX                                      = 15,
};

// Enum M1.EM1MissionInteractableState
// NumValues: 0x0006
enum class EM1MissionInteractableState : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Interactable                             = 2,
	BeginInteraction                         = 3,
	FinishInteraction                        = 4,
	EM1MissionInteractableState_MAX          = 5,
};

// Enum M1.EM1MissionMessageReceiverType
// NumValues: 0x0003
enum class EM1MissionMessageReceiverType : uint8
{
	DynamicDerivative                        = 0,
	StaticDerivative                         = 1,
	EM1MissionMessageReceiverType_MAX        = 2,
};

// Enum M1.EM1MissionNpcMaterialState
// NumValues: 0x0005
enum class EM1MissionNpcMaterialState : uint8
{
	None                                     = 0,
	CannotEnterMission                       = 1,
	MissionActivated                         = 2,
	MissionDeactivated                       = 3,
	EM1MissionNpcMaterialState_MAX           = 4,
};

// Enum M1.EM1MissionResultScore
// NumValues: 0x0006
enum class EM1MissionResultScore : uint8
{
	One                                      = 0,
	Two                                      = 1,
	Three                                    = 2,
	Four                                     = 3,
	Five                                     = 4,
	EM1MissionResultScore_MAX                = 5,
};

// Enum M1.EM1TaskComponentState
// NumValues: 0x0005
enum class EM1TaskComponentState : uint8
{
	None                                     = 0,
	Reset                                    = 1,
	Activated                                = 2,
	Deactivated                              = 3,
	EM1TaskComponentState_MAX                = 4,
};

// Enum M1.EM1MissionTargetActorWidgetVisibleType
// NumValues: 0x0004
enum class EM1MissionTargetActorWidgetVisibleType : uint8
{
	Default                                  = 0,
	AlwaysHidden                             = 1,
	HiddenInRange                            = 2,
	EM1MissionTargetActorWidgetVisibleType_MAX = 3,
};

// Enum M1.EM1KeeperTileAkEventType
// NumValues: 0x0005
enum class EM1KeeperTileAkEventType : uint8
{
	None                                     = 0,
	OverlappedPlayer                         = 1,
	OverlappedMonster                        = 2,
	FullyOccupied                            = 3,
	EM1KeeperTileAkEventType_MAX             = 4,
};

// Enum M1.EM1MissionTargetDestructionIronHeartType
// NumValues: 0x0004
enum class EM1MissionTargetDestructionIronHeartType : uint8
{
	None                                     = 0,
	IronHeart                                = 1,
	VoidErosion                              = 2,
	EM1MissionTargetDestructionIronHeartType_MAX = 3,
};

// Enum M1.EM1MissionObjectBarrierActivatorBarrierFxType
// NumValues: 0x0007
enum class EM1MissionObjectBarrierActivatorBarrierFxType : uint8
{
	None                                     = 0,
	Start                                    = 1,
	Idle                                     = 2,
	Attack                                   = 3,
	End                                      = 4,
	EndFromAttack                            = 5,
	EM1MissionObjectBarrierActivatorBarrierFxType_MAX = 6,
};

// Enum M1.EM1MissionTargetMultiCollectionState
// NumValues: 0x0006
enum class EM1MissionTargetMultiCollectionState : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Collecting                               = 2,
	Collected                                = 3,
	Reset                                    = 4,
	EM1MissionTargetMultiCollectionState_MAX = 5,
};

// Enum M1.EM1DynamicActorLifespanPolicy
// NumValues: 0x0004
enum class EM1DynamicActorLifespanPolicy : uint8
{
	KeepAlive                                = 0,
	InPlaceDespawn                           = 1,
	GoAway                                   = 2,
	EM1DynamicActorLifespanPolicy_MAX        = 3,
};

// Enum M1.EM1MissionTaskActorWidgetVisibleType
// NumValues: 0x0006
enum class EM1MissionTaskActorWidgetVisibleType : uint8
{
	Default                                  = 0,
	AlwaysHidden                             = 1,
	HiddenAfterBegun                         = 2,
	HiddenInRange                            = 3,
	HiddenInRangeAfterBegun                  = 4,
	EM1MissionTaskActorWidgetVisibleType_MAX = 5,
};

// Enum M1.EM1BaseMissionProgressState
// NumValues: 0x0007
enum class EM1BaseMissionProgressState : uint8
{
	Default                                  = 0,
	Deactivated                              = 1,
	Activated                                = 2,
	Running                                  = 3,
	Disturbed                                = 4,
	Completed                                = 5,
	MAX                                      = 6,
};

// Enum M1.EM1SubTaskSchedulerType
// NumValues: 0x0005
enum class EM1SubTaskSchedulerType : uint8
{
	Default                                  = 0,
	Simultaneous                             = 1,
	Sequential                               = 2,
	RandomlySequential                       = 3,
	MAX                                      = 4,
};

// Enum M1.EM1MissionCollectionReturnPhaseType
// NumValues: 0x0005
enum class EM1MissionCollectionReturnPhaseType : uint8
{
	None                                     = 0,
	CollectionReturn                         = 1,
	Destruction                              = 2,
	NamedBattle                              = 3,
	MAX                                      = 4,
};

// Enum M1.EM1MissionTaskDestructionIronHeartState
// NumValues: 0x0006
enum class EM1MissionTaskDestructionIronHeartState : uint8
{
	OccupationTaskInProgress                 = 0,
	OccupationTaskOutProgress                = 1,
	OtherTask                                = 2,
	AllCompleted                             = 3,
	None                                     = 4,
	EM1MissionTaskDestructionIronHeartState_MAX = 5,
};

// Enum M1.EM1DestructionIronHeartSplineActorMovementType
// NumValues: 0x0004
enum class EM1DestructionIronHeartSplineActorMovementType : uint8
{
	Idle                                     = 0,
	Forward                                  = 1,
	Backward                                 = 2,
	EM1DestructionIronHeartSplineActorMovementType_MAX = 3,
};

// Enum M1.EM1MissionVulgusPostState
// NumValues: 0x0005
enum class EM1MissionVulgusPostState : uint8
{
	None                                     = 0,
	BatteState                               = 1,
	NonBattleState                           = 2,
	InCoolTimeToEnterNonBattleState          = 3,
	EM1MissionVulgusPostState_MAX            = 4,
};

// Enum M1.EM1MissionInteractionObjectVisibility
// NumValues: 0x0004
enum class EM1MissionInteractionObjectVisibility : uint8
{
	AlwaysVisible                            = 0,
	VisibleToHidden                          = 1,
	HiddenToVisiblle                         = 2,
	EM1MissionInteractionObjectVisibility_MAX = 3,
};

// Enum M1.EM1MissionTaskStealProgressState
// NumValues: 0x0006
enum class EM1MissionTaskStealProgressState : uint8
{
	None                                     = 0,
	Activated                                = 1,
	Stealing                                 = 2,
	Destructing                              = 3,
	Stolen                                   = 4,
	EM1MissionTaskStealProgressState_MAX     = 5,
};

// Enum M1.EM1MissionWavePlayerProgressState
// NumValues: 0x0005
enum class EM1MissionWavePlayerProgressState : uint8
{
	Default                                  = 0,
	Stopped                                  = 1,
	Continued                                = 2,
	Pending                                  = 3,
	EM1MissionWavePlayerProgressState_MAX    = 4,
};

// Enum M1.EM1MissionTaskOccupationState
// NumValues: 0x0007
enum class EM1MissionTaskOccupationState : uint8
{
	Deactivated                              = 0,
	Activated                                = 1,
	BeingActivated                           = 2,
	Occupied                                 = 3,
	OccupiedStopped                          = 4,
	FullyOccupied                            = 5,
	EM1MissionTaskOccupationState_MAX        = 6,
};

// Enum M1.EM1MissionTaskOccupationType
// NumValues: 0x0004
enum class EM1MissionTaskOccupationType : uint8
{
	Occupation                               = 0,
	Hacking                                  = 1,
	Steal                                    = 2,
	EM1MissionTaskOccupationType_MAX         = 3,
};

// Enum M1.EM1MissionInstantDeathType
// NumValues: 0x0004
enum class EM1MissionInstantDeathType : uint8
{
	None                                     = 0,
	Extermination                            = 1,
	ForDeathEvasion                          = 2,
	EM1MissionInstantDeathType_MAX           = 3,
};

// Enum M1.EM1CoverState
// NumValues: 0x0006
enum class EM1CoverState : uint8
{
	None                                     = 0,
	Move                                     = 1,
	Wait                                     = 2,
	Attack                                   = 3,
	ReturnCover                              = 4,
	EM1CoverState_MAX                        = 5,
};

// Enum M1.EM1MonsterAIDataRangeType
// NumValues: 0x0003
enum class EM1MonsterAIDataRangeType : uint8
{
	Battle                                   = 0,
	Mission                                  = 1,
	EM1MonsterAIDataRangeType_MAX            = 2,
};

// Enum M1.EM1MonsterAIDebugState
// NumValues: 0x0005
enum class EM1MonsterAIDebugState : uint8
{
	None                                     = 0,
	Running                                  = 1,
	Paused                                   = 2,
	Stopped                                  = 3,
	EM1MonsterAIDebugState_MAX               = 4,
};

// Enum M1.EM1MonsterType
// NumValues: 0x0006
enum class EM1MonsterType : uint8
{
	Melee                                    = 0,
	Range                                    = 1,
	Drone                                    = 2,
	EpicMonster                              = 3,
	EpicMonsterSphere                        = 4,
	EM1MonsterType_MAX                       = 5,
};

// Enum M1.EM1MonsterSpeedPreference
// NumValues: 0x0003
enum class EM1MonsterSpeedPreference : uint32
{
	WalkingPrefer                            = 0,
	RunningPrefer                            = 1,
	EM1MonsterSpeedPreference_MAX            = 2,
};

// Enum M1.EM1CrowdMonsterType
// NumValues: 0x0004
enum class EM1CrowdMonsterType : uint8
{
	None                                     = 0,
	Leader                                   = 1,
	Follower                                 = 2,
	EM1CrowdMonsterType_MAX                  = 3,
};

// Enum M1.EM1MonsterSpawnEffectState
// NumValues: 0x0004
enum class EM1MonsterSpawnEffectState : uint8
{
	None                                     = 0,
	Spawning                                 = 1,
	Finishing                                = 2,
	Max                                      = 3,
};

// Enum M1.EM1MovingActorState
// NumValues: 0x000A
enum class EM1MovingActorState : uint8
{
	Initial                                  = 0,
	PreDespawn                               = 1,
	PreDespawnLoopByTrigger                  = 2,
	PreDespawnEndByTrigger                   = 3,
	Despawn                                  = 4,
	Spawn                                    = 5,
	Deactivate                               = 6,
	PreActivateByTrigger                     = 7,
	Activate                                 = 8,
	EM1MovingActorState_MAX                  = 9,
};

// Enum M1.EM1MovingActorTriggerActionType
// NumValues: 0x0003
enum class EM1MovingActorTriggerActionType : uint8
{
	Overlap                                  = 0,
	Interaction                              = 1,
	EM1MovingActorTriggerActionType_MAX      = 2,
};

// Enum M1.EM1MovingActorTriggerVolumeType
// NumValues: 0x0004
enum class EM1MovingActorTriggerVolumeType : uint8
{
	Box                                      = 0,
	Sphere                                   = 1,
	Capsule                                  = 2,
	EM1MovingActorTriggerVolumeType_MAX      = 3,
};

// Enum M1.EM1SplineMovingType
// NumValues: 0x0005
enum class EM1SplineMovingType : uint8
{
	OneWay                                   = 0,
	Return                                   = 1,
	Cycle                                    = 2,
	MultiAngle                               = 3,
	EM1SplineMovingType_MAX                  = 4,
};

// Enum M1.EM1MovingActorInteractableActorState
// NumValues: 0x0004
enum class EM1MovingActorInteractableActorState : uint8
{
	Idle                                     = 0,
	Interactable                             = 1,
	BeginInteraction                         = 2,
	EM1MovingActorInteractableActorState_MAX = 3,
};

// Enum M1.EM1MovingSpeedType
// NumValues: 0x0005
enum class EM1MovingSpeedType : uint8
{
	Walking                                  = 0,
	Running                                  = 1,
	Sprinting                                = 2,
	MaxSprinting                             = 3,
	EM1MovingSpeedType_MAX                   = 4,
};

// Enum M1.EM1JumpAnimType
// NumValues: 0x0004
enum class EM1JumpAnimType : uint8
{
	Start                                    = 0,
	Apex                                     = 1,
	Land                                     = 2,
	EM1JumpAnimType_MAX                      = 3,
};

// Enum M1.EM1JumpResult
// NumValues: 0x0006
enum class EM1JumpResult : uint8
{
	None                                     = 0,
	Success                                  = 1,
	Fail                                     = 2,
	NotEnoughJumpSpeed                       = 3,
	Collision                                = 4,
	EM1JumpResult_MAX                        = 5,
};

// Enum M1.EM1JumpType
// NumValues: 0x0004
enum class EM1JumpType : uint8
{
	None                                     = 0,
	Down                                     = 1,
	Up                                       = 2,
	EM1JumpType_MAX                          = 3,
};

// Enum M1.EM1NpcAudioEventType
// NumValues: 0x0004
enum class EM1NpcAudioEventType : uint8
{
	RandomTalk                               = 0,
	Interaction                              = 1,
	LookAt                                   = 2,
	EM1NpcAudioEventType_MAX                 = 3,
};

// Enum M1.EM1NpcAnimState
// NumValues: 0x0006
enum class EM1NpcAnimState : uint8
{
	None                                     = 0,
	Idle1                                    = 1,
	Idle2                                    = 2,
	MovingIdle1                              = 3,
	MovingIdle2                              = 4,
	EM1NpcAnimState_MAX                      = 5,
};

// Enum M1.EM1NxLogPlayFlowType
// NumValues: 0x0007
enum class EM1NxLogPlayFlowType : uint8
{
	None                                     = 0,
	EnterMissionMap                          = 1,
	MissionStart                             = 2,
	DuringMission                            = 3,
	MissionEnd                               = 4,
	LeaveMissionMap                          = 5,
	EM1NxLogPlayFlowType_MAX                 = 6,
};

// Enum M1.EM1ResearchActionType
// NumValues: 0x0006
enum class EM1ResearchActionType : uint8
{
	None                                     = 0,
	Start                                    = 1,
	Boost                                    = 2,
	Cancel                                   = 3,
	Receive                                  = 4,
	EM1ResearchActionType_MAX                = 5,
};

// Enum M1.EM1InvitationResponse
// NumValues: 0x0007
enum class EM1InvitationResponse : uint8
{
	NotLoggedInSoMakeReservation             = 0,
	LoggedInButNotInCityNowSoMakeReservation = 1,
	CanNowJoin                               = 2,
	CannotJoinNow                            = 3,
	CannotJoinInField                        = 4,
	AlreadyJoined                            = 5,
	EM1InvitationResponse_MAX                = 6,
};

// Enum M1.EM1OnlineConnectionState
// NumValues: 0x0004
enum class EM1OnlineConnectionState : uint32
{
	Disconnected                             = 0,
	Connecting                               = 1,
	Online                                   = 2,
	EM1OnlineConnectionState_MAX             = 3,
};

// Enum M1.EM1OptionFeature
// NumValues: 0x00D0
enum class EM1OptionFeature : uint8
{
	None                                     = 0,
	Test                                     = 1,
	Input_PC_Sprint                          = 2,
	Input_PC_Jump                            = 3,
	Input_PC_Skill1                          = 4,
	Input_PC_Skill2                          = 5,
	Input_PC_Skill3                          = 6,
	Input_PC_Skill4                          = 7,
	Input_PC_Action1                         = 8,
	Input_PC_Action2                         = 9,
	Input_PC_Reload                          = 10,
	Input_PC_SubSkill                        = 11,
	Input_PC_PrevWeapon                      = 12,
	Input_PC_NextWeapon                      = 13,
	Input_PC_WeaponShortcut1                 = 14,
	Input_PC_WeaponShortcut2                 = 15,
	Input_PC_WeaponShortcut3                 = 16,
	Input_PC_WireAction                      = 17,
	Input_PC_Inventory                       = 18,
	Input_PC_WorldMap                        = 19,
	Input_PC_LocalMap                        = 20,
	Input_PC_Interaction                     = 21,
	Input_PC_IncreaseMouseSensitivity        = 22,
	Input_PC_DecreaseMouseSensitivity        = 23,
	Input_PC_Character                       = 24,
	Input_PC_Chatting                        = 25,
	Input_PC_Detecting                       = 26,
	Input_PC_Evade                           = 27,
	Input_PC_GiveupRescue                    = 28,
	Input_PC_Help                            = 29,
	Input_PC_InteractionWithPlayer           = 30,
	Input_PC_Quest                           = 31,
	Input_PC_Rescue                          = 32,
	Input_PC_RadialMenu                      = 33,
	Input_PC_ToggleObjectivePanel            = 34,
	Input_PC_MoveForward                     = 35,
	Input_PC_MoveBackward                    = 36,
	Input_PC_MoveRight                       = 37,
	Input_PC_MoveLeft                        = 38,
	Input_PC_Consumable                      = 39,
	Input_PC_BattlePass                      = 40,
	Input_PC_CashShop                        = 41,
	Input_PC_Codex                           = 42,
	Input_PC_Journal                         = 43,
	Input_PC_Social                          = 44,
	Input_Gamepad_Action1                    = 45,
	Input_Gamepad_Action2                    = 46,
	Input_Gamepad_Interaction                = 47,
	Input_Gamepad_Jump                       = 48,
	Input_Gamepad_Reload                     = 49,
	Input_Gamepad_Skill1                     = 50,
	Input_Gamepad_Skill2                     = 51,
	Input_Gamepad_Skill3                     = 52,
	Input_Gamepad_Skill4                     = 53,
	Input_Gamepad_Sprint                     = 54,
	Input_Gamepad_SubSkill                   = 55,
	Input_Gamepad_WeaponChangeHold           = 56,
	Input_Gamepad_WireAction                 = 57,
	Input_Gamepad_WorldMap                   = 58,
	Input_Gamepad_Character                  = 59,
	Input_Gamepad_Chatting                   = 60,
	Input_Gamepad_Detecting                  = 61,
	Input_Gamepad_Evade                      = 62,
	Input_Gamepad_GiveupRescue               = 63,
	Input_Gamepad_Help                       = 64,
	Input_Gamepad_InteractionWithPlayer      = 65,
	Input_Gamepad_Quest                      = 66,
	Input_Gamepad_Rescue                     = 67,
	Input_Gamepad_PushToTalk                 = 68,
	Input_Gamepad_CompositeSettingsOnly      = 69,
	Input_Gamepad_RadialMenu                 = 70,
	Input_Gamepad_ToggleObjectivePanel       = 71,
	Input_Gamepad_Consumable                 = 72,
	Input_Gamepad_BattlePass                 = 73,
	Input_Gamepad_CashShop                   = 74,
	Input_Gamepad_Codex                      = 75,
	Input_Gamepad_Journal                    = 76,
	Input_Gamepad_Social                     = 77,
	Chat_AutoHide                            = 78,
	Chat_BGVisible                           = 79,
	Chat_TextSize                            = 80,
	Chat_VoiceTalkActive                     = 81,
	Input_PC_PushToTalk                      = 82,
	Chat_VoiceChannel                        = 83,
	Chat_VoiceMicUse                         = 84,
	Chat_VoiceMicVolume                      = 85,
	Chat_VoiceSoundUse                       = 86,
	Chat_VoiceSoundVolume                    = 87,
	Chat_Range                               = 88,
	CrossPlatformPlay                        = 89,
	CrossPlatformChatRange                   = 90,
	FriendInviteOption                       = 91,
	PartyInviteOption                        = 92,
	ReceiveRequestSupportOption              = 93,
	Notice_LastShowDateTime                  = 94,
	MouseSensitivity_Normal                  = 95,
	MouseSensitivity_Zoom                    = 96,
	MouseSensitivity_Zoom_AR                 = 97,
	MouseSensitivity_Zoom_BR                 = 98,
	MouseSensitivity_Zoom_HC                 = 99,
	MouseSensitivity_Zoom_HG                 = 100,
	MouseSensitivity_Zoom_LNC                = 101,
	MouseSensitivity_Zoom_MG                 = 102,
	MouseSensitivity_Zoom_SCR                = 103,
	MouseSensitivity_Zoom_SG                 = 104,
	MouseSensitivity_Zoom_SMG                = 105,
	MouseSensitivity_Zoom_SR                 = 106,
	MouseSensitivity_Zoom_TR                 = 107,
	GamepadSensitivity_NormalX               = 108,
	GamepadSensitivity_NormalY               = 109,
	GamepadSensitivity_ZoomX                 = 110,
	GamepadSensitivity_ZoomY                 = 111,
	IndividualMouseSensitivity               = 112,
	MouseInvertAxis_X                        = 113,
	MouseInvertAxis_Y                        = 114,
	GamepadInvertAxis_X                      = 115,
	GamepadInvertAxis_Y                      = 116,
	ZoomControl                              = 117,
	RunSprintControl                         = 118,
	SprintControl                            = 119,
	AutoStartFireControl                     = 120,
	ShowBrightnessPopup                      = 121,
	ShowGamepadAxisSettingPopup              = 122,
	ShowGamepadKeySettingPopup               = 123,
	Account_Link                             = 124,
	Account_NpaCode                          = 125,
	Account_EnterCoupon                      = 126,
	Account_Withdrawal                       = 127,
	GamePlay_Floater                         = 128,
	GamePlay_Floater_Skill                   = 129,
	Gameplay_Locale                          = 130,
	Gameplay_AudioLocale                     = 131,
	Gameplay_ShowDamage                      = 132,
	Gameplay_ShowHUDNumbers                  = 133,
	Gameplay_ShowStatusEffectNotice          = 134,
	Gameplay_ShowCreatorIcon                 = 135,
	Gameplay_HideUserName                    = 136,
	GrapplingHookCorrect                     = 137,
	GrapplingHookHUDGuide                    = 138,
	GrapplingHookHUDGuideWidgetType          = 139,
	Graphic_UseHDR                           = 140,
	Graphic_AdjustBrightness                 = 141,
	Graphic_AdjustContrast                   = 142,
	Graphic_QualityPreset                    = 143,
	Graphic_ViewDistance                     = 144,
	Graphic_AntiAliasing                     = 145,
	Graphic_PostProcessing                   = 146,
	Graphic_Shadows                          = 147,
	Graphic_GlobalIllumination               = 148,
	Graphic_Reflections                      = 149,
	Graphic_Textures                         = 150,
	Graphic_Effects                          = 151,
	Graphic_Foliage                          = 152,
	Graphic_Shading                          = 153,
	Graphic_Mesh                             = 154,
	Graphic_Physics                          = 155,
	Graphic_RayTracingQuality                = 156,
	Graphic_SelectUpscaler                   = 157,
	Graphic_DLSS_SR                          = 158,
	Graphic_DLSS_FG                          = 159,
	Graphic_DLSS_RR                          = 160,
	Graphic_FSR                              = 161,
	Graphic_FSR_FG                           = 162,
	Graphic_XeSS                             = 163,
	Graphic_TSR                              = 164,
	Graphic_ConsoleQuality                   = 165,
	Graphic_ConsoleFG                        = 166,
	Graphic_ConsoleRayTracing                = 167,
	Graphic_Resolution                       = 168,
	Graphic_FullscreenMode                   = 169,
	Graphic_MotionBlur                       = 170,
	Graphic_VSync                            = 171,
	Graphic_NVIDIAReflex                     = 172,
	Graphic_FrameRateLimit                   = 173,
	Graphic_Sharpness                        = 174,
	Sound_MasterVolume                       = 175,
	Sound_MusicVolume                        = 176,
	Sound_SfxVolume                          = 177,
	Sound_DialogueVolume                     = 178,
	Sound_HitMarkerSoundVolume               = 179,
	Sound_3DAudioAcive                       = 180,
	Sound_PlayAudioWhenFocusIsLost           = 181,
	Sound_PanningRule                        = 182,
	Sound_AudioMix                           = 183,
	Sound_BattleVoice                        = 184,
	FOV                                      = 185,
	AimAssist_Usage                          = 186,
	AimAssist_IntensityAimRotate             = 187,
	AimAssist_IntensityAimSlowdown           = 188,
	AimAssist_IntensityStickyAim             = 189,
	AimAssist_HipFire                        = 190,
	BattleKeyPreset                          = 191,
	BattleAxisPreset                         = 192,
	VirtualCursorMaxSpeed                    = 193,
	ControllerVibrationStrength              = 194,
	ControllerUseDeadZoneSetting             = 195,
	ControllerDeadZoneLeft                   = 196,
	ControllerDeadZoneRight                  = 197,
	AdaptiveTrigger                          = 198,
	CityCameraDistance                       = 199,
	HardwareCursor                           = 200,
	ColorBlindness                           = 201,
	LauncherHipfireGuide                     = 202,
	BulletHitPositionGuide                   = 203,
	CameraShake                              = 204,
	CityCrosshairVisible                     = 205,
	DisplayBattleFXType                      = 206,
	EM1OptionFeature_MAX                     = 207,
};

// Enum M1.EM1OptionValueType
// NumValues: 0x000D
enum class EM1OptionValueType : uint8
{
	None                                     = 0,
	Bool                                     = 1,
	Integer                                  = 2,
	Float                                    = 3,
	String                                   = 4,
	KeyInput                                 = 5,
	AxisInput                                = 6,
	GamepadKeyInput                          = 7,
	Int64                                    = 8,
	UInt8                                    = 9,
	Enumeration                              = 10,
	IntPoint                                 = 11,
	EM1OptionValueType_MAX                   = 12,
};

// Enum M1.EM1OptionApplyTime
// NumValues: 0x0005
enum class EM1OptionApplyTime : uint8
{
	NonResolution                            = 0,
	Resolution                               = 1,
	WorldExist                               = 2,
	ClickedStartButton                       = 3,
	EM1OptionApplyTime_MAX                   = 4,
};

// Enum M1.EM1OptionUIComponent
// NumValues: 0x000C
enum class EM1OptionUIComponent : uint8
{
	None                                     = 0,
	Select                                   = 1,
	SelectWidget                             = 2,
	DropDown                                 = 3,
	Slider                                   = 4,
	DirectInput                              = 5,
	GamepadInput                             = 6,
	Toggle                                   = 7,
	Button                                   = 8,
	ButtonToggle                             = 9,
	ButtonDesc                               = 10,
	EM1OptionUIComponent_MAX                 = 11,
};

// Enum M1.EM1OptionDetail
// NumValues: 0x0006
enum class EM1OptionDetail : uint8
{
	None                                     = 0,
	Text                                     = 1,
	Image                                    = 2,
	Controller                               = 3,
	KeyButton                                = 4,
	EM1OptionDetail_MAX                      = 5,
};

// Enum M1.EM1OptionUIComponentButtonOperation
// NumValues: 0x0003
enum class EM1OptionUIComponentButtonOperation : uint8
{
	None                                     = 0,
	ShowPopup                                = 1,
	EM1OptionUIComponentButtonOperation_MAX  = 2,
};

// Enum M1.EM1OptionApplicationMethod
// NumValues: 0x0004
enum class EM1OptionApplicationMethod : uint8
{
	None                                     = 0,
	Default                                  = 1,
	ApplyButton                              = 2,
	EM1OptionApplicationMethod_MAX           = 3,
};

// Enum M1.EM1OptionCategoryExposureArea
// NumValues: 0x0004
enum class EM1OptionCategoryExposureArea : uint8
{
	Always                                   = 0,
	TitleOnly                                = 1,
	AfterTitle                               = 2,
	EM1OptionCategoryExposureArea_MAX        = 3,
};

// Enum M1.EM1CameraSensitivityAxis
// NumValues: 0x0004
enum class EM1CameraSensitivityAxis : uint8
{
	None                                     = 0,
	X                                        = 1,
	Y                                        = 2,
	EM1CameraSensitivityAxis_MAX             = 3,
};

// Enum M1.EM1AimAssistIntensity
// NumValues: 0x0004
enum class EM1AimAssistIntensity : uint8
{
	AimRotate                                = 0,
	AimSlowdown                              = 1,
	StickyAim                                = 2,
	EM1AimAssistIntensity_MAX                = 3,
};

// Enum M1.EM1OptionSubClassType
// NumValues: 0x0005
enum class EM1OptionSubClassType : uint8
{
	Default                                  = 0,
	CrossPlatform                            = 1,
	GraphicDefault                           = 2,
	GraphicUpscale                           = 3,
	EM1OptionSubClassType_MAX                = 4,
};

// Enum M1.EM1StatusEffectNoticeOption
// NumValues: 0x0005
enum class EM1StatusEffectNoticeOption : uint8
{
	None                                     = 0,
	Ally                                     = 1,
	Enemy                                    = 2,
	All                                      = 3,
	EM1StatusEffectNoticeOption_MAX          = 4,
};

// Enum M1.EM1DisplayBattleFXOption
// NumValues: 0x0005
enum class EM1DisplayBattleFXOption : uint8
{
	All                                      = 0,
	Party                                    = 1,
	Squad                                    = 2,
	Own                                      = 3,
	EM1DisplayBattleFXOption_MAX             = 4,
};

// Enum M1.EM1OutOfPlayableAreaEffectActiveType
// NumValues: 0x0008
enum class EM1OutOfPlayableAreaEffectActiveType : uint8
{
	None                                     = 0,
	Forward                                  = 1,
	Reserve                                  = 2,
	ForwardEnded                             = 3,
	WaitForStart                             = 4,
	Pause                                    = 5,
	Clear                                    = 6,
	EM1OutOfPlayableAreaEffectActiveType_MAX = 7,
};

// Enum M1.EM1OutOfPlayableAreaVolumeType
// NumValues: 0x0006
enum class EM1OutOfPlayableAreaVolumeType : uint8
{
	None                                     = 0,
	PlayerRespawnVolume                      = 1,
	TickDamageVolume                         = 2,
	KillMonster                              = 3,
	Count                                    = 4,
	EM1OutOfPlayableAreaVolumeType_MAX       = 5,
};

// Enum M1.EM1OutOfPlayableAreaVolumeActiveType
// NumValues: 0x0003
enum class EM1OutOfPlayableAreaVolumeActiveType : uint8
{
	Default                                  = 0,
	TaskEvent                                = 1,
	EM1OutOfPlayableAreaVolumeActiveType_MAX = 2,
};

// Enum M1.EM1PartyInviteOption
// NumValues: 0x0004
enum class EM1PartyInviteOption : uint8
{
	None                                     = 0,
	AllPossible                              = 1,
	Impossible                               = 2,
	EM1PartyInviteOption_MAX                 = 3,
};

// Enum M1.EM1PlayerContextualActionState
// NumValues: 0x0006
enum class EM1PlayerContextualActionState : uint8
{
	None                                     = 0,
	Initialized                              = 1,
	Activated                                = 2,
	Deactivated                              = 3,
	Finalized                                = 4,
	EM1PlayerContextualActionState_MAX       = 5,
};

// Enum M1.EM1PlayerContextualActionPermission
// NumValues: 0x0006
enum class EM1PlayerContextualActionPermission : uint8
{
	All                                      = 0,
	OwnedOnly                                = 1,
	LocalOnly                                = 2,
	ClientOnly                               = 3,
	SimulatedOnly                            = 4,
	EM1PlayerContextualActionPermission_MAX  = 5,
};

// Enum M1.EM1PlayerAsyncProbeType
// NumValues: 0x0008
enum class EM1PlayerAsyncProbeType : uint8
{
	NONE                                     = 0,
	Upper                                    = 1,
	Step                                     = 2,
	Foot                                     = 3,
	Pawn                                     = 4,
	Loot                                     = 5,
	LAST                                     = 5,
	EM1PlayerAsyncProbeType_MAX              = 6,
};

// Enum M1.EM1CharacterChangeReason
// NumValues: 0x0008
enum class EM1CharacterChangeReason : uint8
{
	Unknown                                  = 0,
	Success                                  = 1,
	OutOfPermittedAreaInField                = 2,
	InBattleState                            = 3,
	InStatAction                             = 4,
	InMission                                = 5,
	InMatchingCharacterDungeon               = 6,
	EM1CharacterChangeReason_MAX             = 7,
};

// Enum M1.EM1CharacterAttachmentType
// NumValues: 0x0007
enum class EM1CharacterAttachmentType : uint8
{
	None                                     = 0,
	WeaponBack                               = 1,
	Weapon0LT                                = 2,
	BackAttachment                           = 3,
	ChestAttachment                          = 4,
	HeadRoot                                 = 5,
	EM1CharacterAttachmentType_MAX           = 6,
};

// Enum M1.EM1PlayerActionGroup
// NumValues: 0x0004
enum class EM1PlayerActionGroup : uint8
{
	None                                     = 0,
	Player                                   = 1,
	Weapon                                   = 2,
	EM1PlayerActionGroup_MAX                 = 3,
};

// Enum M1.EM1MovementRotationDirection
// NumValues: 0x0004
enum class EM1MovementRotationDirection : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	EM1MovementRotationDirection_MAX         = 3,
};

// Enum M1.EM1PlayerRoundsDepositReason
// NumValues: 0x0005
enum class EM1PlayerRoundsDepositReason : uint8
{
	None                                     = 0,
	DepositWeapon                            = 1,
	AcquireRounds                            = 2,
	Recover                                  = 3,
	EM1PlayerRoundsDepositReason_MAX         = 4,
};

// Enum M1.EM1WeaponStatPageType
// NumValues: 0x0006
enum class EM1WeaponStatPageType : uint8
{
	Barehand                                 = 0,
	Range1                                   = 1,
	Range2                                   = 2,
	Range3                                   = 3,
	PickedUp                                 = 4,
	Max                                      = 5,
};

// Enum M1.EM1PostProcessState
// NumValues: 0x0005
enum class EM1PostProcessState : uint8
{
	None                                     = 0,
	Activated                                = 1,
	Looping                                  = 2,
	Deactivated                              = 3,
	Max                                      = 4,
};

// Enum M1.EM1PreviewLevelType
// NumValues: 0x0015
enum class EM1PreviewLevelType : uint8
{
	None                                     = 0,
	Character                                = 1,
	Weapon                                   = 2,
	CharacterSequence                        = 3,
	CustomizeCharacter                       = 4,
	CustomizeWeapon                          = 5,
	CustomizeWire                            = 6,
	CustomizeSocial                          = 7,
	BattlePassCharacter                      = 8,
	BattlePassWeapon                         = 9,
	BattlePassWire                           = 10,
	BattlePassSocial                         = 11,
	BattlePassSkinPaint                      = 12,
	BattlePassEtc                            = 13,
	ShopCharacter                            = 14,
	ShopWeapon                               = 15,
	ShopWire                                 = 16,
	ShopSocial                               = 17,
	ShopSkinPaint                            = 18,
	ShopEtc                                  = 19,
	Max                                      = 20,
};

// Enum M1.EM1SeasonReinforceSlotChangeType
// NumValues: 0x0005
enum class EM1SeasonReinforceSlotChangeType : uint8
{
	Unlock                                   = 0,
	Equip                                    = 1,
	Unequip                                  = 2,
	Clear                                    = 3,
	EM1SeasonReinforceSlotChangeType_MAX     = 4,
};

// Enum M1.EM1ProceduralKeyTimeType
// NumValues: 0x0004
enum class EM1ProceduralKeyTimeType : uint8
{
	FootOffToFootStrike                      = 0,
	FootStrikeToFootOff                      = 1,
	FootStance                               = 2,
	EM1ProceduralKeyTimeType_MAX             = 3,
};

// Enum M1.EM1ProjectileHomingTargetSearchType
// NumValues: 0x0004
enum class EM1ProjectileHomingTargetSearchType : uint8
{
	None                                     = 0,
	Always                                   = 1,
	TargetDeath                              = 2,
	EM1ProjectileHomingTargetSearchType_MAX  = 3,
};

// Enum M1.EM1QuestStatus
// NumValues: 0x0007
enum class EM1QuestStatus : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	RequestStart                             = 2,
	Progress                                 = 3,
	CompleteBeforReward                      = 4,
	Completed                                = 5,
	EM1QuestStatus_MAX                       = 6,
};

// Enum M1.EM1QuestDirection_OperatorDialogType
// NumValues: 0x0004
enum class EM1QuestDirection_OperatorDialogType : uint8
{
	None                                     = 0,
	Begin                                    = 1,
	Complete                                 = 2,
	EM1QuestDirection_MAX                    = 3,
};

// Enum M1.EM1QuestDirection_SequenceType
// NumValues: 0x0004
enum class EM1QuestDirection_SequenceType : uint8
{
	None                                     = 0,
	Begin                                    = 1,
	Complete                                 = 2,
	EM1QuestDirection_MAX                    = 3,
};

// Enum M1.EM1QuestCountUpdateMethod
// NumValues: 0x0004
enum class EM1QuestCountUpdateMethod : uint8
{
	Add                                      = 0,
	Override                                 = 1,
	OverrideIfBigger                         = 2,
	EM1QuestCountUpdateMethod_MAX            = 3,
};

// Enum M1.EClassRepNodeMapping
// NumValues: 0x000B
enum class EClassRepNodeMapping : uint8
{
	NotRouted                                = 0,
	RelevantAllConnections                   = 1,
	RelevantAllConnections_NoDistanceCheck   = 2,
	RelevantAllConnections_Dormancy          = 3,
	RelevantForConnection                    = 4,
	RelevantAllConnections_ForMissionPlayer  = 5,
	Spatialize_Static                        = 6,
	Spatialize_Dynamic                       = 7,
	Spatialize_Dormancy                      = 8,
	Spatialize_Dormancy_Or_ConnectionOnly    = 9,
	EClassRepNodeMapping_MAX                 = 10,
};

// Enum M1.EM1UnresearchableState
// NumValues: 0x0004
enum class EM1UnresearchableState : uint8
{
	MasteryRankNotReached                    = 0,
	CurrencyNotEnough                        = 1,
	MaterialNotEnough                        = 2,
	EM1UnresearchableState_MAX               = 3,
};

// Enum M1.EM1RPCValidateOption
// NumValues: 0x0005
enum class EM1RPCValidateOption : uint8
{
	DependsOnValidation                      = 0,
	ConfigOpt1                               = 1,
	ConfigOpt2                               = 2,
	AlwaysReturnsTrue                        = 3,
	EM1RPCValidateOption_MAX                 = 4,
};

// Enum M1.EM1FadeInterval
// NumValues: 0x0004
enum class EM1FadeInterval : uint8
{
	None                                     = 0,
	PlayList                                 = 1,
	Track                                    = 2,
	EM1FadeInterval_MAX                      = 3,
};

// Enum M1.EM1SequenceOrder
// NumValues: 0x0006
enum class EM1SequenceOrder : uint8
{
	None                                     = 0,
	Begin                                    = 1,
	Start                                    = 2,
	Finish                                   = 3,
	End                                      = 4,
	EM1SequenceOrder_MAX                     = 5,
};

// Enum M1.EM1ShopProductEventType
// NumValues: 0x0007
enum class EM1ShopProductEventType : uint8
{
	All                                      = 0,
	Always                                   = 1,
	Term                                     = 2,
	Discount                                 = 3,
	Featured                                 = 4,
	Popular                                  = 5,
	EM1ShopProductEventType_MAX              = 6,
};

// Enum M1.EM1ShopProductOwnedType
// NumValues: 0x0004
enum class EM1ShopProductOwnedType : uint8
{
	None                                     = 0,
	Partially                                = 1,
	All                                      = 2,
	EM1ShopProductOwnedType_MAX              = 3,
};

// Enum M1.EM1SkillActivateFailReason
// NumValues: 0x000A
enum class EM1SkillActivateFailReason : uint8
{
	Success                                  = 0,
	Activated                                = 1,
	OwnerLevel                               = 2,
	Cooltime                                 = 3,
	Cost                                     = 4,
	InvalidOwner                             = 5,
	InvalidData                              = 6,
	FailedTagEnter                           = 7,
	Unknown                                  = 8,
	EM1SkillActivateFailReason_MAX           = 9,
};

// Enum M1.EM1SkillActiveType
// NumValues: 0x0008
enum class EM1SkillActiveType : uint8
{
	Normal                                   = 0,
	Wire                                     = 1,
	SubSkill                                 = 2,
	Evade                                    = 3,
	Vault                                    = 4,
	Climb                                    = 5,
	Ecive                                    = 6,
	Max                                      = 7,
};

// Enum M1.EM1CSPChannelPlatformType
// NumValues: 0x0006
enum class EM1CSPChannelPlatformType : uint8
{
	YOUTUBE                                  = 0,
	AFREECATV                                = 1,
	TWITCH                                   = 2,
	X                                        = 3,
	CHZZK                                    = 4,
	EM1CSPChannelPlatformType_MAX            = 5,
};

// Enum M1.EM1SocialInviteType
// NumValues: 0x0004
enum class EM1SocialInviteType : uint8
{
	Party                                    = 0,
	Friend                                   = 1,
	RequestSupport                           = 2,
	EM1SocialInviteType_MAX                  = 3,
};

// Enum M1.EM1SpawnLocationEffectState
// NumValues: 0x0005
enum class EM1SpawnLocationEffectState : uint8
{
	None                                     = 0,
	Preparing                                = 1,
	ReadyToSpawn                             = 2,
	Cleaning                                 = 3,
	EM1SpawnLocationEffectState_MAX          = 4,
};

// Enum M1.EM1StatisticsElement
// NumValues: 0x0057
enum class EM1StatisticsElement : uint8
{
	None                                     = 0,
	TotalBattleTime                          = 1,
	TotalDamage                              = 2,
	GiveDamageCount                          = 3,
	TakeDamage                               = 4,
	TakeDamageCount                          = 5,
	WeaponDamage                             = 6,
	WeaponElementalDamage_Blazer             = 7,
	WeaponElementalDamage_Glacier            = 8,
	WeaponElementalDamage_Electricity        = 9,
	WeaponElementalDamage_Demonic            = 10,
	SkillDamage                              = 11,
	SkillElementalDamage_Plain               = 12,
	SkillElementalDamage_Blazer              = 13,
	SkillElementalDamage_Glacier             = 14,
	SkillElementalDamage_Electricity         = 15,
	SkillElementalDamage_Demonic             = 16,
	SkillArcheTypeDamage_Fusion              = 17,
	SkillArcheTypeDamage_Singular            = 18,
	SkillArcheTypeDamage_Dimension           = 19,
	SkillArcheTypeDamage_Tech                = 20,
	SubSkillDamage                           = 21,
	WeaknessDamageCount                      = 22,
	WeaknessDamage                           = 23,
	CriticalDamage                           = 24,
	TakeDamageNormal                         = 25,
	TakeElementalDamage_Blazer               = 26,
	TakeElementalDamage_Glacier              = 27,
	TakeElementalDamage_Electricity          = 28,
	TakeElementalDamage_Demonic              = 29,
	GiveRecovery_Total_HP                    = 30,
	GiveRecovery_Other_HP                    = 31,
	TakeRecovery_Total_HP                    = 32,
	TakeRecovery_Other_HP                    = 33,
	GiveStatusEffect_Other_Buff              = 34,
	GiveStatusEffect_Other_Debuff            = 35,
	TakeStatusEffect_Other_Buff              = 36,
	TakeStatusEffect_Other_Debuff            = 37,
	DeathCount                               = 38,
	RescueCount                              = 39,
	ReviveByRescueCount                      = 40,
	TotalKillCount                           = 41,
	EliteKillCount                           = 42,
	NamedKillCount                           = 43,
	DarknessKillCount                        = 44,
	TruthKillCount                           = 45,
	ImmortalKillCount                        = 46,
	BossKillCount                            = 47,
	WeaponKillCount                          = 48,
	SkillKillCount                           = 49,
	SubSkillKillCount                        = 50,
	WeaknessKillCount                        = 51,
	DestroyCount                             = 52,
	DeboneCount                              = 53,
	PartsDestoryInfos                        = 54,
	BattleStatistics_Max                     = 55,
	MissionStatisticsStart                   = 55,
	Mission_DataCollection                   = 56,
	Mission_MultiCollection                  = 57,
	Mission_SupplyCount                      = 58,
	Mission_SupplyRate                       = 59,
	Mission_EscortTime                       = 60,
	Mission_OccupiedTime                     = 61,
	Mission_LastWaveIndex                    = 62,
	Mission_LastClearWaveIndex               = 63,
	Mission_TakeDamage_DefenseTarget         = 64,
	Mission_TakeRecovery_DefenseTarget       = 65,
	Mission_CompletelyHackingCount           = 66,
	Mission_SafetyStealLongestTime           = 67,
	Mission_DefenseObjectSafetyLongestTime   = 68,
	Mission_StopMiningCount                  = 69,
	Mission_DefenseObjectHpRate              = 70,
	Mission_EscortLongestTime                = 71,
	Mission_UnescortedTime                   = 72,
	Mission_StoppedEscortTime                = 73,
	Mission_MultiCollectionCompletelyCount   = 74,
	Mission_BarrierActivatorRetreatRate      = 75,
	Mission_ObtainedVoidPieceItem            = 76,
	Mission_VoidFusionTargetKillCount        = 77,
	Mission_VulgusObservationTowerDeactivatedCount = 78,
	Mission_VulgusPostPowerDeviceInteractedCount = 79,
	Mission_CompetitiveOccupationTargetObjectDestructedCount = 80,
	Mission_CompetitiveOccupationHintObjectDestructedCount = 81,
	Mission_CompetitiveOccupationTotalOccupiedTime = 82,
	Mission_CompetitiveOccupationCompletelyOccupiedCount = 83,
	MissionStatistics_Max                    = 84,
	EM1StatisticsElement_MAX                 = 85,
};

// Enum M1.EM1ComponentCollisionOption
// NumValues: 0x0004
enum class EM1ComponentCollisionOption : uint8
{
	IgnoreWhenOverlapped                     = 0,
	IgnoreTraceForAimTarget                  = 1,
	BlockExplosion                           = 2,
	Max                                      = 3,
};

// Enum M1.EM1TaskEventState
// NumValues: 0x0005
enum class EM1TaskEventState : uint8
{
	None                                     = 0,
	Pending                                  = 1,
	Succeeded                                = 2,
	Failed                                   = 3,
	EM1TaskEventState_MAX                    = 4,
};

// Enum M1.EM1EventActorState
// NumValues: 0x0006
enum class EM1EventActorState : uint8
{
	Default                                  = 0,
	Activated                                = 1,
	Running                                  = 2,
	Completed                                = 3,
	Deactivated                              = 4,
	EM1EventActorState_MAX                   = 5,
};

// Enum M1.EM1EventActorCustomTaskResult
// NumValues: 0x0006
enum class EM1EventActorCustomTaskResult : uint8
{
	None                                     = 0,
	OnGoing                                  = 1,
	Pending                                  = 2,
	Succeeded                                = 3,
	Failed                                   = 4,
	EM1EventActorCustomTaskResult_MAX        = 5,
};

// Enum M1.EM1EventActorPreRunningCustomTaskResult
// NumValues: 0x0003
enum class EM1EventActorPreRunningCustomTaskResult : uint8
{
	WaitingRunning                           = 0,
	Stop                                     = 1,
	EM1EventActorPreRunningCustomTaskResult_MAX = 2,
};

// Enum M1.EM1TaskEventActorRunResult
// NumValues: 0x0005
enum class EM1TaskEventActorRunResult : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Failed                                   = 2,
	Succeeded                                = 3,
	EM1TaskEventActorRunResult_MAX           = 4,
};

// Enum M1.EM1TaskEventPreConditionApproachPlayerType
// NumValues: 0x0004
enum class EM1TaskEventPreConditionApproachPlayerType : uint8
{
	OwnerActor                               = 0,
	TargetActors                             = 1,
	SpawnLocations                           = 2,
	EM1TaskEventPreConditionApproachPlayerType_MAX = 3,
};

// Enum M1.EM1QueryStateTagUpdateType
// NumValues: 0x0003
enum class EM1QueryStateTagUpdateType : uint8
{
	Add                                      = 0,
	Remove                                   = 1,
	EM1QueryStateTagUpdateType_MAX           = 2,
};

// Enum M1.EM1InteractableActorState
// NumValues: 0x0006
enum class EM1InteractableActorState : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Interactable                             = 2,
	BeginInteraction                         = 3,
	FinishInteraction                        = 4,
	EM1InteractableActorState_MAX            = 5,
};

// Enum M1.EM1TeleportState
// NumValues: 0x0005
enum class EM1TeleportState : uint8
{
	None                                     = 0,
	Requested                                = 1,
	FinishTeleport                           = 2,
	Idle                                     = 3,
	EM1TeleportState_MAX                     = 4,
};

// Enum M1.EM1TeleportExecuteType
// NumValues: 0x0004
enum class EM1TeleportExecuteType : uint8
{
	NoAllowInterruption                      = 0,
	AllowDoubleTeleport                      = 1,
	AllowInterruption                        = 2,
	EM1TeleportExecuteType_MAX               = 3,
};

// Enum M1.EM1TrapTargetType
// NumValues: 0x0004
enum class EM1TrapTargetType : uint8
{
	Both                                     = 0,
	Monster                                  = 1,
	Player                                   = 2,
	EM1TrapTargetType_MAX                    = 3,
};

// Enum M1.EM1AchievementListFilter
// NumValues: 0x0004
enum class EM1AchievementListFilter : uint8
{
	All                                      = 0,
	Incomplete                               = 1,
	Complete                                 = 2,
	EM1AchievementListFilter_MAX             = 3,
};

// Enum M1.EM1UIActionIconCustomType
// NumValues: 0x0004
enum class EM1UIActionIconCustomType : uint8
{
	Mid                                      = 0,
	Front                                    = 1,
	IconOverlay                              = 2,
	EM1UIActionIconCustomType_MAX            = 3,
};

// Enum M1.EUIAllyPlayerNavigationIconState
// NumValues: 0x0006
enum class EUIAllyPlayerNavigationIconState : uint32
{
	Normal                                   = 0,
	PartyMember                              = 1,
	DBNO                                     = 2,
	UnderRevival                             = 3,
	None                                     = 100,
	EUIAllyPlayerNavigationIconState_MAX     = 101,
};

// Enum M1.EM1ButtonItemAnimType
// NumValues: 0x0004
enum class EM1ButtonItemAnimType : uint8
{
	Equip                                    = 0,
	Warehouse_TakeOut                        = 1,
	Warehouse_PutIn                          = 2,
	EM1ButtonItemAnimType_MAX                = 3,
};

// Enum M1.EM1CashShopContextType
// NumValues: 0x0004
enum class EM1CashShopContextType : uint8
{
	None                                     = 0,
	Featured                                 = 1,
	BattlePass                               = 2,
	EM1CashShopContextType_MAX               = 3,
};

// Enum M1.EM1CashShopItemEndOfSaleReason
// NumValues: 0x0004
enum class EM1CashShopItemEndOfSaleReason : uint8
{
	None                                     = 0,
	TimeExpired                              = 1,
	SlotFullyExpandedAlready                 = 2,
	EM1CashShopItemEndOfSaleReason_MAX       = 3,
};

// Enum M1.EM1CashShopInfoPage
// NumValues: 0x0008
enum class EM1CashShopInfoPage : uint8
{
	Weapon                                   = 0,
	Character                                = 1,
	Custom                                   = 2,
	Selector                                 = 3,
	Custom_UISkin                            = 4,
	Custom_UINameCard                        = 5,
	Bundle                                   = 6,
	MAX                                      = 7,
};

// Enum M1.EM1UISubBundlePreviewPriority
// NumValues: 0x0006
enum class EM1UISubBundlePreviewPriority : uint8
{
	None                                     = 0,
	CharacterSkin                            = 1,
	WeaponSkin                               = 2,
	Customize                                = 3,
	Weapon                                   = 4,
	EM1UISubBundlePreviewPriority_MAX        = 5,
};

// Enum M1.EM1CaptureMode
// NumValues: 0x0004
enum class EM1CaptureMode : uint8
{
	None                                     = 0,
	InputDetected                            = 1,
	CaptureMode                              = 2,
	EM1CaptureMode_MAX                       = 3,
};

// Enum M1.EM1ChattingUIState
// NumValues: 0x0004
enum class EM1ChattingUIState : uint8
{
	Hidden                                   = 0,
	Minimal                                  = 1,
	Maximal                                  = 2,
	EM1ChattingUIState_MAX                   = 3,
};

// Enum M1.EM1CodexUICategoryType
// NumValues: 0x0009
enum class EM1CodexUICategoryType : uint8
{
	Research_Character                       = 0,
	Research_Weapon                          = 1,
	Research_UpgradeMaterial                 = 2,
	Module                                   = 3,
	Accessory                                = 4,
	Consumable_KeyMaterial                   = 5,
	Consumable_Material                      = 6,
	Consumable_VoidValut                     = 7,
	Max                                      = 8,
};

// Enum M1.EM1CustomizeTabType
// NumValues: 0x000A
enum class EM1CustomizeTabType : uint8
{
	None                                     = 0,
	CharacterSkin                            = 1,
	WeaponSkin                               = 2,
	GrapplingHook                            = 3,
	UITheme                                  = 4,
	NameCard                                 = 5,
	Ecive                                    = 6,
	Emotion                                  = 7,
	LobbyMotion                              = 8,
	EM1CustomizeTabType_MAX                  = 9,
};

// Enum M1.EM1UICustomizeType
// NumValues: 0x0007
enum class EM1UICustomizeType : uint8
{
	None                                     = 0,
	TabControl                               = 1,
	TabButton                                = 2,
	CommonButton                             = 3,
	MetaBack                                 = 4,
	Namecard                                 = 5,
	EM1UICustomizeType_MAX                   = 6,
};

// Enum M1.EM1UIDamagedEffectType
// NumValues: 0x0006
enum class EM1UIDamagedEffectType : uint8
{
	None                                     = 0,
	ShieldLoss                               = 1,
	ShieldBroken                             = 2,
	HPLoss                                   = 3,
	DeathWarning                             = 4,
	EM1UIDamagedEffectType_MAX               = 5,
};

// Enum M1.EM1UIActionState
// NumValues: 0x0006
enum class EM1UIActionState : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Cooldown                                 = 2,
	RemainingDuration                        = 3,
	Activate                                 = 4,
	Max                                      = 5,
};

// Enum M1.EM1UIActionDisableType
// NumValues: 0x0008
enum class EM1UIActionDisableType : uint8
{
	None                                     = 0,
	Locked                                   = 1,
	Cost                                     = 2,
	Stack                                    = 3,
	Cooltime                                 = 4,
	Silence                                  = 5,
	Etc                                      = 6,
	Max                                      = 7,
};

// Enum M1.EM1ChattingTextSize
// NumValues: 0x0006
enum class EM1ChattingTextSize : uint8
{
	VerySmall                                = 10,
	Small                                    = 12,
	Normal                                   = 14,
	Big                                      = 16,
	VeryBig                                  = 18,
	EM1ChattingTextSize_MAX                  = 19,
};

// Enum M1.EM1CustomizeEvolutionStatus
// NumValues: 0x0005
enum class EM1CustomizeEvolutionStatus : uint8
{
	Locked                                   = 0,
	Evolutionable                            = 1,
	Selectable                               = 2,
	Equipped                                 = 3,
	EM1CustomizeEvolutionStatus_MAX          = 4,
};

// Enum M1.EM1CustomFloaterType
// NumValues: 0x0003
enum class EM1CustomFloaterType : uint8
{
	None                                     = 0,
	ImmuneBreak                              = 1,
	EM1CustomFloaterType_MAX                 = 2,
};

// Enum M1.EM1UIDataMissionType
// NumValues: 0x0007
enum class EM1UIDataMissionType : uint8
{
	Normal                                   = 0,
	WorldMission                             = 1,
	VoidBattle                               = 2,
	InstanceDungeon                          = 3,
	CharacterDungeon                         = 4,
	InvasionDungeon                          = 5,
	EM1UIDataMissionType_MAX                 = 6,
};

// Enum M1.EM1UIDataPatchState
// NumValues: 0x0007
enum class EM1UIDataPatchState : uint8
{
	NotEnoughSpace                           = 0,
	Retry                                    = 1,
	PatchDataDownload                        = 2,
	PatchDataUpdate                          = 3,
	Finished                                 = 4,
	None                                     = 5,
	EM1UIDataPatchState_MAX                  = 6,
};

// Enum M1.EM1UIDataPatchDownloadState
// NumValues: 0x0003
enum class EM1UIDataPatchDownloadState : uint8
{
	Download                                 = 0,
	Update                                   = 1,
	EM1UIDataPatchDownloadState_MAX          = 2,
};

// Enum M1.EM1ResearchProceedType
// NumValues: 0x0003
enum class EM1ResearchProceedType : uint8
{
	Normal                                   = 0,
	Boost                                    = 1,
	EM1ResearchProceedType_MAX               = 2,
};

// Enum M1.EM1RuneSocketTypeMatchCondition
// NumValues: 0x0004
enum class EM1RuneSocketTypeMatchCondition : uint8
{
	Neutral                                  = 0,
	MatchedWithRune                          = 1,
	NotMatchedWithRune                       = 2,
	EM1RuneSocketTypeMatchCondition_MAX      = 3,
};

// Enum M1.EM1RuneSocketViewType
// NumValues: 0x0003
enum class EM1RuneSocketViewType : uint8
{
	Default                                  = 0,
	SocketType                               = 1,
	EM1RuneSocketViewType_MAX                = 2,
};

// Enum M1.EM1RuneStatCalcType
// NumValues: 0x0003
enum class EM1RuneStatCalcType : uint8
{
	Plus                                     = 0,
	Percent                                  = 1,
	EM1RuneStatCalcType_MAX                  = 2,
};

// Enum M1.EM1RuneDetailPreviewType
// NumValues: 0x0005
enum class EM1RuneDetailPreviewType : uint8
{
	None                                     = 0,
	Add                                      = 1,
	Remove                                   = 2,
	Change                                   = 3,
	EM1RuneDetailPreviewType_MAX             = 4,
};

// Enum M1.EM1InstanaceContentType
// NumValues: 0x0005
enum class EM1InstanaceContentType : uint8
{
	NormalInstanceDungeon                    = 0,
	HardInstanceDungeon                      = 1,
	InvasionDungeon                          = 2,
	WorldMission                             = 3,
	MAX                                      = 4,
};

// Enum M1.EWidgetLayer
// NumValues: 0x0011
enum class EWidgetLayer : uint8
{
	NotAssigned                              = 0,
	UnderMainLayer                           = 1,
	ActorWidgetLayer                         = 2,
	MainLayer                                = 3,
	AboveMainButUnderStandaloneLayer         = 4,
	ChatLayer                                = 5,
	StandaloneLayer                          = 6,
	GuideLayer                               = 7,
	OutOfPlayableAreaMessageLayer            = 8,
	PopupLayer                               = 9,
	MatchingLayer                            = 10,
	ToastLayer                               = 11,
	OverlayLayer                             = 12,
	TestLayer                                = 13,
	SystemLayer                              = 14,
	AlwaysVisibleLayer                       = 15,
	Max                                      = 16,
};

// Enum M1.EM1MainWidgetType
// NumValues: 0x0004
enum class EM1MainWidgetType : uint8
{
	None                                     = 0,
	Lobby                                    = 1,
	Game                                     = 2,
	EM1MainWidgetType_MAX                    = 3,
};

// Enum M1.EM1AboveMainButUnderStandaloneWidgetType
// NumValues: 0x0004
enum class EM1AboveMainButUnderStandaloneWidgetType : uint8
{
	None                                     = 0,
	MissionResult                            = 1,
	MissionWaveCheckPoint                    = 2,
	EM1AboveMainButUnderStandaloneWidgetType_MAX = 3,
};

// Enum M1.EStandaloneWidgetType
// NumValues: 0x000C
enum class EStandaloneWidgetType : uint8
{
	None                                     = 0,
	InGameContentInven                       = 1,
	InGameContentWorld                       = 2,
	InGameMainMenu                           = 3,
	InGameCheat                              = 4,
	InGameNpc                                = 5,
	InGameSequence                           = 6,
	InGameOption                             = 7,
	InGameRadialMenu                         = 8,
	MiniGame                                 = 9,
	GameplayDebugViewer                      = 10,
	EStandaloneWidgetType_MAX                = 11,
};

// Enum M1.EM1CommonWidgetType
// NumValues: 0x0011
enum class EM1CommonWidgetType : uint8
{
	None                                     = 0,
	Popup                                    = 1,
	ToastMessage                             = 2,
	LoadingScreen                            = 3,
	InitLoadingScreen                        = 4,
	GameSession                              = 5,
	Help                                     = 6,
	GameGuideMessage                         = 7,
	MetaGameGuidePanel                       = 8,
	MetaGameGuideMessage                     = 9,
	VideoGuideMessage                        = 10,
	Dialog                                   = 11,
	GraphicsQualitySettings                  = 12,
	PlayerRespawnVolumeWarning               = 13,
	Credits                                  = 14,
	Skip                                     = 15,
	EM1CommonWidgetType_MAX                  = 16,
};

// Enum M1.EM1SystemWidgetType
// NumValues: 0x0006
enum class EM1SystemWidgetType : uint8
{
	None                                     = 0,
	WaitingForNetwork                        = 1,
	Announce_Emergency                       = 2,
	Announce_Information                     = 3,
	Announce_Chat                            = 4,
	EM1SystemWidgetType_MAX                  = 5,
};

// Enum M1.EM1AlwaysVisibleWidgetType
// NumValues: 0x0003
enum class EM1AlwaysVisibleWidgetType : uint8
{
	None                                     = 0,
	SimpleVoiceChattingBoard                 = 1,
	EM1AlwaysVisibleWidgetType_MAX           = 2,
};

// Enum M1.EM1OverlayWidgetType
// NumValues: 0x0005
enum class EM1OverlayWidgetType : uint8
{
	None                                     = 0,
	BackgroundLoading                        = 1,
	BoostNotice                              = 2,
	AkCheatWidget                            = 3,
	EM1OverlayWidgetType_MAX                 = 4,
};

// Enum M1.EM1ButtonUIType
// NumValues: 0x0005
enum class EM1ButtonUIType : uint8
{
	Default                                  = 0,
	Hovered                                  = 1,
	Focused                                  = 2,
	Pressed                                  = 3,
	EM1ButtonUIType_MAX                      = 4,
};

// Enum M1.EM1ButtonUIState
// NumValues: 0x0006
enum class EM1ButtonUIState : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Hovered                                  = 2,
	Pressed                                  = 4,
	All                                      = 6,
	EM1ButtonUIState_MAX                     = 7,
};

// Enum M1.EM1PreferredToolTipPosition
// NumValues: 0x0009
enum class EM1PreferredToolTipPosition : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	Top                                      = 2,
	Bottom                                   = 3,
	LeftTop                                  = 4,
	RightTop                                 = 5,
	LeftBottom                               = 6,
	RightBottom                              = 7,
	Max                                      = 8,
};

// Enum M1.EM1UITextType
// NumValues: 0x0005
enum class EM1UITextType : uint8
{
	DefaultText                              = 0,
	Description                              = 1,
	Narrative                                = 2,
	NarrativeLong                            = 3,
	EM1UITextType_MAX                        = 4,
};

// Enum M1.EFloaterType
// NumValues: 0x000A
enum class EFloaterType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Critical                                 = 2,
	Weakness                                 = 3,
	Advantage                                = 4,
	Inferiority                              = 5,
	Immune                                   = 6,
	Stun                                     = 7,
	Exp                                      = 8,
	MAX                                      = 9,
};

// Enum M1.EM1HitMarkType
// NumValues: 0x0003
enum class EM1HitMarkType : uint8
{
	Normal                                   = 0,
	Kill                                     = 1,
	MAX                                      = 2,
};

// Enum M1.EM1LobbySequenceTrackType
// NumValues: 0x0005
enum class EM1LobbySequenceTrackType : uint8
{
	None                                     = 0,
	Login                                    = 1,
	Menu                                     = 2,
	Menu_Detail                              = 3,
	EM1LobbySequenceTrackType_MAX            = 4,
};

// Enum M1.EM1PrologueSequenceTrackType
// NumValues: 0x0012
enum class EM1PrologueSequenceTrackType : uint8
{
	None                                     = 0,
	WorldView                                = 1,
	Master1                                  = 2,
	Intro                                    = 3,
	Intro_Loop                               = 4,
	Select_In_Ajax                           = 5,
	Select_In_Viessa                         = 6,
	Select_In_Lepic                          = 7,
	Select_Out_Ajax                          = 8,
	Select_Out_Viessa                        = 9,
	Select_Out_Lepic                         = 10,
	Outro_Ajax                               = 11,
	Outro_Viessa                             = 12,
	Outro_Lepic                              = 13,
	GameStart_Ajax                           = 14,
	GameStart_Viessa                         = 15,
	GameStart_Lepic                          = 16,
	MAX                                      = 17,
};

// Enum M1.EM1SequencePlayType
// NumValues: 0x0003
enum class EM1SequencePlayType : uint8
{
	Standard                                 = 0,
	Random                                   = 1,
	EM1SequencePlayType_MAX                  = 2,
};

// Enum M1.UM1UIAnimType
// NumValues: 0x0004
enum class EUM1UIAnimType : uint8
{
	Default                                  = 0,
	FadeIn                                   = 1,
	FadeOut                                  = 2,
	UM1UIAnimType_MAX                        = 3,
};

// Enum M1.EM1PlayMode
// NumValues: 0x0003
enum class EM1PlayMode : uint8
{
	Single                                   = 0,
	Multi                                    = 1,
	EM1PlayMode_MAX                          = 2,
};

// Enum M1.EM1WorldMapInputPlatform
// NumValues: 0x0005
enum class EM1WorldMapInputPlatform : uint8
{
	None                                     = 0,
	Mouse                                    = 1,
	Keyboard                                 = 2,
	Gamepad                                  = 3,
	EM1WorldMapInputPlatform_MAX             = 4,
};

// Enum M1.EM1InputControlMode
// NumValues: 0x0003
enum class EM1InputControlMode : uint8
{
	VirtualCursor                            = 0,
	Navigation                               = 1,
	EM1InputControlMode_MAX                  = 2,
};

// Enum M1.EM1RuneInfoTextColorType
// NumValues: 0x0006
enum class EM1RuneInfoTextColorType : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Negative                                 = 2,
	Add                                      = 3,
	Remove                                   = 4,
	EM1RuneInfoTextColorType_MAX             = 5,
};

// Enum M1.EM1MissionDerivativeMarkerType
// NumValues: 0x0009
enum class EM1MissionDerivativeMarkerType : uint8
{
	None                                     = 0,
	OneOfRemainingFew                        = 1,
	OneOfSpotlighted                         = 2,
	ThiefMonster                             = 3,
	OneOfSpawnedByMission                    = 4,
	SiegeMonster                             = 5,
	ExplosiveMonster                         = 6,
	WarningMarkerAtMonster                   = 7,
	EM1MissionDerivativeMarkerType_MAX       = 8,
};

// Enum M1.EM1BattleZoneCheckType
// NumValues: 0x0005
enum class EM1BattleZoneCheckType : uint8
{
	None                                     = 0,
	Camp                                     = 1,
	Mission                                  = 2,
	Quest                                    = 3,
	EM1BattleZoneCheckType_MAX               = 4,
};

// Enum M1.EM1RuneBoardOffsetColorType
// NumValues: 0x0005
enum class EM1RuneBoardOffsetColorType : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Negative                                 = 2,
	Positive                                 = 3,
	EM1RuneBoardOffsetColorType_MAX          = 4,
};

// Enum M1.EM1ItemListSourceType
// NumValues: 0x0014
enum class EM1ItemListSourceType : uint8
{
	None                                     = 0,
	VoidBattle                               = 1,
	VoidVaultWithVoidBattle                  = 2,
	VoidVaultWithMission                     = 3,
	Shop                                     = 4,
	FieldObject                              = 5,
	WorldMission                             = 6,
	MissionReward                            = 7,
	InstanceDungeon                          = 8,
	InvasionDungeon                          = 9,
	MissionMonster                           = 10,
	InstanceDungeonMonster                   = 11,
	InvasionDungeonMonster                   = 12,
	FieldSpawnMonster                        = 13,
	Quest                                    = 14,
	Decompose                                = 15,
	RotationDrop                             = 16,
	Compose                                  = 17,
	Research                                 = 18,
	EM1ItemListSourceType_MAX                = 19,
};

// Enum M1.EM1TextOverflowType
// NumValues: 0x0004
enum class EM1TextOverflowType : uint8
{
	None                                     = 0,
	Scale                                    = 1,
	Slide                                    = 2,
	EM1TextOverflowType_MAX                  = 3,
};

// Enum M1.EM1TextSlideType
// NumValues: 0x0003
enum class EM1TextSlideType : uint8
{
	Always                                   = 0,
	Hover                                    = 1,
	EM1TextSlideType_MAX                     = 2,
};

// Enum M1.EM1ExpType
// NumValues: 0x0007
enum class EM1ExpType : uint8
{
	None                                     = 0,
	MasteryRank                              = 1,
	BattlePass                               = 2,
	Character                                = 3,
	WeaponProficiency                        = 4,
	Season                                   = 5,
	EM1ExpType_MAX                           = 6,
};

// Enum M1.EM1GrapplingHookHUDGuideWidget
// NumValues: 0x0006
enum class EM1GrapplingHookHUDGuideWidget : uint8
{
	None                                     = 0,
	Type1                                    = 1,
	Type2                                    = 2,
	Type3                                    = 3,
	Type4                                    = 4,
	EM1GrapplingHookHUDGuideWidget_MAX       = 5,
};

// Enum M1.EM1WidgetDirectionBasedOnParent
// NumValues: 0x0003
enum class EM1WidgetDirectionBasedOnParent : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	EM1WidgetDirectionBasedOnParent_MAX      = 2,
};

// Enum M1.EM1UIEquipmentsType
// NumValues: 0x0003
enum class EM1UIEquipmentsType : uint8
{
	RangedWeapon                             = 0,
	Accessory                                = 1,
	EM1UIEquipmentsType_MAX                  = 2,
};

// Enum M1.EM1UIItemFilterType
// NumValues: 0x0009
enum class EM1UIItemFilterType : uint8
{
	None                                     = 0,
	Weapon                                   = 1,
	Accessory                                = 2,
	Rune                                     = 3,
	RuneWide                                 = 4,
	Consumable                               = 5,
	SocialMotions                            = 6,
	Customizing                              = 7,
	EM1UIItemFilterType_MAX                  = 8,
};

// Enum M1.EFlipbookPlayType
// NumValues: 0x0006
enum class EFlipbookPlayType : uint8
{
	None                                     = 0,
	KeepLastFrame                            = 1,
	Loop                                     = 2,
	BackToFirstFrame                         = 3,
	HideAfterAnimation                       = 4,
	EFlipbookPlayType_MAX                    = 5,
};

// Enum M1.EGameCenterMessageType
// NumValues: 0x0005
enum class EGameCenterMessageType : uint8
{
	None                                     = 0,
	NoRounds                                 = 1,
	NoMpForSkillUse                          = 2,
	NoReactorForSkillUse                     = 3,
	MAX                                      = 4,
};

// Enum M1.EM1DBNOType
// NumValues: 0x0005
enum class EM1DBNOType : uint8
{
	None                                     = 0,
	Rescue                                   = 1,
	Giveup                                   = 2,
	NoGiveup                                 = 3,
	EM1DBNOType_MAX                          = 4,
};

// Enum M1.EM1UIContentTabType_Inven
// NumValues: 0x0007
enum class EM1UIContentTabType_Inven : uint8
{
	CashShop                                 = 0,
	BattlePass                               = 1,
	Customize                                = 2,
	Equipment                                = 3,
	Character                                = 4,
	Consumable                               = 5,
	Max                                      = 6,
};

// Enum M1.EM1UIContentTabType_World
// NumValues: 0x0006
enum class EM1UIContentTabType_World : uint8
{
	Journal                                  = 0,
	Codex                                    = 1,
	Map                                      = 2,
	Quest                                    = 3,
	Social                                   = 4,
	Max                                      = 5,
};

// Enum M1.EM1GameMainMenuType
// NumValues: 0x000A
enum class EM1GameMainMenuType : uint8
{
	None                                     = 0,
	Prologue                                 = 1,
	City                                     = 2,
	Field                                    = 3,
	Laboratory                               = 4,
	InstanceField                            = 5,
	VoidBattle                               = 6,
	WorldMission                             = 7,
	InstanceDungeon                          = 8,
	EM1GameMainMenuType_MAX                  = 9,
};

// Enum M1.EM1GameObjectiveDisplayByPriority
// NumValues: 0x0005
enum class EM1GameObjectiveDisplayByPriority : uint8
{
	None                                     = 0,
	MissionTaskOutOfArea                     = 1,
	MissionTaskInfo                          = 2,
	Quest                                    = 3,
	Max                                      = 4,
};

// Enum M1.EM1GameObjectiveDisplayType
// NumValues: 0x0004
enum class EM1GameObjectiveDisplayType : uint8
{
	None                                     = 0,
	QuestOrMission                           = 1,
	Codex                                    = 2,
	EM1GameObjectiveDisplayType_MAX          = 3,
};

// Enum M1.EM1RadarEntityType
// NumValues: 0x0011
enum class EM1RadarEntityType : uint8
{
	None                                     = 0,
	Player                                   = 1,
	SquadMissionMember                       = 2,
	SquadMember                              = 3,
	CampUnlock                               = 4,
	CampLock                                 = 5,
	Mission                                  = 6,
	WorldMission                             = 7,
	DroppedItem_Ammo                         = 8,
	DroppedItem_Rune                         = 9,
	DroppedItem_RangedWeapon                 = 10,
	DroppedItem_Accessory                    = 11,
	DroppedItem_Reactor                      = 12,
	PartyMissionMember                       = 13,
	PartyMember                              = 14,
	WayPoint                                 = 15,
	EM1RadarEntityType_MAX                   = 16,
};

// Enum M1.EM1RadarCenterType
// NumValues: 0x0003
enum class EM1RadarCenterType : uint8
{
	PlayerPawn                               = 0,
	PlayerController                         = 1,
	EM1RadarCenterType_MAX                   = 2,
};

// Enum M1.EM1UIStatColor
// NumValues: 0x0004
enum class EM1UIStatColor : uint8
{
	Default                                  = 0,
	RandomOptionOnly                         = 1,
	PerkOnly                                 = 2,
	EM1UIStatColor_MAX                       = 3,
};

// Enum M1.EM1UIVoidBattleStatColor
// NumValues: 0x0004
enum class EM1UIVoidBattleStatColor : uint8
{
	Default                                  = 0,
	Up                                       = 1,
	Down                                     = 2,
	EM1UIVoidBattleStatColor_MAX             = 3,
};

// Enum M1.EM1InGameSequenceType
// NumValues: 0x0004
enum class EM1InGameSequenceType : uint8
{
	Prologue                                 = 0,
	MapEntrance                              = 1,
	MasteryRankUp                            = 2,
	EM1InGameSequenceType_MAX                = 3,
};

// Enum M1.EM1InvasionDungeonScoreState
// NumValues: 0x0004
enum class EM1InvasionDungeonScoreState : uint8
{
	None                                     = 0,
	Active                                   = 1,
	Fail                                     = 2,
	EM1InvasionDungeonScoreState_MAX         = 3,
};

// Enum M1.EM1InventoryAnimDirection
// NumValues: 0x0005
enum class EM1InventoryAnimDirection : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	Up                                       = 2,
	Down                                     = 3,
	EM1InventoryAnimDirection_MAX            = 4,
};

// Enum M1.EM1InventoryTab
// NumValues: 0x000C
enum class EM1InventoryTab : uint8
{
	Default                                  = 0,
	WeaponInventory                          = 1,
	AccInventory                             = 2,
	Information                              = 3,
	Customize                                = 4,
	Preset                                   = 5,
	WeaponBook                               = 6,
	ItemInformation                          = 7,
	MasteryRankBenefits                      = 8,
	AchievementTitle                         = 9,
	SeasonReinforce                          = 10,
	MAX                                      = 11,
};

// Enum M1.EM1ItemIconType
// NumValues: 0x0004
enum class EM1ItemIconType : uint8
{
	Default                                  = 0,
	Big                                      = 1,
	Small                                    = 2,
	EM1ItemIconType_MAX                      = 3,
};

// Enum M1.EM1LevelUpgradePhase
// NumValues: 0x0005
enum class EM1LevelUpgradePhase : uint8
{
	None                                     = 0,
	SelectTarget                             = 1,
	BeforeSelectMaterial                     = 2,
	AfterSelectMaterial                      = 3,
	EM1LevelUpgradePhase_MAX                 = 4,
};

// Enum M1.EM1JournalWidgetType
// NumValues: 0x0003
enum class EM1JournalWidgetType : uint8
{
	Achievement                              = 0,
	Record                                   = 1,
	EM1JournalWidgetType_MAX                 = 2,
};

// Enum M1.EM1JunkFilterTabType
// NumValues: 0x0005
enum class EM1JunkFilterTabType : uint8
{
	Weapon                                   = 0,
	Reactor                                  = 1,
	Accessory                                = 2,
	All                                      = 3,
	EM1JunkFilterTabType_MAX                 = 4,
};

// Enum M1.EM1UIKeyTypeInputEvent
// NumValues: 0x0005
enum class EM1UIKeyTypeInputEvent : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	ReleaseOnly                              = 2,
	HoldButton                               = 3,
	EM1UIKeyTypeInputEvent_MAX               = 4,
};

// Enum M1.EM1LobbyWidgetPage
// NumValues: 0x0007
enum class EM1LobbyWidgetPage : uint32
{
	None                                     = 18446744073709551615,
	OptionLanguage                           = 0,
	OptionBrightness                         = 1,
	OptionScreenSize                         = 2,
	Login                                    = 3,
	Menu                                     = 4,
	EM1LobbyWidgetPage_MAX                   = 5,
};

// Enum M1.EM1MapBattleZoneCondition
// NumValues: 0x0007
enum class EM1MapBattleZoneCondition : uint8
{
	Default                                  = 0,
	Locked                                   = 1,
	Selected                                 = 2,
	Focus_Default                            = 3,
	Focus_Locked                             = 4,
	Focus_Selected                           = 5,
	EM1MapBattleZoneCondition_MAX            = 6,
};

// Enum M1.EM1LoginWidgetSwitch
// NumValues: 0x0006
enum class EM1LoginWidgetSwitch : uint8
{
	DevLogin                                 = 0,
	WaitInputToToyLogin                      = 1,
	ToyLogin                                 = 2,
	WaitInput                                = 3,
	SelectBoostingAccount                    = 4,
	EM1LoginWidgetSwitch_MAX                 = 5,
};

// Enum M1.EM1UIMailPageType
// NumValues: 0x0005
enum class EM1UIMailPageType : uint8
{
	LostMail                                 = 0,
	Default                                  = 1,
	NarrativeMail                            = 2,
	Count                                    = 3,
	EM1UIMailPageType_MAX                    = 4,
};

// Enum M1.EM1MasteryLimitActionType
// NumValues: 0x0004
enum class EM1MasteryLimitActionType : uint8
{
	None                                     = 0,
	Research                                 = 1,
	BuyAtShop                                = 2,
	EM1MasteryLimitActionType_MAX            = 3,
};

// Enum M1.EM1MasteryRankBenefitType
// NumValues: 0x000F
enum class EM1MasteryRankBenefitType : uint8
{
	None                                     = 0,
	VISIBLE_ALWAYS_BEGIN                     = 1,
	CharacterRune                            = 2,
	WeaponRune                               = 3,
	EquipInventoryCapacity                   = 4,
	WarehoueCapacity                         = 5,
	ConsumableInventoryCapacity              = 6,
	VoidVaultStabilizerMaxStackCount         = 7,
	VISIBLE_ALWAYS_END                       = 8,
	VISIBLE_WHEN_CHANGED_BEGIN               = 9,
	TradeCount                               = 10,
	CodexTrackingSlot                        = 11,
	VISIBLE_WHEN_CHANGED_END                 = 12,
	Custom                                   = 13,
	EM1MasteryRankBenefitType_MAX            = 14,
};

// Enum M1.EM1MissionGuideType
// NumValues: 0x0004
enum class EM1MissionGuideType : uint8
{
	Mission                                  = 0,
	FieldContents                            = 1,
	VoidBattle                               = 2,
	EM1MissionGuideType_MAX                  = 3,
};

// Enum M1.EM1MissionGuideStateType
// NumValues: 0x0004
enum class EM1MissionGuideStateType : uint8
{
	Start                                    = 0,
	Success                                  = 1,
	Fail                                     = 2,
	EM1MissionGuideStateType_MAX             = 3,
};

// Enum M1.EM1MissionResultOpenAnimType
// NumValues: 0x0004
enum class EM1MissionResultOpenAnimType : uint8
{
	None                                     = 0,
	InstanceDungeon                          = 1,
	InvasionDungeon                          = 2,
	EM1MissionResultOpenAnimType_MAX         = 3,
};

// Enum M1.EM1UIMissionResultExpOwnerType
// NumValues: 0x0005
enum class EM1UIMissionResultExpOwnerType : uint8
{
	None                                     = 0,
	MasteryRank                              = 1,
	Player                                   = 2,
	WeaponProficiency                        = 3,
	EM1UIMissionResultExpOwnerType_MAX       = 4,
};

// Enum M1.EM1UIMissionResultExpType
// NumValues: 0x0007
enum class EM1UIMissionResultExpType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	MissionClear                             = 2,
	EventBoost                               = 3,
	BoostItem                                = 4,
	ItemOption                               = 5,
	EM1UIMissionResultExpType_MAX            = 6,
};

// Enum M1.EM1StatisticsShowType
// NumValues: 0x0004
enum class EM1StatisticsShowType : uint8
{
	Always                                   = 0,
	MissionTask                              = 1,
	MissionSubType                           = 2,
	EM1StatisticsShowType_MAX                = 3,
};

// Enum M1.EM1UIMissionTaskMessageType
// NumValues: 0x0003
enum class EM1UIMissionTaskMessageType : uint8
{
	RetriableTask                            = 0,
	LastChance                               = 1,
	EM1UIMissionTaskMessageType_MAX          = 2,
};

// Enum M1.EM1MultiConditionStateChangedReason
// NumValues: 0x0007
enum class EM1MultiConditionStateChangedReason : uint8
{
	None                                     = 0,
	Sorter                                   = 1,
	SortDirection                            = 2,
	Filter                                   = 3,
	ResetFilter                              = 4,
	Search                                   = 5,
	EM1MultiConditionStateChangedReason_MAX  = 6,
};

// Enum M1.EM1UIValueChangedReason
// NumValues: 0x0003
enum class EM1UIValueChangedReason : uint8
{
	Direct                                   = 0,
	WidgetInput                              = 1,
	EM1UIValueChangedReason_MAX              = 2,
};

// Enum M1.EM1InputKeySelectorWrapperType
// NumValues: 0x0004
enum class EM1InputKeySelectorWrapperType : uint8
{
	None                                     = 0,
	KeyboardAndMouse                         = 1,
	Controller                               = 2,
	EM1InputKeySelectorWrapperType_MAX       = 3,
};

// Enum M1.EM1ItemVisibleMode
// NumValues: 0x0008
enum class EM1ItemVisibleMode : uint8
{
	None                                     = 0,
	Equipment                                = 1,
	Consumables                              = 2,
	Runes                                    = 3,
	Emotions                                 = 4,
	All                                      = 6,
	Customizing                              = 7,
	EM1ItemVisibleMode_MAX                   = 8,
};

// Enum M1.EM1EquipmentVisibleMode
// NumValues: 0x0007
enum class EM1EquipmentVisibleMode : uint8
{
	Weapon                                   = 0,
	Accessory                                = 1,
	WeaponOptionChange                       = 2,
	ReactorOptionChange                      = 3,
	Warehouse_Inven                          = 4,
	Warehouse_Storage                        = 5,
	EM1EquipmentVisibleMode_MAX              = 6,
};

// Enum M1.EM1RuneVisibleMode
// NumValues: 0x0003
enum class EM1RuneVisibleMode : uint8
{
	None                                     = 0,
	ClassAndSocketTypes                      = 1,
	EM1RuneVisibleMode_MAX                   = 2,
};

// Enum M1.EM1RuneItemsViewType
// NumValues: 0x0004
enum class EM1RuneItemsViewType : uint8
{
	All                                      = 0,
	ActiveCharacterRunes                     = 1,
	ActiveWeaponRunes                        = 2,
	EM1RuneItemsViewType_MAX                 = 3,
};

// Enum M1.EM1PerkEnchantPhase
// NumValues: 0x0004
enum class EM1PerkEnchantPhase : uint8
{
	SelectTarget                             = 0,
	SelectMaterial                           = 1,
	TargetAndMaterialSelected                = 2,
	EM1PerkEnchantPhase_MAX                  = 3,
};

// Enum M1.EM1PolygonalLineAnchorType
// NumValues: 0x0003
enum class EM1PolygonalLineAnchorType : uint8
{
	Center                                   = 0,
	LeftBottom                               = 1,
	EM1PolygonalLineAnchorType_MAX           = 2,
};

// Enum M1.EM1AccountInfoPopupButtonType
// NumValues: 0x0014
enum class EM1AccountInfoPopupButtonType : uint8
{
	None                                     = 0,
	PartyInvite                              = 1,
	PartyInviteAccept                        = 2,
	PartyInviteReject                        = 3,
	PartyMasterDevolve                       = 4,
	PartyExile                               = 5,
	PartyLeave                               = 6,
	FriendRequest                            = 7,
	FriendDelete                             = 8,
	FriendInviteAccept                       = 9,
	FriendInviteCancel                       = 10,
	FriendBookmark                           = 11,
	BlockRequest                             = 12,
	BlockCancel                              = 13,
	DirectMessage                            = 14,
	Report                                   = 15,
	PlatformProfilePS                        = 16,
	PlatformProfileXbox                      = 17,
	CSP                                      = 18,
	EM1AccountInfoPopupButtonType_MAX        = 19,
};

// Enum M1.EM1QuestMarkerIconType
// NumValues: 0x0008
enum class EM1QuestMarkerIconType : uint8
{
	InteractionNPC                           = 0,
	MainQuest                                = 1,
	FieldQuest                               = 2,
	SubQuest                                 = 3,
	CharacterStoryQuest                      = 4,
	SeasonQuest                              = 5,
	None                                     = 6,
	EM1QuestMarkerIconType_MAX               = 7,
};

// Enum M1.EM1RadialMenuAction
// NumValues: 0x0003
enum class EM1RadialMenuAction : uint8
{
	None                                     = 0,
	SocialMotion                             = 1,
	EM1RadialMenuAction_MAX                  = 2,
};

// Enum M1.EM1ResearchTabType
// NumValues: 0x0009
enum class EM1ResearchTabType : uint8
{
	Featured                                 = 0,
	Favorite                                 = 1,
	All                                      = 2,
	Character                                = 3,
	Equipment                                = 4,
	CharacterMaterial                        = 5,
	EquipmentMaterial                        = 6,
	UpgradeMaterial                          = 7,
	EM1ResearchTabType_MAX                   = 8,
};

// Enum M1.EM1RuneCapacityIncreaseCondition
// NumValues: 0x0005
enum class EM1RuneCapacityIncreaseCondition : uint8
{
	Unknown                                  = 0,
	MaxCapacityIncreaseCount                 = 1,
	NotEnoughItem                            = 2,
	Success                                  = 3,
	EM1RuneCapacityIncreaseCondition_MAX     = 4,
};

// Enum M1.EM1RuneComposeViewType
// NumValues: 0x0003
enum class EM1RuneComposeViewType : uint8
{
	Default                                  = 0,
	DulicatedRunes                           = 1,
	EM1RuneComposeViewType_MAX               = 2,
};

// Enum M1.EM1RuneEnchantFailureReason
// NumValues: 0x0007
enum class EM1RuneEnchantFailureReason : uint8
{
	Success                                  = 0,
	GoldNotEnough                            = 1,
	QulipothiumNotEnough                     = 2,
	NotReachedMasteryLevel                   = 3,
	NotEnchantable                           = 4,
	RuneInvalidData                          = 5,
	EM1RuneEnchantFailureReason_MAX          = 6,
};

// Enum M1.EM1RuneEnchantTabCategory
// NumValues: 0x0004
enum class EM1RuneEnchantTabCategory : uint8
{
	All                                      = 0,
	AttachedToEquippedCharacter              = 1,
	AttachedToEquippedWeapons                = 2,
	EM1RuneEnchantTabCategory_MAX            = 3,
};

// Enum M1.EM1RuneBoardSideTab
// NumValues: 0x0003
enum class EM1RuneBoardSideTab : uint8
{
	RuneSocketTypeAdd                        = 0,
	RuneCapacityIncrease                     = 1,
	EM1RuneBoardSideTab_MAX                  = 2,
};

// Enum M1.EM1RuneSocketTypeAddCondition
// NumValues: 0x0008
enum class EM1RuneSocketTypeAddCondition : uint8
{
	Unknown                                  = 0,
	NotEnoughWeaponLevel                     = 1,
	NotEnoughCharLevel                       = 2,
	NotEnoughItem                            = 3,
	ExceptSameType                           = 4,
	NotSelectSlot                            = 5,
	Success                                  = 6,
	EM1RuneSocketTypeAddCondition_MAX        = 7,
};

// Enum M1.EM1SeasonRewardButtonState
// NumValues: 0x0005
enum class EM1SeasonRewardButtonState : uint8
{
	CanBuy                                   = 0,
	NotSatisfiedRequiredConditon             = 1,
	LackCoin                                 = 2,
	AlreadyBuy                               = 3,
	EM1SeasonRewardButtonState_MAX           = 4,
};

// Enum M1.EM1ShopGoodsIconIndex
// NumValues: 0x0009
enum class EM1ShopGoodsIconIndex : uint8
{
	Bundle                                   = 0,
	Character                                = 1,
	Weapon                                   = 2,
	Reactor                                  = 3,
	Accesory                                 = 4,
	CustomizeCharacter                       = 5,
	CustomizeWeapon                          = 6,
	Etc                                      = 7,
	EM1ShopGoodsIconIndex_MAX                = 8,
};

// Enum M1.EM1ShopEquipmentCategoryFilter
// NumValues: 0x0005
enum class EM1ShopEquipmentCategoryFilter : uint8
{
	None                                     = 0,
	Accessory                                = 1,
	Reactor                                  = 2,
	Weapon                                   = 3,
	EM1ShopEquipmentCategoryFilter_MAX       = 4,
};

// Enum M1.EM1SkipButtonType
// NumValues: 0x0004
enum class EM1SkipButtonType : uint8
{
	Click                                    = 0,
	Hold                                     = 1,
	Both                                     = 2,
	EM1SkipButtonType_MAX                    = 3,
};

// Enum M1.EM1UISocialTabType
// NumValues: 0x0003
enum class EM1UISocialTabType : uint8
{
	InGame                                   = 0,
	Platform                                 = 1,
	EM1UISocialTabType_MAX                   = 2,
};

// Enum M1.EM1ConstantTimeFormat
// NumValues: 0x0007
enum class EM1ConstantTimeFormat : uint8
{
	MMSS                                     = 0,
	HHMM                                     = 1,
	HHMMSS                                   = 2,
	DDHHMM                                   = 3,
	DDHHMMSS                                 = 4,
	DD                                       = 5,
	EM1ConstantTimeFormat_MAX                = 6,
};

// Enum M1.EM1ToastType
// NumValues: 0x0008
enum class EM1ToastType : uint8
{
	None                                     = 0,
	B_Crosshair                              = 1,
	MidLine                                  = 2,
	CBot_Side                                = 3,
	RTop_Side                                = 4,
	BottomLine                               = 5,
	BottomButton                             = 6,
	EM1ToastType_MAX                         = 7,
};

// Enum M1.EM1ValuableItemType
// NumValues: 0x0004
enum class EM1ValuableItemType : uint8
{
	HighTierItem                             = 0,
	HighPerkLevelWeapon                      = 1,
	HighEnchantLevelReactor                  = 2,
	Max                                      = 3,
};

// Enum M1.EM1WarehouseTabType
// NumValues: 0x0003
enum class EM1WarehouseTabType : uint8
{
	Warehouse                                = 0,
	Inventory                                = 1,
	MAX                                      = 2,
};

// Enum M1.EM1WarehouseItemCategory
// NumValues: 0x0005
enum class EM1WarehouseItemCategory : uint8
{
	All                                      = 0,
	Weapon                                   = 1,
	Reactor                                  = 2,
	Accessory                                = 3,
	MAX                                      = 4,
};

// Enum M1.EM1WidgetAnimDirection
// NumValues: 0x0004
enum class EM1WidgetAnimDirection : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	EM1WidgetAnimDirection_MAX               = 3,
};

// Enum M1.EM1TooltipAttachOption
// NumValues: 0x0003
enum class EM1TooltipAttachOption : uint8
{
	Relative                                 = 0,
	Absolute                                 = 1,
	EM1TooltipAttachOption_MAX               = 2,
};

// Enum M1.EM1TooltipAttachDirection
// NumValues: 0x0004
enum class EM1TooltipAttachDirection : uint8
{
	Auto                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	EM1TooltipAttachDirection_MAX            = 3,
};

// Enum M1.EM1WorldFieldCondition
// NumValues: 0x0005
enum class EM1WorldFieldCondition : uint8
{
	Default                                  = 0,
	Selected                                 = 1,
	Locked                                   = 2,
	Unvalid                                  = 3,
	EM1WorldFieldCondition_MAX               = 4,
};

// Enum M1.EM1MapObjectSnappingPriority
// NumValues: 0x000D
enum class EM1MapObjectSnappingPriority : uint8
{
	None                                     = 0,
	EpicMonsterSphere                        = 1,
	EpicMonster                              = 2,
	Squad                                    = 3,
	Party                                    = 4,
	Player                                   = 5,
	Npc                                      = 6,
	Quest                                    = 7,
	Mission                                  = 8,
	Portal                                   = 9,
	Camp                                     = 10,
	WayPoint                                 = 11,
	EM1MapObjectSnappingPriority_MAX         = 12,
};

// Enum M1.EM1MapObjectPriority
// NumValues: 0x000D
enum class EM1MapObjectPriority : uint8
{
	None                                     = 0,
	Npc                                      = 1,
	Camp                                     = 2,
	Portal                                   = 3,
	EpicMonsterSphere                        = 4,
	Mission                                  = 5,
	EpicMonster                              = 6,
	Squad                                    = 7,
	Party                                    = 8,
	Player                                   = 9,
	Quest                                    = 10,
	WayPoint                                 = 11,
	EM1MapObjectPriority_MAX                 = 12,
};

// Enum M1.EM1ComponentVisibilityControl
// NumValues: 0x0003
enum class EM1ComponentVisibilityControl : uint8
{
	Hidden                                   = 0,
	Visible                                  = 1,
	EM1ComponentVisibilityControl_MAX        = 2,
};

// Enum M1.EM1VoiceChatChannel
// NumValues: 0x0004
enum class EM1VoiceChatChannel : uint8
{
	EchoChannel                              = 0,
	PartyChannel                             = 1,
	SquadChannel                             = 2,
	EM1VoiceChatChannel_MAX                  = 3,
};

// Enum M1.EM1VoiceChatChannelJoinState
// NumValues: 0x0006
enum class EM1VoiceChatChannelJoinState : uint8
{
	NotJoined                                = 0,
	Leaving                                  = 1,
	Requested                                = 2,
	Joining                                  = 3,
	Joined                                   = 4,
	EM1VoiceChatChannelJoinState_MAX         = 5,
};

// Enum M1.EM1WeaponChargeState
// NumValues: 0x0004
enum class EM1WeaponChargeState : uint8
{
	Steady                                   = 0,
	Charging                                 = 1,
	Discharging                              = 2,
	EM1WeaponChargeState_MAX                 = 3,
};

// Enum M1.EM1WeaponReloadState
// NumValues: 0x0006
enum class EM1WeaponReloadState : uint32
{
	None                                     = 0,
	Reload                                   = 1,
	LoopEnd                                  = 2,
	End                                      = 3,
	Stop                                     = 4,
	EM1WeaponReloadState_MAX                 = 5,
};

// Enum M1.EM1WeaponAnimType
// NumValues: 0x000D
enum class EM1WeaponAnimType : uint8
{
	None                                     = 0,
	Fire                                     = 1,
	Reload                                   = 2,
	Equip                                    = 3,
	UnEquip                                  = 4,
	Spawn                                    = 5,
	Despawn                                  = 6,
	SkillMontage01                           = 7,
	SkillMontage02                           = 8,
	SkillMontage03                           = 9,
	SkillMontage04                           = 10,
	SkillMontage05                           = 11,
	Max                                      = 12,
};

// Enum M1.EM1WeaponFXType
// NumValues: 0x0019
enum class EM1WeaponFXType : uint8
{
	None                                     = 0,
	EmptyCartridge01                         = 1,
	EmptyCartridge02                         = 2,
	EmptyCartridge03                         = 3,
	Muzzle01                                 = 4,
	Muzzle02                                 = 5,
	Muzzle03                                 = 6,
	Muzzle04                                 = 7,
	Muzzle05                                 = 8,
	Trail01                                  = 9,
	Trail02                                  = 10,
	Trail03                                  = 11,
	Etc01                                    = 12,
	Etc02                                    = 13,
	Etc03                                    = 14,
	Etc04                                    = 15,
	Etc05                                    = 16,
	Etc06                                    = 17,
	Etc07                                    = 18,
	Etc08                                    = 19,
	Etc09                                    = 20,
	Etc10                                    = 21,
	EmptyCartridge04                         = 22,
	EmptyCartridge05                         = 23,
	Max                                      = 24,
};

// Enum M1.EM1WeaponActionState
// NumValues: 0x0007
enum class EM1WeaponActionState : uint8
{
	Idle                                     = 0,
	AimOn                                    = 1,
	ReadyToFire                              = 2,
	WarmingUp                                = 3,
	Fire                                     = 4,
	AimOff                                   = 5,
	EM1WeaponActionState_MAX                 = 6,
};

// Enum M1.EM1WeaponAimState
// NumValues: 0x0005
enum class EM1WeaponAimState : uint8
{
	None                                     = 0,
	AimOn                                    = 1,
	AimHold                                  = 2,
	AimOff                                   = 3,
	EM1WeaponAimState_MAX                    = 4,
};

// Enum M1.EM1WidgetAudioType
// NumValues: 0x0009
enum class EM1WidgetAudioType : uint8
{
	Open                                     = 0,
	Close                                    = 1,
	Selected                                 = 2,
	Click                                    = 3,
	Pressed                                  = 4,
	Released                                 = 5,
	Hover                                    = 6,
	Hold                                     = 7,
	Max                                      = 8,
};

// Enum M1.EM1SaveSortAndFilterScope
// NumValues: 0x001C
enum class EM1SaveSortAndFilterScope : uint8
{
	None                                     = 0,
	Character                                = 1,
	Consumable                               = 2,
	RuneBoard                                = 3,
	RuneCompose                              = 4,
	RuneDecompose                            = 5,
	RuneEnchant                              = 6,
	Inventory                                = 7,
	InventoryAcc                             = 8,
	SocialMotion                             = 9,
	ShopBuy                                  = 10,
	ShopSell                                 = 11,
	Research                                 = 12,
	WeaponBook                               = 13,
	ItemLevelUpgrade                         = 14,
	WareHouse                                = 15,
	Quest                                    = 16,
	Customize_CharacterSkin                  = 17,
	Customize_CharacterSkinPaint             = 18,
	Customize_Weaponlist                     = 19,
	Customize_WeaponSkin                     = 20,
	Customize_WeaponSkinPaint                = 21,
	Customize_Spawn                          = 22,
	Customize_GrapplingHook                  = 23,
	Customize_UITheme                        = 24,
	Customize_Namecard                       = 25,
	Customize_Ecive                          = 26,
	EM1SaveSortAndFilterScope_MAX            = 27,
};

// Enum M1.EM1WirePullingAnim
// NumValues: 0x0004
enum class EM1WirePullingAnim : uint8
{
	Default                                  = 0,
	Up                                       = 1,
	Down                                     = 2,
	Max                                      = 3,
};

// Enum M1.EM1CollisionEffectType
// NumValues: 0x0004
enum class EM1CollisionEffectType : uint8
{
	Start                                    = 0,
	Loop                                     = 1,
	End                                      = 2,
	EM1CollisionEffectType_MAX               = 3,
};

// Enum M1.EM1BattleZoneProgressState
// NumValues: 0x0004
enum class EM1BattleZoneProgressState : uint8
{
	InProgress                               = 0,
	EssentialLeft                            = 1,
	AllClear                                 = 2,
	EM1BattleZoneProgressState_MAX           = 3,
};

// Enum M1.EM1FieldProgressState
// NumValues: 0x0004
enum class EM1FieldProgressState : uint8
{
	InProgress                               = 0,
	BattleZoneClear                          = 1,
	AllClear                                 = 2,
	EM1FieldProgressState_MAX                = 3,
};

// Enum M1.EM1FieldProgressTargetState
// NumValues: 0x0004
enum class EM1FieldProgressTargetState : uint8
{
	None                                     = 0,
	InProgress                               = 1,
	Done                                     = 2,
	EM1FieldProgressTargetState_MAX          = 3,
};

// Enum M1.EM1MapEntityQuestTargetState
// NumValues: 0x0005
enum class EM1MapEntityQuestTargetState : uint8
{
	Main                                     = 0,
	Sub                                      = 1,
	CharacterStory                           = 2,
	None                                     = 3,
	EM1MapEntityQuestTargetState_MAX         = 4,
};

// ScriptStruct M1.M1Request
// 0x0000 (0x0000 - 0x0000)
#pragma pack(push, 0x1)
struct alignas(0x01) FM1Request
{
};
#pragma pack(pop)
static_assert(alignof(FM1Request) == 0x000001, "Wrong alignment on FM1Request");
static_assert(sizeof(FM1Request) == 0x000001, "Wrong size on FM1Request");

// ScriptStruct M1.M1Request_CheatCompleteBattleZone
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CheatCompleteBattleZone final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MapTemplateId;                                     // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          BattleZoneId;                                      // 0x000C(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatCompleteBattleZone) == 0x000008, "Wrong alignment on FM1Request_CheatCompleteBattleZone");
static_assert(sizeof(FM1Request_CheatCompleteBattleZone) == 0x000010, "Wrong size on FM1Request_CheatCompleteBattleZone");
static_assert(offsetof(FM1Request_CheatCompleteBattleZone, AccountUid) == 0x000000, "Member 'FM1Request_CheatCompleteBattleZone::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatCompleteBattleZone, MapTemplateId) == 0x000008, "Member 'FM1Request_CheatCompleteBattleZone::MapTemplateId' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatCompleteBattleZone, BattleZoneId) == 0x00000C, "Member 'FM1Request_CheatCompleteBattleZone::BattleZoneId' has a wrong offset!");

// ScriptStruct M1.M1FXColorParam
// 0x0018 (0x0018 - 0x0000)
struct FM1FXColorParam final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ParamValue;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FXColorParam) == 0x000004, "Wrong alignment on FM1FXColorParam");
static_assert(sizeof(FM1FXColorParam) == 0x000018, "Wrong size on FM1FXColorParam");
static_assert(offsetof(FM1FXColorParam, ParamName) == 0x000000, "Member 'FM1FXColorParam::ParamName' has a wrong offset!");
static_assert(offsetof(FM1FXColorParam, ParamValue) == 0x000008, "Member 'FM1FXColorParam::ParamValue' has a wrong offset!");

// ScriptStruct M1.M1DecomposeJunkElement
// 0x0008 (0x0008 - 0x0000)
struct FM1DecomposeJunkElement final
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DecomposeJunkElement) == 0x000004, "Wrong alignment on FM1DecomposeJunkElement");
static_assert(sizeof(FM1DecomposeJunkElement) == 0x000008, "Wrong size on FM1DecomposeJunkElement");
static_assert(offsetof(FM1DecomposeJunkElement, TemplateId) == 0x000000, "Member 'FM1DecomposeJunkElement::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1DecomposeJunkElement, Count) == 0x000004, "Member 'FM1DecomposeJunkElement::Count' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatWeaponProficiencyMax
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CheatWeaponProficiencyMax final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          WeaponTid;                                         // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_CheatWeaponProficiencyMax) == 0x000008, "Wrong alignment on FM1Request_CheatWeaponProficiencyMax");
static_assert(sizeof(FM1Request_CheatWeaponProficiencyMax) == 0x000010, "Wrong size on FM1Request_CheatWeaponProficiencyMax");
static_assert(offsetof(FM1Request_CheatWeaponProficiencyMax, AccountUid) == 0x000000, "Member 'FM1Request_CheatWeaponProficiencyMax::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatWeaponProficiencyMax, WeaponTid) == 0x000008, "Member 'FM1Request_CheatWeaponProficiencyMax::WeaponTid' has a wrong offset!");

// ScriptStruct M1.M1CalcDamageInfo
// 0x0138 (0x0138 - 0x0000)
struct FM1CalcDamageInfo final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x009C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                CauserLocation;                                    // 0x009C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Instigator;                                        // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AActor>>          DamageEventObservers;                              // 0x00B0(0x0010)(ZeroConstructor, Transient, RepSkip, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FM1ScaledInteger                       TotalDamage;                                       // 0x00C0(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1WeaponDamageType                           WeaponDamageType;                                  // 0x00C8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1AdvantageCalcResult                        AdvantageCalcResult;                               // 0x00C9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ElementalDamageChannel                     RepresentativeElementalDamageType;                 // 0x00CA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB[0x5];                                       // 0x00CB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1ScaledInteger>               ElementalDamages;                                  // 0x00D0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bInvokeElemetalSE;                                 // 0x00E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ScaledInteger                       HitStopAttackPoint;                                // 0x00E8(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PhysicalPowerOptionKey;                            // 0x00F0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCritical;                                         // 0x00F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeakness;                                         // 0x00F9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForcedReduceHP;                                   // 0x00FA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForcedKillDBNO;                                   // 0x00FB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransferredDamage;                                // 0x00FC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasDied;                                          // 0x00FD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReduceHP;                                         // 0x00FE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBreakShield;                                      // 0x00FF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmune;                                           // 0x0100(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        Time;                                              // 0x0108(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TraitTags;                                         // 0x0110(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CalcDamageInfo) == 0x000008, "Wrong alignment on FM1CalcDamageInfo");
static_assert(sizeof(FM1CalcDamageInfo) == 0x000138, "Wrong size on FM1CalcDamageInfo");
static_assert(offsetof(FM1CalcDamageInfo, HitResult) == 0x000000, "Member 'FM1CalcDamageInfo::HitResult' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, CauserLocation) == 0x00009C, "Member 'FM1CalcDamageInfo::CauserLocation' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, Instigator) == 0x0000A8, "Member 'FM1CalcDamageInfo::Instigator' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, DamageEventObservers) == 0x0000B0, "Member 'FM1CalcDamageInfo::DamageEventObservers' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, TotalDamage) == 0x0000C0, "Member 'FM1CalcDamageInfo::TotalDamage' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, WeaponDamageType) == 0x0000C8, "Member 'FM1CalcDamageInfo::WeaponDamageType' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, AdvantageCalcResult) == 0x0000C9, "Member 'FM1CalcDamageInfo::AdvantageCalcResult' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, RepresentativeElementalDamageType) == 0x0000CA, "Member 'FM1CalcDamageInfo::RepresentativeElementalDamageType' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, ElementalDamages) == 0x0000D0, "Member 'FM1CalcDamageInfo::ElementalDamages' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, bInvokeElemetalSE) == 0x0000E0, "Member 'FM1CalcDamageInfo::bInvokeElemetalSE' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, HitStopAttackPoint) == 0x0000E8, "Member 'FM1CalcDamageInfo::HitStopAttackPoint' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, PhysicalPowerOptionKey) == 0x0000F0, "Member 'FM1CalcDamageInfo::PhysicalPowerOptionKey' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, bCritical) == 0x0000F8, "Member 'FM1CalcDamageInfo::bCritical' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, bWeakness) == 0x0000F9, "Member 'FM1CalcDamageInfo::bWeakness' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, bForcedReduceHP) == 0x0000FA, "Member 'FM1CalcDamageInfo::bForcedReduceHP' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, bForcedKillDBNO) == 0x0000FB, "Member 'FM1CalcDamageInfo::bForcedKillDBNO' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, bTransferredDamage) == 0x0000FC, "Member 'FM1CalcDamageInfo::bTransferredDamage' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, bHasDied) == 0x0000FD, "Member 'FM1CalcDamageInfo::bHasDied' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, bReduceHP) == 0x0000FE, "Member 'FM1CalcDamageInfo::bReduceHP' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, bBreakShield) == 0x0000FF, "Member 'FM1CalcDamageInfo::bBreakShield' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, bImmune) == 0x000100, "Member 'FM1CalcDamageInfo::bImmune' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, Time) == 0x000108, "Member 'FM1CalcDamageInfo::Time' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageInfo, TraitTags) == 0x000110, "Member 'FM1CalcDamageInfo::TraitTags' has a wrong offset!");

// ScriptStruct M1.M1MovingActorDebugData
// 0x000C (0x000C - 0x0000)
struct FM1MovingActorDebugData final
{
public:
	class FName                                   MovingActorName;                                   // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bServerTickEnabled;                                // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MovingActorState                           MovingActorState;                                  // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MovingActorDebugData) == 0x000004, "Wrong alignment on FM1MovingActorDebugData");
static_assert(sizeof(FM1MovingActorDebugData) == 0x00000C, "Wrong size on FM1MovingActorDebugData");
static_assert(offsetof(FM1MovingActorDebugData, MovingActorName) == 0x000000, "Member 'FM1MovingActorDebugData::MovingActorName' has a wrong offset!");
static_assert(offsetof(FM1MovingActorDebugData, bServerTickEnabled) == 0x000008, "Member 'FM1MovingActorDebugData::bServerTickEnabled' has a wrong offset!");
static_assert(offsetof(FM1MovingActorDebugData, MovingActorState) == 0x000009, "Member 'FM1MovingActorDebugData::MovingActorState' has a wrong offset!");

// ScriptStruct M1.M1Response_RequestBaseItem
// 0x00B8 (0x00B8 - 0x0000)
struct FM1Response_RequestBaseItem final
{
public:
	struct FM1AccountSimpleInfo                   Notification;                                      // 0x0000(0x00B8)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_RequestBaseItem) == 0x000008, "Wrong alignment on FM1Response_RequestBaseItem");
static_assert(sizeof(FM1Response_RequestBaseItem) == 0x0000B8, "Wrong size on FM1Response_RequestBaseItem");
static_assert(offsetof(FM1Response_RequestBaseItem, Notification) == 0x000000, "Member 'FM1Response_RequestBaseItem::Notification' has a wrong offset!");

// ScriptStruct M1.M1FXScalarParam
// 0x000C (0x000C - 0x0000)
struct FM1FXScalarParam final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParamValue;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FXScalarParam) == 0x000004, "Wrong alignment on FM1FXScalarParam");
static_assert(sizeof(FM1FXScalarParam) == 0x00000C, "Wrong size on FM1FXScalarParam");
static_assert(offsetof(FM1FXScalarParam, ParamName) == 0x000000, "Member 'FM1FXScalarParam::ParamName' has a wrong offset!");
static_assert(offsetof(FM1FXScalarParam, ParamValue) == 0x000008, "Member 'FM1FXScalarParam::ParamValue' has a wrong offset!");

// ScriptStruct M1.M1FXVectorParam
// 0x0014 (0x0014 - 0x0000)
struct FM1FXVectorParam final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ParamValue;                                        // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FXVectorParam) == 0x000004, "Wrong alignment on FM1FXVectorParam");
static_assert(sizeof(FM1FXVectorParam) == 0x000014, "Wrong size on FM1FXVectorParam");
static_assert(offsetof(FM1FXVectorParam, ParamName) == 0x000000, "Member 'FM1FXVectorParam::ParamName' has a wrong offset!");
static_assert(offsetof(FM1FXVectorParam, ParamValue) == 0x000008, "Member 'FM1FXVectorParam::ParamValue' has a wrong offset!");

// ScriptStruct M1.M1FXParam
// 0x0030 (0x0030 - 0x0000)
struct FM1FXParam final
{
public:
	TArray<struct FM1FXScalarParam>               Scalars;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1FXVectorParam>               Vectors;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1FXColorParam>                Colors;                                            // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FXParam) == 0x000008, "Wrong alignment on FM1FXParam");
static_assert(sizeof(FM1FXParam) == 0x000030, "Wrong size on FM1FXParam");
static_assert(offsetof(FM1FXParam, Scalars) == 0x000000, "Member 'FM1FXParam::Scalars' has a wrong offset!");
static_assert(offsetof(FM1FXParam, Vectors) == 0x000010, "Member 'FM1FXParam::Vectors' has a wrong offset!");
static_assert(offsetof(FM1FXParam, Colors) == 0x000020, "Member 'FM1FXParam::Colors' has a wrong offset!");

// ScriptStruct M1.M1Response_RequestSupport
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_RequestSupport final
{
public:
	EM1RequestSupportReason                       Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_RequestSupport) == 0x000004, "Wrong alignment on FM1Response_RequestSupport");
static_assert(sizeof(FM1Response_RequestSupport) == 0x000004, "Wrong size on FM1Response_RequestSupport");
static_assert(offsetof(FM1Response_RequestSupport, Notification) == 0x000000, "Member 'FM1Response_RequestSupport::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_DecomposeJunkItems
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_DecomposeJunkItems final
{
public:
	struct FM1JunkItemDecomposeResult             Notification;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_DecomposeJunkItems) == 0x000008, "Wrong alignment on FM1Response_DecomposeJunkItems");
static_assert(sizeof(FM1Response_DecomposeJunkItems) == 0x000010, "Wrong size on FM1Response_DecomposeJunkItems");
static_assert(offsetof(FM1Response_DecomposeJunkItems, Notification) == 0x000000, "Member 'FM1Response_DecomposeJunkItems::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_SetItemTagsWithList
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_SetItemTagsWithList final
{
public:
	EM1ItemReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_SetItemTagsWithList) == 0x000004, "Wrong alignment on FM1Response_SetItemTagsWithList");
static_assert(sizeof(FM1Response_SetItemTagsWithList) == 0x000004, "Wrong size on FM1Response_SetItemTagsWithList");
static_assert(offsetof(FM1Response_SetItemTagsWithList, Notification) == 0x000000, "Member 'FM1Response_SetItemTagsWithList::Notification' has a wrong offset!");

// ScriptStruct M1.M1Notice_DediWillDie
// 0x0001 (0x0001 - 0x0000)
struct FM1Notice_DediWillDie final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_DediWillDie) == 0x000001, "Wrong alignment on FM1Notice_DediWillDie");
static_assert(sizeof(FM1Notice_DediWillDie) == 0x000001, "Wrong size on FM1Notice_DediWillDie");
static_assert(offsetof(FM1Notice_DediWillDie, Notification) == 0x000000, "Member 'FM1Notice_DediWillDie::Notification' has a wrong offset!");

// ScriptStruct M1.M1VisualFXFadeParamInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1VisualFXFadeParamInfo final
{
public:
	float                                         FadeStartTime;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeEndTime;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeStartValue;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeEndValue;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1VisualFXFadeParamInfo) == 0x000004, "Wrong alignment on FM1VisualFXFadeParamInfo");
static_assert(sizeof(FM1VisualFXFadeParamInfo) == 0x000010, "Wrong size on FM1VisualFXFadeParamInfo");
static_assert(offsetof(FM1VisualFXFadeParamInfo, FadeStartTime) == 0x000000, "Member 'FM1VisualFXFadeParamInfo::FadeStartTime' has a wrong offset!");
static_assert(offsetof(FM1VisualFXFadeParamInfo, FadeEndTime) == 0x000004, "Member 'FM1VisualFXFadeParamInfo::FadeEndTime' has a wrong offset!");
static_assert(offsetof(FM1VisualFXFadeParamInfo, FadeStartValue) == 0x000008, "Member 'FM1VisualFXFadeParamInfo::FadeStartValue' has a wrong offset!");
static_assert(offsetof(FM1VisualFXFadeParamInfo, FadeEndValue) == 0x00000C, "Member 'FM1VisualFXFadeParamInfo::FadeEndValue' has a wrong offset!");

// ScriptStruct M1.M1VisualFX_Material_FadeInfo
// 0x0030 (0x0030 - 0x0000)
struct FM1VisualFX_Material_FadeInfo final
{
public:
	class UCurveBase*                             FadeInCurve;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1VisualFXFadeParamInfo               FadeInInfo;                                        // 0x0008(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UCurveBase*                             FadeOutCurve;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1VisualFXFadeParamInfo               FadeOutInfo;                                       // 0x0020(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1VisualFX_Material_FadeInfo) == 0x000008, "Wrong alignment on FM1VisualFX_Material_FadeInfo");
static_assert(sizeof(FM1VisualFX_Material_FadeInfo) == 0x000030, "Wrong size on FM1VisualFX_Material_FadeInfo");
static_assert(offsetof(FM1VisualFX_Material_FadeInfo, FadeInCurve) == 0x000000, "Member 'FM1VisualFX_Material_FadeInfo::FadeInCurve' has a wrong offset!");
static_assert(offsetof(FM1VisualFX_Material_FadeInfo, FadeInInfo) == 0x000008, "Member 'FM1VisualFX_Material_FadeInfo::FadeInInfo' has a wrong offset!");
static_assert(offsetof(FM1VisualFX_Material_FadeInfo, FadeOutCurve) == 0x000018, "Member 'FM1VisualFX_Material_FadeInfo::FadeOutCurve' has a wrong offset!");
static_assert(offsetof(FM1VisualFX_Material_FadeInfo, FadeOutInfo) == 0x000020, "Member 'FM1VisualFX_Material_FadeInfo::FadeOutInfo' has a wrong offset!");

// ScriptStruct M1.M1Request_SendMailForCheat3
// 0x0020 (0x0020 - 0x0000)
struct FM1Request_SendMailForCheat3 final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MailTid;                                           // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ItemPackBundle                      ItemPackBundle;                                    // 0x0010(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_SendMailForCheat3) == 0x000008, "Wrong alignment on FM1Request_SendMailForCheat3");
static_assert(sizeof(FM1Request_SendMailForCheat3) == 0x000020, "Wrong size on FM1Request_SendMailForCheat3");
static_assert(offsetof(FM1Request_SendMailForCheat3, AccountUid) == 0x000000, "Member 'FM1Request_SendMailForCheat3::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_SendMailForCheat3, MailTid) == 0x000008, "Member 'FM1Request_SendMailForCheat3::MailTid' has a wrong offset!");
static_assert(offsetof(FM1Request_SendMailForCheat3, ItemPackBundle) == 0x000010, "Member 'FM1Request_SendMailForCheat3::ItemPackBundle' has a wrong offset!");

// ScriptStruct M1.M1Request_JoinDedicatedServer_2
// 0x0028 (0x0028 - 0x0000)
struct FM1Request_JoinDedicatedServer_2 final : public FM1Request
{
public:
	struct FM1JoinDedicatedServerParam            Req;                                               // 0x0000(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_JoinDedicatedServer_2) == 0x000008, "Wrong alignment on FM1Request_JoinDedicatedServer_2");
static_assert(sizeof(FM1Request_JoinDedicatedServer_2) == 0x000028, "Wrong size on FM1Request_JoinDedicatedServer_2");
static_assert(offsetof(FM1Request_JoinDedicatedServer_2, Req) == 0x000000, "Member 'FM1Request_JoinDedicatedServer_2::Req' has a wrong offset!");

// ScriptStruct M1.M1AbilityAssetPreload
// 0x0040 (0x0040 - 0x0000)
struct FM1AbilityAssetPreload final
{
public:
	TArray<class FName>                           CharacterDataRowNames;                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           AbilityActorRowNames;                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                ClientOnlyAssets;                                  // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                CommonAssets;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityAssetPreload) == 0x000008, "Wrong alignment on FM1AbilityAssetPreload");
static_assert(sizeof(FM1AbilityAssetPreload) == 0x000040, "Wrong size on FM1AbilityAssetPreload");
static_assert(offsetof(FM1AbilityAssetPreload, CharacterDataRowNames) == 0x000000, "Member 'FM1AbilityAssetPreload::CharacterDataRowNames' has a wrong offset!");
static_assert(offsetof(FM1AbilityAssetPreload, AbilityActorRowNames) == 0x000010, "Member 'FM1AbilityAssetPreload::AbilityActorRowNames' has a wrong offset!");
static_assert(offsetof(FM1AbilityAssetPreload, ClientOnlyAssets) == 0x000020, "Member 'FM1AbilityAssetPreload::ClientOnlyAssets' has a wrong offset!");
static_assert(offsetof(FM1AbilityAssetPreload, CommonAssets) == 0x000030, "Member 'FM1AbilityAssetPreload::CommonAssets' has a wrong offset!");

// ScriptStruct M1.M1Request_RequireAchievementReward
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_RequireAchievementReward final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          AchievementId;                                     // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_RequireAchievementReward) == 0x000008, "Wrong alignment on FM1Request_RequireAchievementReward");
static_assert(sizeof(FM1Request_RequireAchievementReward) == 0x000010, "Wrong size on FM1Request_RequireAchievementReward");
static_assert(offsetof(FM1Request_RequireAchievementReward, AccountUid) == 0x000000, "Member 'FM1Request_RequireAchievementReward::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_RequireAchievementReward, AchievementId) == 0x000008, "Member 'FM1Request_RequireAchievementReward::AchievementId' has a wrong offset!");

// ScriptStruct M1.M1ServerConfig
// 0x00A0 (0x00A0 - 0x0000)
struct FM1ServerConfig final
{
public:
	class FString                                 PCLoginIP;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PCLoginPort;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PCToyServiceKey;                                   // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PSLoginIP;                                         // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PSLoginPort;                                       // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PSToyServiceKey;                                   // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 XBLoginIP;                                         // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 XBLoginPort;                                       // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 XBToyServiceKey;                                   // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DataPatchRevision;                                 // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ServerConfig) == 0x000008, "Wrong alignment on FM1ServerConfig");
static_assert(sizeof(FM1ServerConfig) == 0x0000A0, "Wrong size on FM1ServerConfig");
static_assert(offsetof(FM1ServerConfig, PCLoginIP) == 0x000000, "Member 'FM1ServerConfig::PCLoginIP' has a wrong offset!");
static_assert(offsetof(FM1ServerConfig, PCLoginPort) == 0x000010, "Member 'FM1ServerConfig::PCLoginPort' has a wrong offset!");
static_assert(offsetof(FM1ServerConfig, PCToyServiceKey) == 0x000020, "Member 'FM1ServerConfig::PCToyServiceKey' has a wrong offset!");
static_assert(offsetof(FM1ServerConfig, PSLoginIP) == 0x000030, "Member 'FM1ServerConfig::PSLoginIP' has a wrong offset!");
static_assert(offsetof(FM1ServerConfig, PSLoginPort) == 0x000040, "Member 'FM1ServerConfig::PSLoginPort' has a wrong offset!");
static_assert(offsetof(FM1ServerConfig, PSToyServiceKey) == 0x000050, "Member 'FM1ServerConfig::PSToyServiceKey' has a wrong offset!");
static_assert(offsetof(FM1ServerConfig, XBLoginIP) == 0x000060, "Member 'FM1ServerConfig::XBLoginIP' has a wrong offset!");
static_assert(offsetof(FM1ServerConfig, XBLoginPort) == 0x000070, "Member 'FM1ServerConfig::XBLoginPort' has a wrong offset!");
static_assert(offsetof(FM1ServerConfig, XBToyServiceKey) == 0x000080, "Member 'FM1ServerConfig::XBToyServiceKey' has a wrong offset!");
static_assert(offsetof(FM1ServerConfig, DataPatchRevision) == 0x000090, "Member 'FM1ServerConfig::DataPatchRevision' has a wrong offset!");

// ScriptStruct M1.M1AbilityContextHandle
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FM1AbilityContextHandle final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AbilityContextHandle) == 0x000008, "Wrong alignment on FM1AbilityContextHandle");
static_assert(sizeof(FM1AbilityContextHandle) == 0x000010, "Wrong size on FM1AbilityContextHandle");

// ScriptStruct M1.M1Response_CheatCreateBulkEquipment
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatCreateBulkEquipment final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatCreateBulkEquipment) == 0x000001, "Wrong alignment on FM1Response_CheatCreateBulkEquipment");
static_assert(sizeof(FM1Response_CheatCreateBulkEquipment) == 0x000001, "Wrong size on FM1Response_CheatCreateBulkEquipment");
static_assert(offsetof(FM1Response_CheatCreateBulkEquipment, Notification) == 0x000000, "Member 'FM1Response_CheatCreateBulkEquipment::Notification' has a wrong offset!");

// ScriptStruct M1.M1ConsumableInfoWrapper
// 0x0028 (0x0028 - 0x0000)
struct FM1ConsumableInfoWrapper final
{
public:
	struct FM1ConsumableInfo                      ConsumableInfo;                                    // 0x0000(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNewItem;                                          // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ConsumableInfoWrapper) == 0x000008, "Wrong alignment on FM1ConsumableInfoWrapper");
static_assert(sizeof(FM1ConsumableInfoWrapper) == 0x000028, "Wrong size on FM1ConsumableInfoWrapper");
static_assert(offsetof(FM1ConsumableInfoWrapper, ConsumableInfo) == 0x000000, "Member 'FM1ConsumableInfoWrapper::ConsumableInfo' has a wrong offset!");
static_assert(offsetof(FM1ConsumableInfoWrapper, bNewItem) == 0x000020, "Member 'FM1ConsumableInfoWrapper::bNewItem' has a wrong offset!");

// ScriptStruct M1.M1ComponentVisibilityControlValues
// 0x0002 (0x0002 - 0x0000)
struct FM1ComponentVisibilityControlValues final
{
public:
	EM1ComponentVisibilityControl                 DesiredVisibility;                                 // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ComponentVisibilityControlValues) == 0x000001, "Wrong alignment on FM1ComponentVisibilityControlValues");
static_assert(sizeof(FM1ComponentVisibilityControlValues) == 0x000002, "Wrong size on FM1ComponentVisibilityControlValues");
static_assert(offsetof(FM1ComponentVisibilityControlValues, DesiredVisibility) == 0x000000, "Member 'FM1ComponentVisibilityControlValues::DesiredVisibility' has a wrong offset!");
static_assert(offsetof(FM1ComponentVisibilityControlValues, bPropagateToChildren) == 0x000001, "Member 'FM1ComponentVisibilityControlValues::bPropagateToChildren' has a wrong offset!");

// ScriptStruct M1.M1ComponentVisibilityControlTag
// 0x000C (0x000C - 0x0000)
struct FM1ComponentVisibilityControlTag final
{
public:
	struct FGameplayTag                           ControlTag;                                        // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ComponentVisibilityControlValues    ControlValues;                                     // 0x0008(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ComponentVisibilityControlTag) == 0x000004, "Wrong alignment on FM1ComponentVisibilityControlTag");
static_assert(sizeof(FM1ComponentVisibilityControlTag) == 0x00000C, "Wrong size on FM1ComponentVisibilityControlTag");
static_assert(offsetof(FM1ComponentVisibilityControlTag, ControlTag) == 0x000000, "Member 'FM1ComponentVisibilityControlTag::ControlTag' has a wrong offset!");
static_assert(offsetof(FM1ComponentVisibilityControlTag, ControlValues) == 0x000008, "Member 'FM1ComponentVisibilityControlTag::ControlValues' has a wrong offset!");

// ScriptStruct M1.M1ComponentVisibilityControlInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1ComponentVisibilityControlInfo final
{
public:
	TWeakObjectPtr<class USceneComponent>         ControlledComponent;                               // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1ComponentVisibilityControlTag> ControlTags;                                       // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ComponentVisibilityControlInfo) == 0x000008, "Wrong alignment on FM1ComponentVisibilityControlInfo");
static_assert(sizeof(FM1ComponentVisibilityControlInfo) == 0x000018, "Wrong size on FM1ComponentVisibilityControlInfo");
static_assert(offsetof(FM1ComponentVisibilityControlInfo, ControlledComponent) == 0x000000, "Member 'FM1ComponentVisibilityControlInfo::ControlledComponent' has a wrong offset!");
static_assert(offsetof(FM1ComponentVisibilityControlInfo, ControlTags) == 0x000008, "Member 'FM1ComponentVisibilityControlInfo::ControlTags' has a wrong offset!");

// ScriptStruct M1.M1Request_RequestResearchAllAtOnce
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_RequestResearchAllAtOnce final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ResearchTemplateId;                                // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_RequestResearchAllAtOnce) == 0x000008, "Wrong alignment on FM1Request_RequestResearchAllAtOnce");
static_assert(sizeof(FM1Request_RequestResearchAllAtOnce) == 0x000010, "Wrong size on FM1Request_RequestResearchAllAtOnce");
static_assert(offsetof(FM1Request_RequestResearchAllAtOnce, AccountUid) == 0x000000, "Member 'FM1Request_RequestResearchAllAtOnce::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_RequestResearchAllAtOnce, ResearchTemplateId) == 0x000008, "Member 'FM1Request_RequestResearchAllAtOnce::ResearchTemplateId' has a wrong offset!");

// ScriptStruct M1.M1IntegerId
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FM1IntegerId
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1IntegerId) == 0x000008, "Wrong alignment on FM1IntegerId");
static_assert(sizeof(FM1IntegerId) == 0x000010, "Wrong size on FM1IntegerId");
static_assert(offsetof(FM1IntegerId, Value) == 0x000008, "Member 'FM1IntegerId::Value' has a wrong offset!");

// ScriptStruct M1.M1AlarmId
// 0x0000 (0x0010 - 0x0010)
struct FM1AlarmId final : public FM1IntegerId
{
};
static_assert(alignof(FM1AlarmId) == 0x000008, "Wrong alignment on FM1AlarmId");
static_assert(sizeof(FM1AlarmId) == 0x000010, "Wrong size on FM1AlarmId");

// ScriptStruct M1.M1Alarm
// 0x0028 (0x0028 - 0x0000)
struct FM1Alarm final
{
public:
	struct FM1AlarmId                             ID;                                                // 0x0000(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartServerWorldTime;                              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0xF];                                       // 0x0019(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Alarm) == 0x000008, "Wrong alignment on FM1Alarm");
static_assert(sizeof(FM1Alarm) == 0x000028, "Wrong size on FM1Alarm");
static_assert(offsetof(FM1Alarm, ID) == 0x000000, "Member 'FM1Alarm::ID' has a wrong offset!");
static_assert(offsetof(FM1Alarm, StartServerWorldTime) == 0x000010, "Member 'FM1Alarm::StartServerWorldTime' has a wrong offset!");
static_assert(offsetof(FM1Alarm, Duration) == 0x000014, "Member 'FM1Alarm::Duration' has a wrong offset!");
static_assert(offsetof(FM1Alarm, bLoop) == 0x000018, "Member 'FM1Alarm::bLoop' has a wrong offset!");

// ScriptStruct M1.M1Response_GameServerMoveReq
// 0x00B8 (0x00B8 - 0x0000)
struct FM1Response_GameServerMoveReq final
{
public:
	struct FM1AccountSimpleInfo                   Notification;                                      // 0x0000(0x00B8)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_GameServerMoveReq) == 0x000008, "Wrong alignment on FM1Response_GameServerMoveReq");
static_assert(sizeof(FM1Response_GameServerMoveReq) == 0x0000B8, "Wrong size on FM1Response_GameServerMoveReq");
static_assert(offsetof(FM1Response_GameServerMoveReq, Notification) == 0x000000, "Member 'FM1Response_GameServerMoveReq::Notification' has a wrong offset!");

// ScriptStruct M1.M1MissionInstantDeathFx
// 0x0060 (0x0060 - 0x0000)
struct FM1MissionInstantDeathFx final
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          VFXAsset;                                          // 0x0000(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioEvent>           SFXAsset;                                          // 0x0030(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionInstantDeathFx) == 0x000008, "Wrong alignment on FM1MissionInstantDeathFx");
static_assert(sizeof(FM1MissionInstantDeathFx) == 0x000060, "Wrong size on FM1MissionInstantDeathFx");
static_assert(offsetof(FM1MissionInstantDeathFx, VFXAsset) == 0x000000, "Member 'FM1MissionInstantDeathFx::VFXAsset' has a wrong offset!");
static_assert(offsetof(FM1MissionInstantDeathFx, SFXAsset) == 0x000030, "Member 'FM1MissionInstantDeathFx::SFXAsset' has a wrong offset!");

// ScriptStruct M1.M1AbilityTargetInfoHandle
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FM1AbilityTargetInfoHandle final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AbilityTargetInfoHandle) == 0x000008, "Wrong alignment on FM1AbilityTargetInfoHandle");
static_assert(sizeof(FM1AbilityTargetInfoHandle) == 0x000020, "Wrong size on FM1AbilityTargetInfoHandle");

// ScriptStruct M1.M1Request_UnlockCamp
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_UnlockCamp final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CampEntryPointId;                                  // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_UnlockCamp) == 0x000008, "Wrong alignment on FM1Request_UnlockCamp");
static_assert(sizeof(FM1Request_UnlockCamp) == 0x000018, "Wrong size on FM1Request_UnlockCamp");
static_assert(offsetof(FM1Request_UnlockCamp, AccountUid) == 0x000000, "Member 'FM1Request_UnlockCamp::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_UnlockCamp, CampEntryPointId) == 0x000008, "Member 'FM1Request_UnlockCamp::CampEntryPointId' has a wrong offset!");

// ScriptStruct M1.M1AbilityCollisionTargetingRule
// 0x000C (0x000C - 0x0000)
struct FM1AbilityCollisionTargetingRule final
{
public:
	EM1RelationsCheckType                         Relations;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           TargetQueryTag;                                    // 0x0004(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityCollisionTargetingRule) == 0x000004, "Wrong alignment on FM1AbilityCollisionTargetingRule");
static_assert(sizeof(FM1AbilityCollisionTargetingRule) == 0x00000C, "Wrong size on FM1AbilityCollisionTargetingRule");
static_assert(offsetof(FM1AbilityCollisionTargetingRule, Relations) == 0x000000, "Member 'FM1AbilityCollisionTargetingRule::Relations' has a wrong offset!");
static_assert(offsetof(FM1AbilityCollisionTargetingRule, TargetQueryTag) == 0x000004, "Member 'FM1AbilityCollisionTargetingRule::TargetQueryTag' has a wrong offset!");

// ScriptStruct M1.M1Response_SetItemTags
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_SetItemTags final
{
public:
	EM1ItemReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_SetItemTags) == 0x000004, "Wrong alignment on FM1Response_SetItemTags");
static_assert(sizeof(FM1Response_SetItemTags) == 0x000004, "Wrong size on FM1Response_SetItemTags");
static_assert(offsetof(FM1Response_SetItemTags, Notification) == 0x000000, "Member 'FM1Response_SetItemTags::Notification' has a wrong offset!");

// ScriptStruct M1.M1FieldInteractionContext
// 0x0010 (0x0010 - 0x0000)
struct FM1FieldInteractionContext final
{
public:
	EM1FieldInteractableState                     CurrentState;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      Invoker;                                           // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FieldInteractionContext) == 0x000008, "Wrong alignment on FM1FieldInteractionContext");
static_assert(sizeof(FM1FieldInteractionContext) == 0x000010, "Wrong size on FM1FieldInteractionContext");
static_assert(offsetof(FM1FieldInteractionContext, CurrentState) == 0x000000, "Member 'FM1FieldInteractionContext::CurrentState' has a wrong offset!");
static_assert(offsetof(FM1FieldInteractionContext, Invoker) == 0x000008, "Member 'FM1FieldInteractionContext::Invoker' has a wrong offset!");

// ScriptStruct M1.M1HitTestTextureAlphaOnlyData
// 0x0018 (0x0018 - 0x0000)
struct FM1HitTestTextureAlphaOnlyData final
{
public:
	int32                                         SizeX;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeY;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 AlphaValues;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1HitTestTextureAlphaOnlyData) == 0x000008, "Wrong alignment on FM1HitTestTextureAlphaOnlyData");
static_assert(sizeof(FM1HitTestTextureAlphaOnlyData) == 0x000018, "Wrong size on FM1HitTestTextureAlphaOnlyData");
static_assert(offsetof(FM1HitTestTextureAlphaOnlyData, SizeX) == 0x000000, "Member 'FM1HitTestTextureAlphaOnlyData::SizeX' has a wrong offset!");
static_assert(offsetof(FM1HitTestTextureAlphaOnlyData, SizeY) == 0x000004, "Member 'FM1HitTestTextureAlphaOnlyData::SizeY' has a wrong offset!");
static_assert(offsetof(FM1HitTestTextureAlphaOnlyData, AlphaValues) == 0x000008, "Member 'FM1HitTestTextureAlphaOnlyData::AlphaValues' has a wrong offset!");

// ScriptStruct M1.M1WorldMapRow
// 0x0130 (0x0138 - 0x0008)
struct FM1WorldMapRow final : public FTableRowBase
{
public:
	struct FM1TemplateId                          MapTemplateId;                                     // 0x0008(0x0004)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   MapResource;                                       // 0x0010(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinScale;                                          // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxScale;                                          // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultScale;                                      // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimateScale;                                      // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleSpeed;                                        // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              Deselected;                                        // 0x0058(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Selected;                                          // 0x0088(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Locked;                                            // 0x00B8(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Unvalid;                                           // 0x00E8(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      MatInstance_Mask;                                  // 0x0118(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1HitTestTextureAlphaOnlyData         HitTestAlphaData;                                  // 0x0120(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WorldMapRow) == 0x000008, "Wrong alignment on FM1WorldMapRow");
static_assert(sizeof(FM1WorldMapRow) == 0x000138, "Wrong size on FM1WorldMapRow");
static_assert(offsetof(FM1WorldMapRow, MapTemplateId) == 0x000008, "Member 'FM1WorldMapRow::MapTemplateId' has a wrong offset!");
static_assert(offsetof(FM1WorldMapRow, MapResource) == 0x000010, "Member 'FM1WorldMapRow::MapResource' has a wrong offset!");
static_assert(offsetof(FM1WorldMapRow, MinScale) == 0x000040, "Member 'FM1WorldMapRow::MinScale' has a wrong offset!");
static_assert(offsetof(FM1WorldMapRow, MaxScale) == 0x000044, "Member 'FM1WorldMapRow::MaxScale' has a wrong offset!");
static_assert(offsetof(FM1WorldMapRow, DefaultScale) == 0x000048, "Member 'FM1WorldMapRow::DefaultScale' has a wrong offset!");
static_assert(offsetof(FM1WorldMapRow, AnimateScale) == 0x00004C, "Member 'FM1WorldMapRow::AnimateScale' has a wrong offset!");
static_assert(offsetof(FM1WorldMapRow, ScaleSpeed) == 0x000050, "Member 'FM1WorldMapRow::ScaleSpeed' has a wrong offset!");
static_assert(offsetof(FM1WorldMapRow, Deselected) == 0x000058, "Member 'FM1WorldMapRow::Deselected' has a wrong offset!");
static_assert(offsetof(FM1WorldMapRow, Selected) == 0x000088, "Member 'FM1WorldMapRow::Selected' has a wrong offset!");
static_assert(offsetof(FM1WorldMapRow, Locked) == 0x0000B8, "Member 'FM1WorldMapRow::Locked' has a wrong offset!");
static_assert(offsetof(FM1WorldMapRow, Unvalid) == 0x0000E8, "Member 'FM1WorldMapRow::Unvalid' has a wrong offset!");
static_assert(offsetof(FM1WorldMapRow, MatInstance_Mask) == 0x000118, "Member 'FM1WorldMapRow::MatInstance_Mask' has a wrong offset!");
static_assert(offsetof(FM1WorldMapRow, HitTestAlphaData) == 0x000120, "Member 'FM1WorldMapRow::HitTestAlphaData' has a wrong offset!");

// ScriptStruct M1.M1Request_GetCustomizeInventory
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_GetCustomizeInventory final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_GetCustomizeInventory) == 0x000008, "Wrong alignment on FM1Request_GetCustomizeInventory");
static_assert(sizeof(FM1Request_GetCustomizeInventory) == 0x000008, "Wrong size on FM1Request_GetCustomizeInventory");
static_assert(offsetof(FM1Request_GetCustomizeInventory, AccountUid) == 0x000000, "Member 'FM1Request_GetCustomizeInventory::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Notice_NoticePartyErrorMessage
// 0x0048 (0x0048 - 0x0000)
struct FM1Notice_NoticePartyErrorMessage final
{
public:
	struct FM1PartyErrorMessageNoti               Notification;                                      // 0x0000(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_NoticePartyErrorMessage) == 0x000008, "Wrong alignment on FM1Notice_NoticePartyErrorMessage");
static_assert(sizeof(FM1Notice_NoticePartyErrorMessage) == 0x000048, "Wrong size on FM1Notice_NoticePartyErrorMessage");
static_assert(offsetof(FM1Notice_NoticePartyErrorMessage, Notification) == 0x000000, "Member 'FM1Notice_NoticePartyErrorMessage::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_AttachRune
// 0x0028 (0x0028 - 0x0000)
struct FM1Response_AttachRune final
{
public:
	EM1RuneReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1RunePositionBundle                  PositionBundle;                                    // 0x0008(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_AttachRune) == 0x000008, "Wrong alignment on FM1Response_AttachRune");
static_assert(sizeof(FM1Response_AttachRune) == 0x000028, "Wrong size on FM1Response_AttachRune");
static_assert(offsetof(FM1Response_AttachRune, Notification) == 0x000000, "Member 'FM1Response_AttachRune::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_AttachRune, PositionBundle) == 0x000008, "Member 'FM1Response_AttachRune::PositionBundle' has a wrong offset!");

// ScriptStruct M1.M1DropMissionSuppliesInfo
// 0x000C (0x000C - 0x0000)
struct FM1DropMissionSuppliesInfo final
{
public:
	class FName                                   DropContainerRow;                                  // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SupplyRate;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DropMissionSuppliesInfo) == 0x000004, "Wrong alignment on FM1DropMissionSuppliesInfo");
static_assert(sizeof(FM1DropMissionSuppliesInfo) == 0x00000C, "Wrong size on FM1DropMissionSuppliesInfo");
static_assert(offsetof(FM1DropMissionSuppliesInfo, DropContainerRow) == 0x000000, "Member 'FM1DropMissionSuppliesInfo::DropContainerRow' has a wrong offset!");
static_assert(offsetof(FM1DropMissionSuppliesInfo, SupplyRate) == 0x000008, "Member 'FM1DropMissionSuppliesInfo::SupplyRate' has a wrong offset!");

// ScriptStruct M1.M1MissionJoinedPlayerInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1MissionJoinedPlayerInfo final
{
public:
	class FString                                 Accountno;                                         // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Npsn;                                              // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionJoinedPlayerInfo) == 0x000008, "Wrong alignment on FM1MissionJoinedPlayerInfo");
static_assert(sizeof(FM1MissionJoinedPlayerInfo) == 0x000018, "Wrong size on FM1MissionJoinedPlayerInfo");
static_assert(offsetof(FM1MissionJoinedPlayerInfo, Accountno) == 0x000000, "Member 'FM1MissionJoinedPlayerInfo::Accountno' has a wrong offset!");
static_assert(offsetof(FM1MissionJoinedPlayerInfo, Npsn) == 0x000010, "Member 'FM1MissionJoinedPlayerInfo::Npsn' has a wrong offset!");

// ScriptStruct M1.M1SFXDataForAbility
// 0x0030 (0x0030 - 0x0000)
struct FM1SFXDataForAbility final
{
public:
	bool                                          bPlayOnlyLocal;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToOwner;                                    // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsedTargetLocation;                               // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseEventName;                                     // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EventName;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEvent;                                           // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SFXDataForAbility) == 0x000008, "Wrong alignment on FM1SFXDataForAbility");
static_assert(sizeof(FM1SFXDataForAbility) == 0x000030, "Wrong size on FM1SFXDataForAbility");
static_assert(offsetof(FM1SFXDataForAbility, bPlayOnlyLocal) == 0x000000, "Member 'FM1SFXDataForAbility::bPlayOnlyLocal' has a wrong offset!");
static_assert(offsetof(FM1SFXDataForAbility, bAttachToOwner) == 0x000001, "Member 'FM1SFXDataForAbility::bAttachToOwner' has a wrong offset!");
static_assert(offsetof(FM1SFXDataForAbility, bUsedTargetLocation) == 0x000002, "Member 'FM1SFXDataForAbility::bUsedTargetLocation' has a wrong offset!");
static_assert(offsetof(FM1SFXDataForAbility, bUseEventName) == 0x000003, "Member 'FM1SFXDataForAbility::bUseEventName' has a wrong offset!");
static_assert(offsetof(FM1SFXDataForAbility, EventName) == 0x000008, "Member 'FM1SFXDataForAbility::EventName' has a wrong offset!");
static_assert(offsetof(FM1SFXDataForAbility, AkEvent) == 0x000018, "Member 'FM1SFXDataForAbility::AkEvent' has a wrong offset!");
static_assert(offsetof(FM1SFXDataForAbility, Offset) == 0x000020, "Member 'FM1SFXDataForAbility::Offset' has a wrong offset!");

// ScriptStruct M1.M1DataVisualFX_Filter_WeaponClass
// 0x0018 (0x0018 - 0x0000)
struct FM1DataVisualFX_Filter_WeaponClass final
{
public:
	TArray<EM1EquipItemClassType>                 WeaponClassList;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAsBlacklist;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1DataVisualFX_Filter_WeaponClass) == 0x000008, "Wrong alignment on FM1DataVisualFX_Filter_WeaponClass");
static_assert(sizeof(FM1DataVisualFX_Filter_WeaponClass) == 0x000018, "Wrong size on FM1DataVisualFX_Filter_WeaponClass");
static_assert(offsetof(FM1DataVisualFX_Filter_WeaponClass, WeaponClassList) == 0x000000, "Member 'FM1DataVisualFX_Filter_WeaponClass::WeaponClassList' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Filter_WeaponClass, bAsBlacklist) == 0x000010, "Member 'FM1DataVisualFX_Filter_WeaponClass::bAsBlacklist' has a wrong offset!");

// ScriptStruct M1.M1VisualFX_Material_PlayerOption
// 0x0030 (0x0030 - 0x0000)
struct FM1VisualFX_Material_PlayerOption final
{
public:
	TArray<EM1CharacterMeshSlotType>              PlayerMeshSlotTypeArray;                           // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bPlayerApplyToWeaponOnly;                          // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1DataVisualFX_Filter_WeaponClass     PlayerWeaponClassFilter;                           // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1VisualFX_Material_PlayerOption) == 0x000008, "Wrong alignment on FM1VisualFX_Material_PlayerOption");
static_assert(sizeof(FM1VisualFX_Material_PlayerOption) == 0x000030, "Wrong size on FM1VisualFX_Material_PlayerOption");
static_assert(offsetof(FM1VisualFX_Material_PlayerOption, PlayerMeshSlotTypeArray) == 0x000000, "Member 'FM1VisualFX_Material_PlayerOption::PlayerMeshSlotTypeArray' has a wrong offset!");
static_assert(offsetof(FM1VisualFX_Material_PlayerOption, bPlayerApplyToWeaponOnly) == 0x000010, "Member 'FM1VisualFX_Material_PlayerOption::bPlayerApplyToWeaponOnly' has a wrong offset!");
static_assert(offsetof(FM1VisualFX_Material_PlayerOption, PlayerWeaponClassFilter) == 0x000018, "Member 'FM1VisualFX_Material_PlayerOption::PlayerWeaponClassFilter' has a wrong offset!");

// ScriptStruct M1.M1DataVisualFX_ScalarParameter
// 0x0098 (0x0098 - 0x0000)
struct FM1DataVisualFX_ScalarParameter final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParamValue;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     ParamValueCurve;                                   // 0x0010(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DataVisualFX_ScalarParameter) == 0x000008, "Wrong alignment on FM1DataVisualFX_ScalarParameter");
static_assert(sizeof(FM1DataVisualFX_ScalarParameter) == 0x000098, "Wrong size on FM1DataVisualFX_ScalarParameter");
static_assert(offsetof(FM1DataVisualFX_ScalarParameter, ParamName) == 0x000000, "Member 'FM1DataVisualFX_ScalarParameter::ParamName' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_ScalarParameter, ParamValue) == 0x000008, "Member 'FM1DataVisualFX_ScalarParameter::ParamValue' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_ScalarParameter, ParamValueCurve) == 0x000010, "Member 'FM1DataVisualFX_ScalarParameter::ParamValueCurve' has a wrong offset!");

// ScriptStruct M1.M1DataVisualFX_VectorParameter
// 0x01A0 (0x01A0 - 0x0000)
struct FM1DataVisualFX_VectorParameter final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ParamValue;                                        // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeVectorCurve                    ParamValueCurve;                                   // 0x0018(0x0188)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DataVisualFX_VectorParameter) == 0x000008, "Wrong alignment on FM1DataVisualFX_VectorParameter");
static_assert(sizeof(FM1DataVisualFX_VectorParameter) == 0x0001A0, "Wrong size on FM1DataVisualFX_VectorParameter");
static_assert(offsetof(FM1DataVisualFX_VectorParameter, ParamName) == 0x000000, "Member 'FM1DataVisualFX_VectorParameter::ParamName' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_VectorParameter, ParamValue) == 0x000008, "Member 'FM1DataVisualFX_VectorParameter::ParamValue' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_VectorParameter, ParamValueCurve) == 0x000018, "Member 'FM1DataVisualFX_VectorParameter::ParamValueCurve' has a wrong offset!");

// ScriptStruct M1.M1VisualFX_Material_ValueParam
// 0x0020 (0x0020 - 0x0000)
struct FM1VisualFX_Material_ValueParam final
{
public:
	TArray<struct FM1DataVisualFX_ScalarParameter> Scalars;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1DataVisualFX_VectorParameter> Vectors;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1VisualFX_Material_ValueParam) == 0x000008, "Wrong alignment on FM1VisualFX_Material_ValueParam");
static_assert(sizeof(FM1VisualFX_Material_ValueParam) == 0x000020, "Wrong size on FM1VisualFX_Material_ValueParam");
static_assert(offsetof(FM1VisualFX_Material_ValueParam, Scalars) == 0x000000, "Member 'FM1VisualFX_Material_ValueParam::Scalars' has a wrong offset!");
static_assert(offsetof(FM1VisualFX_Material_ValueParam, Vectors) == 0x000010, "Member 'FM1VisualFX_Material_ValueParam::Vectors' has a wrong offset!");

// ScriptStruct M1.M1DataVisualFX_Material
// 0x0130 (0x0130 - 0x0000)
struct FM1DataVisualFX_Material final
{
public:
	class UMaterialInterface*                     Asset;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCloneMesh;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOverlayMaterial;                               // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyToChildActors;                               // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepStatesIfExists;                               // 0x000B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialSlotIndex;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1VisualFX_Material_PlayerOption      PlayerMaterialOption;                              // 0x0010(0x0030)(Edit, NativeAccessSpecifierPublic)
	class FName                                   FadeParamName;                                     // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFade;                                          // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1VisualFX_Material_FadeInfo          FadeInfo;                                          // 0x0050(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseParamValue;                                    // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1VisualFX_Material_ValueParam        ValueParam;                                        // 0x0088(0x0020)(Edit, NativeAccessSpecifierPublic)
	TArray<EM1CharacterMeshSlotType>              MeshSlotTypeArray;                                 // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bApplyToWeaponOnly;                                // 0x00B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1DataVisualFX_Filter_WeaponClass     WeaponClassFilter;                                 // 0x00C0(0x0018)(NativeAccessSpecifierPublic)
	bool                                          bApplyForOverlay;                                  // 0x00D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyToCloneMesh;                                 // 0x00D9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x6];                                       // 0x00DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveBase*                             FadeInCurve;                                       // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1VisualFXFadeParamInfo               FadeInInfo;                                        // 0x00E8(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class UCurveBase*                             FadeOutCurve;                                      // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1VisualFXFadeParamInfo               FadeOutInfo;                                       // 0x0100(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FM1DataVisualFX_ScalarParameter> Scalars;                                           // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1DataVisualFX_VectorParameter> Vectors;                                           // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DataVisualFX_Material) == 0x000008, "Wrong alignment on FM1DataVisualFX_Material");
static_assert(sizeof(FM1DataVisualFX_Material) == 0x000130, "Wrong size on FM1DataVisualFX_Material");
static_assert(offsetof(FM1DataVisualFX_Material, Asset) == 0x000000, "Member 'FM1DataVisualFX_Material::Asset' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, bUseCloneMesh) == 0x000008, "Member 'FM1DataVisualFX_Material::bUseCloneMesh' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, bUseOverlayMaterial) == 0x000009, "Member 'FM1DataVisualFX_Material::bUseOverlayMaterial' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, bApplyToChildActors) == 0x00000A, "Member 'FM1DataVisualFX_Material::bApplyToChildActors' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, bKeepStatesIfExists) == 0x00000B, "Member 'FM1DataVisualFX_Material::bKeepStatesIfExists' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, MaterialSlotIndex) == 0x00000C, "Member 'FM1DataVisualFX_Material::MaterialSlotIndex' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, PlayerMaterialOption) == 0x000010, "Member 'FM1DataVisualFX_Material::PlayerMaterialOption' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, FadeParamName) == 0x000040, "Member 'FM1DataVisualFX_Material::FadeParamName' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, bUseFade) == 0x000048, "Member 'FM1DataVisualFX_Material::bUseFade' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, FadeInfo) == 0x000050, "Member 'FM1DataVisualFX_Material::FadeInfo' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, bUseParamValue) == 0x000080, "Member 'FM1DataVisualFX_Material::bUseParamValue' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, ValueParam) == 0x000088, "Member 'FM1DataVisualFX_Material::ValueParam' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, MeshSlotTypeArray) == 0x0000A8, "Member 'FM1DataVisualFX_Material::MeshSlotTypeArray' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, bApplyToWeaponOnly) == 0x0000B8, "Member 'FM1DataVisualFX_Material::bApplyToWeaponOnly' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, WeaponClassFilter) == 0x0000C0, "Member 'FM1DataVisualFX_Material::WeaponClassFilter' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, bApplyForOverlay) == 0x0000D8, "Member 'FM1DataVisualFX_Material::bApplyForOverlay' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, bApplyToCloneMesh) == 0x0000D9, "Member 'FM1DataVisualFX_Material::bApplyToCloneMesh' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, FadeInCurve) == 0x0000E0, "Member 'FM1DataVisualFX_Material::FadeInCurve' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, FadeInInfo) == 0x0000E8, "Member 'FM1DataVisualFX_Material::FadeInInfo' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, FadeOutCurve) == 0x0000F8, "Member 'FM1DataVisualFX_Material::FadeOutCurve' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, FadeOutInfo) == 0x000100, "Member 'FM1DataVisualFX_Material::FadeOutInfo' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, Scalars) == 0x000110, "Member 'FM1DataVisualFX_Material::Scalars' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Material, Vectors) == 0x000120, "Member 'FM1DataVisualFX_Material::Vectors' has a wrong offset!");

// ScriptStruct M1.M1FXSpawnParam
// 0x0040 (0x0040 - 0x0000)
struct FM1FXSpawnParam final
{
public:
	class UNiagaraSystem*                         FX;                                                // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivateDelayTime;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1FXParam                             FXParam;                                           // 0x0010(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FXSpawnParam) == 0x000008, "Wrong alignment on FM1FXSpawnParam");
static_assert(sizeof(FM1FXSpawnParam) == 0x000040, "Wrong size on FM1FXSpawnParam");
static_assert(offsetof(FM1FXSpawnParam, FX) == 0x000000, "Member 'FM1FXSpawnParam::FX' has a wrong offset!");
static_assert(offsetof(FM1FXSpawnParam, ActivateDelayTime) == 0x000008, "Member 'FM1FXSpawnParam::ActivateDelayTime' has a wrong offset!");
static_assert(offsetof(FM1FXSpawnParam, FXParam) == 0x000010, "Member 'FM1FXSpawnParam::FXParam' has a wrong offset!");

// ScriptStruct M1.M1VFXDataForAbility
// 0x0090 (0x0090 - 0x0000)
struct FM1VFXDataForAbility final
{
public:
	bool                                          bAttachToOwner;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToWeaponOfOwner;                            // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachAbsoluteRotation;                           // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachAbsoluteScale;                              // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsedTargetLocation;                               // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1FXSpawnParam                        FXSpawnParam;                                      // 0x0010(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTransform                             Offset;                                            // 0x0050(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveWithThisAbility;                            // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveImmediately;                                // 0x0081(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScaleForAOE;                                      // 0x0082(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_83[0xD];                                       // 0x0083(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1VFXDataForAbility) == 0x000010, "Wrong alignment on FM1VFXDataForAbility");
static_assert(sizeof(FM1VFXDataForAbility) == 0x000090, "Wrong size on FM1VFXDataForAbility");
static_assert(offsetof(FM1VFXDataForAbility, bAttachToOwner) == 0x000000, "Member 'FM1VFXDataForAbility::bAttachToOwner' has a wrong offset!");
static_assert(offsetof(FM1VFXDataForAbility, bAttachToWeaponOfOwner) == 0x000001, "Member 'FM1VFXDataForAbility::bAttachToWeaponOfOwner' has a wrong offset!");
static_assert(offsetof(FM1VFXDataForAbility, bAttachAbsoluteRotation) == 0x000002, "Member 'FM1VFXDataForAbility::bAttachAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(FM1VFXDataForAbility, bAttachAbsoluteScale) == 0x000003, "Member 'FM1VFXDataForAbility::bAttachAbsoluteScale' has a wrong offset!");
static_assert(offsetof(FM1VFXDataForAbility, bUsedTargetLocation) == 0x000004, "Member 'FM1VFXDataForAbility::bUsedTargetLocation' has a wrong offset!");
static_assert(offsetof(FM1VFXDataForAbility, BoneName) == 0x000008, "Member 'FM1VFXDataForAbility::BoneName' has a wrong offset!");
static_assert(offsetof(FM1VFXDataForAbility, FXSpawnParam) == 0x000010, "Member 'FM1VFXDataForAbility::FXSpawnParam' has a wrong offset!");
static_assert(offsetof(FM1VFXDataForAbility, Offset) == 0x000050, "Member 'FM1VFXDataForAbility::Offset' has a wrong offset!");
static_assert(offsetof(FM1VFXDataForAbility, bRemoveWithThisAbility) == 0x000080, "Member 'FM1VFXDataForAbility::bRemoveWithThisAbility' has a wrong offset!");
static_assert(offsetof(FM1VFXDataForAbility, bRemoveImmediately) == 0x000081, "Member 'FM1VFXDataForAbility::bRemoveImmediately' has a wrong offset!");
static_assert(offsetof(FM1VFXDataForAbility, bScaleForAOE) == 0x000082, "Member 'FM1VFXDataForAbility::bScaleForAOE' has a wrong offset!");

// ScriptStruct M1.M1AbilityNiagaraParamBinder
// 0x001C (0x001C - 0x0000)
struct FM1AbilityNiagaraParamBinder final
{
public:
	EM1AbilityNiagaraParamBindType                Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DurationPropertyName;                              // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SphereSizePropertyName;                            // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoxSizePropertyName;                               // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityNiagaraParamBinder) == 0x000004, "Wrong alignment on FM1AbilityNiagaraParamBinder");
static_assert(sizeof(FM1AbilityNiagaraParamBinder) == 0x00001C, "Wrong size on FM1AbilityNiagaraParamBinder");
static_assert(offsetof(FM1AbilityNiagaraParamBinder, Type) == 0x000000, "Member 'FM1AbilityNiagaraParamBinder::Type' has a wrong offset!");
static_assert(offsetof(FM1AbilityNiagaraParamBinder, DurationPropertyName) == 0x000004, "Member 'FM1AbilityNiagaraParamBinder::DurationPropertyName' has a wrong offset!");
static_assert(offsetof(FM1AbilityNiagaraParamBinder, SphereSizePropertyName) == 0x00000C, "Member 'FM1AbilityNiagaraParamBinder::SphereSizePropertyName' has a wrong offset!");
static_assert(offsetof(FM1AbilityNiagaraParamBinder, BoxSizePropertyName) == 0x000014, "Member 'FM1AbilityNiagaraParamBinder::BoxSizePropertyName' has a wrong offset!");

// ScriptStruct M1.M1VFXDataAssetsForAbility
// 0x0010 (0x0010 - 0x0000)
struct FM1VFXDataAssetsForAbility final
{
public:
	class UM1DataVisualFX*                        FX;                                                // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveWithThisAbility;                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveImmediately;                                // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1VFXDataAssetsForAbility) == 0x000008, "Wrong alignment on FM1VFXDataAssetsForAbility");
static_assert(sizeof(FM1VFXDataAssetsForAbility) == 0x000010, "Wrong size on FM1VFXDataAssetsForAbility");
static_assert(offsetof(FM1VFXDataAssetsForAbility, FX) == 0x000000, "Member 'FM1VFXDataAssetsForAbility::FX' has a wrong offset!");
static_assert(offsetof(FM1VFXDataAssetsForAbility, bRemoveWithThisAbility) == 0x000008, "Member 'FM1VFXDataAssetsForAbility::bRemoveWithThisAbility' has a wrong offset!");
static_assert(offsetof(FM1VFXDataAssetsForAbility, bRemoveImmediately) == 0x000009, "Member 'FM1VFXDataAssetsForAbility::bRemoveImmediately' has a wrong offset!");

// ScriptStruct M1.M1CameraHiddenSetting
// 0x000C (0x000C - 0x0000)
struct FM1CameraHiddenSetting final
{
public:
	bool                                          bEnableHiddenCheck;                                // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HiddenCheckProbeRadius;                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HiddenCheckMaxDistance;                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CameraHiddenSetting) == 0x000004, "Wrong alignment on FM1CameraHiddenSetting");
static_assert(sizeof(FM1CameraHiddenSetting) == 0x00000C, "Wrong size on FM1CameraHiddenSetting");
static_assert(offsetof(FM1CameraHiddenSetting, bEnableHiddenCheck) == 0x000000, "Member 'FM1CameraHiddenSetting::bEnableHiddenCheck' has a wrong offset!");
static_assert(offsetof(FM1CameraHiddenSetting, HiddenCheckProbeRadius) == 0x000004, "Member 'FM1CameraHiddenSetting::HiddenCheckProbeRadius' has a wrong offset!");
static_assert(offsetof(FM1CameraHiddenSetting, HiddenCheckMaxDistance) == 0x000008, "Member 'FM1CameraHiddenSetting::HiddenCheckMaxDistance' has a wrong offset!");

// ScriptStruct M1.M1CameraSetting
// 0x0048 (0x0048 - 0x0000)
struct FM1CameraSetting final
{
public:
	float                                         TargetArmLength;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SocketOffset;                                      // 0x0004(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffset;                                      // 0x0010(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSmoothCameraLocTransition;                        // 0x001C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraLocTransitionSpeed;                          // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseTurnScale;                                     // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseLookUpScale;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFOV;                                           // 0x002C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FOV;                                               // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOVChangeSpeed;                                    // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideHiddenSetting;                            // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1CameraHiddenSetting                 HiddenSetting;                                     // 0x003C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CameraSetting) == 0x000004, "Wrong alignment on FM1CameraSetting");
static_assert(sizeof(FM1CameraSetting) == 0x000048, "Wrong size on FM1CameraSetting");
static_assert(offsetof(FM1CameraSetting, TargetArmLength) == 0x000000, "Member 'FM1CameraSetting::TargetArmLength' has a wrong offset!");
static_assert(offsetof(FM1CameraSetting, SocketOffset) == 0x000004, "Member 'FM1CameraSetting::SocketOffset' has a wrong offset!");
static_assert(offsetof(FM1CameraSetting, TargetOffset) == 0x000010, "Member 'FM1CameraSetting::TargetOffset' has a wrong offset!");
static_assert(offsetof(FM1CameraSetting, bSmoothCameraLocTransition) == 0x00001C, "Member 'FM1CameraSetting::bSmoothCameraLocTransition' has a wrong offset!");
static_assert(offsetof(FM1CameraSetting, CameraLocTransitionSpeed) == 0x000020, "Member 'FM1CameraSetting::CameraLocTransitionSpeed' has a wrong offset!");
static_assert(offsetof(FM1CameraSetting, BaseTurnScale) == 0x000024, "Member 'FM1CameraSetting::BaseTurnScale' has a wrong offset!");
static_assert(offsetof(FM1CameraSetting, BaseLookUpScale) == 0x000028, "Member 'FM1CameraSetting::BaseLookUpScale' has a wrong offset!");
static_assert(offsetof(FM1CameraSetting, bUseFOV) == 0x00002C, "Member 'FM1CameraSetting::bUseFOV' has a wrong offset!");
static_assert(offsetof(FM1CameraSetting, FOV) == 0x000030, "Member 'FM1CameraSetting::FOV' has a wrong offset!");
static_assert(offsetof(FM1CameraSetting, FOVChangeSpeed) == 0x000034, "Member 'FM1CameraSetting::FOVChangeSpeed' has a wrong offset!");
static_assert(offsetof(FM1CameraSetting, bOverrideHiddenSetting) == 0x000038, "Member 'FM1CameraSetting::bOverrideHiddenSetting' has a wrong offset!");
static_assert(offsetof(FM1CameraSetting, HiddenSetting) == 0x00003C, "Member 'FM1CameraSetting::HiddenSetting' has a wrong offset!");

// ScriptStruct M1.M1MotionBlurPostProcessSetting
// 0x0020 (0x0020 - 0x0000)
struct FM1MotionBlurPostProcessSetting final
{
public:
	bool                                          bEnableMotionBlur;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMotionBlurAmount;                         // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MotionBlurAmount;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMotionBlurMax;                            // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MotionBlurMax;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMotionBlurTargetFPS;                      // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MotionBlurTargetFPS;                               // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMotionBlurPerObjectSize;                  // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MotionBlurPerObjectSize;                           // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MotionBlurPostProcessSetting) == 0x000004, "Wrong alignment on FM1MotionBlurPostProcessSetting");
static_assert(sizeof(FM1MotionBlurPostProcessSetting) == 0x000020, "Wrong size on FM1MotionBlurPostProcessSetting");
static_assert(offsetof(FM1MotionBlurPostProcessSetting, bEnableMotionBlur) == 0x000000, "Member 'FM1MotionBlurPostProcessSetting::bEnableMotionBlur' has a wrong offset!");
static_assert(offsetof(FM1MotionBlurPostProcessSetting, bOverrideMotionBlurAmount) == 0x000001, "Member 'FM1MotionBlurPostProcessSetting::bOverrideMotionBlurAmount' has a wrong offset!");
static_assert(offsetof(FM1MotionBlurPostProcessSetting, MotionBlurAmount) == 0x000004, "Member 'FM1MotionBlurPostProcessSetting::MotionBlurAmount' has a wrong offset!");
static_assert(offsetof(FM1MotionBlurPostProcessSetting, bOverrideMotionBlurMax) == 0x000008, "Member 'FM1MotionBlurPostProcessSetting::bOverrideMotionBlurMax' has a wrong offset!");
static_assert(offsetof(FM1MotionBlurPostProcessSetting, MotionBlurMax) == 0x00000C, "Member 'FM1MotionBlurPostProcessSetting::MotionBlurMax' has a wrong offset!");
static_assert(offsetof(FM1MotionBlurPostProcessSetting, bOverrideMotionBlurTargetFPS) == 0x000010, "Member 'FM1MotionBlurPostProcessSetting::bOverrideMotionBlurTargetFPS' has a wrong offset!");
static_assert(offsetof(FM1MotionBlurPostProcessSetting, MotionBlurTargetFPS) == 0x000014, "Member 'FM1MotionBlurPostProcessSetting::MotionBlurTargetFPS' has a wrong offset!");
static_assert(offsetof(FM1MotionBlurPostProcessSetting, bOverrideMotionBlurPerObjectSize) == 0x000018, "Member 'FM1MotionBlurPostProcessSetting::bOverrideMotionBlurPerObjectSize' has a wrong offset!");
static_assert(offsetof(FM1MotionBlurPostProcessSetting, MotionBlurPerObjectSize) == 0x00001C, "Member 'FM1MotionBlurPostProcessSetting::MotionBlurPerObjectSize' has a wrong offset!");

// ScriptStruct M1.M1MotionBlurCameraSetting
// 0x0068 (0x0068 - 0x0000)
struct FM1MotionBlurCameraSetting final
{
public:
	struct FM1CameraSetting                       CameraSetting;                                     // 0x0000(0x0048)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1MotionBlurPostProcessSetting        MotionBlurSetting;                                 // 0x0048(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MotionBlurCameraSetting) == 0x000004, "Wrong alignment on FM1MotionBlurCameraSetting");
static_assert(sizeof(FM1MotionBlurCameraSetting) == 0x000068, "Wrong size on FM1MotionBlurCameraSetting");
static_assert(offsetof(FM1MotionBlurCameraSetting, CameraSetting) == 0x000000, "Member 'FM1MotionBlurCameraSetting::CameraSetting' has a wrong offset!");
static_assert(offsetof(FM1MotionBlurCameraSetting, MotionBlurSetting) == 0x000048, "Member 'FM1MotionBlurCameraSetting::MotionBlurSetting' has a wrong offset!");

// ScriptStruct M1.M1AbilityFXSpawnParams
// 0x00D8 (0x00D8 - 0x0000)
struct FM1AbilityFXSpawnParams final
{
public:
	TArray<struct FM1SFXDataForAbility>           SFXs;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1VFXDataForAbility>           NiagaraVFXs;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1AbilityNiagaraParamBinder           NiagaraVFXParamBinder;                             // 0x0020(0x001C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1DataVisualFX_Material>       MaterialVFXs;                                      // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1VFXDataAssetsForAbility>     VFXDataAssets;                                     // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UM1DataPostProcessMaterialEffect*       PostProcessMaterialEffect;                         // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCameraSetting;                                 // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1MotionBlurCameraSetting             CameraSetting;                                     // 0x006C(0x0068)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AbilityFXSpawnParams) == 0x000008, "Wrong alignment on FM1AbilityFXSpawnParams");
static_assert(sizeof(FM1AbilityFXSpawnParams) == 0x0000D8, "Wrong size on FM1AbilityFXSpawnParams");
static_assert(offsetof(FM1AbilityFXSpawnParams, SFXs) == 0x000000, "Member 'FM1AbilityFXSpawnParams::SFXs' has a wrong offset!");
static_assert(offsetof(FM1AbilityFXSpawnParams, NiagaraVFXs) == 0x000010, "Member 'FM1AbilityFXSpawnParams::NiagaraVFXs' has a wrong offset!");
static_assert(offsetof(FM1AbilityFXSpawnParams, NiagaraVFXParamBinder) == 0x000020, "Member 'FM1AbilityFXSpawnParams::NiagaraVFXParamBinder' has a wrong offset!");
static_assert(offsetof(FM1AbilityFXSpawnParams, MaterialVFXs) == 0x000040, "Member 'FM1AbilityFXSpawnParams::MaterialVFXs' has a wrong offset!");
static_assert(offsetof(FM1AbilityFXSpawnParams, VFXDataAssets) == 0x000050, "Member 'FM1AbilityFXSpawnParams::VFXDataAssets' has a wrong offset!");
static_assert(offsetof(FM1AbilityFXSpawnParams, PostProcessMaterialEffect) == 0x000060, "Member 'FM1AbilityFXSpawnParams::PostProcessMaterialEffect' has a wrong offset!");
static_assert(offsetof(FM1AbilityFXSpawnParams, bUseCameraSetting) == 0x000068, "Member 'FM1AbilityFXSpawnParams::bUseCameraSetting' has a wrong offset!");
static_assert(offsetof(FM1AbilityFXSpawnParams, CameraSetting) == 0x00006C, "Member 'FM1AbilityFXSpawnParams::CameraSetting' has a wrong offset!");

// ScriptStruct M1.M1Response_RemovePresetContents
// 0x0008 (0x0008 - 0x0000)
struct FM1Response_RemovePresetContents final
{
public:
	EM1PresetReason                               Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PresetIndex;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_RemovePresetContents) == 0x000004, "Wrong alignment on FM1Response_RemovePresetContents");
static_assert(sizeof(FM1Response_RemovePresetContents) == 0x000008, "Wrong size on FM1Response_RemovePresetContents");
static_assert(offsetof(FM1Response_RemovePresetContents, Notification) == 0x000000, "Member 'FM1Response_RemovePresetContents::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_RemovePresetContents, PresetIndex) == 0x000004, "Member 'FM1Response_RemovePresetContents::PresetIndex' has a wrong offset!");

// ScriptStruct M1.M1TitleInfoWrapper
// 0x0008 (0x0008 - 0x0000)
struct FM1TitleInfoWrapper final
{
public:
	struct FM1TitleItemInfo                       TitleInfo;                                         // 0x0000(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNewItem;                                          // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1TitleInfoWrapper) == 0x000004, "Wrong alignment on FM1TitleInfoWrapper");
static_assert(sizeof(FM1TitleInfoWrapper) == 0x000008, "Wrong size on FM1TitleInfoWrapper");
static_assert(offsetof(FM1TitleInfoWrapper, TitleInfo) == 0x000000, "Member 'FM1TitleInfoWrapper::TitleInfo' has a wrong offset!");
static_assert(offsetof(FM1TitleInfoWrapper, bNewItem) == 0x000004, "Member 'FM1TitleInfoWrapper::bNewItem' has a wrong offset!");

// ScriptStruct M1.M1MissionInstantDeathPPM
// 0x0010 (0x0010 - 0x0000)
struct FM1MissionInstantDeathPPM final
{
public:
	TArray<struct FSoftObjectPath>                PPMs;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionInstantDeathPPM) == 0x000008, "Wrong alignment on FM1MissionInstantDeathPPM");
static_assert(sizeof(FM1MissionInstantDeathPPM) == 0x000010, "Wrong size on FM1MissionInstantDeathPPM");
static_assert(offsetof(FM1MissionInstantDeathPPM, PPMs) == 0x000000, "Member 'FM1MissionInstantDeathPPM::PPMs' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatCreateCharacter
// 0x0030 (0x0030 - 0x0000)
struct FM1Response_CheatCreateCharacter final
{
public:
	struct FM1CheatCreateCharacterRes             Notification;                                      // 0x0000(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatCreateCharacter) == 0x000008, "Wrong alignment on FM1Response_CheatCreateCharacter");
static_assert(sizeof(FM1Response_CheatCreateCharacter) == 0x000030, "Wrong size on FM1Response_CheatCreateCharacter");
static_assert(offsetof(FM1Response_CheatCreateCharacter, Notification) == 0x000000, "Member 'FM1Response_CheatCreateCharacter::Notification' has a wrong offset!");

// ScriptStruct M1.M1WeaponTriggerSettingValues
// 0x0003 (0x0003 - 0x0000)
struct FM1WeaponTriggerSettingValues final
{
public:
	uint8                                         StartPosition;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EndPosition;                                       // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Strength;                                          // 0x0002(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponTriggerSettingValues) == 0x000001, "Wrong alignment on FM1WeaponTriggerSettingValues");
static_assert(sizeof(FM1WeaponTriggerSettingValues) == 0x000003, "Wrong size on FM1WeaponTriggerSettingValues");
static_assert(offsetof(FM1WeaponTriggerSettingValues, StartPosition) == 0x000000, "Member 'FM1WeaponTriggerSettingValues::StartPosition' has a wrong offset!");
static_assert(offsetof(FM1WeaponTriggerSettingValues, EndPosition) == 0x000001, "Member 'FM1WeaponTriggerSettingValues::EndPosition' has a wrong offset!");
static_assert(offsetof(FM1WeaponTriggerSettingValues, Strength) == 0x000002, "Member 'FM1WeaponTriggerSettingValues::Strength' has a wrong offset!");

// ScriptStruct M1.M1WeaponTriggerSetting
// 0x0008 (0x0008 - 0x0000)
struct FM1WeaponTriggerSetting final
{
public:
	bool                                          bEnableRightTrigger;                               // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1WeaponTriggerSettingValues          Right;                                             // 0x0001(0x0003)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableLeftTrigger;                                // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1WeaponTriggerSettingValues          Left;                                              // 0x0005(0x0003)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponTriggerSetting) == 0x000001, "Wrong alignment on FM1WeaponTriggerSetting");
static_assert(sizeof(FM1WeaponTriggerSetting) == 0x000008, "Wrong size on FM1WeaponTriggerSetting");
static_assert(offsetof(FM1WeaponTriggerSetting, bEnableRightTrigger) == 0x000000, "Member 'FM1WeaponTriggerSetting::bEnableRightTrigger' has a wrong offset!");
static_assert(offsetof(FM1WeaponTriggerSetting, Right) == 0x000001, "Member 'FM1WeaponTriggerSetting::Right' has a wrong offset!");
static_assert(offsetof(FM1WeaponTriggerSetting, bEnableLeftTrigger) == 0x000004, "Member 'FM1WeaponTriggerSetting::bEnableLeftTrigger' has a wrong offset!");
static_assert(offsetof(FM1WeaponTriggerSetting, Left) == 0x000005, "Member 'FM1WeaponTriggerSetting::Left' has a wrong offset!");

// ScriptStruct M1.M1UIEvent_ChangedWeaponChargeState
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FM1UIEvent_ChangedWeaponChargeState final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_ChangedWeaponChargeState) == 0x000004, "Wrong alignment on FM1UIEvent_ChangedWeaponChargeState");
static_assert(sizeof(FM1UIEvent_ChangedWeaponChargeState) == 0x000008, "Wrong size on FM1UIEvent_ChangedWeaponChargeState");

// ScriptStruct M1.M1GameGuideStartCondition
// 0x0058 (0x0058 - 0x0000)
struct FM1GameGuideStartCondition final
{
public:
	int32                                         Order;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1GameGuideStartConditionType                ConditionType;                                     // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         WidgetClassPath;                                   // 0x0008(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   QuestId;                                           // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemRowName;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MissionId;                                         // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ResearchClearType                          ResearchClearType;                                 // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BattlePassLevel;                                   // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ResearchType                               ResearchType;                                      // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ResearchRowName;                                   // 0x004C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1GameGuideStartCondition) == 0x000008, "Wrong alignment on FM1GameGuideStartCondition");
static_assert(sizeof(FM1GameGuideStartCondition) == 0x000058, "Wrong size on FM1GameGuideStartCondition");
static_assert(offsetof(FM1GameGuideStartCondition, Order) == 0x000000, "Member 'FM1GameGuideStartCondition::Order' has a wrong offset!");
static_assert(offsetof(FM1GameGuideStartCondition, ConditionType) == 0x000004, "Member 'FM1GameGuideStartCondition::ConditionType' has a wrong offset!");
static_assert(offsetof(FM1GameGuideStartCondition, WidgetClassPath) == 0x000008, "Member 'FM1GameGuideStartCondition::WidgetClassPath' has a wrong offset!");
static_assert(offsetof(FM1GameGuideStartCondition, QuestId) == 0x000028, "Member 'FM1GameGuideStartCondition::QuestId' has a wrong offset!");
static_assert(offsetof(FM1GameGuideStartCondition, ItemRowName) == 0x000030, "Member 'FM1GameGuideStartCondition::ItemRowName' has a wrong offset!");
static_assert(offsetof(FM1GameGuideStartCondition, MissionId) == 0x000038, "Member 'FM1GameGuideStartCondition::MissionId' has a wrong offset!");
static_assert(offsetof(FM1GameGuideStartCondition, ResearchClearType) == 0x000040, "Member 'FM1GameGuideStartCondition::ResearchClearType' has a wrong offset!");
static_assert(offsetof(FM1GameGuideStartCondition, BattlePassLevel) == 0x000044, "Member 'FM1GameGuideStartCondition::BattlePassLevel' has a wrong offset!");
static_assert(offsetof(FM1GameGuideStartCondition, ResearchType) == 0x000048, "Member 'FM1GameGuideStartCondition::ResearchType' has a wrong offset!");
static_assert(offsetof(FM1GameGuideStartCondition, ResearchRowName) == 0x00004C, "Member 'FM1GameGuideStartCondition::ResearchRowName' has a wrong offset!");

// ScriptStruct M1.M1FieldObjectSpawnerInfo
// 0x0040 (0x0040 - 0x0000)
struct FM1FieldObjectSpawnerInfo final
{
public:
	TArray<struct FTransform>                     SpawnPointTransforms;                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 SpawnerName;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnDelay;                                      // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSpawnCount;                                     // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SpawnGroupDataName;                                // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnRatio;                                        // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1FieldObjectSpawnerInfo) == 0x000008, "Wrong alignment on FM1FieldObjectSpawnerInfo");
static_assert(sizeof(FM1FieldObjectSpawnerInfo) == 0x000040, "Wrong size on FM1FieldObjectSpawnerInfo");
static_assert(offsetof(FM1FieldObjectSpawnerInfo, SpawnPointTransforms) == 0x000000, "Member 'FM1FieldObjectSpawnerInfo::SpawnPointTransforms' has a wrong offset!");
static_assert(offsetof(FM1FieldObjectSpawnerInfo, SpawnerName) == 0x000010, "Member 'FM1FieldObjectSpawnerInfo::SpawnerName' has a wrong offset!");
static_assert(offsetof(FM1FieldObjectSpawnerInfo, RespawnDelay) == 0x000020, "Member 'FM1FieldObjectSpawnerInfo::RespawnDelay' has a wrong offset!");
static_assert(offsetof(FM1FieldObjectSpawnerInfo, MaxSpawnCount) == 0x000024, "Member 'FM1FieldObjectSpawnerInfo::MaxSpawnCount' has a wrong offset!");
static_assert(offsetof(FM1FieldObjectSpawnerInfo, SpawnGroupDataName) == 0x000028, "Member 'FM1FieldObjectSpawnerInfo::SpawnGroupDataName' has a wrong offset!");
static_assert(offsetof(FM1FieldObjectSpawnerInfo, SpawnRatio) == 0x000038, "Member 'FM1FieldObjectSpawnerInfo::SpawnRatio' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatItemReset
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatItemReset final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatItemReset) == 0x000001, "Wrong alignment on FM1Response_CheatItemReset");
static_assert(sizeof(FM1Response_CheatItemReset) == 0x000001, "Wrong size on FM1Response_CheatItemReset");
static_assert(offsetof(FM1Response_CheatItemReset, Notification) == 0x000000, "Member 'FM1Response_CheatItemReset::Notification' has a wrong offset!");

// ScriptStruct M1.M1SocialServicePartyMoveDediServer
// 0x00D8 (0x00D8 - 0x0000)
struct FM1SocialServicePartyMoveDediServer final
{
public:
	int64                                         PartyUID;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         AccountID;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StartLocationId;                                   // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1PartyMoveRes                        PartyMoveRes;                                      // 0x0020(0x00B8)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SocialServicePartyMoveDediServer) == 0x000008, "Wrong alignment on FM1SocialServicePartyMoveDediServer");
static_assert(sizeof(FM1SocialServicePartyMoveDediServer) == 0x0000D8, "Wrong size on FM1SocialServicePartyMoveDediServer");
static_assert(offsetof(FM1SocialServicePartyMoveDediServer, PartyUID) == 0x000000, "Member 'FM1SocialServicePartyMoveDediServer::PartyUID' has a wrong offset!");
static_assert(offsetof(FM1SocialServicePartyMoveDediServer, AccountID) == 0x000008, "Member 'FM1SocialServicePartyMoveDediServer::AccountID' has a wrong offset!");
static_assert(offsetof(FM1SocialServicePartyMoveDediServer, StartLocationId) == 0x000010, "Member 'FM1SocialServicePartyMoveDediServer::StartLocationId' has a wrong offset!");
static_assert(offsetof(FM1SocialServicePartyMoveDediServer, PartyMoveRes) == 0x000020, "Member 'FM1SocialServicePartyMoveDediServer::PartyMoveRes' has a wrong offset!");

// ScriptStruct M1.M1CustomizeCharacterInfo
// 0x0058 (0x0058 - 0x0000)
struct FM1CustomizeCharacterInfo final
{
public:
	struct FM1TemplateId                          CharacterTid;                                      // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EM1CustomizingCharacterSkinType, struct FM1TemplateId> SkinTids;                                          // 0x0008(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizeCharacterInfo) == 0x000008, "Wrong alignment on FM1CustomizeCharacterInfo");
static_assert(sizeof(FM1CustomizeCharacterInfo) == 0x000058, "Wrong size on FM1CustomizeCharacterInfo");
static_assert(offsetof(FM1CustomizeCharacterInfo, CharacterTid) == 0x000000, "Member 'FM1CustomizeCharacterInfo::CharacterTid' has a wrong offset!");
static_assert(offsetof(FM1CustomizeCharacterInfo, SkinTids) == 0x000008, "Member 'FM1CustomizeCharacterInfo::SkinTids' has a wrong offset!");

// ScriptStruct M1.M1CustomizeWeaponInfo
// 0x0008 (0x0008 - 0x0000)
struct FM1CustomizeWeaponInfo final
{
public:
	struct FM1TemplateId                          WeaponTid;                                         // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          SkinTid;                                           // 0x0004(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizeWeaponInfo) == 0x000004, "Wrong alignment on FM1CustomizeWeaponInfo");
static_assert(sizeof(FM1CustomizeWeaponInfo) == 0x000008, "Wrong size on FM1CustomizeWeaponInfo");
static_assert(offsetof(FM1CustomizeWeaponInfo, WeaponTid) == 0x000000, "Member 'FM1CustomizeWeaponInfo::WeaponTid' has a wrong offset!");
static_assert(offsetof(FM1CustomizeWeaponInfo, SkinTid) == 0x000004, "Member 'FM1CustomizeWeaponInfo::SkinTid' has a wrong offset!");

// ScriptStruct M1.M1CustomizePaintInfo
// 0x0058 (0x0058 - 0x0000)
struct FM1CustomizePaintInfo final
{
public:
	struct FM1TemplateId                          SkinTid;                                           // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FM1TemplateId>             Paints;                                            // 0x0008(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizePaintInfo) == 0x000008, "Wrong alignment on FM1CustomizePaintInfo");
static_assert(sizeof(FM1CustomizePaintInfo) == 0x000058, "Wrong size on FM1CustomizePaintInfo");
static_assert(offsetof(FM1CustomizePaintInfo, SkinTid) == 0x000000, "Member 'FM1CustomizePaintInfo::SkinTid' has a wrong offset!");
static_assert(offsetof(FM1CustomizePaintInfo, Paints) == 0x000008, "Member 'FM1CustomizePaintInfo::Paints' has a wrong offset!");

// ScriptStruct M1.M1CustomizeBoundedItems
// 0x0050 (0x0050 - 0x0000)
struct FM1CustomizeBoundedItems final
{
public:
	TSet<struct FM1TemplateId>                    Tids;                                              // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizeBoundedItems) == 0x000008, "Wrong alignment on FM1CustomizeBoundedItems");
static_assert(sizeof(FM1CustomizeBoundedItems) == 0x000050, "Wrong size on FM1CustomizeBoundedItems");
static_assert(offsetof(FM1CustomizeBoundedItems, Tids) == 0x000000, "Member 'FM1CustomizeBoundedItems::Tids' has a wrong offset!");

// ScriptStruct M1.M1CustomizeInfos
// 0x0280 (0x0280 - 0x0000)
struct FM1CustomizeInfos final
{
public:
	TMap<struct FM1TemplateId, struct FM1CustomizeCharacterInfo> Characters;                                        // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	TMap<struct FM1TemplateId, struct FM1CustomizeWeaponInfo> Weapons;                                           // 0x0050(0x0050)(NativeAccessSpecifierPublic)
	TMap<struct FM1TemplateId, struct FM1CustomizePaintInfo> Paints;                                            // 0x00A0(0x0050)(NativeAccessSpecifierPublic)
	TMap<int32, struct FM1TemplateId>             EmotionSlots;                                      // 0x00F0(0x0050)(NativeAccessSpecifierPublic)
	TMap<EM1CustomizingItemCategoryType, struct FM1TemplateId> Etc;                                               // 0x0140(0x0050)(NativeAccessSpecifierPublic)
	TMap<struct FM1TemplateId, struct FM1CustomizeBoundedItems> BoundedToCharacter;                                // 0x0190(0x0050)(NativeAccessSpecifierPublic)
	TMap<struct FM1TemplateId, struct FM1CustomizeBoundedItems> BoundedToWeapon;                                   // 0x01E0(0x0050)(NativeAccessSpecifierPublic)
	TMap<struct FM1TemplateId, struct FM1CustomizeBoundedItems> BoundedToSkin;                                     // 0x0230(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizeInfos) == 0x000008, "Wrong alignment on FM1CustomizeInfos");
static_assert(sizeof(FM1CustomizeInfos) == 0x000280, "Wrong size on FM1CustomizeInfos");
static_assert(offsetof(FM1CustomizeInfos, Characters) == 0x000000, "Member 'FM1CustomizeInfos::Characters' has a wrong offset!");
static_assert(offsetof(FM1CustomizeInfos, Weapons) == 0x000050, "Member 'FM1CustomizeInfos::Weapons' has a wrong offset!");
static_assert(offsetof(FM1CustomizeInfos, Paints) == 0x0000A0, "Member 'FM1CustomizeInfos::Paints' has a wrong offset!");
static_assert(offsetof(FM1CustomizeInfos, EmotionSlots) == 0x0000F0, "Member 'FM1CustomizeInfos::EmotionSlots' has a wrong offset!");
static_assert(offsetof(FM1CustomizeInfos, Etc) == 0x000140, "Member 'FM1CustomizeInfos::Etc' has a wrong offset!");
static_assert(offsetof(FM1CustomizeInfos, BoundedToCharacter) == 0x000190, "Member 'FM1CustomizeInfos::BoundedToCharacter' has a wrong offset!");
static_assert(offsetof(FM1CustomizeInfos, BoundedToWeapon) == 0x0001E0, "Member 'FM1CustomizeInfos::BoundedToWeapon' has a wrong offset!");
static_assert(offsetof(FM1CustomizeInfos, BoundedToSkin) == 0x000230, "Member 'FM1CustomizeInfos::BoundedToSkin' has a wrong offset!");

// ScriptStruct M1.M1DestructionVulgusPostTargetInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1DestructionVulgusPostTargetInfo final
{
public:
	int64                                         TargetUid;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StringId;                                          // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentHp;                                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeactivated;                                      // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1DestructionVulgusPostTargetInfo) == 0x000008, "Wrong alignment on FM1DestructionVulgusPostTargetInfo");
static_assert(sizeof(FM1DestructionVulgusPostTargetInfo) == 0x000020, "Wrong size on FM1DestructionVulgusPostTargetInfo");
static_assert(offsetof(FM1DestructionVulgusPostTargetInfo, TargetUid) == 0x000000, "Member 'FM1DestructionVulgusPostTargetInfo::TargetUid' has a wrong offset!");
static_assert(offsetof(FM1DestructionVulgusPostTargetInfo, StringId) == 0x000008, "Member 'FM1DestructionVulgusPostTargetInfo::StringId' has a wrong offset!");
static_assert(offsetof(FM1DestructionVulgusPostTargetInfo, CurrentHp) == 0x000018, "Member 'FM1DestructionVulgusPostTargetInfo::CurrentHp' has a wrong offset!");
static_assert(offsetof(FM1DestructionVulgusPostTargetInfo, bDeactivated) == 0x00001C, "Member 'FM1DestructionVulgusPostTargetInfo::bDeactivated' has a wrong offset!");

// ScriptStruct M1.M1Response_GrantRuneSocket
// 0x0018 (0x0018 - 0x0000)
struct FM1Response_GrantRuneSocket final
{
public:
	EM1RuneReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemTidBox                          OwnerTidBox;                                       // 0x0004(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	EM1RuneSubClassType                           SubClassType;                                      // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotIndex;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RuneSocketType                             SocketType;                                        // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Response_GrantRuneSocket) == 0x000004, "Wrong alignment on FM1Response_GrantRuneSocket");
static_assert(sizeof(FM1Response_GrantRuneSocket) == 0x000018, "Wrong size on FM1Response_GrantRuneSocket");
static_assert(offsetof(FM1Response_GrantRuneSocket, Notification) == 0x000000, "Member 'FM1Response_GrantRuneSocket::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_GrantRuneSocket, OwnerTidBox) == 0x000004, "Member 'FM1Response_GrantRuneSocket::OwnerTidBox' has a wrong offset!");
static_assert(offsetof(FM1Response_GrantRuneSocket, SubClassType) == 0x00000C, "Member 'FM1Response_GrantRuneSocket::SubClassType' has a wrong offset!");
static_assert(offsetof(FM1Response_GrantRuneSocket, SlotIndex) == 0x000010, "Member 'FM1Response_GrantRuneSocket::SlotIndex' has a wrong offset!");
static_assert(offsetof(FM1Response_GrantRuneSocket, SocketType) == 0x000014, "Member 'FM1Response_GrantRuneSocket::SocketType' has a wrong offset!");

// ScriptStruct M1.M1Response_TryEquipReinforce
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_TryEquipReinforce final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GroupIndex;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquip;                                            // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Response_TryEquipReinforce) == 0x000004, "Wrong alignment on FM1Response_TryEquipReinforce");
static_assert(sizeof(FM1Response_TryEquipReinforce) == 0x000010, "Wrong size on FM1Response_TryEquipReinforce");
static_assert(offsetof(FM1Response_TryEquipReinforce, Notification) == 0x000000, "Member 'FM1Response_TryEquipReinforce::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_TryEquipReinforce, GroupIndex) == 0x000004, "Member 'FM1Response_TryEquipReinforce::GroupIndex' has a wrong offset!");
static_assert(offsetof(FM1Response_TryEquipReinforce, SlotIndex) == 0x000008, "Member 'FM1Response_TryEquipReinforce::SlotIndex' has a wrong offset!");
static_assert(offsetof(FM1Response_TryEquipReinforce, bEquip) == 0x00000C, "Member 'FM1Response_TryEquipReinforce::bEquip' has a wrong offset!");

// ScriptStruct M1.M1Response_GetTitleItemInvenvory
// 0x0020 (0x0020 - 0x0000)
struct FM1Response_GetTitleItemInvenvory final
{
public:
	struct FM1TitleItemInvenvory                  Notification;                                      // 0x0000(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_GetTitleItemInvenvory) == 0x000008, "Wrong alignment on FM1Response_GetTitleItemInvenvory");
static_assert(sizeof(FM1Response_GetTitleItemInvenvory) == 0x000020, "Wrong size on FM1Response_GetTitleItemInvenvory");
static_assert(offsetof(FM1Response_GetTitleItemInvenvory, Notification) == 0x000000, "Member 'FM1Response_GetTitleItemInvenvory::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_BlockRequest
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_BlockRequest final : public FM1Request
{
public:
	class FString                                 TargetName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_BlockRequest) == 0x000008, "Wrong alignment on FM1Request_BlockRequest");
static_assert(sizeof(FM1Request_BlockRequest) == 0x000010, "Wrong size on FM1Request_BlockRequest");
static_assert(offsetof(FM1Request_BlockRequest, TargetName) == 0x000000, "Member 'FM1Request_BlockRequest::TargetName' has a wrong offset!");

// ScriptStruct M1.M1TaskEventList
// 0x0018 (0x0018 - 0x0000)
struct FM1TaskEventList final
{
public:
	class FName                                   KeyName;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UM1TaskEvent*>                   TaskEvents;                                        // 0x0008(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TaskEventList) == 0x000008, "Wrong alignment on FM1TaskEventList");
static_assert(sizeof(FM1TaskEventList) == 0x000018, "Wrong size on FM1TaskEventList");
static_assert(offsetof(FM1TaskEventList, KeyName) == 0x000000, "Member 'FM1TaskEventList::KeyName' has a wrong offset!");
static_assert(offsetof(FM1TaskEventList, TaskEvents) == 0x000008, "Member 'FM1TaskEventList::TaskEvents' has a wrong offset!");

// ScriptStruct M1.M1GameSessionServiceAccountInfo
// 0x0078 (0x0078 - 0x0000)
struct FM1GameSessionServiceAccountInfo final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MasteryLevel;                                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MasteryExp;                                        // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1UnlockedFieldInfo>           UnlockedFields;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1VoidBattleClearInfo>         VoidBattleClearCounts;                             // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         LoginPlatformType;                                 // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LoginPlatformOnlineId;                             // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         LoginPlatformUid;                                  // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Npsn;                                              // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCreator;                                         // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1GameSessionServiceAccountInfo) == 0x000008, "Wrong alignment on FM1GameSessionServiceAccountInfo");
static_assert(sizeof(FM1GameSessionServiceAccountInfo) == 0x000078, "Wrong size on FM1GameSessionServiceAccountInfo");
static_assert(offsetof(FM1GameSessionServiceAccountInfo, AccountUid) == 0x000000, "Member 'FM1GameSessionServiceAccountInfo::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1GameSessionServiceAccountInfo, MasteryLevel) == 0x000008, "Member 'FM1GameSessionServiceAccountInfo::MasteryLevel' has a wrong offset!");
static_assert(offsetof(FM1GameSessionServiceAccountInfo, MasteryExp) == 0x000010, "Member 'FM1GameSessionServiceAccountInfo::MasteryExp' has a wrong offset!");
static_assert(offsetof(FM1GameSessionServiceAccountInfo, Name) == 0x000018, "Member 'FM1GameSessionServiceAccountInfo::Name' has a wrong offset!");
static_assert(offsetof(FM1GameSessionServiceAccountInfo, UnlockedFields) == 0x000028, "Member 'FM1GameSessionServiceAccountInfo::UnlockedFields' has a wrong offset!");
static_assert(offsetof(FM1GameSessionServiceAccountInfo, VoidBattleClearCounts) == 0x000038, "Member 'FM1GameSessionServiceAccountInfo::VoidBattleClearCounts' has a wrong offset!");
static_assert(offsetof(FM1GameSessionServiceAccountInfo, LoginPlatformType) == 0x000048, "Member 'FM1GameSessionServiceAccountInfo::LoginPlatformType' has a wrong offset!");
static_assert(offsetof(FM1GameSessionServiceAccountInfo, LoginPlatformOnlineId) == 0x000050, "Member 'FM1GameSessionServiceAccountInfo::LoginPlatformOnlineId' has a wrong offset!");
static_assert(offsetof(FM1GameSessionServiceAccountInfo, LoginPlatformUid) == 0x000060, "Member 'FM1GameSessionServiceAccountInfo::LoginPlatformUid' has a wrong offset!");
static_assert(offsetof(FM1GameSessionServiceAccountInfo, Npsn) == 0x000068, "Member 'FM1GameSessionServiceAccountInfo::Npsn' has a wrong offset!");
static_assert(offsetof(FM1GameSessionServiceAccountInfo, IsCreator) == 0x000070, "Member 'FM1GameSessionServiceAccountInfo::IsCreator' has a wrong offset!");

// ScriptStruct M1.M1NxLogInteger
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FM1NxLogInteger final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1NxLogInteger) == 0x000008, "Wrong alignment on FM1NxLogInteger");
static_assert(sizeof(FM1NxLogInteger) == 0x000010, "Wrong size on FM1NxLogInteger");

// ScriptStruct M1.M1NxLog_ETC_EACLog
// 0x0020 (0x0020 - 0x0000)
struct FM1NxLog_ETC_EACLog final
{
public:
	struct FM1NxLogInteger                        Logseqno;                                          // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Lograwdata;                                        // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_ETC_EACLog) == 0x000008, "Wrong alignment on FM1NxLog_ETC_EACLog");
static_assert(sizeof(FM1NxLog_ETC_EACLog) == 0x000020, "Wrong size on FM1NxLog_ETC_EACLog");
static_assert(offsetof(FM1NxLog_ETC_EACLog, Logseqno) == 0x000000, "Member 'FM1NxLog_ETC_EACLog::Logseqno' has a wrong offset!");
static_assert(offsetof(FM1NxLog_ETC_EACLog, Lograwdata) == 0x000010, "Member 'FM1NxLog_ETC_EACLog::Lograwdata' has a wrong offset!");

// ScriptStruct M1.M1NxLog_Base
// 0x00E0 (0x00E0 - 0x0000)
struct FM1NxLog_Base
{
public:
	class FString                                 Type;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CreateDate;                                        // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServiceId;                                         // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Npsn;                                              // 0x0030(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Accountno;                                         // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Ipaddress;                                         // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerName;                                        // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RegionId;                                          // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CountryName;                                       // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DeviceName;                                        // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OsType;                                            // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OsName;                                            // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Osplatform;                                        // 0x00C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SessionId;                                         // 0x00D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_Base) == 0x000008, "Wrong alignment on FM1NxLog_Base");
static_assert(sizeof(FM1NxLog_Base) == 0x0000E0, "Wrong size on FM1NxLog_Base");
static_assert(offsetof(FM1NxLog_Base, Type) == 0x000000, "Member 'FM1NxLog_Base::Type' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Base, CreateDate) == 0x000010, "Member 'FM1NxLog_Base::CreateDate' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Base, ServiceId) == 0x000020, "Member 'FM1NxLog_Base::ServiceId' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Base, Npsn) == 0x000030, "Member 'FM1NxLog_Base::Npsn' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Base, Accountno) == 0x000040, "Member 'FM1NxLog_Base::Accountno' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Base, Ipaddress) == 0x000050, "Member 'FM1NxLog_Base::Ipaddress' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Base, ServerName) == 0x000060, "Member 'FM1NxLog_Base::ServerName' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Base, RegionId) == 0x000070, "Member 'FM1NxLog_Base::RegionId' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Base, CountryName) == 0x000080, "Member 'FM1NxLog_Base::CountryName' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Base, DeviceName) == 0x000090, "Member 'FM1NxLog_Base::DeviceName' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Base, OsType) == 0x0000A0, "Member 'FM1NxLog_Base::OsType' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Base, OsName) == 0x0000B0, "Member 'FM1NxLog_Base::OsName' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Base, Osplatform) == 0x0000C0, "Member 'FM1NxLog_Base::Osplatform' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Base, SessionId) == 0x0000D0, "Member 'FM1NxLog_Base::SessionId' has a wrong offset!");

// ScriptStruct M1.M1NxLog_ETC_EACLog_Base
// 0x0020 (0x0100 - 0x00E0)
struct FM1NxLog_ETC_EACLog_Base final : public FM1NxLog_Base
{
public:
	struct FM1NxLog_ETC_EACLog                    ETC_EACLog;                                        // 0x00E0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_ETC_EACLog_Base) == 0x000008, "Wrong alignment on FM1NxLog_ETC_EACLog_Base");
static_assert(sizeof(FM1NxLog_ETC_EACLog_Base) == 0x000100, "Wrong size on FM1NxLog_ETC_EACLog_Base");
static_assert(offsetof(FM1NxLog_ETC_EACLog_Base, ETC_EACLog) == 0x0000E0, "Member 'FM1NxLog_ETC_EACLog_Base::ETC_EACLog' has a wrong offset!");

// ScriptStruct M1.M1TypedUICustomizing
// 0x0028 (0x0028 - 0x0000)
struct FM1TypedUICustomizing
{
public:
	EM1UICustomizeType                            Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLinearColor>                   CustomColors;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSlateBrush>                    CustomBrushes;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TypedUICustomizing) == 0x000008, "Wrong alignment on FM1TypedUICustomizing");
static_assert(sizeof(FM1TypedUICustomizing) == 0x000028, "Wrong size on FM1TypedUICustomizing");
static_assert(offsetof(FM1TypedUICustomizing, Type) == 0x000000, "Member 'FM1TypedUICustomizing::Type' has a wrong offset!");
static_assert(offsetof(FM1TypedUICustomizing, CustomColors) == 0x000008, "Member 'FM1TypedUICustomizing::CustomColors' has a wrong offset!");
static_assert(offsetof(FM1TypedUICustomizing, CustomBrushes) == 0x000018, "Member 'FM1TypedUICustomizing::CustomBrushes' has a wrong offset!");

// ScriptStruct M1.M1UINamecardData
// 0x0028 (0x0030 - 0x0008)
struct FM1UINamecardData final : public FTableRowBase
{
public:
	struct FM1TypedUICustomizing                  NamecardStyle;                                     // 0x0008(0x0028)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1UINamecardData) == 0x000008, "Wrong alignment on FM1UINamecardData");
static_assert(sizeof(FM1UINamecardData) == 0x000030, "Wrong size on FM1UINamecardData");
static_assert(offsetof(FM1UINamecardData, NamecardStyle) == 0x000008, "Member 'FM1UINamecardData::NamecardStyle' has a wrong offset!");

// ScriptStruct M1.M1DedicatedServerSetMatchingPlayersNum
// 0x0004 (0x0004 - 0x0000)
struct FM1DedicatedServerSetMatchingPlayersNum final
{
public:
	int32                                         Noti;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DedicatedServerSetMatchingPlayersNum) == 0x000004, "Wrong alignment on FM1DedicatedServerSetMatchingPlayersNum");
static_assert(sizeof(FM1DedicatedServerSetMatchingPlayersNum) == 0x000004, "Wrong size on FM1DedicatedServerSetMatchingPlayersNum");
static_assert(offsetof(FM1DedicatedServerSetMatchingPlayersNum, Noti) == 0x000000, "Member 'FM1DedicatedServerSetMatchingPlayersNum::Noti' has a wrong offset!");

// ScriptStruct M1.M1Response_DeleteMailList
// 0x0018 (0x0018 - 0x0000)
struct FM1Response_DeleteMailList final
{
public:
	struct FM1MailDeleteAllInfo                   Notification;                                      // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_DeleteMailList) == 0x000008, "Wrong alignment on FM1Response_DeleteMailList");
static_assert(sizeof(FM1Response_DeleteMailList) == 0x000018, "Wrong size on FM1Response_DeleteMailList");
static_assert(offsetof(FM1Response_DeleteMailList, Notification) == 0x000000, "Member 'FM1Response_DeleteMailList::Notification' has a wrong offset!");

// ScriptStruct M1.M1BundleSubTaskActorConstruction
// 0x0010 (0x0010 - 0x0000)
struct FM1BundleSubTaskActorConstruction final
{
public:
	TSubclassOf<class AM1MissionSubTaskActor>     ClassType;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1BundleSubTaskActorConstruction) == 0x000008, "Wrong alignment on FM1BundleSubTaskActorConstruction");
static_assert(sizeof(FM1BundleSubTaskActorConstruction) == 0x000010, "Wrong size on FM1BundleSubTaskActorConstruction");
static_assert(offsetof(FM1BundleSubTaskActorConstruction, ClassType) == 0x000000, "Member 'FM1BundleSubTaskActorConstruction::ClassType' has a wrong offset!");
static_assert(offsetof(FM1BundleSubTaskActorConstruction, Count) == 0x000008, "Member 'FM1BundleSubTaskActorConstruction::Count' has a wrong offset!");

// ScriptStruct M1.M1Response_ChangeCharacter
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_ChangeCharacter final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_ChangeCharacter) == 0x000001, "Wrong alignment on FM1Response_ChangeCharacter");
static_assert(sizeof(FM1Response_ChangeCharacter) == 0x000001, "Wrong size on FM1Response_ChangeCharacter");
static_assert(offsetof(FM1Response_ChangeCharacter, Notification) == 0x000000, "Member 'FM1Response_ChangeCharacter::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_GetAccountInfo
// 0x01C8 (0x01C8 - 0x0000)
struct FM1Response_GetAccountInfo final
{
public:
	struct FM1GetAccountInfoRes                   Notification;                                      // 0x0000(0x01C8)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_GetAccountInfo) == 0x000008, "Wrong alignment on FM1Response_GetAccountInfo");
static_assert(sizeof(FM1Response_GetAccountInfo) == 0x0001C8, "Wrong size on FM1Response_GetAccountInfo");
static_assert(offsetof(FM1Response_GetAccountInfo, Notification) == 0x000000, "Member 'FM1Response_GetAccountInfo::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_DeleteMailList
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_DeleteMailList final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MailType                                   MailType;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_DeleteMailList) == 0x000008, "Wrong alignment on FM1Request_DeleteMailList");
static_assert(sizeof(FM1Request_DeleteMailList) == 0x000010, "Wrong size on FM1Request_DeleteMailList");
static_assert(offsetof(FM1Request_DeleteMailList, AccountUid) == 0x000000, "Member 'FM1Request_DeleteMailList::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_DeleteMailList, MailType) == 0x000008, "Member 'FM1Request_DeleteMailList::MailType' has a wrong offset!");

// ScriptStruct M1.M1Response_GetInventoryMaxCount
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_GetInventoryMaxCount final
{
public:
	struct FM1InventorySlotCountBundle            Notification;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_GetInventoryMaxCount) == 0x000008, "Wrong alignment on FM1Response_GetInventoryMaxCount");
static_assert(sizeof(FM1Response_GetInventoryMaxCount) == 0x000010, "Wrong size on FM1Response_GetInventoryMaxCount");
static_assert(offsetof(FM1Response_GetInventoryMaxCount, Notification) == 0x000000, "Member 'FM1Response_GetInventoryMaxCount::Notification' has a wrong offset!");

// ScriptStruct M1.M1EquipmentInfoWrapper
// 0x0020 (0x0020 - 0x0000)
struct FM1EquipmentInfoWrapper final
{
public:
	struct FM1EquipmentBaseInfo                   EquipmentInfo;                                     // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNewItem;                                          // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1EquipmentInfoWrapper) == 0x000008, "Wrong alignment on FM1EquipmentInfoWrapper");
static_assert(sizeof(FM1EquipmentInfoWrapper) == 0x000020, "Wrong size on FM1EquipmentInfoWrapper");
static_assert(offsetof(FM1EquipmentInfoWrapper, EquipmentInfo) == 0x000000, "Member 'FM1EquipmentInfoWrapper::EquipmentInfo' has a wrong offset!");
static_assert(offsetof(FM1EquipmentInfoWrapper, bNewItem) == 0x000018, "Member 'FM1EquipmentInfoWrapper::bNewItem' has a wrong offset!");

// ScriptStruct M1.M1Response_GiveMissionWaveMidResult
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_GiveMissionWaveMidResult final
{
public:
	struct FM1MissionMidRewardRes                 Notification;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_GiveMissionWaveMidResult) == 0x000008, "Wrong alignment on FM1Response_GiveMissionWaveMidResult");
static_assert(sizeof(FM1Response_GiveMissionWaveMidResult) == 0x000010, "Wrong size on FM1Response_GiveMissionWaveMidResult");
static_assert(offsetof(FM1Response_GiveMissionWaveMidResult, Notification) == 0x000000, "Member 'FM1Response_GiveMissionWaveMidResult::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatResetQuest
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatResetQuest final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatResetQuest) == 0x000001, "Wrong alignment on FM1Response_CheatResetQuest");
static_assert(sizeof(FM1Response_CheatResetQuest) == 0x000001, "Wrong size on FM1Response_CheatResetQuest");
static_assert(offsetof(FM1Response_CheatResetQuest, Notification) == 0x000000, "Member 'FM1Response_CheatResetQuest::Notification' has a wrong offset!");

// ScriptStruct M1.M1NxLogDouble
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FM1NxLogDouble final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1NxLogDouble) == 0x000008, "Wrong alignment on FM1NxLogDouble");
static_assert(sizeof(FM1NxLogDouble) == 0x000010, "Wrong size on FM1NxLogDouble");

// ScriptStruct M1.M1NxLog_Location
// 0x0030 (0x0030 - 0x0000)
struct FM1NxLog_Location final
{
public:
	struct FM1NxLogDouble                         X;                                                 // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1NxLogDouble                         Y;                                                 // 0x0010(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1NxLogDouble                         Z;                                                 // 0x0020(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_Location) == 0x000008, "Wrong alignment on FM1NxLog_Location");
static_assert(sizeof(FM1NxLog_Location) == 0x000030, "Wrong size on FM1NxLog_Location");
static_assert(offsetof(FM1NxLog_Location, X) == 0x000000, "Member 'FM1NxLog_Location::X' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Location, Y) == 0x000010, "Member 'FM1NxLog_Location::Y' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Location, Z) == 0x000020, "Member 'FM1NxLog_Location::Z' has a wrong offset!");

// ScriptStruct M1.M1NxLog_FireLocValidationError
// 0x0110 (0x0110 - 0x0000)
struct FM1NxLog_FireLocValidationError final
{
public:
	class FString                                 Actionid;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Userlevel;                                         // 0x0010(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Usernickname;                                      // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tfdplayeritemid;                                   // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Tfdplayeritemlevel;                                // 0x0040(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Tfdweaponitemid;                                   // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Tfdweaponitemlevel;                                // 0x0060(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 FieldId;                                           // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldUid;                                          // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLog_Location                      Clientfireloc;                                     // 0x0090(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1NxLog_Location                      Serverbaseloc;                                     // 0x00C0(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1NxLogDouble                         Validationlocdiff;                                 // 0x00F0(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1NxLogDouble                         Validationsize;                                    // 0x0100(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_FireLocValidationError) == 0x000008, "Wrong alignment on FM1NxLog_FireLocValidationError");
static_assert(sizeof(FM1NxLog_FireLocValidationError) == 0x000110, "Wrong size on FM1NxLog_FireLocValidationError");
static_assert(offsetof(FM1NxLog_FireLocValidationError, Actionid) == 0x000000, "Member 'FM1NxLog_FireLocValidationError::Actionid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireLocValidationError, Userlevel) == 0x000010, "Member 'FM1NxLog_FireLocValidationError::Userlevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireLocValidationError, Usernickname) == 0x000020, "Member 'FM1NxLog_FireLocValidationError::Usernickname' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireLocValidationError, Tfdplayeritemid) == 0x000030, "Member 'FM1NxLog_FireLocValidationError::Tfdplayeritemid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireLocValidationError, Tfdplayeritemlevel) == 0x000040, "Member 'FM1NxLog_FireLocValidationError::Tfdplayeritemlevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireLocValidationError, Tfdweaponitemid) == 0x000050, "Member 'FM1NxLog_FireLocValidationError::Tfdweaponitemid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireLocValidationError, Tfdweaponitemlevel) == 0x000060, "Member 'FM1NxLog_FireLocValidationError::Tfdweaponitemlevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireLocValidationError, FieldId) == 0x000070, "Member 'FM1NxLog_FireLocValidationError::FieldId' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireLocValidationError, FieldUid) == 0x000080, "Member 'FM1NxLog_FireLocValidationError::FieldUid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireLocValidationError, Clientfireloc) == 0x000090, "Member 'FM1NxLog_FireLocValidationError::Clientfireloc' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireLocValidationError, Serverbaseloc) == 0x0000C0, "Member 'FM1NxLog_FireLocValidationError::Serverbaseloc' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireLocValidationError, Validationlocdiff) == 0x0000F0, "Member 'FM1NxLog_FireLocValidationError::Validationlocdiff' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireLocValidationError, Validationsize) == 0x000100, "Member 'FM1NxLog_FireLocValidationError::Validationsize' has a wrong offset!");

// ScriptStruct M1.M1RecordInfoWrapper
// 0x0008 (0x0008 - 0x0000)
struct FM1RecordInfoWrapper final
{
public:
	struct FM1RecordInfo                          RecordInfo;                                        // 0x0000(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNewItem;                                          // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RecordInfoWrapper) == 0x000004, "Wrong alignment on FM1RecordInfoWrapper");
static_assert(sizeof(FM1RecordInfoWrapper) == 0x000008, "Wrong size on FM1RecordInfoWrapper");
static_assert(offsetof(FM1RecordInfoWrapper, RecordInfo) == 0x000000, "Member 'FM1RecordInfoWrapper::RecordInfo' has a wrong offset!");
static_assert(offsetof(FM1RecordInfoWrapper, bNewItem) == 0x000004, "Member 'FM1RecordInfoWrapper::bNewItem' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatUnlockFieldType
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatUnlockFieldType final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatUnlockFieldType) == 0x000001, "Wrong alignment on FM1Response_CheatUnlockFieldType");
static_assert(sizeof(FM1Response_CheatUnlockFieldType) == 0x000001, "Wrong size on FM1Response_CheatUnlockFieldType");
static_assert(offsetof(FM1Response_CheatUnlockFieldType, Notification) == 0x000000, "Member 'FM1Response_CheatUnlockFieldType::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_RequestSetResearchBookmark
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_RequestSetResearchBookmark final
{
public:
	EM1ResearchReason                             Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_RequestSetResearchBookmark) == 0x000004, "Wrong alignment on FM1Response_RequestSetResearchBookmark");
static_assert(sizeof(FM1Response_RequestSetResearchBookmark) == 0x000004, "Wrong size on FM1Response_RequestSetResearchBookmark");
static_assert(offsetof(FM1Response_RequestSetResearchBookmark, Notification) == 0x000000, "Member 'FM1Response_RequestSetResearchBookmark::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatResetTime
// 0x0008 (0x0008 - 0x0000)
struct FM1Response_CheatResetTime final
{
public:
	int64                                         Notification;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatResetTime) == 0x000008, "Wrong alignment on FM1Response_CheatResetTime");
static_assert(sizeof(FM1Response_CheatResetTime) == 0x000008, "Wrong size on FM1Response_CheatResetTime");
static_assert(offsetof(FM1Response_CheatResetTime, Notification) == 0x000000, "Member 'FM1Response_CheatResetTime::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_InvasionDungeonComplete
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_InvasionDungeonComplete final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1InvasionDungeonCompleteRequest      Request;                                           // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_InvasionDungeonComplete) == 0x000008, "Wrong alignment on FM1Request_InvasionDungeonComplete");
static_assert(sizeof(FM1Request_InvasionDungeonComplete) == 0x000010, "Wrong size on FM1Request_InvasionDungeonComplete");
static_assert(offsetof(FM1Request_InvasionDungeonComplete, AccountUid) == 0x000000, "Member 'FM1Request_InvasionDungeonComplete::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_InvasionDungeonComplete, Request) == 0x000008, "Member 'FM1Request_InvasionDungeonComplete::Request' has a wrong offset!");

// ScriptStruct M1.M1DecalInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1DecalInfo final
{
public:
	class UNiagaraSystem*                         DecalSystem;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideDuration;                                 // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideSize;                                     // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Size;                                              // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideHeight;                                   // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Height;                                            // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DecalInfo) == 0x000008, "Wrong alignment on FM1DecalInfo");
static_assert(sizeof(FM1DecalInfo) == 0x000020, "Wrong size on FM1DecalInfo");
static_assert(offsetof(FM1DecalInfo, DecalSystem) == 0x000000, "Member 'FM1DecalInfo::DecalSystem' has a wrong offset!");
static_assert(offsetof(FM1DecalInfo, bOverrideDuration) == 0x000008, "Member 'FM1DecalInfo::bOverrideDuration' has a wrong offset!");
static_assert(offsetof(FM1DecalInfo, Duration) == 0x00000C, "Member 'FM1DecalInfo::Duration' has a wrong offset!");
static_assert(offsetof(FM1DecalInfo, bOverrideSize) == 0x000010, "Member 'FM1DecalInfo::bOverrideSize' has a wrong offset!");
static_assert(offsetof(FM1DecalInfo, Size) == 0x000014, "Member 'FM1DecalInfo::Size' has a wrong offset!");
static_assert(offsetof(FM1DecalInfo, bOverrideHeight) == 0x000018, "Member 'FM1DecalInfo::bOverrideHeight' has a wrong offset!");
static_assert(offsetof(FM1DecalInfo, Height) == 0x00001C, "Member 'FM1DecalInfo::Height' has a wrong offset!");

// ScriptStruct M1.M1Response_PartyLeave
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_PartyLeave final
{
public:
	EM1PartyErrorCode                             Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_PartyLeave) == 0x000004, "Wrong alignment on FM1Response_PartyLeave");
static_assert(sizeof(FM1Response_PartyLeave) == 0x000004, "Wrong size on FM1Response_PartyLeave");
static_assert(offsetof(FM1Response_PartyLeave, Notification) == 0x000000, "Member 'FM1Response_PartyLeave::Notification' has a wrong offset!");

// ScriptStruct M1.M1NamedMonsterSpawnInfo
// 0x0060 (0x0060 - 0x0000)
struct FM1NamedMonsterSpawnInfo final
{
public:
	class FName                                   MonsterName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class UM1SpawnedActorTrait*>             Traits;                                            // 0x0008(0x0050)(Edit, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         SpawnRatio;                                        // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1NamedMonsterSpawnInfo) == 0x000008, "Wrong alignment on FM1NamedMonsterSpawnInfo");
static_assert(sizeof(FM1NamedMonsterSpawnInfo) == 0x000060, "Wrong size on FM1NamedMonsterSpawnInfo");
static_assert(offsetof(FM1NamedMonsterSpawnInfo, MonsterName) == 0x000000, "Member 'FM1NamedMonsterSpawnInfo::MonsterName' has a wrong offset!");
static_assert(offsetof(FM1NamedMonsterSpawnInfo, Traits) == 0x000008, "Member 'FM1NamedMonsterSpawnInfo::Traits' has a wrong offset!");
static_assert(offsetof(FM1NamedMonsterSpawnInfo, SpawnRatio) == 0x000058, "Member 'FM1NamedMonsterSpawnInfo::SpawnRatio' has a wrong offset!");

// ScriptStruct M1.M1HitMarkerClassRow
// 0x0008 (0x0010 - 0x0008)
struct FM1HitMarkerClassRow final : public FTableRowBase
{
public:
	EM1EquipItemClassType                         WeaponType;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1HitMarkerClassRow) == 0x000008, "Wrong alignment on FM1HitMarkerClassRow");
static_assert(sizeof(FM1HitMarkerClassRow) == 0x000010, "Wrong size on FM1HitMarkerClassRow");
static_assert(offsetof(FM1HitMarkerClassRow, WeaponType) == 0x000008, "Member 'FM1HitMarkerClassRow::WeaponType' has a wrong offset!");

// ScriptStruct M1.M1Response_PartyMoveReserveDedicatedServer_2
// 0x00B8 (0x00B8 - 0x0000)
struct FM1Response_PartyMoveReserveDedicatedServer_2 final
{
public:
	struct FM1PartyMoveRes                        Notification;                                      // 0x0000(0x00B8)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_PartyMoveReserveDedicatedServer_2) == 0x000008, "Wrong alignment on FM1Response_PartyMoveReserveDedicatedServer_2");
static_assert(sizeof(FM1Response_PartyMoveReserveDedicatedServer_2) == 0x0000B8, "Wrong size on FM1Response_PartyMoveReserveDedicatedServer_2");
static_assert(offsetof(FM1Response_PartyMoveReserveDedicatedServer_2, Notification) == 0x000000, "Member 'FM1Response_PartyMoveReserveDedicatedServer_2::Notification' has a wrong offset!");

// ScriptStruct M1.M1ProjectileHomingInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1ProjectileHomingInfo final
{
public:
	bool                                          bEnableHoming;                                     // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HomingAccelerationMagnitude;                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USceneComponent>         HomingTargetComponent;                             // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ProjectileHomingInfo) == 0x000004, "Wrong alignment on FM1ProjectileHomingInfo");
static_assert(sizeof(FM1ProjectileHomingInfo) == 0x000010, "Wrong size on FM1ProjectileHomingInfo");
static_assert(offsetof(FM1ProjectileHomingInfo, bEnableHoming) == 0x000000, "Member 'FM1ProjectileHomingInfo::bEnableHoming' has a wrong offset!");
static_assert(offsetof(FM1ProjectileHomingInfo, HomingAccelerationMagnitude) == 0x000004, "Member 'FM1ProjectileHomingInfo::HomingAccelerationMagnitude' has a wrong offset!");
static_assert(offsetof(FM1ProjectileHomingInfo, HomingTargetComponent) == 0x000008, "Member 'FM1ProjectileHomingInfo::HomingTargetComponent' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatAddWeaponProficiencyPoint
// 0x0028 (0x0028 - 0x0000)
struct FM1Request_CheatAddWeaponProficiencyPoint final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Exp;                                               // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          WeaponId;                                          // 0x0010(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1MonsterRequestInfoBox               MonsterRequestInfoBox;                             // 0x0018(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatAddWeaponProficiencyPoint) == 0x000008, "Wrong alignment on FM1Request_CheatAddWeaponProficiencyPoint");
static_assert(sizeof(FM1Request_CheatAddWeaponProficiencyPoint) == 0x000028, "Wrong size on FM1Request_CheatAddWeaponProficiencyPoint");
static_assert(offsetof(FM1Request_CheatAddWeaponProficiencyPoint, AccountUid) == 0x000000, "Member 'FM1Request_CheatAddWeaponProficiencyPoint::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatAddWeaponProficiencyPoint, Exp) == 0x000008, "Member 'FM1Request_CheatAddWeaponProficiencyPoint::Exp' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatAddWeaponProficiencyPoint, WeaponId) == 0x000010, "Member 'FM1Request_CheatAddWeaponProficiencyPoint::WeaponId' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatAddWeaponProficiencyPoint, MonsterRequestInfoBox) == 0x000018, "Member 'FM1Request_CheatAddWeaponProficiencyPoint::MonsterRequestInfoBox' has a wrong offset!");

// ScriptStruct M1.M1Notice_NoticePartyMemberChange
// 0x0028 (0x0028 - 0x0000)
struct FM1Notice_NoticePartyMemberChange final
{
public:
	struct FM1PartyMemberChangeNoti               Notification;                                      // 0x0000(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_NoticePartyMemberChange) == 0x000008, "Wrong alignment on FM1Notice_NoticePartyMemberChange");
static_assert(sizeof(FM1Notice_NoticePartyMemberChange) == 0x000028, "Wrong size on FM1Notice_NoticePartyMemberChange");
static_assert(offsetof(FM1Notice_NoticePartyMemberChange, Notification) == 0x000000, "Member 'FM1Notice_NoticePartyMemberChange::Notification' has a wrong offset!");

// ScriptStruct M1.M1Notice_NoticePartyRequestChange
// 0x0018 (0x0018 - 0x0000)
struct FM1Notice_NoticePartyRequestChange final
{
public:
	struct FM1PartyRequestChangeNoti              Notification;                                      // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_NoticePartyRequestChange) == 0x000008, "Wrong alignment on FM1Notice_NoticePartyRequestChange");
static_assert(sizeof(FM1Notice_NoticePartyRequestChange) == 0x000018, "Wrong size on FM1Notice_NoticePartyRequestChange");
static_assert(offsetof(FM1Notice_NoticePartyRequestChange, Notification) == 0x000000, "Member 'FM1Notice_NoticePartyRequestChange::Notification' has a wrong offset!");

// ScriptStruct M1.M1TraitTagContainer
// 0x0010 (0x0010 - 0x0000)
struct FM1TraitTagContainer final
{
public:
	TArray<struct FGameplayTag>                   Tags;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TraitTagContainer) == 0x000008, "Wrong alignment on FM1TraitTagContainer");
static_assert(sizeof(FM1TraitTagContainer) == 0x000010, "Wrong size on FM1TraitTagContainer");
static_assert(offsetof(FM1TraitTagContainer, Tags) == 0x000000, "Member 'FM1TraitTagContainer::Tags' has a wrong offset!");

// ScriptStruct M1.M1MissionTaskData
// 0x0018 (0x0018 - 0x0000)
struct FM1MissionTaskData final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UM1MissionTask*                         Task;                                              // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AM1MissionTaskActor>        TaskActorClass;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1MissionTaskData) == 0x000008, "Wrong alignment on FM1MissionTaskData");
static_assert(sizeof(FM1MissionTaskData) == 0x000018, "Wrong size on FM1MissionTaskData");
static_assert(offsetof(FM1MissionTaskData, Name) == 0x000000, "Member 'FM1MissionTaskData::Name' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskData, Task) == 0x000008, "Member 'FM1MissionTaskData::Task' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskData, TaskActorClass) == 0x000010, "Member 'FM1MissionTaskData::TaskActorClass' has a wrong offset!");

// ScriptStruct M1.M1NavConvex
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FM1NavConvex final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1NavConvex) == 0x000008, "Wrong alignment on FM1NavConvex");
static_assert(sizeof(FM1NavConvex) == 0x000010, "Wrong size on FM1NavConvex");

// ScriptStruct M1.M1NavInvasionArea
// 0x00B0 (0x00B0 - 0x0000)
struct FM1NavInvasionArea final
{
public:
	bool                                          bMoveToDirtyArea;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FVector, struct FM1NavConvex>     InvasionAreaConvexData;                            // 0x0008(0x0050)(NativeAccessSpecifierPublic)
	TMap<struct FVector, struct FM1NavConvex>     DirtyAreaConvexData;                               // 0x0058(0x0050)(NativeAccessSpecifierPublic)
	bool                                          bSetViewTarget;                                    // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NavTileIndex;                                      // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NavInvasionArea) == 0x000008, "Wrong alignment on FM1NavInvasionArea");
static_assert(sizeof(FM1NavInvasionArea) == 0x0000B0, "Wrong size on FM1NavInvasionArea");
static_assert(offsetof(FM1NavInvasionArea, bMoveToDirtyArea) == 0x000000, "Member 'FM1NavInvasionArea::bMoveToDirtyArea' has a wrong offset!");
static_assert(offsetof(FM1NavInvasionArea, InvasionAreaConvexData) == 0x000008, "Member 'FM1NavInvasionArea::InvasionAreaConvexData' has a wrong offset!");
static_assert(offsetof(FM1NavInvasionArea, DirtyAreaConvexData) == 0x000058, "Member 'FM1NavInvasionArea::DirtyAreaConvexData' has a wrong offset!");
static_assert(offsetof(FM1NavInvasionArea, bSetViewTarget) == 0x0000A8, "Member 'FM1NavInvasionArea::bSetViewTarget' has a wrong offset!");
static_assert(offsetof(FM1NavInvasionArea, NavTileIndex) == 0x0000AC, "Member 'FM1NavInvasionArea::NavTileIndex' has a wrong offset!");

// ScriptStruct M1.M1ItemServiceResultCommon
// 0x0018 (0x0018 - 0x0000)
struct FM1ItemServiceResultCommon final
{
public:
	EM1ItemType                                   ItemType;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ItemUid;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemReason                                 ItemReason;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ItemServiceResultCommon) == 0x000008, "Wrong alignment on FM1ItemServiceResultCommon");
static_assert(sizeof(FM1ItemServiceResultCommon) == 0x000018, "Wrong size on FM1ItemServiceResultCommon");
static_assert(offsetof(FM1ItemServiceResultCommon, ItemType) == 0x000000, "Member 'FM1ItemServiceResultCommon::ItemType' has a wrong offset!");
static_assert(offsetof(FM1ItemServiceResultCommon, ItemUid) == 0x000008, "Member 'FM1ItemServiceResultCommon::ItemUid' has a wrong offset!");
static_assert(offsetof(FM1ItemServiceResultCommon, ItemReason) == 0x000010, "Member 'FM1ItemServiceResultCommon::ItemReason' has a wrong offset!");

// ScriptStruct M1.M1MissionDeathEvasionBarrierSymbol
// 0x0010 (0x0010 - 0x0000)
struct FM1MissionDeathEvasionBarrierSymbol final
{
public:
	EM1InvasionArcheSymbolType                    SymbolType;                                        // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SymbolName;                                        // 0x0004(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionDeathEvasionBarrierSymbol) == 0x000004, "Wrong alignment on FM1MissionDeathEvasionBarrierSymbol");
static_assert(sizeof(FM1MissionDeathEvasionBarrierSymbol) == 0x000010, "Wrong size on FM1MissionDeathEvasionBarrierSymbol");
static_assert(offsetof(FM1MissionDeathEvasionBarrierSymbol, SymbolType) == 0x000000, "Member 'FM1MissionDeathEvasionBarrierSymbol::SymbolType' has a wrong offset!");
static_assert(offsetof(FM1MissionDeathEvasionBarrierSymbol, SymbolName) == 0x000004, "Member 'FM1MissionDeathEvasionBarrierSymbol::SymbolName' has a wrong offset!");
static_assert(offsetof(FM1MissionDeathEvasionBarrierSymbol, Index) == 0x00000C, "Member 'FM1MissionDeathEvasionBarrierSymbol::Index' has a wrong offset!");

// ScriptStruct M1.M1MissionDeathEvasionBarrierSymbols
// 0x0018 (0x0018 - 0x0000)
struct FM1MissionDeathEvasionBarrierSymbols final
{
public:
	TArray<struct FM1MissionDeathEvasionBarrierSymbol> Symbols;                                           // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          bCorrect;                                          // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MissionDeathEvasionBarrierSymbols) == 0x000008, "Wrong alignment on FM1MissionDeathEvasionBarrierSymbols");
static_assert(sizeof(FM1MissionDeathEvasionBarrierSymbols) == 0x000018, "Wrong size on FM1MissionDeathEvasionBarrierSymbols");
static_assert(offsetof(FM1MissionDeathEvasionBarrierSymbols, Symbols) == 0x000000, "Member 'FM1MissionDeathEvasionBarrierSymbols::Symbols' has a wrong offset!");
static_assert(offsetof(FM1MissionDeathEvasionBarrierSymbols, bCorrect) == 0x000010, "Member 'FM1MissionDeathEvasionBarrierSymbols::bCorrect' has a wrong offset!");

// ScriptStruct M1.M1AbilityActorCollisionSelector
// 0x0008 (0x0008 - 0x0000)
struct FM1AbilityActorCollisionSelector final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityActorCollisionSelector) == 0x000004, "Wrong alignment on FM1AbilityActorCollisionSelector");
static_assert(sizeof(FM1AbilityActorCollisionSelector) == 0x000008, "Wrong size on FM1AbilityActorCollisionSelector");
static_assert(offsetof(FM1AbilityActorCollisionSelector, Name) == 0x000000, "Member 'FM1AbilityActorCollisionSelector::Name' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatMinusPaidCurrency
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatMinusPaidCurrency final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatMinusPaidCurrency) == 0x000001, "Wrong alignment on FM1Response_CheatMinusPaidCurrency");
static_assert(sizeof(FM1Response_CheatMinusPaidCurrency) == 0x000001, "Wrong size on FM1Response_CheatMinusPaidCurrency");
static_assert(offsetof(FM1Response_CheatMinusPaidCurrency, Notification) == 0x000000, "Member 'FM1Response_CheatMinusPaidCurrency::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_DecomposeRuneWithByte
// 0x0020 (0x0020 - 0x0000)
struct FM1Request_DecomposeRuneWithByte final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InventoryRevision;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 RuneUids;                                          // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_DecomposeRuneWithByte) == 0x000008, "Wrong alignment on FM1Request_DecomposeRuneWithByte");
static_assert(sizeof(FM1Request_DecomposeRuneWithByte) == 0x000020, "Wrong size on FM1Request_DecomposeRuneWithByte");
static_assert(offsetof(FM1Request_DecomposeRuneWithByte, AccountUid) == 0x000000, "Member 'FM1Request_DecomposeRuneWithByte::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_DecomposeRuneWithByte, InventoryRevision) == 0x000008, "Member 'FM1Request_DecomposeRuneWithByte::InventoryRevision' has a wrong offset!");
static_assert(offsetof(FM1Request_DecomposeRuneWithByte, Count) == 0x00000C, "Member 'FM1Request_DecomposeRuneWithByte::Count' has a wrong offset!");
static_assert(offsetof(FM1Request_DecomposeRuneWithByte, RuneUids) == 0x000010, "Member 'FM1Request_DecomposeRuneWithByte::RuneUids' has a wrong offset!");

// ScriptStruct M1.M1AbilityEventDataHandle
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FM1AbilityEventDataHandle final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AbilityEventDataHandle) == 0x000008, "Wrong alignment on FM1AbilityEventDataHandle");
static_assert(sizeof(FM1AbilityEventDataHandle) == 0x000010, "Wrong size on FM1AbilityEventDataHandle");

// ScriptStruct M1.M1AbilityEvent
// 0x0040 (0x0040 - 0x0000)
struct FM1AbilityEvent final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                OptionalObject;                                    // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntValue;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1AbilityEventDataHandle              EventData;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UObject*                                ContextObject;                                     // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityEvent) == 0x000008, "Wrong alignment on FM1AbilityEvent");
static_assert(sizeof(FM1AbilityEvent) == 0x000040, "Wrong size on FM1AbilityEvent");
static_assert(offsetof(FM1AbilityEvent, Tag) == 0x000000, "Member 'FM1AbilityEvent::Tag' has a wrong offset!");
static_assert(offsetof(FM1AbilityEvent, Instigator) == 0x000008, "Member 'FM1AbilityEvent::Instigator' has a wrong offset!");
static_assert(offsetof(FM1AbilityEvent, Target) == 0x000010, "Member 'FM1AbilityEvent::Target' has a wrong offset!");
static_assert(offsetof(FM1AbilityEvent, OptionalObject) == 0x000018, "Member 'FM1AbilityEvent::OptionalObject' has a wrong offset!");
static_assert(offsetof(FM1AbilityEvent, FloatValue) == 0x000020, "Member 'FM1AbilityEvent::FloatValue' has a wrong offset!");
static_assert(offsetof(FM1AbilityEvent, IntValue) == 0x000024, "Member 'FM1AbilityEvent::IntValue' has a wrong offset!");
static_assert(offsetof(FM1AbilityEvent, EventData) == 0x000028, "Member 'FM1AbilityEvent::EventData' has a wrong offset!");
static_assert(offsetof(FM1AbilityEvent, ContextObject) == 0x000038, "Member 'FM1AbilityEvent::ContextObject' has a wrong offset!");

// ScriptStruct M1.M1Notice_MasteryCanLevelUpNoti
// 0x0010 (0x0010 - 0x0000)
struct FM1Notice_MasteryCanLevelUpNoti final
{
public:
	struct FM1MasteryCanLevelUpNoti               Notification;                                      // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_MasteryCanLevelUpNoti) == 0x000008, "Wrong alignment on FM1Notice_MasteryCanLevelUpNoti");
static_assert(sizeof(FM1Notice_MasteryCanLevelUpNoti) == 0x000010, "Wrong size on FM1Notice_MasteryCanLevelUpNoti");
static_assert(offsetof(FM1Notice_MasteryCanLevelUpNoti, Notification) == 0x000000, "Member 'FM1Notice_MasteryCanLevelUpNoti::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_GetInvasionEntranceInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1Response_GetInvasionEntranceInfo final
{
public:
	struct FM1InvasionEntranceInfoList            Notification;                                      // 0x0000(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_GetInvasionEntranceInfo) == 0x000008, "Wrong alignment on FM1Response_GetInvasionEntranceInfo");
static_assert(sizeof(FM1Response_GetInvasionEntranceInfo) == 0x000020, "Wrong size on FM1Response_GetInvasionEntranceInfo");
static_assert(offsetof(FM1Response_GetInvasionEntranceInfo, Notification) == 0x000000, "Member 'FM1Response_GetInvasionEntranceInfo::Notification' has a wrong offset!");

// ScriptStruct M1.M1MissionMonsterActivityRange
// 0x000C (0x000C - 0x0000)
struct FM1MissionMonsterActivityRange final
{
public:
	bool                                          bUseActivityRange;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinRadius;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRadius;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionMonsterActivityRange) == 0x000004, "Wrong alignment on FM1MissionMonsterActivityRange");
static_assert(sizeof(FM1MissionMonsterActivityRange) == 0x00000C, "Wrong size on FM1MissionMonsterActivityRange");
static_assert(offsetof(FM1MissionMonsterActivityRange, bUseActivityRange) == 0x000000, "Member 'FM1MissionMonsterActivityRange::bUseActivityRange' has a wrong offset!");
static_assert(offsetof(FM1MissionMonsterActivityRange, MinRadius) == 0x000004, "Member 'FM1MissionMonsterActivityRange::MinRadius' has a wrong offset!");
static_assert(offsetof(FM1MissionMonsterActivityRange, MaxRadius) == 0x000008, "Member 'FM1MissionMonsterActivityRange::MaxRadius' has a wrong offset!");

// ScriptStruct M1.M1Response_GetCodexDataList
// 0x0018 (0x0018 - 0x0000)
struct FM1Response_GetCodexDataList final
{
public:
	struct FM1CodexItemInfoList                   Notification;                                      // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_GetCodexDataList) == 0x000008, "Wrong alignment on FM1Response_GetCodexDataList");
static_assert(sizeof(FM1Response_GetCodexDataList) == 0x000018, "Wrong size on FM1Response_GetCodexDataList");
static_assert(offsetof(FM1Response_GetCodexDataList, Notification) == 0x000000, "Member 'FM1Response_GetCodexDataList::Notification' has a wrong offset!");

// ScriptStruct M1.M1DecomposeJunkInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1DecomposeJunkInfo final
{
public:
	TArray<struct FM1DecomposeJunkElement>        JunkItemList;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DecomposeJunkInfo) == 0x000008, "Wrong alignment on FM1DecomposeJunkInfo");
static_assert(sizeof(FM1DecomposeJunkInfo) == 0x000010, "Wrong size on FM1DecomposeJunkInfo");
static_assert(offsetof(FM1DecomposeJunkInfo, JunkItemList) == 0x000000, "Member 'FM1DecomposeJunkInfo::JunkItemList' has a wrong offset!");

// ScriptStruct M1.M1Response_LastFieldAndBattleZoneSet
// 0x0008 (0x0008 - 0x0000)
struct FM1Response_LastFieldAndBattleZoneSet final
{
public:
	EM1LastBattleZoneSetReason                    Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          BattleZoneId;                                      // 0x0004(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_LastFieldAndBattleZoneSet) == 0x000004, "Wrong alignment on FM1Response_LastFieldAndBattleZoneSet");
static_assert(sizeof(FM1Response_LastFieldAndBattleZoneSet) == 0x000008, "Wrong size on FM1Response_LastFieldAndBattleZoneSet");
static_assert(offsetof(FM1Response_LastFieldAndBattleZoneSet, Notification) == 0x000000, "Member 'FM1Response_LastFieldAndBattleZoneSet::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_LastFieldAndBattleZoneSet, BattleZoneId) == 0x000004, "Member 'FM1Response_LastFieldAndBattleZoneSet::BattleZoneId' has a wrong offset!");

// ScriptStruct M1.M1AbilityId
// 0x0000 (0x0010 - 0x0010)
struct FM1AbilityId final : public FM1IntegerId
{
};
static_assert(alignof(FM1AbilityId) == 0x000008, "Wrong alignment on FM1AbilityId");
static_assert(sizeof(FM1AbilityId) == 0x000010, "Wrong size on FM1AbilityId");

// ScriptStruct M1.M1Response_CheatJumpMainQuest
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_CheatJumpMainQuest final
{
public:
	struct FM1MainQuestJumpResult                 Notification;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatJumpMainQuest) == 0x000008, "Wrong alignment on FM1Response_CheatJumpMainQuest");
static_assert(sizeof(FM1Response_CheatJumpMainQuest) == 0x000010, "Wrong size on FM1Response_CheatJumpMainQuest");
static_assert(offsetof(FM1Response_CheatJumpMainQuest, Notification) == 0x000000, "Member 'FM1Response_CheatJumpMainQuest::Notification' has a wrong offset!");

// ScriptStruct M1.M1GameTestPlayerSettings
// 0x0010 (0x0010 - 0x0000)
struct FM1GameTestPlayerSettings final
{
public:
	class FName                                   CharacterName;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterLevel;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponLevel;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GameTestPlayerSettings) == 0x000004, "Wrong alignment on FM1GameTestPlayerSettings");
static_assert(sizeof(FM1GameTestPlayerSettings) == 0x000010, "Wrong size on FM1GameTestPlayerSettings");
static_assert(offsetof(FM1GameTestPlayerSettings, CharacterName) == 0x000000, "Member 'FM1GameTestPlayerSettings::CharacterName' has a wrong offset!");
static_assert(offsetof(FM1GameTestPlayerSettings, CharacterLevel) == 0x000008, "Member 'FM1GameTestPlayerSettings::CharacterLevel' has a wrong offset!");
static_assert(offsetof(FM1GameTestPlayerSettings, WeaponLevel) == 0x00000C, "Member 'FM1GameTestPlayerSettings::WeaponLevel' has a wrong offset!");

// ScriptStruct M1.M1Response_InstanceDungeonSelectMODReroll
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_InstanceDungeonSelectMODReroll final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_InstanceDungeonSelectMODReroll) == 0x000001, "Wrong alignment on FM1Response_InstanceDungeonSelectMODReroll");
static_assert(sizeof(FM1Response_InstanceDungeonSelectMODReroll) == 0x000001, "Wrong size on FM1Response_InstanceDungeonSelectMODReroll");
static_assert(offsetof(FM1Response_InstanceDungeonSelectMODReroll, Notification) == 0x000000, "Member 'FM1Response_InstanceDungeonSelectMODReroll::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_GetBoostItemEffect
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_GetBoostItemEffect final
{
public:
	struct FM1BoostItemEffectBundle               Notification;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_GetBoostItemEffect) == 0x000008, "Wrong alignment on FM1Response_GetBoostItemEffect");
static_assert(sizeof(FM1Response_GetBoostItemEffect) == 0x000010, "Wrong size on FM1Response_GetBoostItemEffect");
static_assert(offsetof(FM1Response_GetBoostItemEffect, Notification) == 0x000000, "Member 'FM1Response_GetBoostItemEffect::Notification' has a wrong offset!");

// ScriptStruct M1.M1ObjectStackData
// 0x0010 (0x0010 - 0x0000)
struct FM1ObjectStackData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Object;                                            // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ObjectStackData) == 0x000008, "Wrong alignment on FM1ObjectStackData");
static_assert(sizeof(FM1ObjectStackData) == 0x000010, "Wrong size on FM1ObjectStackData");
static_assert(offsetof(FM1ObjectStackData, Object) == 0x000008, "Member 'FM1ObjectStackData::Object' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatGetServerTimeDiff
// 0x0008 (0x0008 - 0x0000)
struct FM1Response_CheatGetServerTimeDiff final
{
public:
	int64                                         Notification;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatGetServerTimeDiff) == 0x000008, "Wrong alignment on FM1Response_CheatGetServerTimeDiff");
static_assert(sizeof(FM1Response_CheatGetServerTimeDiff) == 0x000008, "Wrong size on FM1Response_CheatGetServerTimeDiff");
static_assert(offsetof(FM1Response_CheatGetServerTimeDiff, Notification) == 0x000000, "Member 'FM1Response_CheatGetServerTimeDiff::Notification' has a wrong offset!");

// ScriptStruct M1.M1GameSessionPlayMapInfo
// 0x0014 (0x0014 - 0x0000)
struct FM1GameSessionPlayMapInfo final
{
public:
	struct FM1TemplateId                          MapTemplateId;                                     // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1MapSubData                          MapSubData;                                        // 0x0004(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GameSessionPlayMapInfo) == 0x000004, "Wrong alignment on FM1GameSessionPlayMapInfo");
static_assert(sizeof(FM1GameSessionPlayMapInfo) == 0x000014, "Wrong size on FM1GameSessionPlayMapInfo");
static_assert(offsetof(FM1GameSessionPlayMapInfo, MapTemplateId) == 0x000000, "Member 'FM1GameSessionPlayMapInfo::MapTemplateId' has a wrong offset!");
static_assert(offsetof(FM1GameSessionPlayMapInfo, MapSubData) == 0x000004, "Member 'FM1GameSessionPlayMapInfo::MapSubData' has a wrong offset!");

// ScriptStruct M1.M1GameMapInfo
// 0x0030 (0x0030 - 0x0000)
struct FM1GameMapInfo final
{
public:
	struct FM1MapSubData                          MapSubData;                                        // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         LoginPlatformType;                                 // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0xF];                                       // 0x0011(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BattleZoneName;                                    // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GameMapInfo) == 0x000008, "Wrong alignment on FM1GameMapInfo");
static_assert(sizeof(FM1GameMapInfo) == 0x000030, "Wrong size on FM1GameMapInfo");
static_assert(offsetof(FM1GameMapInfo, MapSubData) == 0x000000, "Member 'FM1GameMapInfo::MapSubData' has a wrong offset!");
static_assert(offsetof(FM1GameMapInfo, LoginPlatformType) == 0x000010, "Member 'FM1GameMapInfo::LoginPlatformType' has a wrong offset!");
static_assert(offsetof(FM1GameMapInfo, BattleZoneName) == 0x000020, "Member 'FM1GameMapInfo::BattleZoneName' has a wrong offset!");

// ScriptStruct M1.M1DecreaseShieldAbilityInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1DecreaseShieldAbilityInfo final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivated;                                        // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UNiagaraComponent*>              SpawnedFXs;                                        // 0x0010(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DecreaseShieldAbilityInfo) == 0x000008, "Wrong alignment on FM1DecreaseShieldAbilityInfo");
static_assert(sizeof(FM1DecreaseShieldAbilityInfo) == 0x000020, "Wrong size on FM1DecreaseShieldAbilityInfo");
static_assert(offsetof(FM1DecreaseShieldAbilityInfo, TargetActor) == 0x000000, "Member 'FM1DecreaseShieldAbilityInfo::TargetActor' has a wrong offset!");
static_assert(offsetof(FM1DecreaseShieldAbilityInfo, bActivated) == 0x000008, "Member 'FM1DecreaseShieldAbilityInfo::bActivated' has a wrong offset!");
static_assert(offsetof(FM1DecreaseShieldAbilityInfo, SpawnedFXs) == 0x000010, "Member 'FM1DecreaseShieldAbilityInfo::SpawnedFXs' has a wrong offset!");

// ScriptStruct M1.M1Request_ExtractPaint
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_ExtractPaint final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ExtractTid;                                        // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_ExtractPaint) == 0x000008, "Wrong alignment on FM1Request_ExtractPaint");
static_assert(sizeof(FM1Request_ExtractPaint) == 0x000010, "Wrong size on FM1Request_ExtractPaint");
static_assert(offsetof(FM1Request_ExtractPaint, AccountUid) == 0x000000, "Member 'FM1Request_ExtractPaint::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_ExtractPaint, ExtractTid) == 0x000008, "Member 'FM1Request_ExtractPaint::ExtractTid' has a wrong offset!");
static_assert(offsetof(FM1Request_ExtractPaint, Amount) == 0x00000C, "Member 'FM1Request_ExtractPaint::Amount' has a wrong offset!");

// ScriptStruct M1.M1Notice_RequestWorldRestart
// 0x0001 (0x0001 - 0x0000)
struct FM1Notice_RequestWorldRestart final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_RequestWorldRestart) == 0x000001, "Wrong alignment on FM1Notice_RequestWorldRestart");
static_assert(sizeof(FM1Notice_RequestWorldRestart) == 0x000001, "Wrong size on FM1Notice_RequestWorldRestart");
static_assert(offsetof(FM1Notice_RequestWorldRestart, Notification) == 0x000000, "Member 'FM1Notice_RequestWorldRestart::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_IncreaseRuneCapacity
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_IncreaseRuneCapacity final
{
public:
	EM1RuneReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemTidBox                          OwnerTid;                                          // 0x0004(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         TargetIncreaseCount;                               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_IncreaseRuneCapacity) == 0x000004, "Wrong alignment on FM1Response_IncreaseRuneCapacity");
static_assert(sizeof(FM1Response_IncreaseRuneCapacity) == 0x000010, "Wrong size on FM1Response_IncreaseRuneCapacity");
static_assert(offsetof(FM1Response_IncreaseRuneCapacity, Notification) == 0x000000, "Member 'FM1Response_IncreaseRuneCapacity::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_IncreaseRuneCapacity, OwnerTid) == 0x000004, "Member 'FM1Response_IncreaseRuneCapacity::OwnerTid' has a wrong offset!");
static_assert(offsetof(FM1Response_IncreaseRuneCapacity, TargetIncreaseCount) == 0x00000C, "Member 'FM1Response_IncreaseRuneCapacity::TargetIncreaseCount' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatAddTickCount
// 0x0008 (0x0008 - 0x0000)
struct FM1Response_CheatAddTickCount final
{
public:
	int64                                         Notification;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatAddTickCount) == 0x000008, "Wrong alignment on FM1Response_CheatAddTickCount");
static_assert(sizeof(FM1Response_CheatAddTickCount) == 0x000008, "Wrong size on FM1Response_CheatAddTickCount");
static_assert(offsetof(FM1Response_CheatAddTickCount, Notification) == 0x000000, "Member 'FM1Response_CheatAddTickCount::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_CustomizingRingSlot
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CustomizingRingSlot final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1RequestCustomizingRingSlot          Request;                                           // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CustomizingRingSlot) == 0x000008, "Wrong alignment on FM1Request_CustomizingRingSlot");
static_assert(sizeof(FM1Request_CustomizingRingSlot) == 0x000010, "Wrong size on FM1Request_CustomizingRingSlot");
static_assert(offsetof(FM1Request_CustomizingRingSlot, AccountUid) == 0x000000, "Member 'FM1Request_CustomizingRingSlot::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CustomizingRingSlot, Request) == 0x000008, "Member 'FM1Request_CustomizingRingSlot::Request' has a wrong offset!");

// ScriptStruct M1.M1Response_OpenPackageItem
// 0x0020 (0x0020 - 0x0000)
struct FM1Response_OpenPackageItem final
{
public:
	struct FM1PackageItemOpenResult               Notification;                                      // 0x0000(0x0014)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          PackageOpenerTid;                                  // 0x0014(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          PackageItemTid;                                    // 0x0018(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          KeyItemTid;                                        // 0x001C(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_OpenPackageItem) == 0x000004, "Wrong alignment on FM1Response_OpenPackageItem");
static_assert(sizeof(FM1Response_OpenPackageItem) == 0x000020, "Wrong size on FM1Response_OpenPackageItem");
static_assert(offsetof(FM1Response_OpenPackageItem, Notification) == 0x000000, "Member 'FM1Response_OpenPackageItem::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_OpenPackageItem, PackageOpenerTid) == 0x000014, "Member 'FM1Response_OpenPackageItem::PackageOpenerTid' has a wrong offset!");
static_assert(offsetof(FM1Response_OpenPackageItem, PackageItemTid) == 0x000018, "Member 'FM1Response_OpenPackageItem::PackageItemTid' has a wrong offset!");
static_assert(offsetof(FM1Response_OpenPackageItem, KeyItemTid) == 0x00001C, "Member 'FM1Response_OpenPackageItem::KeyItemTid' has a wrong offset!");

// ScriptStruct M1.M1UnitOfChange
// 0x0008 (0x0008 - 0x0000)
struct FM1UnitOfChange final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1SystemKey                                  Key;                                               // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UnitOfChange) == 0x000004, "Wrong alignment on FM1UnitOfChange");
static_assert(sizeof(FM1UnitOfChange) == 0x000008, "Wrong size on FM1UnitOfChange");
static_assert(offsetof(FM1UnitOfChange, Value) == 0x000000, "Member 'FM1UnitOfChange::Value' has a wrong offset!");
static_assert(offsetof(FM1UnitOfChange, Key) == 0x000004, "Member 'FM1UnitOfChange::Key' has a wrong offset!");

// ScriptStruct M1.M1Request_UseConsumableItem
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_UseConsumableItem final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ConsumableUid;                                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_UseConsumableItem) == 0x000008, "Wrong alignment on FM1Request_UseConsumableItem");
static_assert(sizeof(FM1Request_UseConsumableItem) == 0x000010, "Wrong size on FM1Request_UseConsumableItem");
static_assert(offsetof(FM1Request_UseConsumableItem, AccountUid) == 0x000000, "Member 'FM1Request_UseConsumableItem::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_UseConsumableItem, ConsumableUid) == 0x000008, "Member 'FM1Request_UseConsumableItem::ConsumableUid' has a wrong offset!");

// ScriptStruct M1.M1Notice_MoveDedicatedServer
// 0x00C0 (0x00C0 - 0x0000)
struct FM1Notice_MoveDedicatedServer final
{
public:
	struct FM1MoveDedicatedServerNoti             Notification;                                      // 0x0000(0x00C0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_MoveDedicatedServer) == 0x000008, "Wrong alignment on FM1Notice_MoveDedicatedServer");
static_assert(sizeof(FM1Notice_MoveDedicatedServer) == 0x0000C0, "Wrong size on FM1Notice_MoveDedicatedServer");
static_assert(offsetof(FM1Notice_MoveDedicatedServer, Notification) == 0x000000, "Member 'FM1Notice_MoveDedicatedServer::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_SetItemTags
// 0x0020 (0x0020 - 0x0000)
struct FM1Request_SetItemTags final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemBoxesInfo                       Boxes;                                             // 0x0008(0x0010)(NativeAccessSpecifierPublic)
	EM1ItemTagStatus                              TagStatus;                                         // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsedByFilter;                                      // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_SetItemTags) == 0x000008, "Wrong alignment on FM1Request_SetItemTags");
static_assert(sizeof(FM1Request_SetItemTags) == 0x000020, "Wrong size on FM1Request_SetItemTags");
static_assert(offsetof(FM1Request_SetItemTags, AccountUid) == 0x000000, "Member 'FM1Request_SetItemTags::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_SetItemTags, Boxes) == 0x000008, "Member 'FM1Request_SetItemTags::Boxes' has a wrong offset!");
static_assert(offsetof(FM1Request_SetItemTags, TagStatus) == 0x000018, "Member 'FM1Request_SetItemTags::TagStatus' has a wrong offset!");
static_assert(offsetof(FM1Request_SetItemTags, UsedByFilter) == 0x000019, "Member 'FM1Request_SetItemTags::UsedByFilter' has a wrong offset!");

// ScriptStruct M1.M1DropItemInstantlyUsed
// 0x0008 (0x0008 - 0x0000)
struct FM1DropItemInstantlyUsed final
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DropItemInstantlyUsed) == 0x000004, "Wrong alignment on FM1DropItemInstantlyUsed");
static_assert(sizeof(FM1DropItemInstantlyUsed) == 0x000008, "Wrong size on FM1DropItemInstantlyUsed");
static_assert(offsetof(FM1DropItemInstantlyUsed, TemplateId) == 0x000000, "Member 'FM1DropItemInstantlyUsed::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1DropItemInstantlyUsed, Count) == 0x000004, "Member 'FM1DropItemInstantlyUsed::Count' has a wrong offset!");

// ScriptStruct M1.M1InstanceDungeonMatchingInfo
// 0x000C (0x000C - 0x0000)
struct FM1InstanceDungeonMatchingInfo final
{
public:
	struct FM1TemplateId                          InstanceDungeonTid;                                // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          RewardGroupTid;                                    // 0x0004(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ModifierPresetTid;                                 // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceDungeonMatchingInfo) == 0x000004, "Wrong alignment on FM1InstanceDungeonMatchingInfo");
static_assert(sizeof(FM1InstanceDungeonMatchingInfo) == 0x00000C, "Wrong size on FM1InstanceDungeonMatchingInfo");
static_assert(offsetof(FM1InstanceDungeonMatchingInfo, InstanceDungeonTid) == 0x000000, "Member 'FM1InstanceDungeonMatchingInfo::InstanceDungeonTid' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonMatchingInfo, RewardGroupTid) == 0x000004, "Member 'FM1InstanceDungeonMatchingInfo::RewardGroupTid' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonMatchingInfo, ModifierPresetTid) == 0x000008, "Member 'FM1InstanceDungeonMatchingInfo::ModifierPresetTid' has a wrong offset!");

// ScriptStruct M1.M1Notice_MasteryExpNoti
// 0x0018 (0x0018 - 0x0000)
struct FM1Notice_MasteryExpNoti final
{
public:
	struct FM1MasteryExpNoti                      Notification;                                      // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_MasteryExpNoti) == 0x000008, "Wrong alignment on FM1Notice_MasteryExpNoti");
static_assert(sizeof(FM1Notice_MasteryExpNoti) == 0x000018, "Wrong size on FM1Notice_MasteryExpNoti");
static_assert(offsetof(FM1Notice_MasteryExpNoti, Notification) == 0x000000, "Member 'FM1Notice_MasteryExpNoti::Notification' has a wrong offset!");

// ScriptStruct M1.M1ItemStatListForUI
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FM1ItemStatListForUI final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ItemStatListForUI) == 0x000008, "Wrong alignment on FM1ItemStatListForUI");
static_assert(sizeof(FM1ItemStatListForUI) == 0x000018, "Wrong size on FM1ItemStatListForUI");

// ScriptStruct M1.M1Request_RequireRecord
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_RequireRecord final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          RecordId;                                          // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_RequireRecord) == 0x000008, "Wrong alignment on FM1Request_RequireRecord");
static_assert(sizeof(FM1Request_RequireRecord) == 0x000010, "Wrong size on FM1Request_RequireRecord");
static_assert(offsetof(FM1Request_RequireRecord, AccountUid) == 0x000000, "Member 'FM1Request_RequireRecord::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_RequireRecord, RecordId) == 0x000008, "Member 'FM1Request_RequireRecord::RecordId' has a wrong offset!");

// ScriptStruct M1.M1RuneInfoWrapper
// 0x0020 (0x0020 - 0x0000)
struct FM1RuneInfoWrapper final
{
public:
	struct FM1RuneInfo                            RuneInfo;                                          // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNewItem;                                          // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RuneInfoWrapper) == 0x000008, "Wrong alignment on FM1RuneInfoWrapper");
static_assert(sizeof(FM1RuneInfoWrapper) == 0x000020, "Wrong size on FM1RuneInfoWrapper");
static_assert(offsetof(FM1RuneInfoWrapper, RuneInfo) == 0x000000, "Member 'FM1RuneInfoWrapper::RuneInfo' has a wrong offset!");
static_assert(offsetof(FM1RuneInfoWrapper, bNewItem) == 0x000018, "Member 'FM1RuneInfoWrapper::bNewItem' has a wrong offset!");

// ScriptStruct M1.M1Request_DropItem
// 0x0040 (0x0040 - 0x0000)
struct FM1Request_DropItem final : public FM1Request
{
public:
	struct FM1DropItemRequest                     Req;                                               // 0x0000(0x0040)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_DropItem) == 0x000008, "Wrong alignment on FM1Request_DropItem");
static_assert(sizeof(FM1Request_DropItem) == 0x000040, "Wrong size on FM1Request_DropItem");
static_assert(offsetof(FM1Request_DropItem, Req) == 0x000000, "Member 'FM1Request_DropItem::Req' has a wrong offset!");

// ScriptStruct M1.M1Response_RequestShopBuyData
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_RequestShopBuyData final
{
public:
	struct FM1ShopBuyBundleData                   Notification;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_RequestShopBuyData) == 0x000008, "Wrong alignment on FM1Response_RequestShopBuyData");
static_assert(sizeof(FM1Response_RequestShopBuyData) == 0x000010, "Wrong size on FM1Response_RequestShopBuyData");
static_assert(offsetof(FM1Response_RequestShopBuyData, Notification) == 0x000000, "Member 'FM1Response_RequestShopBuyData::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_ChangeRandomOption
// 0x0018 (0x0018 - 0x0000)
struct FM1Response_ChangeRandomOption final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ItemUidBox                          EquipmentUid;                                      // 0x0008(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_ChangeRandomOption) == 0x000008, "Wrong alignment on FM1Response_ChangeRandomOption");
static_assert(sizeof(FM1Response_ChangeRandomOption) == 0x000018, "Wrong size on FM1Response_ChangeRandomOption");
static_assert(offsetof(FM1Response_ChangeRandomOption, Notification) == 0x000000, "Member 'FM1Response_ChangeRandomOption::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_ChangeRandomOption, EquipmentUid) == 0x000008, "Member 'FM1Response_ChangeRandomOption::EquipmentUid' has a wrong offset!");

// ScriptStruct M1.M1SocialPlayerDataMap
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FM1SocialPlayerDataMap final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SocialPlayerDataMap) == 0x000008, "Wrong alignment on FM1SocialPlayerDataMap");
static_assert(sizeof(FM1SocialPlayerDataMap) == 0x000050, "Wrong size on FM1SocialPlayerDataMap");

// ScriptStruct M1.M1Request_CheatClearAllMission
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_CheatClearAllMission final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatClearAllMission) == 0x000008, "Wrong alignment on FM1Request_CheatClearAllMission");
static_assert(sizeof(FM1Request_CheatClearAllMission) == 0x000008, "Wrong size on FM1Request_CheatClearAllMission");
static_assert(offsetof(FM1Request_CheatClearAllMission, AccountUid) == 0x000000, "Member 'FM1Request_CheatClearAllMission::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Response_DecomposeItem
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_DecomposeItem final
{
public:
	struct FM1ItemDecomposeResult                 Notification;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_DecomposeItem) == 0x000008, "Wrong alignment on FM1Response_DecomposeItem");
static_assert(sizeof(FM1Response_DecomposeItem) == 0x000010, "Wrong size on FM1Response_DecomposeItem");
static_assert(offsetof(FM1Response_DecomposeItem, Notification) == 0x000000, "Member 'FM1Response_DecomposeItem::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_PartyMoveReserveDedicatedServer_2
// 0x0030 (0x0030 - 0x0000)
struct FM1Request_PartyMoveReserveDedicatedServer_2 final : public FM1Request
{
public:
	struct FM1PartyJoinDedicatedServerParam       Req;                                               // 0x0000(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_PartyMoveReserveDedicatedServer_2) == 0x000008, "Wrong alignment on FM1Request_PartyMoveReserveDedicatedServer_2");
static_assert(sizeof(FM1Request_PartyMoveReserveDedicatedServer_2) == 0x000030, "Wrong size on FM1Request_PartyMoveReserveDedicatedServer_2");
static_assert(offsetof(FM1Request_PartyMoveReserveDedicatedServer_2, Req) == 0x000000, "Member 'FM1Request_PartyMoveReserveDedicatedServer_2::Req' has a wrong offset!");

// ScriptStruct M1.M1Response_InitSpeicificShop
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_InitSpeicificShop final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_InitSpeicificShop) == 0x000001, "Wrong alignment on FM1Response_InitSpeicificShop");
static_assert(sizeof(FM1Response_InitSpeicificShop) == 0x000001, "Wrong size on FM1Response_InitSpeicificShop");
static_assert(offsetof(FM1Response_InitSpeicificShop, Notification) == 0x000000, "Member 'FM1Response_InitSpeicificShop::Notification' has a wrong offset!");

// ScriptStruct M1.M1Notice_NoticeRecentPlayerResponse
// 0x0030 (0x0030 - 0x0000)
struct FM1Notice_NoticeRecentPlayerResponse final
{
public:
	struct FM1RecentPlayerNoti                    Notification;                                      // 0x0000(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_NoticeRecentPlayerResponse) == 0x000008, "Wrong alignment on FM1Notice_NoticeRecentPlayerResponse");
static_assert(sizeof(FM1Notice_NoticeRecentPlayerResponse) == 0x000030, "Wrong size on FM1Notice_NoticeRecentPlayerResponse");
static_assert(offsetof(FM1Notice_NoticeRecentPlayerResponse, Notification) == 0x000000, "Member 'FM1Notice_NoticeRecentPlayerResponse::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_DeleteJunkItem
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_DeleteJunkItem final
{
public:
	struct FM1ItemBoxesInfo                       Notification;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_DeleteJunkItem) == 0x000008, "Wrong alignment on FM1Response_DeleteJunkItem");
static_assert(sizeof(FM1Response_DeleteJunkItem) == 0x000010, "Wrong size on FM1Response_DeleteJunkItem");
static_assert(offsetof(FM1Response_DeleteJunkItem, Notification) == 0x000000, "Member 'FM1Response_DeleteJunkItem::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_RequestRuneEquippedInfoBundleByOwnerTid
// 0x0018 (0x0018 - 0x0000)
struct FM1Response_RequestRuneEquippedInfoBundleByOwnerTid final
{
public:
	struct FM1RuneEquippedInfoBundle              Notification;                                      // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_RequestRuneEquippedInfoBundleByOwnerTid) == 0x000008, "Wrong alignment on FM1Response_RequestRuneEquippedInfoBundleByOwnerTid");
static_assert(sizeof(FM1Response_RequestRuneEquippedInfoBundleByOwnerTid) == 0x000018, "Wrong size on FM1Response_RequestRuneEquippedInfoBundleByOwnerTid");
static_assert(offsetof(FM1Response_RequestRuneEquippedInfoBundleByOwnerTid, Notification) == 0x000000, "Member 'FM1Response_RequestRuneEquippedInfoBundleByOwnerTid::Notification' has a wrong offset!");

// ScriptStruct M1.M1NxLog_User_Revive
// 0x00D0 (0x00D0 - 0x0000)
struct FM1NxLog_User_Revive final
{
public:
	class FString                                 Actionid;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 battletargettype;                                  // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldUid;                                          // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Revivetype;                                        // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetId;                                          // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Targetlevel;                                       // 0x0060(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 TargetType;                                        // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Userlevel;                                         // 0x0080(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Usernickname;                                      // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Deadstatustype;                                    // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tfdplayeritemid;                                   // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Tfdplayeritemlevel;                                // 0x00C0(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_User_Revive) == 0x000008, "Wrong alignment on FM1NxLog_User_Revive");
static_assert(sizeof(FM1NxLog_User_Revive) == 0x0000D0, "Wrong size on FM1NxLog_User_Revive");
static_assert(offsetof(FM1NxLog_User_Revive, Actionid) == 0x000000, "Member 'FM1NxLog_User_Revive::Actionid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Revive, battletargettype) == 0x000010, "Member 'FM1NxLog_User_Revive::battletargettype' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Revive, FieldId) == 0x000020, "Member 'FM1NxLog_User_Revive::FieldId' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Revive, FieldUid) == 0x000030, "Member 'FM1NxLog_User_Revive::FieldUid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Revive, Revivetype) == 0x000040, "Member 'FM1NxLog_User_Revive::Revivetype' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Revive, TargetId) == 0x000050, "Member 'FM1NxLog_User_Revive::TargetId' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Revive, Targetlevel) == 0x000060, "Member 'FM1NxLog_User_Revive::Targetlevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Revive, TargetType) == 0x000070, "Member 'FM1NxLog_User_Revive::TargetType' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Revive, Userlevel) == 0x000080, "Member 'FM1NxLog_User_Revive::Userlevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Revive, Usernickname) == 0x000090, "Member 'FM1NxLog_User_Revive::Usernickname' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Revive, Deadstatustype) == 0x0000A0, "Member 'FM1NxLog_User_Revive::Deadstatustype' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Revive, Tfdplayeritemid) == 0x0000B0, "Member 'FM1NxLog_User_Revive::Tfdplayeritemid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Revive, Tfdplayeritemlevel) == 0x0000C0, "Member 'FM1NxLog_User_Revive::Tfdplayeritemlevel' has a wrong offset!");

// ScriptStruct M1.M1Response_RequestMatching
// 0x0020 (0x0020 - 0x0000)
struct FM1Response_RequestMatching final
{
public:
	struct FM1RequestMatchingResult               Notification;                                      // 0x0000(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         SubMapDataId;                                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MatchType;                                         // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Response_RequestMatching) == 0x000008, "Wrong alignment on FM1Response_RequestMatching");
static_assert(sizeof(FM1Response_RequestMatching) == 0x000020, "Wrong size on FM1Response_RequestMatching");
static_assert(offsetof(FM1Response_RequestMatching, Notification) == 0x000000, "Member 'FM1Response_RequestMatching::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_RequestMatching, SubMapDataId) == 0x000010, "Member 'FM1Response_RequestMatching::SubMapDataId' has a wrong offset!");
static_assert(offsetof(FM1Response_RequestMatching, MatchType) == 0x000018, "Member 'FM1Response_RequestMatching::MatchType' has a wrong offset!");

// ScriptStruct M1.M1Response_FavoritesCharacter
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_FavoritesCharacter final
{
public:
	EM1CharacterFavoriteReason                    Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_FavoritesCharacter) == 0x000004, "Wrong alignment on FM1Response_FavoritesCharacter");
static_assert(sizeof(FM1Response_FavoritesCharacter) == 0x000004, "Wrong size on FM1Response_FavoritesCharacter");
static_assert(offsetof(FM1Response_FavoritesCharacter, Notification) == 0x000000, "Member 'FM1Response_FavoritesCharacter::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_DropItem
// 0x0020 (0x0020 - 0x0000)
struct FM1Response_DropItem final
{
public:
	struct FM1DropItemInfoNoti                    Notification;                                      // 0x0000(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_DropItem) == 0x000008, "Wrong alignment on FM1Response_DropItem");
static_assert(sizeof(FM1Response_DropItem) == 0x000020, "Wrong size on FM1Response_DropItem");
static_assert(offsetof(FM1Response_DropItem, Notification) == 0x000000, "Member 'FM1Response_DropItem::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_GetInitializationData
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_GetInitializationData final
{
public:
	struct FM1InitializationBundle                Notification;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_GetInitializationData) == 0x000008, "Wrong alignment on FM1Response_GetInitializationData");
static_assert(sizeof(FM1Response_GetInitializationData) == 0x000010, "Wrong size on FM1Response_GetInitializationData");
static_assert(offsetof(FM1Response_GetInitializationData, Notification) == 0x000000, "Member 'FM1Response_GetInitializationData::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_FieldObjectDropItem
// 0x0020 (0x0020 - 0x0000)
struct FM1Response_FieldObjectDropItem final
{
public:
	struct FM1DropItemInfoNoti                    Notification;                                      // 0x0000(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_FieldObjectDropItem) == 0x000008, "Wrong alignment on FM1Response_FieldObjectDropItem");
static_assert(sizeof(FM1Response_FieldObjectDropItem) == 0x000020, "Wrong size on FM1Response_FieldObjectDropItem");
static_assert(offsetof(FM1Response_FieldObjectDropItem, Notification) == 0x000000, "Member 'FM1Response_FieldObjectDropItem::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_ItemUpgrade
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_ItemUpgrade final
{
public:
	struct FM1ItemUidBox                          Notification;                                      // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_ItemUpgrade) == 0x000008, "Wrong alignment on FM1Response_ItemUpgrade");
static_assert(sizeof(FM1Response_ItemUpgrade) == 0x000010, "Wrong size on FM1Response_ItemUpgrade");
static_assert(offsetof(FM1Response_ItemUpgrade, Notification) == 0x000000, "Member 'FM1Response_ItemUpgrade::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CheckEnchantRune
// 0x0018 (0x0018 - 0x0000)
struct FM1Response_CheckEnchantRune final
{
public:
	struct FM1CheckEnchantRuneRes                 Notification;                                      // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheckEnchantRune) == 0x000008, "Wrong alignment on FM1Response_CheckEnchantRune");
static_assert(sizeof(FM1Response_CheckEnchantRune) == 0x000018, "Wrong size on FM1Response_CheckEnchantRune");
static_assert(offsetof(FM1Response_CheckEnchantRune, Notification) == 0x000000, "Member 'FM1Response_CheckEnchantRune::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_MasteryLevelUpRequest
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_MasteryLevelUpRequest final
{
public:
	struct FM1MasteryInfo                         Notification;                                      // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_MasteryLevelUpRequest) == 0x000008, "Wrong alignment on FM1Response_MasteryLevelUpRequest");
static_assert(sizeof(FM1Response_MasteryLevelUpRequest) == 0x000010, "Wrong size on FM1Response_MasteryLevelUpRequest");
static_assert(offsetof(FM1Response_MasteryLevelUpRequest, Notification) == 0x000000, "Member 'FM1Response_MasteryLevelUpRequest::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_UncustomizingWeapon
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_UncustomizingWeapon final
{
public:
	EM1CustomizeReason                            Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_UncustomizingWeapon) == 0x000004, "Wrong alignment on FM1Response_UncustomizingWeapon");
static_assert(sizeof(FM1Response_UncustomizingWeapon) == 0x000004, "Wrong size on FM1Response_UncustomizingWeapon");
static_assert(offsetof(FM1Response_UncustomizingWeapon, Notification) == 0x000000, "Member 'FM1Response_UncustomizingWeapon::Notification' has a wrong offset!");

// ScriptStruct M1.M1CharacterInfoWrapper
// 0x0030 (0x0030 - 0x0000)
struct FM1CharacterInfoWrapper final
{
public:
	struct FM1CharacterInfo                       CharacterInfo;                                     // 0x0000(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNewItem;                                          // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CharacterInfoWrapper) == 0x000008, "Wrong alignment on FM1CharacterInfoWrapper");
static_assert(sizeof(FM1CharacterInfoWrapper) == 0x000030, "Wrong size on FM1CharacterInfoWrapper");
static_assert(offsetof(FM1CharacterInfoWrapper, CharacterInfo) == 0x000000, "Member 'FM1CharacterInfoWrapper::CharacterInfo' has a wrong offset!");
static_assert(offsetof(FM1CharacterInfoWrapper, bNewItem) == 0x000028, "Member 'FM1CharacterInfoWrapper::bNewItem' has a wrong offset!");

// ScriptStruct M1.M1Response_UncustomizingEtc
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_UncustomizingEtc final
{
public:
	EM1CustomizeReason                            Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_UncustomizingEtc) == 0x000004, "Wrong alignment on FM1Response_UncustomizingEtc");
static_assert(sizeof(FM1Response_UncustomizingEtc) == 0x000004, "Wrong size on FM1Response_UncustomizingEtc");
static_assert(offsetof(FM1Response_UncustomizingEtc, Notification) == 0x000000, "Member 'FM1Response_UncustomizingEtc::Notification' has a wrong offset!");

// ScriptStruct M1.M1CustomizingInfoWrapper
// 0x0014 (0x0014 - 0x0000)
struct FM1CustomizingInfoWrapper final
{
public:
	struct FM1CustomizingItemInfo                 CustomizingItemInfo;                               // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNewItem;                                          // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CustomizingInfoWrapper) == 0x000004, "Wrong alignment on FM1CustomizingInfoWrapper");
static_assert(sizeof(FM1CustomizingInfoWrapper) == 0x000014, "Wrong size on FM1CustomizingInfoWrapper");
static_assert(offsetof(FM1CustomizingInfoWrapper, CustomizingItemInfo) == 0x000000, "Member 'FM1CustomizingInfoWrapper::CustomizingItemInfo' has a wrong offset!");
static_assert(offsetof(FM1CustomizingInfoWrapper, bNewItem) == 0x000010, "Member 'FM1CustomizingInfoWrapper::bNewItem' has a wrong offset!");

// ScriptStruct M1.M1Response_RequestSelectLoadoutSlot
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_RequestSelectLoadoutSlot final
{
public:
	EM1RuneReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemTidBox                          OwnerTid;                                          // 0x0004(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         LoadoutSlotIndex;                                  // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Response_RequestSelectLoadoutSlot) == 0x000004, "Wrong alignment on FM1Response_RequestSelectLoadoutSlot");
static_assert(sizeof(FM1Response_RequestSelectLoadoutSlot) == 0x000010, "Wrong size on FM1Response_RequestSelectLoadoutSlot");
static_assert(offsetof(FM1Response_RequestSelectLoadoutSlot, Notification) == 0x000000, "Member 'FM1Response_RequestSelectLoadoutSlot::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_RequestSelectLoadoutSlot, OwnerTid) == 0x000004, "Member 'FM1Response_RequestSelectLoadoutSlot::OwnerTid' has a wrong offset!");
static_assert(offsetof(FM1Response_RequestSelectLoadoutSlot, LoadoutSlotIndex) == 0x00000C, "Member 'FM1Response_RequestSelectLoadoutSlot::LoadoutSlotIndex' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatBattlePassChangeLevel
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CheatBattlePassChangeLevel final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          BattlePassTid;                                     // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatBattlePassChangeLevel) == 0x000008, "Wrong alignment on FM1Request_CheatBattlePassChangeLevel");
static_assert(sizeof(FM1Request_CheatBattlePassChangeLevel) == 0x000010, "Wrong size on FM1Request_CheatBattlePassChangeLevel");
static_assert(offsetof(FM1Request_CheatBattlePassChangeLevel, AccountUid) == 0x000000, "Member 'FM1Request_CheatBattlePassChangeLevel::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatBattlePassChangeLevel, BattlePassTid) == 0x000008, "Member 'FM1Request_CheatBattlePassChangeLevel::BattlePassTid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatBattlePassChangeLevel, Level) == 0x00000C, "Member 'FM1Request_CheatBattlePassChangeLevel::Level' has a wrong offset!");

// ScriptStruct M1.M1Response_SetCodexTracker
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_SetCodexTracker final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1CodexTrackingData                   Info;                                              // 0x0004(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_SetCodexTracker) == 0x000004, "Wrong alignment on FM1Response_SetCodexTracker");
static_assert(sizeof(FM1Response_SetCodexTracker) == 0x000010, "Wrong size on FM1Response_SetCodexTracker");
static_assert(offsetof(FM1Response_SetCodexTracker, Notification) == 0x000000, "Member 'FM1Response_SetCodexTracker::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_SetCodexTracker, Info) == 0x000004, "Member 'FM1Response_SetCodexTracker::Info' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatCharacterLevelMax
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatCharacterLevelMax final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatCharacterLevelMax) == 0x000001, "Wrong alignment on FM1Response_CheatCharacterLevelMax");
static_assert(sizeof(FM1Response_CheatCharacterLevelMax) == 0x000001, "Wrong size on FM1Response_CheatCharacterLevelMax");
static_assert(offsetof(FM1Response_CheatCharacterLevelMax, Notification) == 0x000000, "Member 'FM1Response_CheatCharacterLevelMax::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_UnSetCodexTracker
// 0x0002 (0x0002 - 0x0000)
struct FM1Response_UnSetCodexTracker final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          SlotIndex;                                         // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_UnSetCodexTracker) == 0x000001, "Wrong alignment on FM1Response_UnSetCodexTracker");
static_assert(sizeof(FM1Response_UnSetCodexTracker) == 0x000002, "Wrong size on FM1Response_UnSetCodexTracker");
static_assert(offsetof(FM1Response_UnSetCodexTracker, Notification) == 0x000000, "Member 'FM1Response_UnSetCodexTracker::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_UnSetCodexTracker, SlotIndex) == 0x000001, "Member 'FM1Response_UnSetCodexTracker::SlotIndex' has a wrong offset!");

// ScriptStruct M1.M1Response_VoidBattleComplete
// 0x000C (0x000C - 0x0000)
struct FM1Response_VoidBattleComplete final
{
public:
	struct FM1VoidBattleCompleteResult            Notification;                                      // 0x0000(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Success;                                           // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Response_VoidBattleComplete) == 0x000004, "Wrong alignment on FM1Response_VoidBattleComplete");
static_assert(sizeof(FM1Response_VoidBattleComplete) == 0x00000C, "Wrong size on FM1Response_VoidBattleComplete");
static_assert(offsetof(FM1Response_VoidBattleComplete, Notification) == 0x000000, "Member 'FM1Response_VoidBattleComplete::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_VoidBattleComplete, Success) == 0x000008, "Member 'FM1Response_VoidBattleComplete::Success' has a wrong offset!");

// ScriptStruct M1.M1AttachRuneToOwner
// 0x0030 (0x0030 - 0x0000)
struct FM1AttachRuneToOwner final
{
public:
	struct FM1ItemTidBox                          OwnerTidBox;                                       // 0x0000(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         LoadoutSlotIndex;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1RunePosition>                RunePositions;                                     // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1RuneSocketTypeSelection>     RuneSocketTypes;                                   // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AttachRuneToOwner) == 0x000008, "Wrong alignment on FM1AttachRuneToOwner");
static_assert(sizeof(FM1AttachRuneToOwner) == 0x000030, "Wrong size on FM1AttachRuneToOwner");
static_assert(offsetof(FM1AttachRuneToOwner, OwnerTidBox) == 0x000000, "Member 'FM1AttachRuneToOwner::OwnerTidBox' has a wrong offset!");
static_assert(offsetof(FM1AttachRuneToOwner, LoadoutSlotIndex) == 0x000008, "Member 'FM1AttachRuneToOwner::LoadoutSlotIndex' has a wrong offset!");
static_assert(offsetof(FM1AttachRuneToOwner, RunePositions) == 0x000010, "Member 'FM1AttachRuneToOwner::RunePositions' has a wrong offset!");
static_assert(offsetof(FM1AttachRuneToOwner, RuneSocketTypes) == 0x000020, "Member 'FM1AttachRuneToOwner::RuneSocketTypes' has a wrong offset!");

// ScriptStruct M1.M1Response_CancelMatching
// 0x0008 (0x0008 - 0x0000)
struct FM1Response_CancelMatching final
{
public:
	EM1MatchingReason                             Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CancelReason;                                      // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CancelMatching) == 0x000004, "Wrong alignment on FM1Response_CancelMatching");
static_assert(sizeof(FM1Response_CancelMatching) == 0x000008, "Wrong size on FM1Response_CancelMatching");
static_assert(offsetof(FM1Response_CancelMatching, Notification) == 0x000000, "Member 'FM1Response_CancelMatching::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_CancelMatching, CancelReason) == 0x000004, "Member 'FM1Response_CancelMatching::CancelReason' has a wrong offset!");

// ScriptStruct M1.M1ChangeRandomOptionInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1ChangeRandomOptionInfo final
{
public:
	struct FM1ItemUidBox                          ItemUidBox;                                        // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FixedOptionIndexes;                                // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ChangeRandomOptionInfo) == 0x000008, "Wrong alignment on FM1ChangeRandomOptionInfo");
static_assert(sizeof(FM1ChangeRandomOptionInfo) == 0x000020, "Wrong size on FM1ChangeRandomOptionInfo");
static_assert(offsetof(FM1ChangeRandomOptionInfo, ItemUidBox) == 0x000000, "Member 'FM1ChangeRandomOptionInfo::ItemUidBox' has a wrong offset!");
static_assert(offsetof(FM1ChangeRandomOptionInfo, FixedOptionIndexes) == 0x000010, "Member 'FM1ChangeRandomOptionInfo::FixedOptionIndexes' has a wrong offset!");

// ScriptStruct M1.M1FollowSocialMotionParam
// 0x0080 (0x0080 - 0x0000)
struct FM1FollowSocialMotionParam final
{
public:
	struct FTransform                             InteractionTransform;                              // 0x0000(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   InteractionClass;                                  // 0x0030(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    SocialMotionHandle;                                // 0x0060(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   SocialMotionRowName;                               // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1FollowSocialMotionParam) == 0x000010, "Wrong alignment on FM1FollowSocialMotionParam");
static_assert(sizeof(FM1FollowSocialMotionParam) == 0x000080, "Wrong size on FM1FollowSocialMotionParam");
static_assert(offsetof(FM1FollowSocialMotionParam, InteractionTransform) == 0x000000, "Member 'FM1FollowSocialMotionParam::InteractionTransform' has a wrong offset!");
static_assert(offsetof(FM1FollowSocialMotionParam, InteractionClass) == 0x000030, "Member 'FM1FollowSocialMotionParam::InteractionClass' has a wrong offset!");
static_assert(offsetof(FM1FollowSocialMotionParam, SocialMotionHandle) == 0x000060, "Member 'FM1FollowSocialMotionParam::SocialMotionHandle' has a wrong offset!");
static_assert(offsetof(FM1FollowSocialMotionParam, SocialMotionRowName) == 0x000070, "Member 'FM1FollowSocialMotionParam::SocialMotionRowName' has a wrong offset!");

// ScriptStruct M1.M1Request_TestSystemMessageEcho
// 0x0004 (0x0004 - 0x0000)
struct FM1Request_TestSystemMessageEcho final : public FM1Request
{
public:
	EM1SystemMessageType                          Message;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_TestSystemMessageEcho) == 0x000004, "Wrong alignment on FM1Request_TestSystemMessageEcho");
static_assert(sizeof(FM1Request_TestSystemMessageEcho) == 0x000004, "Wrong size on FM1Request_TestSystemMessageEcho");
static_assert(offsetof(FM1Request_TestSystemMessageEcho, Message) == 0x000000, "Member 'FM1Request_TestSystemMessageEcho::Message' has a wrong offset!");

// ScriptStruct M1.M1ItemCreationParam
// 0x0020 (0x0020 - 0x0000)
struct FM1ItemCreationParam final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemType                                   ItemType;                                          // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1TemplateId                          TemplateId;                                        // 0x0010(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerkLevel;                                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReactorEnchantLevel;                               // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemCreationParam) == 0x000008, "Wrong alignment on FM1ItemCreationParam");
static_assert(sizeof(FM1ItemCreationParam) == 0x000020, "Wrong size on FM1ItemCreationParam");
static_assert(offsetof(FM1ItemCreationParam, AccountUid) == 0x000000, "Member 'FM1ItemCreationParam::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1ItemCreationParam, Count) == 0x000008, "Member 'FM1ItemCreationParam::Count' has a wrong offset!");
static_assert(offsetof(FM1ItemCreationParam, ItemType) == 0x00000C, "Member 'FM1ItemCreationParam::ItemType' has a wrong offset!");
static_assert(offsetof(FM1ItemCreationParam, TemplateId) == 0x000010, "Member 'FM1ItemCreationParam::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1ItemCreationParam, Level) == 0x000014, "Member 'FM1ItemCreationParam::Level' has a wrong offset!");
static_assert(offsetof(FM1ItemCreationParam, PerkLevel) == 0x000018, "Member 'FM1ItemCreationParam::PerkLevel' has a wrong offset!");
static_assert(offsetof(FM1ItemCreationParam, ReactorEnchantLevel) == 0x00001C, "Member 'FM1ItemCreationParam::ReactorEnchantLevel' has a wrong offset!");

// ScriptStruct M1.M1GameGuideConditions
// 0x0010 (0x0010 - 0x0000)
struct FM1GameGuideConditions final
{
public:
	TArray<class UM1GameGuideConditionChecker*>   CheckList;                                         // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GameGuideConditions) == 0x000008, "Wrong alignment on FM1GameGuideConditions");
static_assert(sizeof(FM1GameGuideConditions) == 0x000010, "Wrong size on FM1GameGuideConditions");
static_assert(offsetof(FM1GameGuideConditions, CheckList) == 0x000000, "Member 'FM1GameGuideConditions::CheckList' has a wrong offset!");

// ScriptStruct M1.M1Request_GetResearachBookmarkData
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_GetResearachBookmarkData final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_GetResearachBookmarkData) == 0x000008, "Wrong alignment on FM1Request_GetResearachBookmarkData");
static_assert(sizeof(FM1Request_GetResearachBookmarkData) == 0x000008, "Wrong size on FM1Request_GetResearachBookmarkData");
static_assert(offsetof(FM1Request_GetResearachBookmarkData, AccountUid) == 0x000000, "Member 'FM1Request_GetResearachBookmarkData::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1RuneEquippedInfoBundleReqInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1RuneEquippedInfoBundleReqInfo final
{
public:
	struct FM1RuneLoadoutReq                      Req;                                               // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	int32                                         OptionalSelectLoadoutSlot;                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RuneEquippedInfoBundleReqInfo) == 0x000008, "Wrong alignment on FM1RuneEquippedInfoBundleReqInfo");
static_assert(sizeof(FM1RuneEquippedInfoBundleReqInfo) == 0x000020, "Wrong size on FM1RuneEquippedInfoBundleReqInfo");
static_assert(offsetof(FM1RuneEquippedInfoBundleReqInfo, Req) == 0x000000, "Member 'FM1RuneEquippedInfoBundleReqInfo::Req' has a wrong offset!");
static_assert(offsetof(FM1RuneEquippedInfoBundleReqInfo, OptionalSelectLoadoutSlot) == 0x000018, "Member 'FM1RuneEquippedInfoBundleReqInfo::OptionalSelectLoadoutSlot' has a wrong offset!");

// ScriptStruct M1.M1Request_WearEquipment
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_WearEquipment final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         EquipmentUid;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_WearEquipment) == 0x000008, "Wrong alignment on FM1Request_WearEquipment");
static_assert(sizeof(FM1Request_WearEquipment) == 0x000018, "Wrong size on FM1Request_WearEquipment");
static_assert(offsetof(FM1Request_WearEquipment, AccountUid) == 0x000000, "Member 'FM1Request_WearEquipment::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_WearEquipment, EquipmentUid) == 0x000008, "Member 'FM1Request_WearEquipment::EquipmentUid' has a wrong offset!");
static_assert(offsetof(FM1Request_WearEquipment, SlotIndex) == 0x000010, "Member 'FM1Request_WearEquipment::SlotIndex' has a wrong offset!");

// ScriptStruct M1.M1GrantRuneSocketType
// 0x0010 (0x0010 - 0x0000)
struct FM1GrantRuneSocketType final
{
public:
	struct FM1ItemTidBox                          OwnerTidBox;                                       // 0x0000(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         RuneSocketIndex;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RuneSocketType                             RuneSocketType;                                    // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RuneSubClassType                           RuneSubClassType;                                  // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1GrantRuneSocketType) == 0x000004, "Wrong alignment on FM1GrantRuneSocketType");
static_assert(sizeof(FM1GrantRuneSocketType) == 0x000010, "Wrong size on FM1GrantRuneSocketType");
static_assert(offsetof(FM1GrantRuneSocketType, OwnerTidBox) == 0x000000, "Member 'FM1GrantRuneSocketType::OwnerTidBox' has a wrong offset!");
static_assert(offsetof(FM1GrantRuneSocketType, RuneSocketIndex) == 0x000008, "Member 'FM1GrantRuneSocketType::RuneSocketIndex' has a wrong offset!");
static_assert(offsetof(FM1GrantRuneSocketType, RuneSocketType) == 0x00000C, "Member 'FM1GrantRuneSocketType::RuneSocketType' has a wrong offset!");
static_assert(offsetof(FM1GrantRuneSocketType, RuneSubClassType) == 0x00000D, "Member 'FM1GrantRuneSocketType::RuneSubClassType' has a wrong offset!");

// ScriptStruct M1.M1Request_PartyRequest
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_PartyRequest final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RequesteeName;                                     // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_PartyRequest) == 0x000008, "Wrong alignment on FM1Request_PartyRequest");
static_assert(sizeof(FM1Request_PartyRequest) == 0x000018, "Wrong size on FM1Request_PartyRequest");
static_assert(offsetof(FM1Request_PartyRequest, AccountUid) == 0x000000, "Member 'FM1Request_PartyRequest::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_PartyRequest, RequesteeName) == 0x000008, "Member 'FM1Request_PartyRequest::RequesteeName' has a wrong offset!");

// ScriptStruct M1.M1IncreaseRuneCapacity
// 0x000C (0x000C - 0x0000)
struct FM1IncreaseRuneCapacity final
{
public:
	struct FM1ItemTidBox                          OwnerTidBox;                                       // 0x0000(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         TargetIncreaseCount;                               // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1IncreaseRuneCapacity) == 0x000004, "Wrong alignment on FM1IncreaseRuneCapacity");
static_assert(sizeof(FM1IncreaseRuneCapacity) == 0x00000C, "Wrong size on FM1IncreaseRuneCapacity");
static_assert(offsetof(FM1IncreaseRuneCapacity, OwnerTidBox) == 0x000000, "Member 'FM1IncreaseRuneCapacity::OwnerTidBox' has a wrong offset!");
static_assert(offsetof(FM1IncreaseRuneCapacity, TargetIncreaseCount) == 0x000008, "Member 'FM1IncreaseRuneCapacity::TargetIncreaseCount' has a wrong offset!");

// ScriptStruct M1.M1KeySettingSymbolSet
// 0x0028 (0x0028 - 0x0000)
struct FM1KeySettingSymbolSet final
{
public:
	class UTexture2D*                             SupportImage;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PlusImage;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Image;                                             // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Text;                                              // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1KeySettingSymbolSet) == 0x000008, "Wrong alignment on FM1KeySettingSymbolSet");
static_assert(sizeof(FM1KeySettingSymbolSet) == 0x000028, "Wrong size on FM1KeySettingSymbolSet");
static_assert(offsetof(FM1KeySettingSymbolSet, SupportImage) == 0x000000, "Member 'FM1KeySettingSymbolSet::SupportImage' has a wrong offset!");
static_assert(offsetof(FM1KeySettingSymbolSet, PlusImage) == 0x000008, "Member 'FM1KeySettingSymbolSet::PlusImage' has a wrong offset!");
static_assert(offsetof(FM1KeySettingSymbolSet, Image) == 0x000010, "Member 'FM1KeySettingSymbolSet::Image' has a wrong offset!");
static_assert(offsetof(FM1KeySettingSymbolSet, Text) == 0x000018, "Member 'FM1KeySettingSymbolSet::Text' has a wrong offset!");

// ScriptStruct M1.M1StatTypeAndValue
// 0x000C (0x0018 - 0x000C)
struct FM1StatTypeAndValue final : public FFastArraySerializerItem
{
public:
	EM1StatType                                   StatType;                                          // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ScaledInteger                       Value;                                             // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StatTypeAndValue) == 0x000008, "Wrong alignment on FM1StatTypeAndValue");
static_assert(sizeof(FM1StatTypeAndValue) == 0x000018, "Wrong size on FM1StatTypeAndValue");
static_assert(offsetof(FM1StatTypeAndValue, StatType) == 0x00000C, "Member 'FM1StatTypeAndValue::StatType' has a wrong offset!");
static_assert(offsetof(FM1StatTypeAndValue, Value) == 0x000010, "Member 'FM1StatTypeAndValue::Value' has a wrong offset!");

// ScriptStruct M1.M1StatArraySerializer
// 0x0060 (0x0168 - 0x0108)
struct FM1StatArraySerializer final : public FFastArraySerializer
{
public:
	TArray<struct FM1StatTypeAndValue>            Stats;                                             // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<EM1StatType, int32>                      StatIndexMap;                                      // 0x0118(0x0050)(RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StatArraySerializer) == 0x000008, "Wrong alignment on FM1StatArraySerializer");
static_assert(sizeof(FM1StatArraySerializer) == 0x000168, "Wrong size on FM1StatArraySerializer");
static_assert(offsetof(FM1StatArraySerializer, Stats) == 0x000108, "Member 'FM1StatArraySerializer::Stats' has a wrong offset!");
static_assert(offsetof(FM1StatArraySerializer, StatIndexMap) == 0x000118, "Member 'FM1StatArraySerializer::StatIndexMap' has a wrong offset!");

// ScriptStruct M1.M1CameraVelocityExp
// 0x0028 (0x0028 - 0x0000)
struct FM1CameraVelocityExp final
{
public:
	float                                         CameraZoomExp;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraMoveYExp;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorRotateYawExp;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorTiltExp;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraZoomVelocityDecreaseExp;                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraMoveYVelocityDecreaseExp;                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorRotateYawVelocityDecreaseExp;                 // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorTiltVelocityDecreaseExp;                      // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorRotateYawVelocityLimit;                       // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorTiltVelocityLimit;                            // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CameraVelocityExp) == 0x000004, "Wrong alignment on FM1CameraVelocityExp");
static_assert(sizeof(FM1CameraVelocityExp) == 0x000028, "Wrong size on FM1CameraVelocityExp");
static_assert(offsetof(FM1CameraVelocityExp, CameraZoomExp) == 0x000000, "Member 'FM1CameraVelocityExp::CameraZoomExp' has a wrong offset!");
static_assert(offsetof(FM1CameraVelocityExp, CameraMoveYExp) == 0x000004, "Member 'FM1CameraVelocityExp::CameraMoveYExp' has a wrong offset!");
static_assert(offsetof(FM1CameraVelocityExp, ActorRotateYawExp) == 0x000008, "Member 'FM1CameraVelocityExp::ActorRotateYawExp' has a wrong offset!");
static_assert(offsetof(FM1CameraVelocityExp, ActorTiltExp) == 0x00000C, "Member 'FM1CameraVelocityExp::ActorTiltExp' has a wrong offset!");
static_assert(offsetof(FM1CameraVelocityExp, CameraZoomVelocityDecreaseExp) == 0x000010, "Member 'FM1CameraVelocityExp::CameraZoomVelocityDecreaseExp' has a wrong offset!");
static_assert(offsetof(FM1CameraVelocityExp, CameraMoveYVelocityDecreaseExp) == 0x000014, "Member 'FM1CameraVelocityExp::CameraMoveYVelocityDecreaseExp' has a wrong offset!");
static_assert(offsetof(FM1CameraVelocityExp, ActorRotateYawVelocityDecreaseExp) == 0x000018, "Member 'FM1CameraVelocityExp::ActorRotateYawVelocityDecreaseExp' has a wrong offset!");
static_assert(offsetof(FM1CameraVelocityExp, ActorTiltVelocityDecreaseExp) == 0x00001C, "Member 'FM1CameraVelocityExp::ActorTiltVelocityDecreaseExp' has a wrong offset!");
static_assert(offsetof(FM1CameraVelocityExp, ActorRotateYawVelocityLimit) == 0x000020, "Member 'FM1CameraVelocityExp::ActorRotateYawVelocityLimit' has a wrong offset!");
static_assert(offsetof(FM1CameraVelocityExp, ActorTiltVelocityLimit) == 0x000024, "Member 'FM1CameraVelocityExp::ActorTiltVelocityLimit' has a wrong offset!");

// ScriptStruct M1.M1MissionResultStatisticsRow
// 0x0038 (0x0040 - 0x0008)
struct FM1MissionResultStatisticsRow final : public FTableRowBase
{
public:
	EM1StatisticsElement                          Element;                                           // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1StatisticsShowType                         ShowType;                                          // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AM1MissionTaskActor>> ShowTaskClasses;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<EM1MissionSubType>                     ShowSubTypes;                                      // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   StringKey;                                         // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PostfixStringKey;                                  // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionResultStatisticsRow) == 0x000008, "Wrong alignment on FM1MissionResultStatisticsRow");
static_assert(sizeof(FM1MissionResultStatisticsRow) == 0x000040, "Wrong size on FM1MissionResultStatisticsRow");
static_assert(offsetof(FM1MissionResultStatisticsRow, Element) == 0x000008, "Member 'FM1MissionResultStatisticsRow::Element' has a wrong offset!");
static_assert(offsetof(FM1MissionResultStatisticsRow, ShowType) == 0x000009, "Member 'FM1MissionResultStatisticsRow::ShowType' has a wrong offset!");
static_assert(offsetof(FM1MissionResultStatisticsRow, ShowTaskClasses) == 0x000010, "Member 'FM1MissionResultStatisticsRow::ShowTaskClasses' has a wrong offset!");
static_assert(offsetof(FM1MissionResultStatisticsRow, ShowSubTypes) == 0x000020, "Member 'FM1MissionResultStatisticsRow::ShowSubTypes' has a wrong offset!");
static_assert(offsetof(FM1MissionResultStatisticsRow, StringKey) == 0x000030, "Member 'FM1MissionResultStatisticsRow::StringKey' has a wrong offset!");
static_assert(offsetof(FM1MissionResultStatisticsRow, PostfixStringKey) == 0x000038, "Member 'FM1MissionResultStatisticsRow::PostfixStringKey' has a wrong offset!");

// ScriptStruct M1.M1ShopDisplayInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1ShopDisplayInfo final
{
public:
	class FName                                   DisplayStringId;                                   // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BGId;                                              // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ShopDisplayInfo) == 0x000004, "Wrong alignment on FM1ShopDisplayInfo");
static_assert(sizeof(FM1ShopDisplayInfo) == 0x000010, "Wrong size on FM1ShopDisplayInfo");
static_assert(offsetof(FM1ShopDisplayInfo, DisplayStringId) == 0x000000, "Member 'FM1ShopDisplayInfo::DisplayStringId' has a wrong offset!");
static_assert(offsetof(FM1ShopDisplayInfo, BGId) == 0x000008, "Member 'FM1ShopDisplayInfo::BGId' has a wrong offset!");

// ScriptStruct M1.M1DirectionData
// 0x0008 (0x0008 - 0x0000)
struct FM1DirectionData final
{
public:
	EM1CheckDirection                             Direction;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DirectionData) == 0x000004, "Wrong alignment on FM1DirectionData");
static_assert(sizeof(FM1DirectionData) == 0x000008, "Wrong size on FM1DirectionData");
static_assert(offsetof(FM1DirectionData, Direction) == 0x000000, "Member 'FM1DirectionData::Direction' has a wrong offset!");
static_assert(offsetof(FM1DirectionData, Distance) == 0x000004, "Member 'FM1DirectionData::Distance' has a wrong offset!");

// ScriptStruct M1.M1NxLog_SkillUseCount
// 0x0030 (0x0030 - 0x0000)
struct FM1NxLog_SkillUseCount final
{
public:
	class FString                                 SkillType;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SkillId;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UseCnt;                                            // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_SkillUseCount) == 0x000008, "Wrong alignment on FM1NxLog_SkillUseCount");
static_assert(sizeof(FM1NxLog_SkillUseCount) == 0x000030, "Wrong size on FM1NxLog_SkillUseCount");
static_assert(offsetof(FM1NxLog_SkillUseCount, SkillType) == 0x000000, "Member 'FM1NxLog_SkillUseCount::SkillType' has a wrong offset!");
static_assert(offsetof(FM1NxLog_SkillUseCount, SkillId) == 0x000010, "Member 'FM1NxLog_SkillUseCount::SkillId' has a wrong offset!");
static_assert(offsetof(FM1NxLog_SkillUseCount, UseCnt) == 0x000020, "Member 'FM1NxLog_SkillUseCount::UseCnt' has a wrong offset!");

// ScriptStruct M1.M1OptionValue
// 0x0010 (0x0010 - 0x0000)
struct FM1OptionValue final
{
public:
	class FString                                 Value;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1OptionValue) == 0x000008, "Wrong alignment on FM1OptionValue");
static_assert(sizeof(FM1OptionValue) == 0x000010, "Wrong size on FM1OptionValue");
static_assert(offsetof(FM1OptionValue, Value) == 0x000000, "Member 'FM1OptionValue::Value' has a wrong offset!");

// ScriptStruct M1.M1Response_ReceiveMultipleMailAttachment
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_ReceiveMultipleMailAttachment final
{
public:
	struct FM1MultipleMailResultBundle            Notification;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_ReceiveMultipleMailAttachment) == 0x000008, "Wrong alignment on FM1Response_ReceiveMultipleMailAttachment");
static_assert(sizeof(FM1Response_ReceiveMultipleMailAttachment) == 0x000010, "Wrong size on FM1Response_ReceiveMultipleMailAttachment");
static_assert(offsetof(FM1Response_ReceiveMultipleMailAttachment, Notification) == 0x000000, "Member 'FM1Response_ReceiveMultipleMailAttachment::Notification' has a wrong offset!");

// ScriptStruct M1.M1AcceptableRadiusData
// 0x0030 (0x0030 - 0x0000)
struct FM1AcceptableRadiusData final
{
public:
	bool                                          bUseBlackboardKey;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBKey;                                             // 0x0008(0x0028)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AcceptableRadiusData) == 0x000008, "Wrong alignment on FM1AcceptableRadiusData");
static_assert(sizeof(FM1AcceptableRadiusData) == 0x000030, "Wrong size on FM1AcceptableRadiusData");
static_assert(offsetof(FM1AcceptableRadiusData, bUseBlackboardKey) == 0x000000, "Member 'FM1AcceptableRadiusData::bUseBlackboardKey' has a wrong offset!");
static_assert(offsetof(FM1AcceptableRadiusData, Value) == 0x000004, "Member 'FM1AcceptableRadiusData::Value' has a wrong offset!");
static_assert(offsetof(FM1AcceptableRadiusData, BBKey) == 0x000008, "Member 'FM1AcceptableRadiusData::BBKey' has a wrong offset!");

// ScriptStruct M1.M1Response_ReceiveMailAttachment
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_ReceiveMailAttachment final
{
public:
	EM1MailReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_ReceiveMailAttachment) == 0x000004, "Wrong alignment on FM1Response_ReceiveMailAttachment");
static_assert(sizeof(FM1Response_ReceiveMailAttachment) == 0x000004, "Wrong size on FM1Response_ReceiveMailAttachment");
static_assert(offsetof(FM1Response_ReceiveMailAttachment, Notification) == 0x000000, "Member 'FM1Response_ReceiveMailAttachment::Notification' has a wrong offset!");

// ScriptStruct M1.M1DecoFootAlignCondition
// 0x000C (0x000C - 0x0000)
struct FM1DecoFootAlignCondition final
{
public:
	class FName                                   FootSocket;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToleranceDistanceToFloor;                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DecoFootAlignCondition) == 0x000004, "Wrong alignment on FM1DecoFootAlignCondition");
static_assert(sizeof(FM1DecoFootAlignCondition) == 0x00000C, "Wrong size on FM1DecoFootAlignCondition");
static_assert(offsetof(FM1DecoFootAlignCondition, FootSocket) == 0x000000, "Member 'FM1DecoFootAlignCondition::FootSocket' has a wrong offset!");
static_assert(offsetof(FM1DecoFootAlignCondition, ToleranceDistanceToFloor) == 0x000008, "Member 'FM1DecoFootAlignCondition::ToleranceDistanceToFloor' has a wrong offset!");

// ScriptStruct M1.M1BattleAxisContent
// 0x0020 (0x0020 - 0x0000)
struct FM1BattleAxisContent final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1BattleAxisContent) == 0x000008, "Wrong alignment on FM1BattleAxisContent");
static_assert(sizeof(FM1BattleAxisContent) == 0x000020, "Wrong size on FM1BattleAxisContent");
static_assert(offsetof(FM1BattleAxisContent, Key) == 0x000000, "Member 'FM1BattleAxisContent::Key' has a wrong offset!");
static_assert(offsetof(FM1BattleAxisContent, Scale) == 0x000018, "Member 'FM1BattleAxisContent::Scale' has a wrong offset!");

// ScriptStruct M1.M1BattleAxisSetting
// 0x0020 (0x0020 - 0x0000)
struct FM1BattleAxisSetting final
{
public:
	class FName                                   AxisName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1BattleAxis                                 BattleAxis;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1BattleAxisContent>           AxisContents;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattleAxisSetting) == 0x000008, "Wrong alignment on FM1BattleAxisSetting");
static_assert(sizeof(FM1BattleAxisSetting) == 0x000020, "Wrong size on FM1BattleAxisSetting");
static_assert(offsetof(FM1BattleAxisSetting, AxisName) == 0x000000, "Member 'FM1BattleAxisSetting::AxisName' has a wrong offset!");
static_assert(offsetof(FM1BattleAxisSetting, BattleAxis) == 0x000008, "Member 'FM1BattleAxisSetting::BattleAxis' has a wrong offset!");
static_assert(offsetof(FM1BattleAxisSetting, AxisContents) == 0x000010, "Member 'FM1BattleAxisSetting::AxisContents' has a wrong offset!");

// ScriptStruct M1.M1UIEvent_InventoryCapacityOverflowed
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FM1UIEvent_InventoryCapacityOverflowed final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_InventoryCapacityOverflowed) == 0x000004, "Wrong alignment on FM1UIEvent_InventoryCapacityOverflowed");
static_assert(sizeof(FM1UIEvent_InventoryCapacityOverflowed) == 0x000008, "Wrong size on FM1UIEvent_InventoryCapacityOverflowed");

// ScriptStruct M1.M1DecoCondition
// 0x0060 (0x0060 - 0x0000)
struct FM1DecoCondition final
{
public:
	EM1BTBlackboardCondition                      Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 Key;                                               // 0x0008(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  StateTags;                                         // 0x0038(0x0020)(Edit, NativeAccessSpecifierPublic)
	bool                                          IsActive;                                          // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1DecoCondition) == 0x000008, "Wrong alignment on FM1DecoCondition");
static_assert(sizeof(FM1DecoCondition) == 0x000060, "Wrong size on FM1DecoCondition");
static_assert(offsetof(FM1DecoCondition, Type) == 0x000000, "Member 'FM1DecoCondition::Type' has a wrong offset!");
static_assert(offsetof(FM1DecoCondition, Key) == 0x000008, "Member 'FM1DecoCondition::Key' has a wrong offset!");
static_assert(offsetof(FM1DecoCondition, IsValid) == 0x000030, "Member 'FM1DecoCondition::IsValid' has a wrong offset!");
static_assert(offsetof(FM1DecoCondition, StateTags) == 0x000038, "Member 'FM1DecoCondition::StateTags' has a wrong offset!");
static_assert(offsetof(FM1DecoCondition, IsActive) == 0x000058, "Member 'FM1DecoCondition::IsActive' has a wrong offset!");

// ScriptStruct M1.M1Response_BattlePassCompile
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_BattlePassCompile final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_BattlePassCompile) == 0x000001, "Wrong alignment on FM1Response_BattlePassCompile");
static_assert(sizeof(FM1Response_BattlePassCompile) == 0x000001, "Wrong size on FM1Response_BattlePassCompile");
static_assert(offsetof(FM1Response_BattlePassCompile, Notification) == 0x000000, "Member 'FM1Response_BattlePassCompile::Notification' has a wrong offset!");

// ScriptStruct M1.M1FindObjectCondition
// 0x0008 (0x0008 - 0x0000)
struct FM1FindObjectCondition final
{
public:
	EM1ObjectConditionType                        Type;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIs2D;                                             // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRelated;                                          // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RelationsCheckType                         TargetCheckType;                                   // 0x0006(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreferHigherSeekerCount;                          // 0x0007(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FindObjectCondition) == 0x000004, "Wrong alignment on FM1FindObjectCondition");
static_assert(sizeof(FM1FindObjectCondition) == 0x000008, "Wrong size on FM1FindObjectCondition");
static_assert(offsetof(FM1FindObjectCondition, Type) == 0x000000, "Member 'FM1FindObjectCondition::Type' has a wrong offset!");
static_assert(offsetof(FM1FindObjectCondition, bIs2D) == 0x000004, "Member 'FM1FindObjectCondition::bIs2D' has a wrong offset!");
static_assert(offsetof(FM1FindObjectCondition, bRelated) == 0x000005, "Member 'FM1FindObjectCondition::bRelated' has a wrong offset!");
static_assert(offsetof(FM1FindObjectCondition, TargetCheckType) == 0x000006, "Member 'FM1FindObjectCondition::TargetCheckType' has a wrong offset!");
static_assert(offsetof(FM1FindObjectCondition, bPreferHigherSeekerCount) == 0x000007, "Member 'FM1FindObjectCondition::bPreferHigherSeekerCount' has a wrong offset!");

// ScriptStruct M1.M1Request_SendMailForCheat
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_SendMailForCheat final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MailType                                   MailType;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MailTid;                                           // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          DropGroupTemplateId;                               // 0x0010(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_SendMailForCheat) == 0x000008, "Wrong alignment on FM1Request_SendMailForCheat");
static_assert(sizeof(FM1Request_SendMailForCheat) == 0x000018, "Wrong size on FM1Request_SendMailForCheat");
static_assert(offsetof(FM1Request_SendMailForCheat, AccountUid) == 0x000000, "Member 'FM1Request_SendMailForCheat::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_SendMailForCheat, MailType) == 0x000008, "Member 'FM1Request_SendMailForCheat::MailType' has a wrong offset!");
static_assert(offsetof(FM1Request_SendMailForCheat, MailTid) == 0x00000C, "Member 'FM1Request_SendMailForCheat::MailTid' has a wrong offset!");
static_assert(offsetof(FM1Request_SendMailForCheat, DropGroupTemplateId) == 0x000010, "Member 'FM1Request_SendMailForCheat::DropGroupTemplateId' has a wrong offset!");

// ScriptStruct M1.M1MonsterFacingToTarget
// 0x0010 (0x0010 - 0x0000)
struct FM1MonsterFacingToTarget final
{
public:
	float                                         MinDegree;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDegree;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Anim;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterFacingToTarget) == 0x000008, "Wrong alignment on FM1MonsterFacingToTarget");
static_assert(sizeof(FM1MonsterFacingToTarget) == 0x000010, "Wrong size on FM1MonsterFacingToTarget");
static_assert(offsetof(FM1MonsterFacingToTarget, MinDegree) == 0x000000, "Member 'FM1MonsterFacingToTarget::MinDegree' has a wrong offset!");
static_assert(offsetof(FM1MonsterFacingToTarget, MaxDegree) == 0x000004, "Member 'FM1MonsterFacingToTarget::MaxDegree' has a wrong offset!");
static_assert(offsetof(FM1MonsterFacingToTarget, Anim) == 0x000008, "Member 'FM1MonsterFacingToTarget::Anim' has a wrong offset!");

// ScriptStruct M1.M1MonsterLogic_Seudo_RandomWalkRoot
// 0x0040 (0x0040 - 0x0000)
struct FM1MonsterLogic_Seudo_RandomWalkRoot final
{
public:
	TWeakObjectPtr<class AM1Player>               Target;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BaseTransform;                                     // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterLogic_Seudo_RandomWalkRoot) == 0x000010, "Wrong alignment on FM1MonsterLogic_Seudo_RandomWalkRoot");
static_assert(sizeof(FM1MonsterLogic_Seudo_RandomWalkRoot) == 0x000040, "Wrong size on FM1MonsterLogic_Seudo_RandomWalkRoot");
static_assert(offsetof(FM1MonsterLogic_Seudo_RandomWalkRoot, Target) == 0x000000, "Member 'FM1MonsterLogic_Seudo_RandomWalkRoot::Target' has a wrong offset!");
static_assert(offsetof(FM1MonsterLogic_Seudo_RandomWalkRoot, BaseTransform) == 0x000010, "Member 'FM1MonsterLogic_Seudo_RandomWalkRoot::BaseTransform' has a wrong offset!");

// ScriptStruct M1.M1Response_SendMailForCheat2
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_SendMailForCheat2 final
{
public:
	EM1MailReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_SendMailForCheat2) == 0x000004, "Wrong alignment on FM1Response_SendMailForCheat2");
static_assert(sizeof(FM1Response_SendMailForCheat2) == 0x000004, "Wrong size on FM1Response_SendMailForCheat2");
static_assert(offsetof(FM1Response_SendMailForCheat2, Notification) == 0x000000, "Member 'FM1Response_SendMailForCheat2::Notification' has a wrong offset!");

// ScriptStruct M1.M1UBTTagData
// 0x000C (0x000C - 0x0000)
struct FM1UBTTagData final
{
public:
	bool                                          bActivate;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Tag;                                               // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1UBTTagData) == 0x000004, "Wrong alignment on FM1UBTTagData");
static_assert(sizeof(FM1UBTTagData) == 0x00000C, "Wrong size on FM1UBTTagData");
static_assert(offsetof(FM1UBTTagData, bActivate) == 0x000000, "Member 'FM1UBTTagData::bActivate' has a wrong offset!");
static_assert(offsetof(FM1UBTTagData, Tag) == 0x000004, "Member 'FM1UBTTagData::Tag' has a wrong offset!");

// ScriptStruct M1.M1HitReactionDataMacroSetting
// 0x0030 (0x0030 - 0x0000)
struct FM1HitReactionDataMacroSetting final
{
public:
	bool                                          bHitStopData;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PartsName;                                         // 0x0004(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FrontAnimName;                                     // 0x000C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BackAnimName;                                      // 0x0014(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           HitStopAnimNames;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1HitReactionDataMacroSetting) == 0x000008, "Wrong alignment on FM1HitReactionDataMacroSetting");
static_assert(sizeof(FM1HitReactionDataMacroSetting) == 0x000030, "Wrong size on FM1HitReactionDataMacroSetting");
static_assert(offsetof(FM1HitReactionDataMacroSetting, bHitStopData) == 0x000000, "Member 'FM1HitReactionDataMacroSetting::bHitStopData' has a wrong offset!");
static_assert(offsetof(FM1HitReactionDataMacroSetting, PartsName) == 0x000004, "Member 'FM1HitReactionDataMacroSetting::PartsName' has a wrong offset!");
static_assert(offsetof(FM1HitReactionDataMacroSetting, FrontAnimName) == 0x00000C, "Member 'FM1HitReactionDataMacroSetting::FrontAnimName' has a wrong offset!");
static_assert(offsetof(FM1HitReactionDataMacroSetting, BackAnimName) == 0x000014, "Member 'FM1HitReactionDataMacroSetting::BackAnimName' has a wrong offset!");
static_assert(offsetof(FM1HitReactionDataMacroSetting, HitStopAnimNames) == 0x000020, "Member 'FM1HitReactionDataMacroSetting::HitStopAnimNames' has a wrong offset!");

// ScriptStruct M1.M1SocialMotionFlowSetting
// 0x0014 (0x0014 - 0x0000)
struct FM1SocialMotionFlowSetting final
{
public:
	class FName                                   SectionName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediatelyJumpSection;                           // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FXName;                                            // 0x000C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SocialMotionFlowSetting) == 0x000004, "Wrong alignment on FM1SocialMotionFlowSetting");
static_assert(sizeof(FM1SocialMotionFlowSetting) == 0x000014, "Wrong size on FM1SocialMotionFlowSetting");
static_assert(offsetof(FM1SocialMotionFlowSetting, SectionName) == 0x000000, "Member 'FM1SocialMotionFlowSetting::SectionName' has a wrong offset!");
static_assert(offsetof(FM1SocialMotionFlowSetting, bImmediatelyJumpSection) == 0x000008, "Member 'FM1SocialMotionFlowSetting::bImmediatelyJumpSection' has a wrong offset!");
static_assert(offsetof(FM1SocialMotionFlowSetting, FXName) == 0x00000C, "Member 'FM1SocialMotionFlowSetting::FXName' has a wrong offset!");

// ScriptStruct M1.M1Response_UncustomizingCharacter
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_UncustomizingCharacter final
{
public:
	EM1CustomizeReason                            Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_UncustomizingCharacter) == 0x000004, "Wrong alignment on FM1Response_UncustomizingCharacter");
static_assert(sizeof(FM1Response_UncustomizingCharacter) == 0x000004, "Wrong size on FM1Response_UncustomizingCharacter");
static_assert(offsetof(FM1Response_UncustomizingCharacter, Notification) == 0x000000, "Member 'FM1Response_UncustomizingCharacter::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_SendLinkInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_SendLinkInfo final : public FM1Request
{
public:
	class FString                                 LinkInfo;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_SendLinkInfo) == 0x000008, "Wrong alignment on FM1Request_SendLinkInfo");
static_assert(sizeof(FM1Request_SendLinkInfo) == 0x000010, "Wrong size on FM1Request_SendLinkInfo");
static_assert(offsetof(FM1Request_SendLinkInfo, LinkInfo) == 0x000000, "Member 'FM1Request_SendLinkInfo::LinkInfo' has a wrong offset!");

// ScriptStruct M1.M1KeySymbolContent
// 0x0080 (0x0080 - 0x0000)
struct FM1KeySymbolContent final
{
public:
	struct FSoftObjectPath                        SymbolImage;                                       // 0x0000(0x0020)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EM1Platform, struct FSoftObjectPath>     DetailedPlatformSymbolImage;                       // 0x0020(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FString                                 Text;                                              // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1KeySymbolContent) == 0x000008, "Wrong alignment on FM1KeySymbolContent");
static_assert(sizeof(FM1KeySymbolContent) == 0x000080, "Wrong size on FM1KeySymbolContent");
static_assert(offsetof(FM1KeySymbolContent, SymbolImage) == 0x000000, "Member 'FM1KeySymbolContent::SymbolImage' has a wrong offset!");
static_assert(offsetof(FM1KeySymbolContent, DetailedPlatformSymbolImage) == 0x000020, "Member 'FM1KeySymbolContent::DetailedPlatformSymbolImage' has a wrong offset!");
static_assert(offsetof(FM1KeySymbolContent, Text) == 0x000070, "Member 'FM1KeySymbolContent::Text' has a wrong offset!");

// ScriptStruct M1.M1CustomKeySymbolContent
// 0x0100 (0x0100 - 0x0000)
struct FM1CustomKeySymbolContent final
{
public:
	struct FM1KeySymbolContent                    MainKeySymbolContent;                              // 0x0000(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FM1KeySymbolContent                    SupportKeySymbolContent;                           // 0x0080(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomKeySymbolContent) == 0x000008, "Wrong alignment on FM1CustomKeySymbolContent");
static_assert(sizeof(FM1CustomKeySymbolContent) == 0x000100, "Wrong size on FM1CustomKeySymbolContent");
static_assert(offsetof(FM1CustomKeySymbolContent, MainKeySymbolContent) == 0x000000, "Member 'FM1CustomKeySymbolContent::MainKeySymbolContent' has a wrong offset!");
static_assert(offsetof(FM1CustomKeySymbolContent, SupportKeySymbolContent) == 0x000080, "Member 'FM1CustomKeySymbolContent::SupportKeySymbolContent' has a wrong offset!");

// ScriptStruct M1.M1SystemKeySetting
// 0x0078 (0x0078 - 0x0000)
struct FM1SystemKeySetting final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1SystemKey                                  SystemKey;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInputChord>                    Chords;                                            // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EM1UIPlatform, struct FM1CustomKeySymbolContent> CustomSymbolSet;                                   // 0x0020(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseBattleKeySettingChords;                        // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SystemKeySetting) == 0x000008, "Wrong alignment on FM1SystemKeySetting");
static_assert(sizeof(FM1SystemKeySetting) == 0x000078, "Wrong size on FM1SystemKeySetting");
static_assert(offsetof(FM1SystemKeySetting, ActionName) == 0x000000, "Member 'FM1SystemKeySetting::ActionName' has a wrong offset!");
static_assert(offsetof(FM1SystemKeySetting, SystemKey) == 0x000008, "Member 'FM1SystemKeySetting::SystemKey' has a wrong offset!");
static_assert(offsetof(FM1SystemKeySetting, Chords) == 0x000010, "Member 'FM1SystemKeySetting::Chords' has a wrong offset!");
static_assert(offsetof(FM1SystemKeySetting, CustomSymbolSet) == 0x000020, "Member 'FM1SystemKeySetting::CustomSymbolSet' has a wrong offset!");
static_assert(offsetof(FM1SystemKeySetting, bUseBattleKeySettingChords) == 0x000070, "Member 'FM1SystemKeySetting::bUseBattleKeySettingChords' has a wrong offset!");

// ScriptStruct M1.M1Notice_MailOpReloadRequest
// 0x0008 (0x0008 - 0x0000)
struct FM1Notice_MailOpReloadRequest final
{
public:
	int64                                         Notification;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_MailOpReloadRequest) == 0x000008, "Wrong alignment on FM1Notice_MailOpReloadRequest");
static_assert(sizeof(FM1Notice_MailOpReloadRequest) == 0x000008, "Wrong size on FM1Notice_MailOpReloadRequest");
static_assert(offsetof(FM1Notice_MailOpReloadRequest, Notification) == 0x000000, "Member 'FM1Notice_MailOpReloadRequest::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_JoinDedicatedServerByOid_2
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_JoinDedicatedServerByOid_2 final : public FM1Request
{
public:
	struct FM1JoinDedicatedServerOid              Req;                                               // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_JoinDedicatedServerByOid_2) == 0x000008, "Wrong alignment on FM1Request_JoinDedicatedServerByOid_2");
static_assert(sizeof(FM1Request_JoinDedicatedServerByOid_2) == 0x000010, "Wrong size on FM1Request_JoinDedicatedServerByOid_2");
static_assert(offsetof(FM1Request_JoinDedicatedServerByOid_2, Req) == 0x000000, "Member 'FM1Request_JoinDedicatedServerByOid_2::Req' has a wrong offset!");

// ScriptStruct M1.M1ActorComponentTypeCache
// 0x0050 (0x0050 - 0x0000)
struct FM1ActorComponentTypeCache final
{
public:
	TSet<TSubclassOf<class UPrimitiveComponent>>  ComponentClasses;                                  // 0x0000(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ActorComponentTypeCache) == 0x000008, "Wrong alignment on FM1ActorComponentTypeCache");
static_assert(sizeof(FM1ActorComponentTypeCache) == 0x000050, "Wrong size on FM1ActorComponentTypeCache");
static_assert(offsetof(FM1ActorComponentTypeCache, ComponentClasses) == 0x000000, "Member 'FM1ActorComponentTypeCache::ComponentClasses' has a wrong offset!");

// ScriptStruct M1.M1HelpWidgetRow
// 0x0030 (0x0038 - 0x0008)
struct FM1HelpWidgetRow final : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   HelpWidgetClass;                                   // 0x0008(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1HelpWidgetRow) == 0x000008, "Wrong alignment on FM1HelpWidgetRow");
static_assert(sizeof(FM1HelpWidgetRow) == 0x000038, "Wrong size on FM1HelpWidgetRow");
static_assert(offsetof(FM1HelpWidgetRow, HelpWidgetClass) == 0x000008, "Member 'FM1HelpWidgetRow::HelpWidgetClass' has a wrong offset!");

// ScriptStruct M1.M1Request_JoinLastField_2
// 0x0001 (0x0001 - 0x0000)
struct FM1Request_JoinLastField_2 final : public FM1Request
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_JoinLastField_2) == 0x000001, "Wrong alignment on FM1Request_JoinLastField_2");
static_assert(sizeof(FM1Request_JoinLastField_2) == 0x000001, "Wrong size on FM1Request_JoinLastField_2");

// ScriptStruct M1.M1Request_CheatJoinDedicatedServerByMapName_2
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CheatJoinDedicatedServerByMapName_2 final : public FM1Request
{
public:
	class FString                                 MapName;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatJoinDedicatedServerByMapName_2) == 0x000008, "Wrong alignment on FM1Request_CheatJoinDedicatedServerByMapName_2");
static_assert(sizeof(FM1Request_CheatJoinDedicatedServerByMapName_2) == 0x000010, "Wrong size on FM1Request_CheatJoinDedicatedServerByMapName_2");
static_assert(offsetof(FM1Request_CheatJoinDedicatedServerByMapName_2, MapName) == 0x000000, "Member 'FM1Request_CheatJoinDedicatedServerByMapName_2::MapName' has a wrong offset!");

// ScriptStruct M1.M1Request_CustomizingSkinPaint
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_CustomizingSkinPaint final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1RequestCustomizingSkinPaint         Request;                                           // 0x0008(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_CustomizingSkinPaint) == 0x000008, "Wrong alignment on FM1Request_CustomizingSkinPaint");
static_assert(sizeof(FM1Request_CustomizingSkinPaint) == 0x000018, "Wrong size on FM1Request_CustomizingSkinPaint");
static_assert(offsetof(FM1Request_CustomizingSkinPaint, AccountUid) == 0x000000, "Member 'FM1Request_CustomizingSkinPaint::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CustomizingSkinPaint, Request) == 0x000008, "Member 'FM1Request_CustomizingSkinPaint::Request' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatJoinDedicatedServerByAccountName_2
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CheatJoinDedicatedServerByAccountName_2 final : public FM1Request
{
public:
	class FString                                 AccountName;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatJoinDedicatedServerByAccountName_2) == 0x000008, "Wrong alignment on FM1Request_CheatJoinDedicatedServerByAccountName_2");
static_assert(sizeof(FM1Request_CheatJoinDedicatedServerByAccountName_2) == 0x000010, "Wrong size on FM1Request_CheatJoinDedicatedServerByAccountName_2");
static_assert(offsetof(FM1Request_CheatJoinDedicatedServerByAccountName_2, AccountName) == 0x000000, "Member 'FM1Request_CheatJoinDedicatedServerByAccountName_2::AccountName' has a wrong offset!");

// ScriptStruct M1.M1MovieSceneDialogTemplate
// 0x0008 (0x0028 - 0x0020)
struct FM1MovieSceneDialogTemplate final : public FMovieSceneEvalTemplate
{
public:
	class UM1MovieSceneDialogSection*             Section;                                           // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1MovieSceneDialogTemplate) == 0x000008, "Wrong alignment on FM1MovieSceneDialogTemplate");
static_assert(sizeof(FM1MovieSceneDialogTemplate) == 0x000028, "Wrong size on FM1MovieSceneDialogTemplate");
static_assert(offsetof(FM1MovieSceneDialogTemplate, Section) == 0x000020, "Member 'FM1MovieSceneDialogTemplate::Section' has a wrong offset!");

// ScriptStruct M1.M1Response_CustomizingWeapon
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_CustomizingWeapon final
{
public:
	EM1CustomizeReason                            Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CustomizingWeapon) == 0x000004, "Wrong alignment on FM1Response_CustomizingWeapon");
static_assert(sizeof(FM1Response_CustomizingWeapon) == 0x000004, "Wrong size on FM1Response_CustomizingWeapon");
static_assert(offsetof(FM1Response_CustomizingWeapon, Notification) == 0x000000, "Member 'FM1Response_CustomizingWeapon::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_RelocateDedicatedServer
// 0x0001 (0x0001 - 0x0000)
struct FM1Request_RelocateDedicatedServer final : public FM1Request
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_RelocateDedicatedServer) == 0x000001, "Wrong alignment on FM1Request_RelocateDedicatedServer");
static_assert(sizeof(FM1Request_RelocateDedicatedServer) == 0x000001, "Wrong size on FM1Request_RelocateDedicatedServer");

// ScriptStruct M1.M1Request_PartyJoinLobby
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_PartyJoinLobby final : public FM1Request
{
public:
	class FString                                 TargetName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_PartyJoinLobby) == 0x000008, "Wrong alignment on FM1Request_PartyJoinLobby");
static_assert(sizeof(FM1Request_PartyJoinLobby) == 0x000010, "Wrong size on FM1Request_PartyJoinLobby");
static_assert(offsetof(FM1Request_PartyJoinLobby, TargetName) == 0x000000, "Member 'FM1Request_PartyJoinLobby::TargetName' has a wrong offset!");

// ScriptStruct M1.M1MonsterLogic_Seudo_RandomWalkLocationsToVisit
// 0x0018 (0x0018 - 0x0000)
struct FM1MonsterLogic_Seudo_RandomWalkLocationsToVisit final
{
public:
	TArray<struct FVector>                        Locations;                                         // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         IndexToVisit;                                      // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MonsterLogic_Seudo_RandomWalkLocationsToVisit) == 0x000008, "Wrong alignment on FM1MonsterLogic_Seudo_RandomWalkLocationsToVisit");
static_assert(sizeof(FM1MonsterLogic_Seudo_RandomWalkLocationsToVisit) == 0x000018, "Wrong size on FM1MonsterLogic_Seudo_RandomWalkLocationsToVisit");
static_assert(offsetof(FM1MonsterLogic_Seudo_RandomWalkLocationsToVisit, Locations) == 0x000000, "Member 'FM1MonsterLogic_Seudo_RandomWalkLocationsToVisit::Locations' has a wrong offset!");
static_assert(offsetof(FM1MonsterLogic_Seudo_RandomWalkLocationsToVisit, IndexToVisit) == 0x000010, "Member 'FM1MonsterLogic_Seudo_RandomWalkLocationsToVisit::IndexToVisit' has a wrong offset!");

// ScriptStruct M1.M1MonsterLogic_Seudo_RandomWalkTreeContext
// 0x0070 (0x0070 - 0x0000)
struct FM1MonsterLogic_Seudo_RandomWalkTreeContext final
{
public:
	struct FM1MonsterLogic_Seudo_RandomWalkRoot   Root;                                              // 0x0000(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1MonsterLogic_Seudo_RandomWalkLocationsToVisit LeftSide;                                          // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FM1MonsterLogic_Seudo_RandomWalkLocationsToVisit RightSide;                                         // 0x0058(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterLogic_Seudo_RandomWalkTreeContext) == 0x000010, "Wrong alignment on FM1MonsterLogic_Seudo_RandomWalkTreeContext");
static_assert(sizeof(FM1MonsterLogic_Seudo_RandomWalkTreeContext) == 0x000070, "Wrong size on FM1MonsterLogic_Seudo_RandomWalkTreeContext");
static_assert(offsetof(FM1MonsterLogic_Seudo_RandomWalkTreeContext, Root) == 0x000000, "Member 'FM1MonsterLogic_Seudo_RandomWalkTreeContext::Root' has a wrong offset!");
static_assert(offsetof(FM1MonsterLogic_Seudo_RandomWalkTreeContext, LeftSide) == 0x000040, "Member 'FM1MonsterLogic_Seudo_RandomWalkTreeContext::LeftSide' has a wrong offset!");
static_assert(offsetof(FM1MonsterLogic_Seudo_RandomWalkTreeContext, RightSide) == 0x000058, "Member 'FM1MonsterLogic_Seudo_RandomWalkTreeContext::RightSide' has a wrong offset!");

// ScriptStruct M1.M1NXCreatorGradeInfo
// 0x0040 (0x0040 - 0x0000)
struct FM1NXCreatorGradeInfo final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Order;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ServiceId;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ImgUrl;                                            // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Color;                                             // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NXCreatorGradeInfo) == 0x000008, "Wrong alignment on FM1NXCreatorGradeInfo");
static_assert(sizeof(FM1NXCreatorGradeInfo) == 0x000040, "Wrong size on FM1NXCreatorGradeInfo");
static_assert(offsetof(FM1NXCreatorGradeInfo, ID) == 0x000000, "Member 'FM1NXCreatorGradeInfo::ID' has a wrong offset!");
static_assert(offsetof(FM1NXCreatorGradeInfo, Order) == 0x000004, "Member 'FM1NXCreatorGradeInfo::Order' has a wrong offset!");
static_assert(offsetof(FM1NXCreatorGradeInfo, ServiceId) == 0x000008, "Member 'FM1NXCreatorGradeInfo::ServiceId' has a wrong offset!");
static_assert(offsetof(FM1NXCreatorGradeInfo, Name) == 0x000010, "Member 'FM1NXCreatorGradeInfo::Name' has a wrong offset!");
static_assert(offsetof(FM1NXCreatorGradeInfo, ImgUrl) == 0x000020, "Member 'FM1NXCreatorGradeInfo::ImgUrl' has a wrong offset!");
static_assert(offsetof(FM1NXCreatorGradeInfo, Color) == 0x000030, "Member 'FM1NXCreatorGradeInfo::Color' has a wrong offset!");

// ScriptStruct M1.M1NXCreatorChannelInfo
// 0x0040 (0x0040 - 0x0000)
struct FM1NXCreatorChannelInfo final
{
public:
	int64                                         ID;                                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1CSPChannelPlatformType                     PlatformName;                                      // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         SubscriberCount;                                   // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 URL;                                               // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              RegisteredDate;                                    // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NXCreatorChannelInfo) == 0x000008, "Wrong alignment on FM1NXCreatorChannelInfo");
static_assert(sizeof(FM1NXCreatorChannelInfo) == 0x000040, "Wrong size on FM1NXCreatorChannelInfo");
static_assert(offsetof(FM1NXCreatorChannelInfo, ID) == 0x000000, "Member 'FM1NXCreatorChannelInfo::ID' has a wrong offset!");
static_assert(offsetof(FM1NXCreatorChannelInfo, PlatformName) == 0x000008, "Member 'FM1NXCreatorChannelInfo::PlatformName' has a wrong offset!");
static_assert(offsetof(FM1NXCreatorChannelInfo, SubscriberCount) == 0x000010, "Member 'FM1NXCreatorChannelInfo::SubscriberCount' has a wrong offset!");
static_assert(offsetof(FM1NXCreatorChannelInfo, Name) == 0x000018, "Member 'FM1NXCreatorChannelInfo::Name' has a wrong offset!");
static_assert(offsetof(FM1NXCreatorChannelInfo, URL) == 0x000028, "Member 'FM1NXCreatorChannelInfo::URL' has a wrong offset!");
static_assert(offsetof(FM1NXCreatorChannelInfo, RegisteredDate) == 0x000038, "Member 'FM1NXCreatorChannelInfo::RegisteredDate' has a wrong offset!");

// ScriptStruct M1.M1NXCreatorInfo
// 0x00B8 (0x00B8 - 0x0000)
struct FM1NXCreatorInfo final
{
public:
	class FString                                 CreatorCode;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Nickname;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ProfileImgUrl;                                     // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AboutMe;                                           // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         SupporterCount;                                    // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SupportUrl;                                        // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SupportUrlForGuest;                                // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NXCreatorGradeInfo                  GradeInfo;                                         // 0x0068(0x0040)(NativeAccessSpecifierPublic)
	TArray<struct FM1NXCreatorChannelInfo>        Channels;                                          // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NXCreatorInfo) == 0x000008, "Wrong alignment on FM1NXCreatorInfo");
static_assert(sizeof(FM1NXCreatorInfo) == 0x0000B8, "Wrong size on FM1NXCreatorInfo");
static_assert(offsetof(FM1NXCreatorInfo, CreatorCode) == 0x000000, "Member 'FM1NXCreatorInfo::CreatorCode' has a wrong offset!");
static_assert(offsetof(FM1NXCreatorInfo, Nickname) == 0x000010, "Member 'FM1NXCreatorInfo::Nickname' has a wrong offset!");
static_assert(offsetof(FM1NXCreatorInfo, ProfileImgUrl) == 0x000020, "Member 'FM1NXCreatorInfo::ProfileImgUrl' has a wrong offset!");
static_assert(offsetof(FM1NXCreatorInfo, AboutMe) == 0x000030, "Member 'FM1NXCreatorInfo::AboutMe' has a wrong offset!");
static_assert(offsetof(FM1NXCreatorInfo, SupporterCount) == 0x000040, "Member 'FM1NXCreatorInfo::SupporterCount' has a wrong offset!");
static_assert(offsetof(FM1NXCreatorInfo, SupportUrl) == 0x000048, "Member 'FM1NXCreatorInfo::SupportUrl' has a wrong offset!");
static_assert(offsetof(FM1NXCreatorInfo, SupportUrlForGuest) == 0x000058, "Member 'FM1NXCreatorInfo::SupportUrlForGuest' has a wrong offset!");
static_assert(offsetof(FM1NXCreatorInfo, GradeInfo) == 0x000068, "Member 'FM1NXCreatorInfo::GradeInfo' has a wrong offset!");
static_assert(offsetof(FM1NXCreatorInfo, Channels) == 0x0000A8, "Member 'FM1NXCreatorInfo::Channels' has a wrong offset!");

// ScriptStruct M1.M1NXSupporterInfo
// 0x00D8 (0x00D8 - 0x0000)
struct FM1NXSupporterInfo final
{
public:
	class FString                                 SupporterCode;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              RegisteredDate;                                    // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ExpirationDate;                                    // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NXCreatorInfo                       CreatorInfo;                                       // 0x0020(0x00B8)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NXSupporterInfo) == 0x000008, "Wrong alignment on FM1NXSupporterInfo");
static_assert(sizeof(FM1NXSupporterInfo) == 0x0000D8, "Wrong size on FM1NXSupporterInfo");
static_assert(offsetof(FM1NXSupporterInfo, SupporterCode) == 0x000000, "Member 'FM1NXSupporterInfo::SupporterCode' has a wrong offset!");
static_assert(offsetof(FM1NXSupporterInfo, RegisteredDate) == 0x000010, "Member 'FM1NXSupporterInfo::RegisteredDate' has a wrong offset!");
static_assert(offsetof(FM1NXSupporterInfo, ExpirationDate) == 0x000018, "Member 'FM1NXSupporterInfo::ExpirationDate' has a wrong offset!");
static_assert(offsetof(FM1NXSupporterInfo, CreatorInfo) == 0x000020, "Member 'FM1NXSupporterInfo::CreatorInfo' has a wrong offset!");

// ScriptStruct M1.M1NXReceiveMyCSPInfo
// 0x0190 (0x0190 - 0x0000)
struct FM1NXReceiveMyCSPInfo final
{
public:
	struct FM1NXCreatorInfo                       CreatorInfo;                                       // 0x0000(0x00B8)(NativeAccessSpecifierPublic)
	struct FM1NXSupporterInfo                     SupporterInfo;                                     // 0x00B8(0x00D8)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NXReceiveMyCSPInfo) == 0x000008, "Wrong alignment on FM1NXReceiveMyCSPInfo");
static_assert(sizeof(FM1NXReceiveMyCSPInfo) == 0x000190, "Wrong size on FM1NXReceiveMyCSPInfo");
static_assert(offsetof(FM1NXReceiveMyCSPInfo, CreatorInfo) == 0x000000, "Member 'FM1NXReceiveMyCSPInfo::CreatorInfo' has a wrong offset!");
static_assert(offsetof(FM1NXReceiveMyCSPInfo, SupporterInfo) == 0x0000B8, "Member 'FM1NXReceiveMyCSPInfo::SupporterInfo' has a wrong offset!");

// ScriptStruct M1.M1NXReceiveMyCSPInfoWrapper
// 0x0198 (0x0198 - 0x0000)
struct FM1NXReceiveMyCSPInfoWrapper final
{
public:
	int32                                         Code;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1NXReceiveMyCSPInfo                  Data;                                              // 0x0008(0x0190)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NXReceiveMyCSPInfoWrapper) == 0x000008, "Wrong alignment on FM1NXReceiveMyCSPInfoWrapper");
static_assert(sizeof(FM1NXReceiveMyCSPInfoWrapper) == 0x000198, "Wrong size on FM1NXReceiveMyCSPInfoWrapper");
static_assert(offsetof(FM1NXReceiveMyCSPInfoWrapper, Code) == 0x000000, "Member 'FM1NXReceiveMyCSPInfoWrapper::Code' has a wrong offset!");
static_assert(offsetof(FM1NXReceiveMyCSPInfoWrapper, Data) == 0x000008, "Member 'FM1NXReceiveMyCSPInfoWrapper::Data' has a wrong offset!");

// ScriptStruct M1.M1Response_CheckOntimeEvent
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheckOntimeEvent final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheckOntimeEvent) == 0x000001, "Wrong alignment on FM1Response_CheckOntimeEvent");
static_assert(sizeof(FM1Response_CheckOntimeEvent) == 0x000001, "Wrong size on FM1Response_CheckOntimeEvent");
static_assert(offsetof(FM1Response_CheckOntimeEvent, Notification) == 0x000000, "Member 'FM1Response_CheckOntimeEvent::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_RequestBaseItem
// 0x0004 (0x0004 - 0x0000)
struct FM1Request_RequestBaseItem final : public FM1Request
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_RequestBaseItem) == 0x000004, "Wrong alignment on FM1Request_RequestBaseItem");
static_assert(sizeof(FM1Request_RequestBaseItem) == 0x000004, "Wrong size on FM1Request_RequestBaseItem");
static_assert(offsetof(FM1Request_RequestBaseItem, TemplateId) == 0x000000, "Member 'FM1Request_RequestBaseItem::TemplateId' has a wrong offset!");

// ScriptStruct M1.M1ExclusiveBattleKeys
// 0x0050 (0x0050 - 0x0000)
struct FM1ExclusiveBattleKeys final
{
public:
	TSet<EM1BattleKey>                            ExclusiveBattleKeys;                               // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ExclusiveBattleKeys) == 0x000008, "Wrong alignment on FM1ExclusiveBattleKeys");
static_assert(sizeof(FM1ExclusiveBattleKeys) == 0x000050, "Wrong size on FM1ExclusiveBattleKeys");
static_assert(offsetof(FM1ExclusiveBattleKeys, ExclusiveBattleKeys) == 0x000000, "Member 'FM1ExclusiveBattleKeys::ExclusiveBattleKeys' has a wrong offset!");

// ScriptStruct M1.M1NxLogExtraInfo
// 0x0050 (0x0050 - 0x0000)
struct FM1NxLogExtraInfo final
{
public:
	class FString                                 Infodesc;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Infosubtype;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Infotype;                                          // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Infovalue;                                         // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Infovalue2;                                        // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLogExtraInfo) == 0x000008, "Wrong alignment on FM1NxLogExtraInfo");
static_assert(sizeof(FM1NxLogExtraInfo) == 0x000050, "Wrong size on FM1NxLogExtraInfo");
static_assert(offsetof(FM1NxLogExtraInfo, Infodesc) == 0x000000, "Member 'FM1NxLogExtraInfo::Infodesc' has a wrong offset!");
static_assert(offsetof(FM1NxLogExtraInfo, Infosubtype) == 0x000010, "Member 'FM1NxLogExtraInfo::Infosubtype' has a wrong offset!");
static_assert(offsetof(FM1NxLogExtraInfo, Infotype) == 0x000020, "Member 'FM1NxLogExtraInfo::Infotype' has a wrong offset!");
static_assert(offsetof(FM1NxLogExtraInfo, Infovalue) == 0x000030, "Member 'FM1NxLogExtraInfo::Infovalue' has a wrong offset!");
static_assert(offsetof(FM1NxLogExtraInfo, Infovalue2) == 0x000040, "Member 'FM1NxLogExtraInfo::Infovalue2' has a wrong offset!");

// ScriptStruct M1.M1NxLog_Play_PlayerFlow
// 0x0180 (0x0180 - 0x0000)
struct FM1NxLog_Play_PlayerFlow final
{
public:
	class FString                                 Actionid;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Contentsdifficulty;                                // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Contentsid;                                        // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Contentsmeta;                                      // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ContentsType;                                      // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Contentsuid;                                       // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        ElapsedTime;                                       // 0x0060(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 FieldId;                                           // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldUid;                                          // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PartyId;                                           // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Partymembercnt;                                    // 0x00A0(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Pcstatustype;                                      // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Pcplayendtype;                                     // 0x00C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Pctype;                                            // 0x00D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Playplayerflowmeta;                                // 0x00E0(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Playplayerflowtype;                                // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Userlevel;                                         // 0x0100(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Usernickname;                                      // 0x0110(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1NxLogExtraInfo>              Extrainfoarray;                                    // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Privateflag;                                       // 0x0130(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tfdplayeritemid;                                   // 0x0140(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Tfdplayeritemlevel;                                // 0x0150(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Contentsseasontype;                                // 0x0160(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Contentsseasonid;                                  // 0x0170(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_Play_PlayerFlow) == 0x000008, "Wrong alignment on FM1NxLog_Play_PlayerFlow");
static_assert(sizeof(FM1NxLog_Play_PlayerFlow) == 0x000180, "Wrong size on FM1NxLog_Play_PlayerFlow");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, Actionid) == 0x000000, "Member 'FM1NxLog_Play_PlayerFlow::Actionid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, Contentsdifficulty) == 0x000010, "Member 'FM1NxLog_Play_PlayerFlow::Contentsdifficulty' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, Contentsid) == 0x000020, "Member 'FM1NxLog_Play_PlayerFlow::Contentsid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, Contentsmeta) == 0x000030, "Member 'FM1NxLog_Play_PlayerFlow::Contentsmeta' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, ContentsType) == 0x000040, "Member 'FM1NxLog_Play_PlayerFlow::ContentsType' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, Contentsuid) == 0x000050, "Member 'FM1NxLog_Play_PlayerFlow::Contentsuid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, ElapsedTime) == 0x000060, "Member 'FM1NxLog_Play_PlayerFlow::ElapsedTime' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, FieldId) == 0x000070, "Member 'FM1NxLog_Play_PlayerFlow::FieldId' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, FieldUid) == 0x000080, "Member 'FM1NxLog_Play_PlayerFlow::FieldUid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, PartyId) == 0x000090, "Member 'FM1NxLog_Play_PlayerFlow::PartyId' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, Partymembercnt) == 0x0000A0, "Member 'FM1NxLog_Play_PlayerFlow::Partymembercnt' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, Pcstatustype) == 0x0000B0, "Member 'FM1NxLog_Play_PlayerFlow::Pcstatustype' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, Pcplayendtype) == 0x0000C0, "Member 'FM1NxLog_Play_PlayerFlow::Pcplayendtype' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, Pctype) == 0x0000D0, "Member 'FM1NxLog_Play_PlayerFlow::Pctype' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, Playplayerflowmeta) == 0x0000E0, "Member 'FM1NxLog_Play_PlayerFlow::Playplayerflowmeta' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, Playplayerflowtype) == 0x0000F0, "Member 'FM1NxLog_Play_PlayerFlow::Playplayerflowtype' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, Userlevel) == 0x000100, "Member 'FM1NxLog_Play_PlayerFlow::Userlevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, Usernickname) == 0x000110, "Member 'FM1NxLog_Play_PlayerFlow::Usernickname' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, Extrainfoarray) == 0x000120, "Member 'FM1NxLog_Play_PlayerFlow::Extrainfoarray' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, Privateflag) == 0x000130, "Member 'FM1NxLog_Play_PlayerFlow::Privateflag' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, Tfdplayeritemid) == 0x000140, "Member 'FM1NxLog_Play_PlayerFlow::Tfdplayeritemid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, Tfdplayeritemlevel) == 0x000150, "Member 'FM1NxLog_Play_PlayerFlow::Tfdplayeritemlevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, Contentsseasontype) == 0x000160, "Member 'FM1NxLog_Play_PlayerFlow::Contentsseasontype' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow, Contentsseasonid) == 0x000170, "Member 'FM1NxLog_Play_PlayerFlow::Contentsseasonid' has a wrong offset!");

// ScriptStruct M1.M1Request_GameServerMoveReq
// 0x0020 (0x0020 - 0x0000)
struct FM1Request_GameServerMoveReq final : public FM1Request
{
public:
	class FString                                 SessionToken;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LinkInfo;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_GameServerMoveReq) == 0x000008, "Wrong alignment on FM1Request_GameServerMoveReq");
static_assert(sizeof(FM1Request_GameServerMoveReq) == 0x000020, "Wrong size on FM1Request_GameServerMoveReq");
static_assert(offsetof(FM1Request_GameServerMoveReq, SessionToken) == 0x000000, "Member 'FM1Request_GameServerMoveReq::SessionToken' has a wrong offset!");
static_assert(offsetof(FM1Request_GameServerMoveReq, LinkInfo) == 0x000010, "Member 'FM1Request_GameServerMoveReq::LinkInfo' has a wrong offset!");

// ScriptStruct M1.M1Response_BuyLoadoutSlot
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_BuyLoadoutSlot final
{
public:
	EM1RuneReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_BuyLoadoutSlot) == 0x000004, "Wrong alignment on FM1Response_BuyLoadoutSlot");
static_assert(sizeof(FM1Response_BuyLoadoutSlot) == 0x000004, "Wrong size on FM1Response_BuyLoadoutSlot");
static_assert(offsetof(FM1Response_BuyLoadoutSlot, Notification) == 0x000000, "Member 'FM1Response_BuyLoadoutSlot::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_GamePlatformBlockUserSet
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_GamePlatformBlockUserSet final : public FM1Request
{
public:
	struct FM1PlatformBlockList                   Req;                                               // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_GamePlatformBlockUserSet) == 0x000008, "Wrong alignment on FM1Request_GamePlatformBlockUserSet");
static_assert(sizeof(FM1Request_GamePlatformBlockUserSet) == 0x000010, "Wrong size on FM1Request_GamePlatformBlockUserSet");
static_assert(offsetof(FM1Request_GamePlatformBlockUserSet, Req) == 0x000000, "Member 'FM1Request_GamePlatformBlockUserSet::Req' has a wrong offset!");

// ScriptStruct M1.M1CoverAttackCheckData
// 0x000C (0x000C - 0x0000)
struct FM1CoverAttackCheckData final
{
public:
	float                                         ZOffset;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackMoveDistance;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackableCheckDistance;                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CoverAttackCheckData) == 0x000004, "Wrong alignment on FM1CoverAttackCheckData");
static_assert(sizeof(FM1CoverAttackCheckData) == 0x00000C, "Wrong size on FM1CoverAttackCheckData");
static_assert(offsetof(FM1CoverAttackCheckData, ZOffset) == 0x000000, "Member 'FM1CoverAttackCheckData::ZOffset' has a wrong offset!");
static_assert(offsetof(FM1CoverAttackCheckData, AttackMoveDistance) == 0x000004, "Member 'FM1CoverAttackCheckData::AttackMoveDistance' has a wrong offset!");
static_assert(offsetof(FM1CoverAttackCheckData, AttackableCheckDistance) == 0x000008, "Member 'FM1CoverAttackCheckData::AttackableCheckDistance' has a wrong offset!");

// ScriptStruct M1.M1Request_InitializeCommunity
// 0x0001 (0x0001 - 0x0000)
struct FM1Request_InitializeCommunity final : public FM1Request
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_InitializeCommunity) == 0x000001, "Wrong alignment on FM1Request_InitializeCommunity");
static_assert(sizeof(FM1Request_InitializeCommunity) == 0x000001, "Wrong size on FM1Request_InitializeCommunity");

// ScriptStruct M1.M1Response_SavePreset
// 0x0008 (0x0008 - 0x0000)
struct FM1Response_SavePreset final
{
public:
	EM1PresetReason                               Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PresetIndex;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_SavePreset) == 0x000004, "Wrong alignment on FM1Response_SavePreset");
static_assert(sizeof(FM1Response_SavePreset) == 0x000008, "Wrong size on FM1Response_SavePreset");
static_assert(offsetof(FM1Response_SavePreset, Notification) == 0x000000, "Member 'FM1Response_SavePreset::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_SavePreset, PresetIndex) == 0x000004, "Member 'FM1Response_SavePreset::PresetIndex' has a wrong offset!");

// ScriptStruct M1.M1Request_ChattingMessage
// 0x0028 (0x0028 - 0x0000)
struct FM1Request_ChattingMessage final : public FM1Request
{
public:
	EM1ChattingType                               Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Language;                                          // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_ChattingMessage) == 0x000008, "Wrong alignment on FM1Request_ChattingMessage");
static_assert(sizeof(FM1Request_ChattingMessage) == 0x000028, "Wrong size on FM1Request_ChattingMessage");
static_assert(offsetof(FM1Request_ChattingMessage, Type) == 0x000000, "Member 'FM1Request_ChattingMessage::Type' has a wrong offset!");
static_assert(offsetof(FM1Request_ChattingMessage, Language) == 0x000008, "Member 'FM1Request_ChattingMessage::Language' has a wrong offset!");
static_assert(offsetof(FM1Request_ChattingMessage, Message) == 0x000018, "Member 'FM1Request_ChattingMessage::Message' has a wrong offset!");

// ScriptStruct M1.M1Request_SearchRequest
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_SearchRequest final : public FM1Request
{
public:
	EM1SearchType                                 SearchType;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SearchName;                                        // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_SearchRequest) == 0x000008, "Wrong alignment on FM1Request_SearchRequest");
static_assert(sizeof(FM1Request_SearchRequest) == 0x000018, "Wrong size on FM1Request_SearchRequest");
static_assert(offsetof(FM1Request_SearchRequest, SearchType) == 0x000000, "Member 'FM1Request_SearchRequest::SearchType' has a wrong offset!");
static_assert(offsetof(FM1Request_SearchRequest, SearchName) == 0x000008, "Member 'FM1Request_SearchRequest::SearchName' has a wrong offset!");

// ScriptStruct M1.M1TaskCollectionInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1TaskCollectionInfo final
{
public:
	class FName                                   CollectiblesName;                                  // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentCollectiblesCount;                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetCollectiblesCount;                           // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TaskCollectionInfo) == 0x000004, "Wrong alignment on FM1TaskCollectionInfo");
static_assert(sizeof(FM1TaskCollectionInfo) == 0x000010, "Wrong size on FM1TaskCollectionInfo");
static_assert(offsetof(FM1TaskCollectionInfo, CollectiblesName) == 0x000000, "Member 'FM1TaskCollectionInfo::CollectiblesName' has a wrong offset!");
static_assert(offsetof(FM1TaskCollectionInfo, CurrentCollectiblesCount) == 0x000008, "Member 'FM1TaskCollectionInfo::CurrentCollectiblesCount' has a wrong offset!");
static_assert(offsetof(FM1TaskCollectionInfo, TargetCollectiblesCount) == 0x00000C, "Member 'FM1TaskCollectionInfo::TargetCollectiblesCount' has a wrong offset!");

// ScriptStruct M1.M1Response_BuyItemRequest
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_BuyItemRequest final
{
public:
	struct FM1ShopBuyInfoBundle                   Notification;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_BuyItemRequest) == 0x000008, "Wrong alignment on FM1Response_BuyItemRequest");
static_assert(sizeof(FM1Response_BuyItemRequest) == 0x000010, "Wrong size on FM1Response_BuyItemRequest");
static_assert(offsetof(FM1Response_BuyItemRequest, Notification) == 0x000000, "Member 'FM1Response_BuyItemRequest::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_SearchRequestByAuthValue
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_SearchRequestByAuthValue final : public FM1Request
{
public:
	EM1SearchType                                 SearchType;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         AuthValue;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_SearchRequestByAuthValue) == 0x000008, "Wrong alignment on FM1Request_SearchRequestByAuthValue");
static_assert(sizeof(FM1Request_SearchRequestByAuthValue) == 0x000010, "Wrong size on FM1Request_SearchRequestByAuthValue");
static_assert(offsetof(FM1Request_SearchRequestByAuthValue, SearchType) == 0x000000, "Member 'FM1Request_SearchRequestByAuthValue::SearchType' has a wrong offset!");
static_assert(offsetof(FM1Request_SearchRequestByAuthValue, AuthValue) == 0x000008, "Member 'FM1Request_SearchRequestByAuthValue::AuthValue' has a wrong offset!");

// ScriptStruct M1.M1StatModifierHandle
// 0x0008 (0x0008 - 0x0000)
struct FM1StatModifierHandle final
{
public:
	EM1StatType                                   StatType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1StatModifierOp                             Op;                                                // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ModifierId;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StatModifierHandle) == 0x000004, "Wrong alignment on FM1StatModifierHandle");
static_assert(sizeof(FM1StatModifierHandle) == 0x000008, "Wrong size on FM1StatModifierHandle");
static_assert(offsetof(FM1StatModifierHandle, StatType) == 0x000000, "Member 'FM1StatModifierHandle::StatType' has a wrong offset!");
static_assert(offsetof(FM1StatModifierHandle, Op) == 0x000001, "Member 'FM1StatModifierHandle::Op' has a wrong offset!");
static_assert(offsetof(FM1StatModifierHandle, ModifierId) == 0x000004, "Member 'FM1StatModifierHandle::ModifierId' has a wrong offset!");

// ScriptStruct M1.M1EquippedPartsItemInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1EquippedPartsItemInfo final
{
public:
	int64                                         Uid;                                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          PartsTemplateId;                                   // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1StatModifierHandle>          OptionStatHandles;                                 // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EquippedPartsItemInfo) == 0x000008, "Wrong alignment on FM1EquippedPartsItemInfo");
static_assert(sizeof(FM1EquippedPartsItemInfo) == 0x000020, "Wrong size on FM1EquippedPartsItemInfo");
static_assert(offsetof(FM1EquippedPartsItemInfo, Uid) == 0x000000, "Member 'FM1EquippedPartsItemInfo::Uid' has a wrong offset!");
static_assert(offsetof(FM1EquippedPartsItemInfo, PartsTemplateId) == 0x000008, "Member 'FM1EquippedPartsItemInfo::PartsTemplateId' has a wrong offset!");
static_assert(offsetof(FM1EquippedPartsItemInfo, Level) == 0x00000C, "Member 'FM1EquippedPartsItemInfo::Level' has a wrong offset!");
static_assert(offsetof(FM1EquippedPartsItemInfo, OptionStatHandles) == 0x000010, "Member 'FM1EquippedPartsItemInfo::OptionStatHandles' has a wrong offset!");

// ScriptStruct M1.M1Response_BattlePassReset
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_BattlePassReset final
{
public:
	EM1BattlePassReason                           Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_BattlePassReset) == 0x000004, "Wrong alignment on FM1Response_BattlePassReset");
static_assert(sizeof(FM1Response_BattlePassReset) == 0x000004, "Wrong size on FM1Response_BattlePassReset");
static_assert(offsetof(FM1Response_BattlePassReset, Notification) == 0x000000, "Member 'FM1Response_BattlePassReset::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_UnblockRequest
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_UnblockRequest final : public FM1Request
{
public:
	class FString                                 TargetName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_UnblockRequest) == 0x000008, "Wrong alignment on FM1Request_UnblockRequest");
static_assert(sizeof(FM1Request_UnblockRequest) == 0x000010, "Wrong size on FM1Request_UnblockRequest");
static_assert(offsetof(FM1Request_UnblockRequest, TargetName) == 0x000000, "Member 'FM1Request_UnblockRequest::TargetName' has a wrong offset!");

// ScriptStruct M1.M1SpeedRandomRange
// 0x0008 (0x0008 - 0x0000)
struct FM1SpeedRandomRange final
{
public:
	float                                         MinRange;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SpeedRandomRange) == 0x000004, "Wrong alignment on FM1SpeedRandomRange");
static_assert(sizeof(FM1SpeedRandomRange) == 0x000008, "Wrong size on FM1SpeedRandomRange");
static_assert(offsetof(FM1SpeedRandomRange, MinRange) == 0x000000, "Member 'FM1SpeedRandomRange::MinRange' has a wrong offset!");
static_assert(offsetof(FM1SpeedRandomRange, MaxRange) == 0x000004, "Member 'FM1SpeedRandomRange::MaxRange' has a wrong offset!");

// ScriptStruct M1.M1Request_FriendPropertyInvoke
// 0x0001 (0x0001 - 0x0000)
struct FM1Request_FriendPropertyInvoke final : public FM1Request
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_FriendPropertyInvoke) == 0x000001, "Wrong alignment on FM1Request_FriendPropertyInvoke");
static_assert(sizeof(FM1Request_FriendPropertyInvoke) == 0x000001, "Wrong size on FM1Request_FriendPropertyInvoke");

// ScriptStruct M1.M1Response_RequestShopRestrictionInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_RequestShopRestrictionInfo final
{
public:
	struct FM1ShopRestrictionInfoBundle           Notification;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_RequestShopRestrictionInfo) == 0x000008, "Wrong alignment on FM1Response_RequestShopRestrictionInfo");
static_assert(sizeof(FM1Response_RequestShopRestrictionInfo) == 0x000010, "Wrong size on FM1Response_RequestShopRestrictionInfo");
static_assert(offsetof(FM1Response_RequestShopRestrictionInfo, Notification) == 0x000000, "Member 'FM1Response_RequestShopRestrictionInfo::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_FriendRequest
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_FriendRequest final : public FM1Request
{
public:
	class FString                                 FriendName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_FriendRequest) == 0x000008, "Wrong alignment on FM1Request_FriendRequest");
static_assert(sizeof(FM1Request_FriendRequest) == 0x000010, "Wrong size on FM1Request_FriendRequest");
static_assert(offsetof(FM1Request_FriendRequest, FriendName) == 0x000000, "Member 'FM1Request_FriendRequest::FriendName' has a wrong offset!");

// ScriptStruct M1.M1SpawnGroupIDSelector
// 0x0008 (0x0008 - 0x0000)
struct FM1SpawnGroupIDSelector final
{
public:
	class FName                                   SpawnGroupID;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SpawnGroupIDSelector) == 0x000004, "Wrong alignment on FM1SpawnGroupIDSelector");
static_assert(sizeof(FM1SpawnGroupIDSelector) == 0x000008, "Wrong size on FM1SpawnGroupIDSelector");
static_assert(offsetof(FM1SpawnGroupIDSelector, SpawnGroupID) == 0x000000, "Member 'FM1SpawnGroupIDSelector::SpawnGroupID' has a wrong offset!");

// ScriptStruct M1.M1Request_FriendAccept
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_FriendAccept final : public FM1Request
{
public:
	class FString                                 FriendName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Accept;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_FriendAccept) == 0x000008, "Wrong alignment on FM1Request_FriendAccept");
static_assert(sizeof(FM1Request_FriendAccept) == 0x000018, "Wrong size on FM1Request_FriendAccept");
static_assert(offsetof(FM1Request_FriendAccept, FriendName) == 0x000000, "Member 'FM1Request_FriendAccept::FriendName' has a wrong offset!");
static_assert(offsetof(FM1Request_FriendAccept, Accept) == 0x000010, "Member 'FM1Request_FriendAccept::Accept' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatAddSeasonExp
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_CheatAddSeasonExp final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Exp;                                               // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatAddSeasonExp) == 0x000008, "Wrong alignment on FM1Response_CheatAddSeasonExp");
static_assert(sizeof(FM1Response_CheatAddSeasonExp) == 0x000010, "Wrong size on FM1Response_CheatAddSeasonExp");
static_assert(offsetof(FM1Response_CheatAddSeasonExp, Notification) == 0x000000, "Member 'FM1Response_CheatAddSeasonExp::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_CheatAddSeasonExp, Exp) == 0x000008, "Member 'FM1Response_CheatAddSeasonExp::Exp' has a wrong offset!");

// ScriptStruct M1.M1Request_FriendDelete
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_FriendDelete final : public FM1Request
{
public:
	class FString                                 FriendName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_FriendDelete) == 0x000008, "Wrong alignment on FM1Request_FriendDelete");
static_assert(sizeof(FM1Request_FriendDelete) == 0x000010, "Wrong size on FM1Request_FriendDelete");
static_assert(offsetof(FM1Request_FriendDelete, FriendName) == 0x000000, "Member 'FM1Request_FriendDelete::FriendName' has a wrong offset!");

// ScriptStruct M1.M1Request_FriendBookmark
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_FriendBookmark final : public FM1Request
{
public:
	class FString                                 FriendName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BookMark;                                          // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_FriendBookmark) == 0x000008, "Wrong alignment on FM1Request_FriendBookmark");
static_assert(sizeof(FM1Request_FriendBookmark) == 0x000018, "Wrong size on FM1Request_FriendBookmark");
static_assert(offsetof(FM1Request_FriendBookmark, FriendName) == 0x000000, "Member 'FM1Request_FriendBookmark::FriendName' has a wrong offset!");
static_assert(offsetof(FM1Request_FriendBookmark, BookMark) == 0x000010, "Member 'FM1Request_FriendBookmark::BookMark' has a wrong offset!");

// ScriptStruct M1.M1DestructionCountInfo
// 0x000C (0x000C - 0x0000)
struct FM1DestructionCountInfo final
{
public:
	struct FM1TemplateId                          MissionTargetTemplateId;                           // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentDestructionCount;                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetDestructionCount;                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DestructionCountInfo) == 0x000004, "Wrong alignment on FM1DestructionCountInfo");
static_assert(sizeof(FM1DestructionCountInfo) == 0x00000C, "Wrong size on FM1DestructionCountInfo");
static_assert(offsetof(FM1DestructionCountInfo, MissionTargetTemplateId) == 0x000000, "Member 'FM1DestructionCountInfo::MissionTargetTemplateId' has a wrong offset!");
static_assert(offsetof(FM1DestructionCountInfo, CurrentDestructionCount) == 0x000004, "Member 'FM1DestructionCountInfo::CurrentDestructionCount' has a wrong offset!");
static_assert(offsetof(FM1DestructionCountInfo, TargetDestructionCount) == 0x000008, "Member 'FM1DestructionCountInfo::TargetDestructionCount' has a wrong offset!");

// ScriptStruct M1.M1Response_CancelResearch
// 0x0020 (0x0020 - 0x0000)
struct FM1Response_CancelResearch final
{
public:
	struct FM1ResearchResultNoti                  Notification;                                      // 0x0000(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CancelResearch) == 0x000008, "Wrong alignment on FM1Response_CancelResearch");
static_assert(sizeof(FM1Response_CancelResearch) == 0x000020, "Wrong size on FM1Response_CancelResearch");
static_assert(offsetof(FM1Response_CancelResearch, Notification) == 0x000000, "Member 'FM1Response_CancelResearch::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_ReportRequest
// 0x0038 (0x0038 - 0x0000)
struct FM1Request_ReportRequest final : public FM1Request
{
public:
	struct FM1CommunityReportInfo                 Info;                                              // 0x0000(0x0038)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_ReportRequest) == 0x000008, "Wrong alignment on FM1Request_ReportRequest");
static_assert(sizeof(FM1Request_ReportRequest) == 0x000038, "Wrong size on FM1Request_ReportRequest");
static_assert(offsetof(FM1Request_ReportRequest, Info) == 0x000000, "Member 'FM1Request_ReportRequest::Info' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatBlockPropertyInvoke
// 0x0001 (0x0001 - 0x0000)
struct FM1Request_CheatBlockPropertyInvoke final : public FM1Request
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_CheatBlockPropertyInvoke) == 0x000001, "Wrong alignment on FM1Request_CheatBlockPropertyInvoke");
static_assert(sizeof(FM1Request_CheatBlockPropertyInvoke) == 0x000001, "Wrong size on FM1Request_CheatBlockPropertyInvoke");

// ScriptStruct M1.M1MissionInstantBarrierSpawnInfo
// 0x0060 (0x0060 - 0x0000)
struct FM1MissionInstantBarrierSpawnInfo final
{
public:
	class FName                                   InstantDeathBarrierRowName;                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class UM1SpawnedActorTrait*>             InstantDeathBarrierTraits;                         // 0x0008(0x0050)(Edit, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         CorrectBarrierCount;                               // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IncorrectBarrierCount;                             // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionInstantBarrierSpawnInfo) == 0x000008, "Wrong alignment on FM1MissionInstantBarrierSpawnInfo");
static_assert(sizeof(FM1MissionInstantBarrierSpawnInfo) == 0x000060, "Wrong size on FM1MissionInstantBarrierSpawnInfo");
static_assert(offsetof(FM1MissionInstantBarrierSpawnInfo, InstantDeathBarrierRowName) == 0x000000, "Member 'FM1MissionInstantBarrierSpawnInfo::InstantDeathBarrierRowName' has a wrong offset!");
static_assert(offsetof(FM1MissionInstantBarrierSpawnInfo, InstantDeathBarrierTraits) == 0x000008, "Member 'FM1MissionInstantBarrierSpawnInfo::InstantDeathBarrierTraits' has a wrong offset!");
static_assert(offsetof(FM1MissionInstantBarrierSpawnInfo, CorrectBarrierCount) == 0x000058, "Member 'FM1MissionInstantBarrierSpawnInfo::CorrectBarrierCount' has a wrong offset!");
static_assert(offsetof(FM1MissionInstantBarrierSpawnInfo, IncorrectBarrierCount) == 0x00005C, "Member 'FM1MissionInstantBarrierSpawnInfo::IncorrectBarrierCount' has a wrong offset!");

// ScriptStruct M1.M1PostProcessMaterialEffectSoundInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1PostProcessMaterialEffectSoundInfo final
{
public:
	class UAkAudioEvent*                          ActivatedAkEvent;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDelay;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepeatDelay;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PostProcessMaterialEffectSoundInfo) == 0x000008, "Wrong alignment on FM1PostProcessMaterialEffectSoundInfo");
static_assert(sizeof(FM1PostProcessMaterialEffectSoundInfo) == 0x000010, "Wrong size on FM1PostProcessMaterialEffectSoundInfo");
static_assert(offsetof(FM1PostProcessMaterialEffectSoundInfo, ActivatedAkEvent) == 0x000000, "Member 'FM1PostProcessMaterialEffectSoundInfo::ActivatedAkEvent' has a wrong offset!");
static_assert(offsetof(FM1PostProcessMaterialEffectSoundInfo, StartDelay) == 0x000008, "Member 'FM1PostProcessMaterialEffectSoundInfo::StartDelay' has a wrong offset!");
static_assert(offsetof(FM1PostProcessMaterialEffectSoundInfo, RepeatDelay) == 0x00000C, "Member 'FM1PostProcessMaterialEffectSoundInfo::RepeatDelay' has a wrong offset!");

// ScriptStruct M1.M1Response_AcceptSupport
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_AcceptSupport final
{
public:
	EM1SupportReason                              Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_AcceptSupport) == 0x000004, "Wrong alignment on FM1Response_AcceptSupport");
static_assert(sizeof(FM1Response_AcceptSupport) == 0x000004, "Wrong size on FM1Response_AcceptSupport");
static_assert(offsetof(FM1Response_AcceptSupport, Notification) == 0x000000, "Member 'FM1Response_AcceptSupport::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatFriendRequestPropertyInvoke
// 0x0001 (0x0001 - 0x0000)
struct FM1Request_CheatFriendRequestPropertyInvoke final : public FM1Request
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_CheatFriendRequestPropertyInvoke) == 0x000001, "Wrong alignment on FM1Request_CheatFriendRequestPropertyInvoke");
static_assert(sizeof(FM1Request_CheatFriendRequestPropertyInvoke) == 0x000001, "Wrong size on FM1Request_CheatFriendRequestPropertyInvoke");

// ScriptStruct M1.M1PartsEffect
// 0x0070 (0x0070 - 0x0000)
struct FM1PartsEffect final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeOffset;                                    // 0x0010(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        FxToPlay;                                          // 0x0040(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEvent;                                           // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PartsEffect) == 0x000010, "Wrong alignment on FM1PartsEffect");
static_assert(sizeof(FM1PartsEffect) == 0x000070, "Wrong size on FM1PartsEffect");
static_assert(offsetof(FM1PartsEffect, SocketName) == 0x000000, "Member 'FM1PartsEffect::SocketName' has a wrong offset!");
static_assert(offsetof(FM1PartsEffect, RelativeOffset) == 0x000010, "Member 'FM1PartsEffect::RelativeOffset' has a wrong offset!");
static_assert(offsetof(FM1PartsEffect, FxToPlay) == 0x000040, "Member 'FM1PartsEffect::FxToPlay' has a wrong offset!");
static_assert(offsetof(FM1PartsEffect, AkEvent) == 0x000060, "Member 'FM1PartsEffect::AkEvent' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatSystemMessageEcho
// 0x0004 (0x0004 - 0x0000)
struct FM1Request_CheatSystemMessageEcho final : public FM1Request
{
public:
	EM1SystemMessageType                          Message;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatSystemMessageEcho) == 0x000004, "Wrong alignment on FM1Request_CheatSystemMessageEcho");
static_assert(sizeof(FM1Request_CheatSystemMessageEcho) == 0x000004, "Wrong size on FM1Request_CheatSystemMessageEcho");
static_assert(offsetof(FM1Request_CheatSystemMessageEcho, Message) == 0x000000, "Member 'FM1Request_CheatSystemMessageEcho::Message' has a wrong offset!");

// ScriptStruct M1.M1Response_RequestBattlePassLevelUp
// 0x0008 (0x0008 - 0x0000)
struct FM1Response_RequestBattlePassLevelUp final
{
public:
	EM1BattlePassReason                           Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BundleBuy;                                         // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Response_RequestBattlePassLevelUp) == 0x000004, "Wrong alignment on FM1Response_RequestBattlePassLevelUp");
static_assert(sizeof(FM1Response_RequestBattlePassLevelUp) == 0x000008, "Wrong size on FM1Response_RequestBattlePassLevelUp");
static_assert(offsetof(FM1Response_RequestBattlePassLevelUp, Notification) == 0x000000, "Member 'FM1Response_RequestBattlePassLevelUp::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_RequestBattlePassLevelUp, BundleBuy) == 0x000004, "Member 'FM1Response_RequestBattlePassLevelUp::BundleBuy' has a wrong offset!");

// ScriptStruct M1.M1Request_UpdateLastFieldDifficulty
// 0x0004 (0x0004 - 0x0000)
struct FM1Request_UpdateLastFieldDifficulty final : public FM1Request
{
public:
	int32                                         FieldDifficulty;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_UpdateLastFieldDifficulty) == 0x000004, "Wrong alignment on FM1Request_UpdateLastFieldDifficulty");
static_assert(sizeof(FM1Request_UpdateLastFieldDifficulty) == 0x000004, "Wrong size on FM1Request_UpdateLastFieldDifficulty");
static_assert(offsetof(FM1Request_UpdateLastFieldDifficulty, FieldDifficulty) == 0x000000, "Member 'FM1Request_UpdateLastFieldDifficulty::FieldDifficulty' has a wrong offset!");

// ScriptStruct M1.M1ProgressInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1ProgressInfo final
{
public:
	float                                         Ratio;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UM1ProgressBar*                         ProgressBar;                                       // 0x0008(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ProgressInfo) == 0x000008, "Wrong alignment on FM1ProgressInfo");
static_assert(sizeof(FM1ProgressInfo) == 0x000010, "Wrong size on FM1ProgressInfo");
static_assert(offsetof(FM1ProgressInfo, Ratio) == 0x000000, "Member 'FM1ProgressInfo::Ratio' has a wrong offset!");
static_assert(offsetof(FM1ProgressInfo, ProgressBar) == 0x000008, "Member 'FM1ProgressInfo::ProgressBar' has a wrong offset!");

// ScriptStruct M1.M1Request_NGSInitialize
// 0x0001 (0x0001 - 0x0000)
struct FM1Request_NGSInitialize final : public FM1Request
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_NGSInitialize) == 0x000001, "Wrong alignment on FM1Request_NGSInitialize");
static_assert(sizeof(FM1Request_NGSInitialize) == 0x000001, "Wrong size on FM1Request_NGSInitialize");

// ScriptStruct M1.M1Request_NGSData
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_NGSData final : public FM1Request
{
public:
	struct FM1NGSPacket                           Req;                                               // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_NGSData) == 0x000008, "Wrong alignment on FM1Request_NGSData");
static_assert(sizeof(FM1Request_NGSData) == 0x000010, "Wrong size on FM1Request_NGSData");
static_assert(offsetof(FM1Request_NGSData, Req) == 0x000000, "Member 'FM1Request_NGSData::Req' has a wrong offset!");

// ScriptStruct M1.M1Request_CashShopClickRecordNxLog
// 0x0030 (0x0030 - 0x0000)
struct FM1Request_CashShopClickRecordNxLog final : public FM1Request
{
public:
	struct FM1CashShopClickRecordNoti             Noti;                                              // 0x0000(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CashShopClickRecordNxLog) == 0x000008, "Wrong alignment on FM1Request_CashShopClickRecordNxLog");
static_assert(sizeof(FM1Request_CashShopClickRecordNxLog) == 0x000030, "Wrong size on FM1Request_CashShopClickRecordNxLog");
static_assert(offsetof(FM1Request_CashShopClickRecordNxLog, Noti) == 0x000000, "Member 'FM1Request_CashShopClickRecordNxLog::Noti' has a wrong offset!");

// ScriptStruct M1.M1NpcQuestDialogInfo
// 0x0028 (0x0028 - 0x0000)
struct FM1NpcQuestDialogInfo final
{
public:
	class UAnimSequence*                          StartAnimSequence;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LoopAnimSequence;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          EndAnimSequence;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPlayedDialogMontage;                           // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0xF];                                       // 0x0019(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1NpcQuestDialogInfo) == 0x000008, "Wrong alignment on FM1NpcQuestDialogInfo");
static_assert(sizeof(FM1NpcQuestDialogInfo) == 0x000028, "Wrong size on FM1NpcQuestDialogInfo");
static_assert(offsetof(FM1NpcQuestDialogInfo, StartAnimSequence) == 0x000000, "Member 'FM1NpcQuestDialogInfo::StartAnimSequence' has a wrong offset!");
static_assert(offsetof(FM1NpcQuestDialogInfo, LoopAnimSequence) == 0x000008, "Member 'FM1NpcQuestDialogInfo::LoopAnimSequence' has a wrong offset!");
static_assert(offsetof(FM1NpcQuestDialogInfo, EndAnimSequence) == 0x000010, "Member 'FM1NpcQuestDialogInfo::EndAnimSequence' has a wrong offset!");
static_assert(offsetof(FM1NpcQuestDialogInfo, bHasPlayedDialogMontage) == 0x000018, "Member 'FM1NpcQuestDialogInfo::bHasPlayedDialogMontage' has a wrong offset!");

// ScriptStruct M1.M1Response_SetTitle
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_SetTitle final
{
public:
	EM1TitleReason                                Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_SetTitle) == 0x000004, "Wrong alignment on FM1Response_SetTitle");
static_assert(sizeof(FM1Response_SetTitle) == 0x000004, "Wrong size on FM1Response_SetTitle");
static_assert(offsetof(FM1Response_SetTitle, Notification) == 0x000000, "Member 'FM1Response_SetTitle::Notification' has a wrong offset!");

// ScriptStruct M1.M1Notice_KickMessage
// 0x0018 (0x0018 - 0x0000)
struct FM1Notice_KickMessage final
{
public:
	struct FM1KickInfo                            Notification;                                      // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_KickMessage) == 0x000008, "Wrong alignment on FM1Notice_KickMessage");
static_assert(sizeof(FM1Notice_KickMessage) == 0x000018, "Wrong size on FM1Notice_KickMessage");
static_assert(offsetof(FM1Notice_KickMessage, Notification) == 0x000000, "Member 'FM1Notice_KickMessage::Notification' has a wrong offset!");

// ScriptStruct M1.M1Notice_JoinDedicatedServerResponse
// 0x00B0 (0x00B0 - 0x0000)
struct FM1Notice_JoinDedicatedServerResponse final
{
public:
	struct FM1JoinDedicatedServerRes              Notification;                                      // 0x0000(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_JoinDedicatedServerResponse) == 0x000008, "Wrong alignment on FM1Notice_JoinDedicatedServerResponse");
static_assert(sizeof(FM1Notice_JoinDedicatedServerResponse) == 0x0000B0, "Wrong size on FM1Notice_JoinDedicatedServerResponse");
static_assert(offsetof(FM1Notice_JoinDedicatedServerResponse, Notification) == 0x000000, "Member 'FM1Notice_JoinDedicatedServerResponse::Notification' has a wrong offset!");

// ScriptStruct M1.M1NpcDialogSequenceSettings
// 0x00B8 (0x00B8 - 0x0000)
struct FM1NpcDialogSequenceSettings final
{
public:
	TSoftObjectPtr<class ULevelSequence>          DialogLevelSequence;                               // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMovieSceneSequencePlaybackSettings    PlaybackSettings;                                  // 0x0030(0x0024)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCameraFocusSettings                   CameraFocusSettings;                               // 0x0058(0x0058)(Edit, NativeAccessSpecifierPublic)
	float                                         CameraFocalLength;                                 // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraAperture;                                    // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NpcDialogSequenceSettings) == 0x000008, "Wrong alignment on FM1NpcDialogSequenceSettings");
static_assert(sizeof(FM1NpcDialogSequenceSettings) == 0x0000B8, "Wrong size on FM1NpcDialogSequenceSettings");
static_assert(offsetof(FM1NpcDialogSequenceSettings, DialogLevelSequence) == 0x000000, "Member 'FM1NpcDialogSequenceSettings::DialogLevelSequence' has a wrong offset!");
static_assert(offsetof(FM1NpcDialogSequenceSettings, PlaybackSettings) == 0x000030, "Member 'FM1NpcDialogSequenceSettings::PlaybackSettings' has a wrong offset!");
static_assert(offsetof(FM1NpcDialogSequenceSettings, CameraFocusSettings) == 0x000058, "Member 'FM1NpcDialogSequenceSettings::CameraFocusSettings' has a wrong offset!");
static_assert(offsetof(FM1NpcDialogSequenceSettings, CameraFocalLength) == 0x0000B0, "Member 'FM1NpcDialogSequenceSettings::CameraFocalLength' has a wrong offset!");
static_assert(offsetof(FM1NpcDialogSequenceSettings, CameraAperture) == 0x0000B4, "Member 'FM1NpcDialogSequenceSettings::CameraAperture' has a wrong offset!");

// ScriptStruct M1.M1ItemServiceRuneDecomposeResult
// 0x0030 (0x0030 - 0x0000)
struct FM1ItemServiceRuneDecomposeResult final
{
public:
	EM1RuneReason                                 RuneReason;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1TemplateId>                  RuneTemplateIds;                                   // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 RuneEnchantLevels;                                 // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EM1ItemUidCompressionMethod                   CompressionMethod;                                 // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ItemServiceRuneDecomposeResult) == 0x000008, "Wrong alignment on FM1ItemServiceRuneDecomposeResult");
static_assert(sizeof(FM1ItemServiceRuneDecomposeResult) == 0x000030, "Wrong size on FM1ItemServiceRuneDecomposeResult");
static_assert(offsetof(FM1ItemServiceRuneDecomposeResult, RuneReason) == 0x000000, "Member 'FM1ItemServiceRuneDecomposeResult::RuneReason' has a wrong offset!");
static_assert(offsetof(FM1ItemServiceRuneDecomposeResult, RuneTemplateIds) == 0x000008, "Member 'FM1ItemServiceRuneDecomposeResult::RuneTemplateIds' has a wrong offset!");
static_assert(offsetof(FM1ItemServiceRuneDecomposeResult, RuneEnchantLevels) == 0x000018, "Member 'FM1ItemServiceRuneDecomposeResult::RuneEnchantLevels' has a wrong offset!");
static_assert(offsetof(FM1ItemServiceRuneDecomposeResult, CompressionMethod) == 0x000028, "Member 'FM1ItemServiceRuneDecomposeResult::CompressionMethod' has a wrong offset!");

// ScriptStruct M1.M1Response_GetSeasonInfo
// 0x0030 (0x0030 - 0x0000)
struct FM1Response_GetSeasonInfo final
{
public:
	struct FM1SeasonInfo                          Notification;                                      // 0x0000(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_GetSeasonInfo) == 0x000008, "Wrong alignment on FM1Response_GetSeasonInfo");
static_assert(sizeof(FM1Response_GetSeasonInfo) == 0x000030, "Wrong size on FM1Response_GetSeasonInfo");
static_assert(offsetof(FM1Response_GetSeasonInfo, Notification) == 0x000000, "Member 'FM1Response_GetSeasonInfo::Notification' has a wrong offset!");

// ScriptStruct M1.M1Notice_NoticePartyJoinLobbyErrorMessage
// 0x0048 (0x0048 - 0x0000)
struct FM1Notice_NoticePartyJoinLobbyErrorMessage final
{
public:
	struct FM1PartyErrorMessageNoti               Notification;                                      // 0x0000(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_NoticePartyJoinLobbyErrorMessage) == 0x000008, "Wrong alignment on FM1Notice_NoticePartyJoinLobbyErrorMessage");
static_assert(sizeof(FM1Notice_NoticePartyJoinLobbyErrorMessage) == 0x000048, "Wrong size on FM1Notice_NoticePartyJoinLobbyErrorMessage");
static_assert(offsetof(FM1Notice_NoticePartyJoinLobbyErrorMessage, Notification) == 0x000000, "Member 'FM1Notice_NoticePartyJoinLobbyErrorMessage::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_GetCodexTrackingList
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_GetCodexTrackingList final
{
public:
	struct FM1CodexTrackingList                   Notification;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_GetCodexTrackingList) == 0x000008, "Wrong alignment on FM1Response_GetCodexTrackingList");
static_assert(sizeof(FM1Response_GetCodexTrackingList) == 0x000010, "Wrong size on FM1Response_GetCodexTrackingList");
static_assert(offsetof(FM1Response_GetCodexTrackingList, Notification) == 0x000000, "Member 'FM1Response_GetCodexTrackingList::Notification' has a wrong offset!");

// ScriptStruct M1.M1Notice_GameServerMoveNoti
// 0x0048 (0x0048 - 0x0000)
struct FM1Notice_GameServerMoveNoti final
{
public:
	struct FM1GameServerMoveData                  Notification;                                      // 0x0000(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_GameServerMoveNoti) == 0x000008, "Wrong alignment on FM1Notice_GameServerMoveNoti");
static_assert(sizeof(FM1Notice_GameServerMoveNoti) == 0x000048, "Wrong size on FM1Notice_GameServerMoveNoti");
static_assert(offsetof(FM1Notice_GameServerMoveNoti, Notification) == 0x000000, "Member 'FM1Notice_GameServerMoveNoti::Notification' has a wrong offset!");

// ScriptStruct M1.M1Notice_MailDeleteNoti
// 0x0018 (0x0018 - 0x0000)
struct FM1Notice_MailDeleteNoti final
{
public:
	struct FM1MailDeletePushInfo                  Notification;                                      // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_MailDeleteNoti) == 0x000008, "Wrong alignment on FM1Notice_MailDeleteNoti");
static_assert(sizeof(FM1Notice_MailDeleteNoti) == 0x000018, "Wrong size on FM1Notice_MailDeleteNoti");
static_assert(offsetof(FM1Notice_MailDeleteNoti, Notification) == 0x000000, "Member 'FM1Notice_MailDeleteNoti::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_ChattingMessage
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_ChattingMessage final
{
public:
	EM1ChattingErrorCode                          Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_ChattingMessage) == 0x000004, "Wrong alignment on FM1Response_ChattingMessage");
static_assert(sizeof(FM1Response_ChattingMessage) == 0x000004, "Wrong size on FM1Response_ChattingMessage");
static_assert(offsetof(FM1Response_ChattingMessage, Notification) == 0x000000, "Member 'FM1Response_ChattingMessage::Notification' has a wrong offset!");

// ScriptStruct M1.M1Notice_SearchResponse
// 0x0068 (0x0068 - 0x0000)
struct FM1Notice_SearchResponse final
{
public:
	struct FM1SearchResponse                      Notification;                                      // 0x0000(0x0068)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_SearchResponse) == 0x000008, "Wrong alignment on FM1Notice_SearchResponse");
static_assert(sizeof(FM1Notice_SearchResponse) == 0x000068, "Wrong size on FM1Notice_SearchResponse");
static_assert(offsetof(FM1Notice_SearchResponse, Notification) == 0x000000, "Member 'FM1Notice_SearchResponse::Notification' has a wrong offset!");

// ScriptStruct M1.M1NxLogItemChangeInfo
// 0x0070 (0x0070 - 0x0000)
struct FM1NxLogItemChangeInfo final
{
public:
	class FString                                 Itemflowtype;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemUid;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Itemidcategory;                                    // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemId;                                            // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Itemchangecnt;                                     // 0x0040(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Itemchangebef;                                     // 0x0050(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Itemchangeaft;                                     // 0x0060(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLogItemChangeInfo) == 0x000008, "Wrong alignment on FM1NxLogItemChangeInfo");
static_assert(sizeof(FM1NxLogItemChangeInfo) == 0x000070, "Wrong size on FM1NxLogItemChangeInfo");
static_assert(offsetof(FM1NxLogItemChangeInfo, Itemflowtype) == 0x000000, "Member 'FM1NxLogItemChangeInfo::Itemflowtype' has a wrong offset!");
static_assert(offsetof(FM1NxLogItemChangeInfo, ItemUid) == 0x000010, "Member 'FM1NxLogItemChangeInfo::ItemUid' has a wrong offset!");
static_assert(offsetof(FM1NxLogItemChangeInfo, Itemidcategory) == 0x000020, "Member 'FM1NxLogItemChangeInfo::Itemidcategory' has a wrong offset!");
static_assert(offsetof(FM1NxLogItemChangeInfo, ItemId) == 0x000030, "Member 'FM1NxLogItemChangeInfo::ItemId' has a wrong offset!");
static_assert(offsetof(FM1NxLogItemChangeInfo, Itemchangecnt) == 0x000040, "Member 'FM1NxLogItemChangeInfo::Itemchangecnt' has a wrong offset!");
static_assert(offsetof(FM1NxLogItemChangeInfo, Itemchangebef) == 0x000050, "Member 'FM1NxLogItemChangeInfo::Itemchangebef' has a wrong offset!");
static_assert(offsetof(FM1NxLogItemChangeInfo, Itemchangeaft) == 0x000060, "Member 'FM1NxLogItemChangeInfo::Itemchangeaft' has a wrong offset!");

// ScriptStruct M1.M1Notice_NoticeBlockUpdate
// 0x0018 (0x0018 - 0x0000)
struct FM1Notice_NoticeBlockUpdate final
{
public:
	struct FM1BlockList                           Notification;                                      // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_NoticeBlockUpdate) == 0x000008, "Wrong alignment on FM1Notice_NoticeBlockUpdate");
static_assert(sizeof(FM1Notice_NoticeBlockUpdate) == 0x000018, "Wrong size on FM1Notice_NoticeBlockUpdate");
static_assert(offsetof(FM1Notice_NoticeBlockUpdate, Notification) == 0x000000, "Member 'FM1Notice_NoticeBlockUpdate::Notification' has a wrong offset!");

// ScriptStruct M1.M1GameServiceAnnounceToClient
// 0x0010 (0x0010 - 0x0000)
struct FM1GameServiceAnnounceToClient final
{
public:
	class FString                                 Context;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GameServiceAnnounceToClient) == 0x000008, "Wrong alignment on FM1GameServiceAnnounceToClient");
static_assert(sizeof(FM1GameServiceAnnounceToClient) == 0x000010, "Wrong size on FM1GameServiceAnnounceToClient");
static_assert(offsetof(FM1GameServiceAnnounceToClient, Context) == 0x000000, "Member 'FM1GameServiceAnnounceToClient::Context' has a wrong offset!");

// ScriptStruct M1.M1AbilityEventData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FM1AbilityEventData
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AbilityEventData) == 0x000008, "Wrong alignment on FM1AbilityEventData");
static_assert(sizeof(FM1AbilityEventData) == 0x000008, "Wrong size on FM1AbilityEventData");

// ScriptStruct M1.M1Notice_NoticeBlockMessage
// 0x0004 (0x0004 - 0x0000)
struct FM1Notice_NoticeBlockMessage final
{
public:
	EM1BlockErrorCode                             Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_NoticeBlockMessage) == 0x000004, "Wrong alignment on FM1Notice_NoticeBlockMessage");
static_assert(sizeof(FM1Notice_NoticeBlockMessage) == 0x000004, "Wrong size on FM1Notice_NoticeBlockMessage");
static_assert(offsetof(FM1Notice_NoticeBlockMessage, Notification) == 0x000000, "Member 'FM1Notice_NoticeBlockMessage::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatResetQuest
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CheatResetQuest final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          QuestTid;                                          // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_CheatResetQuest) == 0x000008, "Wrong alignment on FM1Request_CheatResetQuest");
static_assert(sizeof(FM1Request_CheatResetQuest) == 0x000010, "Wrong size on FM1Request_CheatResetQuest");
static_assert(offsetof(FM1Request_CheatResetQuest, AccountUid) == 0x000000, "Member 'FM1Request_CheatResetQuest::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatResetQuest, QuestTid) == 0x000008, "Member 'FM1Request_CheatResetQuest::QuestTid' has a wrong offset!");

// ScriptStruct M1.M1Notice_NoticeFriendUpdate
// 0x0018 (0x0018 - 0x0000)
struct FM1Notice_NoticeFriendUpdate final
{
public:
	struct FM1FriendList                          Notification;                                      // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_NoticeFriendUpdate) == 0x000008, "Wrong alignment on FM1Notice_NoticeFriendUpdate");
static_assert(sizeof(FM1Notice_NoticeFriendUpdate) == 0x000018, "Wrong size on FM1Notice_NoticeFriendUpdate");
static_assert(offsetof(FM1Notice_NoticeFriendUpdate, Notification) == 0x000000, "Member 'FM1Notice_NoticeFriendUpdate::Notification' has a wrong offset!");

// ScriptStruct M1.M1Notice_NoticeFriendRequestUpdate
// 0x0018 (0x0018 - 0x0000)
struct FM1Notice_NoticeFriendRequestUpdate final
{
public:
	struct FM1FriendRequestList                   Notification;                                      // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_NoticeFriendRequestUpdate) == 0x000008, "Wrong alignment on FM1Notice_NoticeFriendRequestUpdate");
static_assert(sizeof(FM1Notice_NoticeFriendRequestUpdate) == 0x000018, "Wrong size on FM1Notice_NoticeFriendRequestUpdate");
static_assert(offsetof(FM1Notice_NoticeFriendRequestUpdate, Notification) == 0x000000, "Member 'FM1Notice_NoticeFriendRequestUpdate::Notification' has a wrong offset!");

// ScriptStruct M1.M1GameGuideHighlightOption
// 0x0002 (0x0002 - 0x0000)
struct FM1GameGuideHighlightOption final
{
public:
	bool                                          bHighlightFrame;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBackgroundDimmed;                                 // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GameGuideHighlightOption) == 0x000001, "Wrong alignment on FM1GameGuideHighlightOption");
static_assert(sizeof(FM1GameGuideHighlightOption) == 0x000002, "Wrong size on FM1GameGuideHighlightOption");
static_assert(offsetof(FM1GameGuideHighlightOption, bHighlightFrame) == 0x000000, "Member 'FM1GameGuideHighlightOption::bHighlightFrame' has a wrong offset!");
static_assert(offsetof(FM1GameGuideHighlightOption, bBackgroundDimmed) == 0x000001, "Member 'FM1GameGuideHighlightOption::bBackgroundDimmed' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatUnlockBattleZone
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CheatUnlockBattleZone final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MapTemplateId;                                     // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          BattleZoneId;                                      // 0x000C(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatUnlockBattleZone) == 0x000008, "Wrong alignment on FM1Request_CheatUnlockBattleZone");
static_assert(sizeof(FM1Request_CheatUnlockBattleZone) == 0x000010, "Wrong size on FM1Request_CheatUnlockBattleZone");
static_assert(offsetof(FM1Request_CheatUnlockBattleZone, AccountUid) == 0x000000, "Member 'FM1Request_CheatUnlockBattleZone::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatUnlockBattleZone, MapTemplateId) == 0x000008, "Member 'FM1Request_CheatUnlockBattleZone::MapTemplateId' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatUnlockBattleZone, BattleZoneId) == 0x00000C, "Member 'FM1Request_CheatUnlockBattleZone::BattleZoneId' has a wrong offset!");

// ScriptStruct M1.M1UIEvent_EnemyHit
// 0x00F0 (0x00F0 - 0x0000)
struct alignas(0x08) FM1UIEvent_EnemyHit final
{
public:
	uint8                                         Pad_0[0xF0];                                       // 0x0000(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_EnemyHit) == 0x000008, "Wrong alignment on FM1UIEvent_EnemyHit");
static_assert(sizeof(FM1UIEvent_EnemyHit) == 0x0000F0, "Wrong size on FM1UIEvent_EnemyHit");

// ScriptStruct M1.M1Notice_NoticeFriendMessage
// 0x0030 (0x0030 - 0x0000)
struct FM1Notice_NoticeFriendMessage final
{
public:
	struct FM1FriendErrorMessageNoti              Notification;                                      // 0x0000(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_NoticeFriendMessage) == 0x000008, "Wrong alignment on FM1Notice_NoticeFriendMessage");
static_assert(sizeof(FM1Notice_NoticeFriendMessage) == 0x000030, "Wrong size on FM1Notice_NoticeFriendMessage");
static_assert(offsetof(FM1Notice_NoticeFriendMessage, Notification) == 0x000000, "Member 'FM1Notice_NoticeFriendMessage::Notification' has a wrong offset!");

// ScriptStruct M1.M1BattleInputChord
// 0x0040 (0x0040 - 0x0000)
struct FM1BattleInputChord final
{
public:
	struct FInputChord                            Chord;                                             // 0x0000(0x0020)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputChord                            SupportChord;                                      // 0x0020(0x0020)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattleInputChord) == 0x000008, "Wrong alignment on FM1BattleInputChord");
static_assert(sizeof(FM1BattleInputChord) == 0x000040, "Wrong size on FM1BattleInputChord");
static_assert(offsetof(FM1BattleInputChord, Chord) == 0x000000, "Member 'FM1BattleInputChord::Chord' has a wrong offset!");
static_assert(offsetof(FM1BattleInputChord, SupportChord) == 0x000020, "Member 'FM1BattleInputChord::SupportChord' has a wrong offset!");

// ScriptStruct M1.M1BattleKeySet
// 0x0048 (0x0048 - 0x0000)
struct FM1BattleKeySet final
{
public:
	EM1BattleKey                                  GameKey;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1BattleInputChord                    Chord;                                             // 0x0008(0x0040)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattleKeySet) == 0x000008, "Wrong alignment on FM1BattleKeySet");
static_assert(sizeof(FM1BattleKeySet) == 0x000048, "Wrong size on FM1BattleKeySet");
static_assert(offsetof(FM1BattleKeySet, GameKey) == 0x000000, "Member 'FM1BattleKeySet::GameKey' has a wrong offset!");
static_assert(offsetof(FM1BattleKeySet, Chord) == 0x000008, "Member 'FM1BattleKeySet::Chord' has a wrong offset!");

// ScriptStruct M1.M1Response_ReportRequest
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_ReportRequest final
{
public:
	EM1ReportErrorCode                            Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_ReportRequest) == 0x000004, "Wrong alignment on FM1Response_ReportRequest");
static_assert(sizeof(FM1Response_ReportRequest) == 0x000004, "Wrong size on FM1Response_ReportRequest");
static_assert(offsetof(FM1Response_ReportRequest, Notification) == 0x000000, "Member 'FM1Response_ReportRequest::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatMasteryExpUp
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CheatMasteryExpUp final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Exp;                                               // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatMasteryExpUp) == 0x000008, "Wrong alignment on FM1Request_CheatMasteryExpUp");
static_assert(sizeof(FM1Request_CheatMasteryExpUp) == 0x000010, "Wrong size on FM1Request_CheatMasteryExpUp");
static_assert(offsetof(FM1Request_CheatMasteryExpUp, AccountUid) == 0x000000, "Member 'FM1Request_CheatMasteryExpUp::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatMasteryExpUp, Exp) == 0x000008, "Member 'FM1Request_CheatMasteryExpUp::Exp' has a wrong offset!");

// ScriptStruct M1.M1Notice_AnnounceToClient
// 0x0018 (0x0018 - 0x0000)
struct FM1Notice_AnnounceToClient final
{
public:
	struct FM1AnnouncementNoti                    Notification;                                      // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_AnnounceToClient) == 0x000008, "Wrong alignment on FM1Notice_AnnounceToClient");
static_assert(sizeof(FM1Notice_AnnounceToClient) == 0x000018, "Wrong size on FM1Notice_AnnounceToClient");
static_assert(offsetof(FM1Notice_AnnounceToClient, Notification) == 0x000000, "Member 'FM1Notice_AnnounceToClient::Notification' has a wrong offset!");

// ScriptStruct M1.M1OptionValueAxisSetting
// 0x0038 (0x0038 - 0x0000)
struct FM1OptionValueAxisSetting final
{
public:
	EM1BattleAxis                                 BattleAxis;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1AxisScaleSign                              Sign;                                              // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   MainKey;                                           // 0x0008(0x0018)(Edit, DisableEditOnInstance, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   SubKey;                                            // 0x0020(0x0018)(Edit, DisableEditOnInstance, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1OptionValueAxisSetting) == 0x000008, "Wrong alignment on FM1OptionValueAxisSetting");
static_assert(sizeof(FM1OptionValueAxisSetting) == 0x000038, "Wrong size on FM1OptionValueAxisSetting");
static_assert(offsetof(FM1OptionValueAxisSetting, BattleAxis) == 0x000000, "Member 'FM1OptionValueAxisSetting::BattleAxis' has a wrong offset!");
static_assert(offsetof(FM1OptionValueAxisSetting, Sign) == 0x000001, "Member 'FM1OptionValueAxisSetting::Sign' has a wrong offset!");
static_assert(offsetof(FM1OptionValueAxisSetting, MainKey) == 0x000008, "Member 'FM1OptionValueAxisSetting::MainKey' has a wrong offset!");
static_assert(offsetof(FM1OptionValueAxisSetting, SubKey) == 0x000020, "Member 'FM1OptionValueAxisSetting::SubKey' has a wrong offset!");

// ScriptStruct M1.M1Response_NGSInitialize
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_NGSInitialize final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_NGSInitialize) == 0x000001, "Wrong alignment on FM1Response_NGSInitialize");
static_assert(sizeof(FM1Response_NGSInitialize) == 0x000001, "Wrong size on FM1Response_NGSInitialize");
static_assert(offsetof(FM1Response_NGSInitialize, Notification) == 0x000000, "Member 'FM1Response_NGSInitialize::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_CheckOntimeEvent
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_CheckOntimeEvent final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheckOntimeEvent) == 0x000008, "Wrong alignment on FM1Request_CheckOntimeEvent");
static_assert(sizeof(FM1Request_CheckOntimeEvent) == 0x000008, "Wrong size on FM1Request_CheckOntimeEvent");
static_assert(offsetof(FM1Request_CheckOntimeEvent, AccountUid) == 0x000000, "Member 'FM1Request_CheckOntimeEvent::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Notice_NGSDataNoti
// 0x0010 (0x0010 - 0x0000)
struct FM1Notice_NGSDataNoti final
{
public:
	struct FM1NGSPacket                           Notification;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_NGSDataNoti) == 0x000008, "Wrong alignment on FM1Notice_NGSDataNoti");
static_assert(sizeof(FM1Notice_NGSDataNoti) == 0x000010, "Wrong size on FM1Notice_NGSDataNoti");
static_assert(offsetof(FM1Notice_NGSDataNoti, Notification) == 0x000000, "Member 'FM1Notice_NGSDataNoti::Notification' has a wrong offset!");

// ScriptStruct M1.M1Notice_NGSClientKickNoti
// 0x0004 (0x0004 - 0x0000)
struct FM1Notice_NGSClientKickNoti final
{
public:
	uint32                                        Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_NGSClientKickNoti) == 0x000004, "Wrong alignment on FM1Notice_NGSClientKickNoti");
static_assert(sizeof(FM1Notice_NGSClientKickNoti) == 0x000004, "Wrong size on FM1Notice_NGSClientKickNoti");
static_assert(offsetof(FM1Notice_NGSClientKickNoti, Notification) == 0x000000, "Member 'FM1Notice_NGSClientKickNoti::Notification' has a wrong offset!");

// ScriptStruct M1.M1UIBattlePassBG
// 0x0060 (0x0068 - 0x0008)
struct FM1UIBattlePassBG final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        MainBGImagePath;                                   // 0x0008(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PremiumBGImagePath;                                // 0x0028(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ShopBGImagePath;                                   // 0x0048(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1UIBattlePassBG) == 0x000008, "Wrong alignment on FM1UIBattlePassBG");
static_assert(sizeof(FM1UIBattlePassBG) == 0x000068, "Wrong size on FM1UIBattlePassBG");
static_assert(offsetof(FM1UIBattlePassBG, MainBGImagePath) == 0x000008, "Member 'FM1UIBattlePassBG::MainBGImagePath' has a wrong offset!");
static_assert(offsetof(FM1UIBattlePassBG, PremiumBGImagePath) == 0x000028, "Member 'FM1UIBattlePassBG::PremiumBGImagePath' has a wrong offset!");
static_assert(offsetof(FM1UIBattlePassBG, ShopBGImagePath) == 0x000048, "Member 'FM1UIBattlePassBG::ShopBGImagePath' has a wrong offset!");

// ScriptStruct M1.M1Request_CancelMatching
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_CancelMatching final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CancelMatching) == 0x000008, "Wrong alignment on FM1Request_CancelMatching");
static_assert(sizeof(FM1Request_CancelMatching) == 0x000008, "Wrong size on FM1Request_CancelMatching");
static_assert(offsetof(FM1Request_CancelMatching, AccountUid) == 0x000000, "Member 'FM1Request_CancelMatching::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_GetAccountInfo
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_GetAccountInfo final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_GetAccountInfo) == 0x000008, "Wrong alignment on FM1Request_GetAccountInfo");
static_assert(sizeof(FM1Request_GetAccountInfo) == 0x000008, "Wrong size on FM1Request_GetAccountInfo");
static_assert(offsetof(FM1Request_GetAccountInfo, AccountUid) == 0x000000, "Member 'FM1Request_GetAccountInfo::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_SetQuestTracker
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_SetQuestTracker final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          PrequestTid;                                       // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          QuestTid;                                          // 0x000C(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_SetQuestTracker) == 0x000008, "Wrong alignment on FM1Request_SetQuestTracker");
static_assert(sizeof(FM1Request_SetQuestTracker) == 0x000010, "Wrong size on FM1Request_SetQuestTracker");
static_assert(offsetof(FM1Request_SetQuestTracker, AccountUid) == 0x000000, "Member 'FM1Request_SetQuestTracker::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_SetQuestTracker, PrequestTid) == 0x000008, "Member 'FM1Request_SetQuestTracker::PrequestTid' has a wrong offset!");
static_assert(offsetof(FM1Request_SetQuestTracker, QuestTid) == 0x00000C, "Member 'FM1Request_SetQuestTracker::QuestTid' has a wrong offset!");

// ScriptStruct M1.M1UIEvent_ChangedQuickSlotGroup
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FM1UIEvent_ChangedQuickSlotGroup final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_ChangedQuickSlotGroup) == 0x000004, "Wrong alignment on FM1UIEvent_ChangedQuickSlotGroup");
static_assert(sizeof(FM1UIEvent_ChangedQuickSlotGroup) == 0x000004, "Wrong size on FM1UIEvent_ChangedQuickSlotGroup");

// ScriptStruct M1.M1Request_PartyAccept
// 0x0020 (0x0020 - 0x0000)
struct FM1Request_PartyAccept final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RequesterName;                                     // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1PartyErrorCode                             Accept;                                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_PartyAccept) == 0x000008, "Wrong alignment on FM1Request_PartyAccept");
static_assert(sizeof(FM1Request_PartyAccept) == 0x000020, "Wrong size on FM1Request_PartyAccept");
static_assert(offsetof(FM1Request_PartyAccept, AccountUid) == 0x000000, "Member 'FM1Request_PartyAccept::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_PartyAccept, RequesterName) == 0x000008, "Member 'FM1Request_PartyAccept::RequesterName' has a wrong offset!");
static_assert(offsetof(FM1Request_PartyAccept, Accept) == 0x000018, "Member 'FM1Request_PartyAccept::Accept' has a wrong offset!");

// ScriptStruct M1.M1GameplayDebuggerShape
// 0x0040 (0x0040 - 0x0000)
struct FM1GameplayDebuggerShape final
{
public:
	TArray<struct FVector>                        ShapeData;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1GameplayDebuggerShape                      Type;                                              // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawLine;                                         // 0x0025(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x1A];                                      // 0x0026(0x001A)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1GameplayDebuggerShape) == 0x000008, "Wrong alignment on FM1GameplayDebuggerShape");
static_assert(sizeof(FM1GameplayDebuggerShape) == 0x000040, "Wrong size on FM1GameplayDebuggerShape");
static_assert(offsetof(FM1GameplayDebuggerShape, ShapeData) == 0x000000, "Member 'FM1GameplayDebuggerShape::ShapeData' has a wrong offset!");
static_assert(offsetof(FM1GameplayDebuggerShape, Description) == 0x000010, "Member 'FM1GameplayDebuggerShape::Description' has a wrong offset!");
static_assert(offsetof(FM1GameplayDebuggerShape, Color) == 0x000020, "Member 'FM1GameplayDebuggerShape::Color' has a wrong offset!");
static_assert(offsetof(FM1GameplayDebuggerShape, Type) == 0x000024, "Member 'FM1GameplayDebuggerShape::Type' has a wrong offset!");
static_assert(offsetof(FM1GameplayDebuggerShape, bDrawLine) == 0x000025, "Member 'FM1GameplayDebuggerShape::bDrawLine' has a wrong offset!");

// ScriptStruct M1.M1Request_PartyLeave
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_PartyLeave final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_PartyLeave) == 0x000008, "Wrong alignment on FM1Request_PartyLeave");
static_assert(sizeof(FM1Request_PartyLeave) == 0x000008, "Wrong size on FM1Request_PartyLeave");
static_assert(offsetof(FM1Request_PartyLeave, AccountUid) == 0x000000, "Member 'FM1Request_PartyLeave::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_InstanceDungeonComplete
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_InstanceDungeonComplete final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1InstanceDungeonCompleteRequest      Request;                                           // 0x0008(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_InstanceDungeonComplete) == 0x000008, "Wrong alignment on FM1Request_InstanceDungeonComplete");
static_assert(sizeof(FM1Request_InstanceDungeonComplete) == 0x000018, "Wrong size on FM1Request_InstanceDungeonComplete");
static_assert(offsetof(FM1Request_InstanceDungeonComplete, AccountUid) == 0x000000, "Member 'FM1Request_InstanceDungeonComplete::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_InstanceDungeonComplete, Request) == 0x000008, "Member 'FM1Request_InstanceDungeonComplete::Request' has a wrong offset!");

// ScriptStruct M1.M1Request_PartyExile
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_PartyExile final : public FM1Request
{
public:
	int64                                         MasterUid;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MemberUid;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_PartyExile) == 0x000008, "Wrong alignment on FM1Request_PartyExile");
static_assert(sizeof(FM1Request_PartyExile) == 0x000010, "Wrong size on FM1Request_PartyExile");
static_assert(offsetof(FM1Request_PartyExile, MasterUid) == 0x000000, "Member 'FM1Request_PartyExile::MasterUid' has a wrong offset!");
static_assert(offsetof(FM1Request_PartyExile, MemberUid) == 0x000008, "Member 'FM1Request_PartyExile::MemberUid' has a wrong offset!");

// ScriptStruct M1.M1KeyDuplicateElement
// 0x0003 (0x0003 - 0x0000)
struct FM1KeyDuplicateElement final
{
public:
	EM1KeyDuplicateReason                         Reason;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1OptionFeature                              DuplicatedOptionFeature;                           // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1OptionValueKeySettingType                  DuplicatedKeySettingType;                          // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1KeyDuplicateElement) == 0x000001, "Wrong alignment on FM1KeyDuplicateElement");
static_assert(sizeof(FM1KeyDuplicateElement) == 0x000003, "Wrong size on FM1KeyDuplicateElement");
static_assert(offsetof(FM1KeyDuplicateElement, Reason) == 0x000000, "Member 'FM1KeyDuplicateElement::Reason' has a wrong offset!");
static_assert(offsetof(FM1KeyDuplicateElement, DuplicatedOptionFeature) == 0x000001, "Member 'FM1KeyDuplicateElement::DuplicatedOptionFeature' has a wrong offset!");
static_assert(offsetof(FM1KeyDuplicateElement, DuplicatedKeySettingType) == 0x000002, "Member 'FM1KeyDuplicateElement::DuplicatedKeySettingType' has a wrong offset!");

// ScriptStruct M1.M1KeyDuplicateResult
// 0x0018 (0x0018 - 0x0000)
struct FM1KeyDuplicateResult final
{
public:
	bool                                          bCanUseInputChord;                                 // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1KeyDuplicateElement>         Elements;                                          // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1KeyDuplicateResult) == 0x000008, "Wrong alignment on FM1KeyDuplicateResult");
static_assert(sizeof(FM1KeyDuplicateResult) == 0x000018, "Wrong size on FM1KeyDuplicateResult");
static_assert(offsetof(FM1KeyDuplicateResult, bCanUseInputChord) == 0x000000, "Member 'FM1KeyDuplicateResult::bCanUseInputChord' has a wrong offset!");
static_assert(offsetof(FM1KeyDuplicateResult, Elements) == 0x000008, "Member 'FM1KeyDuplicateResult::Elements' has a wrong offset!");

// ScriptStruct M1.M1Request_PartyMasterChange
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_PartyMasterChange final : public FM1Request
{
public:
	int64                                         MasterUid;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MemberUid;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_PartyMasterChange) == 0x000008, "Wrong alignment on FM1Request_PartyMasterChange");
static_assert(sizeof(FM1Request_PartyMasterChange) == 0x000010, "Wrong size on FM1Request_PartyMasterChange");
static_assert(offsetof(FM1Request_PartyMasterChange, MasterUid) == 0x000000, "Member 'FM1Request_PartyMasterChange::MasterUid' has a wrong offset!");
static_assert(offsetof(FM1Request_PartyMasterChange, MemberUid) == 0x000008, "Member 'FM1Request_PartyMasterChange::MemberUid' has a wrong offset!");

// ScriptStruct M1.M1Request_PartyJoin
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_PartyJoin final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetName;                                        // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_PartyJoin) == 0x000008, "Wrong alignment on FM1Request_PartyJoin");
static_assert(sizeof(FM1Request_PartyJoin) == 0x000018, "Wrong size on FM1Request_PartyJoin");
static_assert(offsetof(FM1Request_PartyJoin, AccountUid) == 0x000000, "Member 'FM1Request_PartyJoin::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_PartyJoin, TargetName) == 0x000008, "Member 'FM1Request_PartyJoin::TargetName' has a wrong offset!");

// ScriptStruct M1.M1Response_UseConsumableItem
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_UseConsumableItem final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_UseConsumableItem) == 0x000001, "Wrong alignment on FM1Response_UseConsumableItem");
static_assert(sizeof(FM1Response_UseConsumableItem) == 0x000001, "Wrong size on FM1Response_UseConsumableItem");
static_assert(offsetof(FM1Response_UseConsumableItem, Notification) == 0x000000, "Member 'FM1Response_UseConsumableItem::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_PartyPropertyInvoke
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_PartyPropertyInvoke final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_PartyPropertyInvoke) == 0x000008, "Wrong alignment on FM1Request_PartyPropertyInvoke");
static_assert(sizeof(FM1Request_PartyPropertyInvoke) == 0x000008, "Wrong size on FM1Request_PartyPropertyInvoke");
static_assert(offsetof(FM1Request_PartyPropertyInvoke, AccountUid) == 0x000000, "Member 'FM1Request_PartyPropertyInvoke::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_SetPrivateFieldOptionOpen
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_SetPrivateFieldOptionOpen final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_SetPrivateFieldOptionOpen) == 0x000008, "Wrong alignment on FM1Request_SetPrivateFieldOptionOpen");
static_assert(sizeof(FM1Request_SetPrivateFieldOptionOpen) == 0x000008, "Wrong size on FM1Request_SetPrivateFieldOptionOpen");
static_assert(offsetof(FM1Request_SetPrivateFieldOptionOpen, AccountUid) == 0x000000, "Member 'FM1Request_SetPrivateFieldOptionOpen::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1SimpleMissionPlayerLeaveInfoForRPC
// 0x0028 (0x0028 - 0x0000)
struct FM1SimpleMissionPlayerLeaveInfoForRPC final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlatformOnlineId;                                  // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MissionEndReason                           Reason;                                            // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SimpleMissionPlayerLeaveInfoForRPC) == 0x000008, "Wrong alignment on FM1SimpleMissionPlayerLeaveInfoForRPC");
static_assert(sizeof(FM1SimpleMissionPlayerLeaveInfoForRPC) == 0x000028, "Wrong size on FM1SimpleMissionPlayerLeaveInfoForRPC");
static_assert(offsetof(FM1SimpleMissionPlayerLeaveInfoForRPC, PlayerName) == 0x000000, "Member 'FM1SimpleMissionPlayerLeaveInfoForRPC::PlayerName' has a wrong offset!");
static_assert(offsetof(FM1SimpleMissionPlayerLeaveInfoForRPC, PlatformOnlineId) == 0x000010, "Member 'FM1SimpleMissionPlayerLeaveInfoForRPC::PlatformOnlineId' has a wrong offset!");
static_assert(offsetof(FM1SimpleMissionPlayerLeaveInfoForRPC, Reason) == 0x000020, "Member 'FM1SimpleMissionPlayerLeaveInfoForRPC::Reason' has a wrong offset!");

// ScriptStruct M1.M1Request_VoidBattleComplete
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_VoidBattleComplete final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MapId;                                             // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VoidBattleTId;                                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Success;                                           // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_VoidBattleComplete) == 0x000008, "Wrong alignment on FM1Request_VoidBattleComplete");
static_assert(sizeof(FM1Request_VoidBattleComplete) == 0x000018, "Wrong size on FM1Request_VoidBattleComplete");
static_assert(offsetof(FM1Request_VoidBattleComplete, AccountUid) == 0x000000, "Member 'FM1Request_VoidBattleComplete::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_VoidBattleComplete, MapId) == 0x000008, "Member 'FM1Request_VoidBattleComplete::MapId' has a wrong offset!");
static_assert(offsetof(FM1Request_VoidBattleComplete, VoidBattleTId) == 0x00000C, "Member 'FM1Request_VoidBattleComplete::VoidBattleTId' has a wrong offset!");
static_assert(offsetof(FM1Request_VoidBattleComplete, Success) == 0x000010, "Member 'FM1Request_VoidBattleComplete::Success' has a wrong offset!");

// ScriptStruct M1.M1WeaponChangingState
// 0x0003 (0x0003 - 0x0000)
struct FM1WeaponChangingState final
{
public:
	EM1EquipmentSlotType                          From;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1EquipmentSlotType                          To;                                                // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChanging;                                         // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponChangingState) == 0x000001, "Wrong alignment on FM1WeaponChangingState");
static_assert(sizeof(FM1WeaponChangingState) == 0x000003, "Wrong size on FM1WeaponChangingState");
static_assert(offsetof(FM1WeaponChangingState, From) == 0x000000, "Member 'FM1WeaponChangingState::From' has a wrong offset!");
static_assert(offsetof(FM1WeaponChangingState, To) == 0x000001, "Member 'FM1WeaponChangingState::To' has a wrong offset!");
static_assert(offsetof(FM1WeaponChangingState, bChanging) == 0x000002, "Member 'FM1WeaponChangingState::bChanging' has a wrong offset!");

// ScriptStruct M1.M1Request_TestDediBlockSelf
// 0x0001 (0x0001 - 0x0000)
struct FM1Request_TestDediBlockSelf final : public FM1Request
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_TestDediBlockSelf) == 0x000001, "Wrong alignment on FM1Request_TestDediBlockSelf");
static_assert(sizeof(FM1Request_TestDediBlockSelf) == 0x000001, "Wrong size on FM1Request_TestDediBlockSelf");

// ScriptStruct M1.M1TestJumpUpRangeData
// 0x000C (0x000C - 0x0000)
struct FM1TestJumpUpRangeData final
{
public:
	float                                         MinRange;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpSpeed;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TestJumpUpRangeData) == 0x000004, "Wrong alignment on FM1TestJumpUpRangeData");
static_assert(sizeof(FM1TestJumpUpRangeData) == 0x00000C, "Wrong size on FM1TestJumpUpRangeData");
static_assert(offsetof(FM1TestJumpUpRangeData, MinRange) == 0x000000, "Member 'FM1TestJumpUpRangeData::MinRange' has a wrong offset!");
static_assert(offsetof(FM1TestJumpUpRangeData, MaxRange) == 0x000004, "Member 'FM1TestJumpUpRangeData::MaxRange' has a wrong offset!");
static_assert(offsetof(FM1TestJumpUpRangeData, JumpSpeed) == 0x000008, "Member 'FM1TestJumpUpRangeData::JumpSpeed' has a wrong offset!");

// ScriptStruct M1.M1Notice_BroadcastSystemMessage
// 0x0004 (0x0004 - 0x0000)
struct FM1Notice_BroadcastSystemMessage final
{
public:
	EM1SystemMessageType                          Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_BroadcastSystemMessage) == 0x000004, "Wrong alignment on FM1Notice_BroadcastSystemMessage");
static_assert(sizeof(FM1Notice_BroadcastSystemMessage) == 0x000004, "Wrong size on FM1Notice_BroadcastSystemMessage");
static_assert(offsetof(FM1Notice_BroadcastSystemMessage, Notification) == 0x000000, "Member 'FM1Notice_BroadcastSystemMessage::Notification' has a wrong offset!");

// ScriptStruct M1.M1GridCellInfo
// 0x0070 (0x0070 - 0x0000)
struct FM1GridCellInfo final
{
public:
	TSet<class AActor*>                           OccupyingActors;                                   // 0x0000(0x0050)(NativeAccessSpecifierPrivate)
	bool                                          bValid;                                            // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MatchingSpawnLocation;                             // 0x0054(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1GridCellInfo) == 0x000008, "Wrong alignment on FM1GridCellInfo");
static_assert(sizeof(FM1GridCellInfo) == 0x000070, "Wrong size on FM1GridCellInfo");
static_assert(offsetof(FM1GridCellInfo, OccupyingActors) == 0x000000, "Member 'FM1GridCellInfo::OccupyingActors' has a wrong offset!");
static_assert(offsetof(FM1GridCellInfo, bValid) == 0x000050, "Member 'FM1GridCellInfo::bValid' has a wrong offset!");
static_assert(offsetof(FM1GridCellInfo, MatchingSpawnLocation) == 0x000054, "Member 'FM1GridCellInfo::MatchingSpawnLocation' has a wrong offset!");

// ScriptStruct M1.M1GridArray
// 0x0010 (0x0010 - 0x0000)
struct FM1GridArray final
{
public:
	TArray<struct FM1GridCellInfo>                Array;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GridArray) == 0x000008, "Wrong alignment on FM1GridArray");
static_assert(sizeof(FM1GridArray) == 0x000010, "Wrong size on FM1GridArray");
static_assert(offsetof(FM1GridArray, Array) == 0x000000, "Member 'FM1GridArray::Array' has a wrong offset!");

// ScriptStruct M1.M1Request_StartQuestMultiple
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_StartQuestMultiple final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1QuestStartMultiple                  QuestTids;                                         // 0x0008(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_StartQuestMultiple) == 0x000008, "Wrong alignment on FM1Request_StartQuestMultiple");
static_assert(sizeof(FM1Request_StartQuestMultiple) == 0x000018, "Wrong size on FM1Request_StartQuestMultiple");
static_assert(offsetof(FM1Request_StartQuestMultiple, AccountUid) == 0x000000, "Member 'FM1Request_StartQuestMultiple::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_StartQuestMultiple, QuestTids) == 0x000008, "Member 'FM1Request_StartQuestMultiple::QuestTids' has a wrong offset!");

// ScriptStruct M1.M1Notice_LeaveCharacterNoti
// 0x0010 (0x0010 - 0x0000)
struct FM1Notice_LeaveCharacterNoti final
{
public:
	struct FM1LeaveCharacterNotiInfo              Notification;                                      // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_LeaveCharacterNoti) == 0x000008, "Wrong alignment on FM1Notice_LeaveCharacterNoti");
static_assert(sizeof(FM1Notice_LeaveCharacterNoti) == 0x000010, "Wrong size on FM1Notice_LeaveCharacterNoti");
static_assert(offsetof(FM1Notice_LeaveCharacterNoti, Notification) == 0x000000, "Member 'FM1Notice_LeaveCharacterNoti::Notification' has a wrong offset!");

// ScriptStruct M1.M1Notice_CommandFromServerNoti
// 0x0010 (0x0010 - 0x0000)
struct FM1Notice_CommandFromServerNoti final
{
public:
	class FString                                 Notification;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_CommandFromServerNoti) == 0x000008, "Wrong alignment on FM1Notice_CommandFromServerNoti");
static_assert(sizeof(FM1Notice_CommandFromServerNoti) == 0x000010, "Wrong size on FM1Notice_CommandFromServerNoti");
static_assert(offsetof(FM1Notice_CommandFromServerNoti, Notification) == 0x000000, "Member 'FM1Notice_CommandFromServerNoti::Notification' has a wrong offset!");

// ScriptStruct M1.M1MissionTaskStatus
// 0x0010 (0x0010 - 0x0000)
struct FM1MissionTaskStatus final
{
public:
	EM1MissionTaskState                           TaskState;                                         // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AM1MissionTaskActor*                    TaskActor;                                         // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1MissionTaskStatus) == 0x000008, "Wrong alignment on FM1MissionTaskStatus");
static_assert(sizeof(FM1MissionTaskStatus) == 0x000010, "Wrong size on FM1MissionTaskStatus");
static_assert(offsetof(FM1MissionTaskStatus, TaskState) == 0x000000, "Member 'FM1MissionTaskStatus::TaskState' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskStatus, TaskActor) == 0x000008, "Member 'FM1MissionTaskStatus::TaskActor' has a wrong offset!");

// ScriptStruct M1.M1Notice_DediBlock
// 0x0001 (0x0001 - 0x0000)
struct FM1Notice_DediBlock final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_DediBlock) == 0x000001, "Wrong alignment on FM1Notice_DediBlock");
static_assert(sizeof(FM1Notice_DediBlock) == 0x000001, "Wrong size on FM1Notice_DediBlock");
static_assert(offsetof(FM1Notice_DediBlock, Notification) == 0x000000, "Member 'FM1Notice_DediBlock::Notification' has a wrong offset!");

// ScriptStruct M1.M1MissionProgressInfo
// 0x0028 (0x0028 - 0x0000)
struct FM1MissionProgressInfo final
{
public:
	class AM1MissionTaskActor*                    ActivatedTaskActor;                                // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AM1MissionTaskActor*                    LastTaskActor;                                     // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EM1MissionActorState                          MissionActorState;                                 // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ActivatedTaskIndex;                                // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UM1MissionControlComponent*>     JoinedControls;                                    // 0x0018(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1MissionProgressInfo) == 0x000008, "Wrong alignment on FM1MissionProgressInfo");
static_assert(sizeof(FM1MissionProgressInfo) == 0x000028, "Wrong size on FM1MissionProgressInfo");
static_assert(offsetof(FM1MissionProgressInfo, ActivatedTaskActor) == 0x000000, "Member 'FM1MissionProgressInfo::ActivatedTaskActor' has a wrong offset!");
static_assert(offsetof(FM1MissionProgressInfo, LastTaskActor) == 0x000008, "Member 'FM1MissionProgressInfo::LastTaskActor' has a wrong offset!");
static_assert(offsetof(FM1MissionProgressInfo, MissionActorState) == 0x000010, "Member 'FM1MissionProgressInfo::MissionActorState' has a wrong offset!");
static_assert(offsetof(FM1MissionProgressInfo, ActivatedTaskIndex) == 0x000014, "Member 'FM1MissionProgressInfo::ActivatedTaskIndex' has a wrong offset!");
static_assert(offsetof(FM1MissionProgressInfo, JoinedControls) == 0x000018, "Member 'FM1MissionProgressInfo::JoinedControls' has a wrong offset!");

// ScriptStruct M1.M1CampNotificationSettings
// 0x0004 (0x0004 - 0x0000)
struct FM1CampNotificationSettings final
{
public:
	float                                         DeactivatedCampNotificationDistance;               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CampNotificationSettings) == 0x000004, "Wrong alignment on FM1CampNotificationSettings");
static_assert(sizeof(FM1CampNotificationSettings) == 0x000004, "Wrong size on FM1CampNotificationSettings");
static_assert(offsetof(FM1CampNotificationSettings, DeactivatedCampNotificationDistance) == 0x000000, "Member 'FM1CampNotificationSettings::DeactivatedCampNotificationDistance' has a wrong offset!");

// ScriptStruct M1.M1Response_PartyExile
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_PartyExile final
{
public:
	EM1PartyErrorCode                             Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_PartyExile) == 0x000004, "Wrong alignment on FM1Response_PartyExile");
static_assert(sizeof(FM1Response_PartyExile) == 0x000004, "Wrong size on FM1Response_PartyExile");
static_assert(offsetof(FM1Response_PartyExile, Notification) == 0x000000, "Member 'FM1Response_PartyExile::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatCreateItem
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatCreateItem final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatCreateItem) == 0x000001, "Wrong alignment on FM1Response_CheatCreateItem");
static_assert(sizeof(FM1Response_CheatCreateItem) == 0x000001, "Wrong size on FM1Response_CheatCreateItem");
static_assert(offsetof(FM1Response_CheatCreateItem, Notification) == 0x000000, "Member 'FM1Response_CheatCreateItem::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_PartyMasterChange
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_PartyMasterChange final
{
public:
	EM1PartyErrorCode                             Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_PartyMasterChange) == 0x000004, "Wrong alignment on FM1Response_PartyMasterChange");
static_assert(sizeof(FM1Response_PartyMasterChange) == 0x000004, "Wrong size on FM1Response_PartyMasterChange");
static_assert(offsetof(FM1Response_PartyMasterChange, Notification) == 0x000000, "Member 'FM1Response_PartyMasterChange::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CustomizingEtc
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_CustomizingEtc final
{
public:
	EM1CustomizeReason                            Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CustomizingEtc) == 0x000004, "Wrong alignment on FM1Response_CustomizingEtc");
static_assert(sizeof(FM1Response_CustomizingEtc) == 0x000004, "Wrong size on FM1Response_CustomizingEtc");
static_assert(offsetof(FM1Response_CustomizingEtc, Notification) == 0x000000, "Member 'FM1Response_CustomizingEtc::Notification' has a wrong offset!");

// ScriptStruct M1.M1Notice_DediGameInfoUpdate
// 0x0018 (0x0018 - 0x0000)
struct FM1Notice_DediGameInfoUpdate final
{
public:
	struct FM1DediGameInfo                        Notification;                                      // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_DediGameInfoUpdate) == 0x000008, "Wrong alignment on FM1Notice_DediGameInfoUpdate");
static_assert(sizeof(FM1Notice_DediGameInfoUpdate) == 0x000018, "Wrong size on FM1Notice_DediGameInfoUpdate");
static_assert(offsetof(FM1Notice_DediGameInfoUpdate, Notification) == 0x000000, "Member 'FM1Notice_DediGameInfoUpdate::Notification' has a wrong offset!");

// ScriptStruct M1.M1OptionaEventsForPhase
// 0x0018 (0x0018 - 0x0000)
struct FM1OptionaEventsForPhase final
{
public:
	int32                                         PhaseIndex;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndEventWhenPhaseExited;                          // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           OptionalEventNames;                                // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1OptionaEventsForPhase) == 0x000008, "Wrong alignment on FM1OptionaEventsForPhase");
static_assert(sizeof(FM1OptionaEventsForPhase) == 0x000018, "Wrong size on FM1OptionaEventsForPhase");
static_assert(offsetof(FM1OptionaEventsForPhase, PhaseIndex) == 0x000000, "Member 'FM1OptionaEventsForPhase::PhaseIndex' has a wrong offset!");
static_assert(offsetof(FM1OptionaEventsForPhase, bEndEventWhenPhaseExited) == 0x000004, "Member 'FM1OptionaEventsForPhase::bEndEventWhenPhaseExited' has a wrong offset!");
static_assert(offsetof(FM1OptionaEventsForPhase, OptionalEventNames) == 0x000008, "Member 'FM1OptionaEventsForPhase::OptionalEventNames' has a wrong offset!");

// ScriptStruct M1.M1Request_MailOpReload
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_MailOpReload final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_MailOpReload) == 0x000008, "Wrong alignment on FM1Request_MailOpReload");
static_assert(sizeof(FM1Request_MailOpReload) == 0x000008, "Wrong size on FM1Request_MailOpReload");
static_assert(offsetof(FM1Request_MailOpReload, AccountUid) == 0x000000, "Member 'FM1Request_MailOpReload::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1MissionGuideInfo
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FM1MissionGuideInfo final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MissionGuideInfo) == 0x000004, "Wrong alignment on FM1MissionGuideInfo");
static_assert(sizeof(FM1MissionGuideInfo) == 0x000014, "Wrong size on FM1MissionGuideInfo");

// ScriptStruct M1.M1Notice_DediGameModifierUpdate
// 0x0020 (0x0020 - 0x0000)
struct FM1Notice_DediGameModifierUpdate final
{
public:
	struct FM1DediGameModifierInfo                Notification;                                      // 0x0000(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_DediGameModifierUpdate) == 0x000008, "Wrong alignment on FM1Notice_DediGameModifierUpdate");
static_assert(sizeof(FM1Notice_DediGameModifierUpdate) == 0x000020, "Wrong size on FM1Notice_DediGameModifierUpdate");
static_assert(offsetof(FM1Notice_DediGameModifierUpdate, Notification) == 0x000000, "Member 'FM1Notice_DediGameModifierUpdate::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_SetPrivateFieldOptionOpen
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_SetPrivateFieldOptionOpen final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_SetPrivateFieldOptionOpen) == 0x000001, "Wrong alignment on FM1Response_SetPrivateFieldOptionOpen");
static_assert(sizeof(FM1Response_SetPrivateFieldOptionOpen) == 0x000001, "Wrong size on FM1Response_SetPrivateFieldOptionOpen");
static_assert(offsetof(FM1Response_SetPrivateFieldOptionOpen, Notification) == 0x000000, "Member 'FM1Response_SetPrivateFieldOptionOpen::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_UncustomizingRingSlot
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_UncustomizingRingSlot final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1RequestCustomizingRingSlot          Request;                                           // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_UncustomizingRingSlot) == 0x000008, "Wrong alignment on FM1Request_UncustomizingRingSlot");
static_assert(sizeof(FM1Request_UncustomizingRingSlot) == 0x000010, "Wrong size on FM1Request_UncustomizingRingSlot");
static_assert(offsetof(FM1Request_UncustomizingRingSlot, AccountUid) == 0x000000, "Member 'FM1Request_UncustomizingRingSlot::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_UncustomizingRingSlot, Request) == 0x000008, "Member 'FM1Request_UncustomizingRingSlot::Request' has a wrong offset!");

// ScriptStruct M1.M1Notice_MatchingStart
// 0x0020 (0x0020 - 0x0000)
struct FM1Notice_MatchingStart final
{
public:
	struct FM1MatchingStartInfo                   Notification;                                      // 0x0000(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_MatchingStart) == 0x000008, "Wrong alignment on FM1Notice_MatchingStart");
static_assert(sizeof(FM1Notice_MatchingStart) == 0x000020, "Wrong size on FM1Notice_MatchingStart");
static_assert(offsetof(FM1Notice_MatchingStart, Notification) == 0x000000, "Member 'FM1Notice_MatchingStart::Notification' has a wrong offset!");

// ScriptStruct M1.InteractionCoolTimeInfo
// 0x0010 (0x0010 - 0x0000)
struct FInteractionCoolTimeInfo final
{
public:
	struct FM1TemplateId                          MultiSupplyId;                                     // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ObjectUniqueID;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              NextCooltime;                                      // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionCoolTimeInfo) == 0x000008, "Wrong alignment on FInteractionCoolTimeInfo");
static_assert(sizeof(FInteractionCoolTimeInfo) == 0x000010, "Wrong size on FInteractionCoolTimeInfo");
static_assert(offsetof(FInteractionCoolTimeInfo, MultiSupplyId) == 0x000000, "Member 'FInteractionCoolTimeInfo::MultiSupplyId' has a wrong offset!");
static_assert(offsetof(FInteractionCoolTimeInfo, ObjectUniqueID) == 0x000004, "Member 'FInteractionCoolTimeInfo::ObjectUniqueID' has a wrong offset!");
static_assert(offsetof(FInteractionCoolTimeInfo, NextCooltime) == 0x000008, "Member 'FInteractionCoolTimeInfo::NextCooltime' has a wrong offset!");

// ScriptStruct M1.M1Response_UncustomizingSkinPaint
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_UncustomizingSkinPaint final
{
public:
	EM1CustomizeReason                            Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_UncustomizingSkinPaint) == 0x000004, "Wrong alignment on FM1Response_UncustomizingSkinPaint");
static_assert(sizeof(FM1Response_UncustomizingSkinPaint) == 0x000004, "Wrong size on FM1Response_UncustomizingSkinPaint");
static_assert(offsetof(FM1Response_UncustomizingSkinPaint, Notification) == 0x000000, "Member 'FM1Response_UncustomizingSkinPaint::Notification' has a wrong offset!");

// ScriptStruct M1.M1Notice_MatchingSuccess
// 0x0010 (0x0010 - 0x0000)
struct FM1Notice_MatchingSuccess final
{
public:
	struct FM1MatchingSuccessInfo                 Notification;                                      // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_MatchingSuccess) == 0x000008, "Wrong alignment on FM1Notice_MatchingSuccess");
static_assert(sizeof(FM1Notice_MatchingSuccess) == 0x000010, "Wrong size on FM1Notice_MatchingSuccess");
static_assert(offsetof(FM1Notice_MatchingSuccess, Notification) == 0x000000, "Member 'FM1Notice_MatchingSuccess::Notification' has a wrong offset!");

// ScriptStruct M1.M1Notice_MatchingCanceled
// 0x0010 (0x0010 - 0x0000)
struct FM1Notice_MatchingCanceled final
{
public:
	struct FM1MatchingCancelInfo                  Notification;                                      // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_MatchingCanceled) == 0x000008, "Wrong alignment on FM1Notice_MatchingCanceled");
static_assert(sizeof(FM1Notice_MatchingCanceled) == 0x000010, "Wrong size on FM1Notice_MatchingCanceled");
static_assert(offsetof(FM1Notice_MatchingCanceled, Notification) == 0x000000, "Member 'FM1Notice_MatchingCanceled::Notification' has a wrong offset!");

// ScriptStruct M1.M1MovingActorTriggerVolume
// 0x0010 (0x0010 - 0x0000)
struct FM1MovingActorTriggerVolume
{
public:
	class ATriggerBase*                           TriggerVolume;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATriggerBase>               TriggerVolumeType;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MovingActorTriggerVolume) == 0x000008, "Wrong alignment on FM1MovingActorTriggerVolume");
static_assert(sizeof(FM1MovingActorTriggerVolume) == 0x000010, "Wrong size on FM1MovingActorTriggerVolume");
static_assert(offsetof(FM1MovingActorTriggerVolume, TriggerVolume) == 0x000000, "Member 'FM1MovingActorTriggerVolume::TriggerVolume' has a wrong offset!");
static_assert(offsetof(FM1MovingActorTriggerVolume, TriggerVolumeType) == 0x000008, "Member 'FM1MovingActorTriggerVolume::TriggerVolumeType' has a wrong offset!");

// ScriptStruct M1.M1MovingActorAttachableTriggerVolume
// 0x0008 (0x0018 - 0x0010)
struct FM1MovingActorAttachableTriggerVolume final : public FM1MovingActorTriggerVolume
{
public:
	bool                                          bAttachToMesh;                                     // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MovingActorAttachableTriggerVolume) == 0x000008, "Wrong alignment on FM1MovingActorAttachableTriggerVolume");
static_assert(sizeof(FM1MovingActorAttachableTriggerVolume) == 0x000018, "Wrong size on FM1MovingActorAttachableTriggerVolume");
static_assert(offsetof(FM1MovingActorAttachableTriggerVolume, bAttachToMesh) == 0x000010, "Member 'FM1MovingActorAttachableTriggerVolume::bAttachToMesh' has a wrong offset!");

// ScriptStruct M1.M1Notice_SetMatchingInfo
// 0x0028 (0x0028 - 0x0000)
struct FM1Notice_SetMatchingInfo final
{
public:
	struct FM1SetMatchingInfo                     Notification;                                      // 0x0000(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_SetMatchingInfo) == 0x000008, "Wrong alignment on FM1Notice_SetMatchingInfo");
static_assert(sizeof(FM1Notice_SetMatchingInfo) == 0x000028, "Wrong size on FM1Notice_SetMatchingInfo");
static_assert(offsetof(FM1Notice_SetMatchingInfo, Notification) == 0x000000, "Member 'FM1Notice_SetMatchingInfo::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CustomizingEvolutionChange
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_CustomizingEvolutionChange final
{
public:
	EM1CustomizeReason                            Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CustomizingEvolutionChange) == 0x000004, "Wrong alignment on FM1Response_CustomizingEvolutionChange");
static_assert(sizeof(FM1Response_CustomizingEvolutionChange) == 0x000004, "Wrong size on FM1Response_CustomizingEvolutionChange");
static_assert(offsetof(FM1Response_CustomizingEvolutionChange, Notification) == 0x000000, "Member 'FM1Response_CustomizingEvolutionChange::Notification' has a wrong offset!");

// ScriptStruct M1.M1Notice_TeleportToMission
// 0x0018 (0x0018 - 0x0000)
struct FM1Notice_TeleportToMission final
{
public:
	struct FM1TeleportToMissionInfo               Notification;                                      // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_TeleportToMission) == 0x000008, "Wrong alignment on FM1Notice_TeleportToMission");
static_assert(sizeof(FM1Notice_TeleportToMission) == 0x000018, "Wrong size on FM1Notice_TeleportToMission");
static_assert(offsetof(FM1Notice_TeleportToMission, Notification) == 0x000000, "Member 'FM1Notice_TeleportToMission::Notification' has a wrong offset!");

// ScriptStruct M1.M1InstanceDungeonMissionDataList
// 0x0010 (0x0010 - 0x0000)
struct FM1InstanceDungeonMissionDataList final
{
public:
	TArray<class UM1InstanceDungeonMissionDataHolder*> Missions;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceDungeonMissionDataList) == 0x000008, "Wrong alignment on FM1InstanceDungeonMissionDataList");
static_assert(sizeof(FM1InstanceDungeonMissionDataList) == 0x000010, "Wrong size on FM1InstanceDungeonMissionDataList");
static_assert(offsetof(FM1InstanceDungeonMissionDataList, Missions) == 0x000000, "Member 'FM1InstanceDungeonMissionDataList::Missions' has a wrong offset!");

// ScriptStruct M1.M1Request_PlatformAchievementCompleteInfos
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_PlatformAchievementCompleteInfos final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_PlatformAchievementCompleteInfos) == 0x000008, "Wrong alignment on FM1Request_PlatformAchievementCompleteInfos");
static_assert(sizeof(FM1Request_PlatformAchievementCompleteInfos) == 0x000008, "Wrong size on FM1Request_PlatformAchievementCompleteInfos");
static_assert(offsetof(FM1Request_PlatformAchievementCompleteInfos, AccountUid) == 0x000000, "Member 'FM1Request_PlatformAchievementCompleteInfos::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_DestroyItem
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_DestroyItem final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemUidBox                          ItemUid;                                           // 0x0008(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_DestroyItem) == 0x000008, "Wrong alignment on FM1Request_DestroyItem");
static_assert(sizeof(FM1Request_DestroyItem) == 0x000018, "Wrong size on FM1Request_DestroyItem");
static_assert(offsetof(FM1Request_DestroyItem, AccountUid) == 0x000000, "Member 'FM1Request_DestroyItem::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_DestroyItem, ItemUid) == 0x000008, "Member 'FM1Request_DestroyItem::ItemUid' has a wrong offset!");

// ScriptStruct M1.M1JumpDownAnimSetData
// 0x0060 (0x0060 - 0x0000)
struct FM1JumpDownAnimSetData final
{
public:
	TMap<EM1JumpAnimType, class UAnimSequenceBase*> AnimSet;                                           // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         LandingDuration;                                   // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchInitialSpeed;                                // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestinationOffset;                                 // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1JumpDownAnimSetData) == 0x000008, "Wrong alignment on FM1JumpDownAnimSetData");
static_assert(sizeof(FM1JumpDownAnimSetData) == 0x000060, "Wrong size on FM1JumpDownAnimSetData");
static_assert(offsetof(FM1JumpDownAnimSetData, AnimSet) == 0x000000, "Member 'FM1JumpDownAnimSetData::AnimSet' has a wrong offset!");
static_assert(offsetof(FM1JumpDownAnimSetData, LandingDuration) == 0x000050, "Member 'FM1JumpDownAnimSetData::LandingDuration' has a wrong offset!");
static_assert(offsetof(FM1JumpDownAnimSetData, LaunchInitialSpeed) == 0x000054, "Member 'FM1JumpDownAnimSetData::LaunchInitialSpeed' has a wrong offset!");
static_assert(offsetof(FM1JumpDownAnimSetData, DestinationOffset) == 0x000058, "Member 'FM1JumpDownAnimSetData::DestinationOffset' has a wrong offset!");

// ScriptStruct M1.M1Response_PlatformAchievementCompleteInfos
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_PlatformAchievementCompleteInfos final
{
public:
	struct FM1PlatformAchievementCompleteInfoList Notification;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_PlatformAchievementCompleteInfos) == 0x000008, "Wrong alignment on FM1Response_PlatformAchievementCompleteInfos");
static_assert(sizeof(FM1Response_PlatformAchievementCompleteInfos) == 0x000010, "Wrong size on FM1Response_PlatformAchievementCompleteInfos");
static_assert(offsetof(FM1Response_PlatformAchievementCompleteInfos, Notification) == 0x000000, "Member 'FM1Response_PlatformAchievementCompleteInfos::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_TakeOffEquipment
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_TakeOffEquipment final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_TakeOffEquipment) == 0x000008, "Wrong alignment on FM1Request_TakeOffEquipment");
static_assert(sizeof(FM1Request_TakeOffEquipment) == 0x000010, "Wrong size on FM1Request_TakeOffEquipment");
static_assert(offsetof(FM1Request_TakeOffEquipment, AccountUid) == 0x000000, "Member 'FM1Request_TakeOffEquipment::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_TakeOffEquipment, SlotIndex) == 0x000008, "Member 'FM1Request_TakeOffEquipment::SlotIndex' has a wrong offset!");

// ScriptStruct M1.M1SocialServiceDeleteAllMail
// 0x0018 (0x0018 - 0x0000)
struct FM1SocialServiceDeleteAllMail final
{
public:
	EM1MailReason                                 MailReason;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MailType                                   TargetMailType;                                    // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 RemainMailList;                                    // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SocialServiceDeleteAllMail) == 0x000008, "Wrong alignment on FM1SocialServiceDeleteAllMail");
static_assert(sizeof(FM1SocialServiceDeleteAllMail) == 0x000018, "Wrong size on FM1SocialServiceDeleteAllMail");
static_assert(offsetof(FM1SocialServiceDeleteAllMail, MailReason) == 0x000000, "Member 'FM1SocialServiceDeleteAllMail::MailReason' has a wrong offset!");
static_assert(offsetof(FM1SocialServiceDeleteAllMail, TargetMailType) == 0x000004, "Member 'FM1SocialServiceDeleteAllMail::TargetMailType' has a wrong offset!");
static_assert(offsetof(FM1SocialServiceDeleteAllMail, RemainMailList) == 0x000008, "Member 'FM1SocialServiceDeleteAllMail::RemainMailList' has a wrong offset!");

// ScriptStruct M1.M1Request_DeleteMail
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_DeleteMail final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MailId;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_DeleteMail) == 0x000008, "Wrong alignment on FM1Request_DeleteMail");
static_assert(sizeof(FM1Request_DeleteMail) == 0x000010, "Wrong size on FM1Request_DeleteMail");
static_assert(offsetof(FM1Request_DeleteMail, AccountUid) == 0x000000, "Member 'FM1Request_DeleteMail::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_DeleteMail, MailId) == 0x000008, "Member 'FM1Request_DeleteMail::MailId' has a wrong offset!");

// ScriptStruct M1.M1Request_ChangeCharacter
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_ChangeCharacter final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_ChangeCharacter) == 0x000008, "Wrong alignment on FM1Request_ChangeCharacter");
static_assert(sizeof(FM1Request_ChangeCharacter) == 0x000010, "Wrong size on FM1Request_ChangeCharacter");
static_assert(offsetof(FM1Request_ChangeCharacter, AccountUid) == 0x000000, "Member 'FM1Request_ChangeCharacter::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_ChangeCharacter, TemplateId) == 0x000008, "Member 'FM1Request_ChangeCharacter::TemplateId' has a wrong offset!");

// ScriptStruct M1.M1Request_StartMission
// 0x0020 (0x0020 - 0x0000)
struct FM1Request_StartMission final : public FM1Request
{
public:
	struct FM1MissionRequest                      Request;                                           // 0x0000(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_StartMission) == 0x000008, "Wrong alignment on FM1Request_StartMission");
static_assert(sizeof(FM1Request_StartMission) == 0x000020, "Wrong size on FM1Request_StartMission");
static_assert(offsetof(FM1Request_StartMission, Request) == 0x000000, "Member 'FM1Request_StartMission::Request' has a wrong offset!");

// ScriptStruct M1.M1Request_DeleteJunkItem
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_DeleteJunkItem final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemType                                   ItemType;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InWarehouse;                                       // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_DeleteJunkItem) == 0x000008, "Wrong alignment on FM1Request_DeleteJunkItem");
static_assert(sizeof(FM1Request_DeleteJunkItem) == 0x000010, "Wrong size on FM1Request_DeleteJunkItem");
static_assert(offsetof(FM1Request_DeleteJunkItem, AccountUid) == 0x000000, "Member 'FM1Request_DeleteJunkItem::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_DeleteJunkItem, ItemType) == 0x000008, "Member 'FM1Request_DeleteJunkItem::ItemType' has a wrong offset!");
static_assert(offsetof(FM1Request_DeleteJunkItem, InWarehouse) == 0x000009, "Member 'FM1Request_DeleteJunkItem::InWarehouse' has a wrong offset!");

// ScriptStruct M1.M1Request_FavoritesCharacter
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_FavoritesCharacter final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         CharacterUid;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Favorites;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_FavoritesCharacter) == 0x000008, "Wrong alignment on FM1Request_FavoritesCharacter");
static_assert(sizeof(FM1Request_FavoritesCharacter) == 0x000018, "Wrong size on FM1Request_FavoritesCharacter");
static_assert(offsetof(FM1Request_FavoritesCharacter, AccountUid) == 0x000000, "Member 'FM1Request_FavoritesCharacter::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_FavoritesCharacter, CharacterUid) == 0x000008, "Member 'FM1Request_FavoritesCharacter::CharacterUid' has a wrong offset!");
static_assert(offsetof(FM1Request_FavoritesCharacter, Favorites) == 0x000010, "Member 'FM1Request_FavoritesCharacter::Favorites' has a wrong offset!");

// ScriptStruct M1.M1MapWorldMissionTableRow
// 0x0038 (0x0040 - 0x0008)
struct FM1MapWorldMissionTableRow final : public FTableRowBase
{
public:
	class FName                                   WorldMissionStringId;                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          WorldMissionTid;                                   // 0x0010(0x0004)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MapTemplateId;                                     // 0x0014(0x0004)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MissionName;                                       // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WorldMissionDataLayer;                             // 0x0020(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataLayerAsset*                        WorldMissionDataLayerAsset;                        // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    MissionDataTableRowHandle;                         // 0x0030(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MapWorldMissionTableRow) == 0x000008, "Wrong alignment on FM1MapWorldMissionTableRow");
static_assert(sizeof(FM1MapWorldMissionTableRow) == 0x000040, "Wrong size on FM1MapWorldMissionTableRow");
static_assert(offsetof(FM1MapWorldMissionTableRow, WorldMissionStringId) == 0x000008, "Member 'FM1MapWorldMissionTableRow::WorldMissionStringId' has a wrong offset!");
static_assert(offsetof(FM1MapWorldMissionTableRow, WorldMissionTid) == 0x000010, "Member 'FM1MapWorldMissionTableRow::WorldMissionTid' has a wrong offset!");
static_assert(offsetof(FM1MapWorldMissionTableRow, MapTemplateId) == 0x000014, "Member 'FM1MapWorldMissionTableRow::MapTemplateId' has a wrong offset!");
static_assert(offsetof(FM1MapWorldMissionTableRow, MissionName) == 0x000018, "Member 'FM1MapWorldMissionTableRow::MissionName' has a wrong offset!");
static_assert(offsetof(FM1MapWorldMissionTableRow, WorldMissionDataLayer) == 0x000020, "Member 'FM1MapWorldMissionTableRow::WorldMissionDataLayer' has a wrong offset!");
static_assert(offsetof(FM1MapWorldMissionTableRow, WorldMissionDataLayerAsset) == 0x000028, "Member 'FM1MapWorldMissionTableRow::WorldMissionDataLayerAsset' has a wrong offset!");
static_assert(offsetof(FM1MapWorldMissionTableRow, MissionDataTableRowHandle) == 0x000030, "Member 'FM1MapWorldMissionTableRow::MissionDataTableRowHandle' has a wrong offset!");

// ScriptStruct M1.M1Request_CustomizingEvolution
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CustomizingEvolution final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1RequestCustomizingEvolution         Request;                                           // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CustomizingEvolution) == 0x000008, "Wrong alignment on FM1Request_CustomizingEvolution");
static_assert(sizeof(FM1Request_CustomizingEvolution) == 0x000010, "Wrong size on FM1Request_CustomizingEvolution");
static_assert(offsetof(FM1Request_CustomizingEvolution, AccountUid) == 0x000000, "Member 'FM1Request_CustomizingEvolution::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CustomizingEvolution, Request) == 0x000008, "Member 'FM1Request_CustomizingEvolution::Request' has a wrong offset!");

// ScriptStruct M1.M1MissionWaveSurvivalInfoUI
// 0x0030 (0x0030 - 0x0000)
struct FM1MissionWaveSurvivalInfoUI final
{
public:
	class FText                                   TargetText;                                        // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	class FString                                 MarkerString;                                      // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingMonsterRatio;                             // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllMonstersKilled;                                // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasNamedMonsterSpawned;                           // 0x002D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MissionWaveSurvivalInfoUI) == 0x000008, "Wrong alignment on FM1MissionWaveSurvivalInfoUI");
static_assert(sizeof(FM1MissionWaveSurvivalInfoUI) == 0x000030, "Wrong size on FM1MissionWaveSurvivalInfoUI");
static_assert(offsetof(FM1MissionWaveSurvivalInfoUI, TargetText) == 0x000000, "Member 'FM1MissionWaveSurvivalInfoUI::TargetText' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveSurvivalInfoUI, MarkerString) == 0x000018, "Member 'FM1MissionWaveSurvivalInfoUI::MarkerString' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveSurvivalInfoUI, RemainingMonsterRatio) == 0x000028, "Member 'FM1MissionWaveSurvivalInfoUI::RemainingMonsterRatio' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveSurvivalInfoUI, bAllMonstersKilled) == 0x00002C, "Member 'FM1MissionWaveSurvivalInfoUI::bAllMonstersKilled' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveSurvivalInfoUI, bHasNamedMonsterSpawned) == 0x00002D, "Member 'FM1MissionWaveSurvivalInfoUI::bHasNamedMonsterSpawned' has a wrong offset!");

// ScriptStruct M1.M1Request_UseUpResourceItem
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_UseUpResourceItem final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ConsumableUid;                                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseCnt;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_UseUpResourceItem) == 0x000008, "Wrong alignment on FM1Request_UseUpResourceItem");
static_assert(sizeof(FM1Request_UseUpResourceItem) == 0x000018, "Wrong size on FM1Request_UseUpResourceItem");
static_assert(offsetof(FM1Request_UseUpResourceItem, AccountUid) == 0x000000, "Member 'FM1Request_UseUpResourceItem::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_UseUpResourceItem, ConsumableUid) == 0x000008, "Member 'FM1Request_UseUpResourceItem::ConsumableUid' has a wrong offset!");
static_assert(offsetof(FM1Request_UseUpResourceItem, UseCnt) == 0x000010, "Member 'FM1Request_UseUpResourceItem::UseCnt' has a wrong offset!");

// ScriptStruct M1.M1Request_SetItemTagsWithByte
// 0x0028 (0x0028 - 0x0000)
struct FM1Request_SetItemTagsWithByte final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InventoryRevision;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 FilterIndex;                                       // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EM1ItemTagStatus                              FormerStatus;                                      // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemTagStatus                              TagStatus;                                         // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_SetItemTagsWithByte) == 0x000008, "Wrong alignment on FM1Request_SetItemTagsWithByte");
static_assert(sizeof(FM1Request_SetItemTagsWithByte) == 0x000028, "Wrong size on FM1Request_SetItemTagsWithByte");
static_assert(offsetof(FM1Request_SetItemTagsWithByte, AccountUid) == 0x000000, "Member 'FM1Request_SetItemTagsWithByte::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_SetItemTagsWithByte, InventoryRevision) == 0x000008, "Member 'FM1Request_SetItemTagsWithByte::InventoryRevision' has a wrong offset!");
static_assert(offsetof(FM1Request_SetItemTagsWithByte, Count) == 0x00000C, "Member 'FM1Request_SetItemTagsWithByte::Count' has a wrong offset!");
static_assert(offsetof(FM1Request_SetItemTagsWithByte, FilterIndex) == 0x000010, "Member 'FM1Request_SetItemTagsWithByte::FilterIndex' has a wrong offset!");
static_assert(offsetof(FM1Request_SetItemTagsWithByte, FormerStatus) == 0x000020, "Member 'FM1Request_SetItemTagsWithByte::FormerStatus' has a wrong offset!");
static_assert(offsetof(FM1Request_SetItemTagsWithByte, TagStatus) == 0x000021, "Member 'FM1Request_SetItemTagsWithByte::TagStatus' has a wrong offset!");

// ScriptStruct M1.M1Request_LastFieldAndBattleZoneSet
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_LastFieldAndBattleZoneSet final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MapTemplateId;                                     // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          BattleZoneId;                                      // 0x000C(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_LastFieldAndBattleZoneSet) == 0x000008, "Wrong alignment on FM1Request_LastFieldAndBattleZoneSet");
static_assert(sizeof(FM1Request_LastFieldAndBattleZoneSet) == 0x000010, "Wrong size on FM1Request_LastFieldAndBattleZoneSet");
static_assert(offsetof(FM1Request_LastFieldAndBattleZoneSet, AccountUid) == 0x000000, "Member 'FM1Request_LastFieldAndBattleZoneSet::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_LastFieldAndBattleZoneSet, MapTemplateId) == 0x000008, "Member 'FM1Request_LastFieldAndBattleZoneSet::MapTemplateId' has a wrong offset!");
static_assert(offsetof(FM1Request_LastFieldAndBattleZoneSet, BattleZoneId) == 0x00000C, "Member 'FM1Request_LastFieldAndBattleZoneSet::BattleZoneId' has a wrong offset!");

// ScriptStruct M1.M1Request_SetItemTagsWithList
// 0x0028 (0x0028 - 0x0000)
struct FM1Request_SetItemTagsWithList final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InventoryRevision;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemShortIndexBundle                IndexBundle;                                       // 0x0010(0x0010)(NativeAccessSpecifierPublic)
	EM1ItemTagStatus                              FormerStatus;                                      // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemTagStatus                              TagStatus;                                         // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_SetItemTagsWithList) == 0x000008, "Wrong alignment on FM1Request_SetItemTagsWithList");
static_assert(sizeof(FM1Request_SetItemTagsWithList) == 0x000028, "Wrong size on FM1Request_SetItemTagsWithList");
static_assert(offsetof(FM1Request_SetItemTagsWithList, AccountUid) == 0x000000, "Member 'FM1Request_SetItemTagsWithList::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_SetItemTagsWithList, InventoryRevision) == 0x000008, "Member 'FM1Request_SetItemTagsWithList::InventoryRevision' has a wrong offset!");
static_assert(offsetof(FM1Request_SetItemTagsWithList, Count) == 0x00000C, "Member 'FM1Request_SetItemTagsWithList::Count' has a wrong offset!");
static_assert(offsetof(FM1Request_SetItemTagsWithList, IndexBundle) == 0x000010, "Member 'FM1Request_SetItemTagsWithList::IndexBundle' has a wrong offset!");
static_assert(offsetof(FM1Request_SetItemTagsWithList, FormerStatus) == 0x000020, "Member 'FM1Request_SetItemTagsWithList::FormerStatus' has a wrong offset!");
static_assert(offsetof(FM1Request_SetItemTagsWithList, TagStatus) == 0x000021, "Member 'FM1Request_SetItemTagsWithList::TagStatus' has a wrong offset!");

// ScriptStruct M1.M1Request_MoveEquipmentToWareHouse
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_MoveEquipmentToWareHouse final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemUidBox                          ItemUidBox;                                        // 0x0008(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_MoveEquipmentToWareHouse) == 0x000008, "Wrong alignment on FM1Request_MoveEquipmentToWareHouse");
static_assert(sizeof(FM1Request_MoveEquipmentToWareHouse) == 0x000018, "Wrong size on FM1Request_MoveEquipmentToWareHouse");
static_assert(offsetof(FM1Request_MoveEquipmentToWareHouse, AccountUid) == 0x000000, "Member 'FM1Request_MoveEquipmentToWareHouse::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_MoveEquipmentToWareHouse, ItemUidBox) == 0x000008, "Member 'FM1Request_MoveEquipmentToWareHouse::ItemUidBox' has a wrong offset!");

// ScriptStruct M1.M1OptionPlatformInfo
// 0x000B (0x000B - 0x0000)
struct FM1OptionPlatformInfo final
{
public:
	bool                                          bPC;                                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNexon;                                            // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPS4_Normal;                                       // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPS4_Pro;                                          // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPS5;                                              // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPS5_Trinity;                                      // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bXB1;                                              // 0x0006(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bXB1S;                                             // 0x0007(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bXB1X;                                             // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bXSS;                                              // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bXSX;                                              // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1OptionPlatformInfo) == 0x000001, "Wrong alignment on FM1OptionPlatformInfo");
static_assert(sizeof(FM1OptionPlatformInfo) == 0x00000B, "Wrong size on FM1OptionPlatformInfo");
static_assert(offsetof(FM1OptionPlatformInfo, bPC) == 0x000000, "Member 'FM1OptionPlatformInfo::bPC' has a wrong offset!");
static_assert(offsetof(FM1OptionPlatformInfo, bNexon) == 0x000001, "Member 'FM1OptionPlatformInfo::bNexon' has a wrong offset!");
static_assert(offsetof(FM1OptionPlatformInfo, bPS4_Normal) == 0x000002, "Member 'FM1OptionPlatformInfo::bPS4_Normal' has a wrong offset!");
static_assert(offsetof(FM1OptionPlatformInfo, bPS4_Pro) == 0x000003, "Member 'FM1OptionPlatformInfo::bPS4_Pro' has a wrong offset!");
static_assert(offsetof(FM1OptionPlatformInfo, bPS5) == 0x000004, "Member 'FM1OptionPlatformInfo::bPS5' has a wrong offset!");
static_assert(offsetof(FM1OptionPlatformInfo, bPS5_Trinity) == 0x000005, "Member 'FM1OptionPlatformInfo::bPS5_Trinity' has a wrong offset!");
static_assert(offsetof(FM1OptionPlatformInfo, bXB1) == 0x000006, "Member 'FM1OptionPlatformInfo::bXB1' has a wrong offset!");
static_assert(offsetof(FM1OptionPlatformInfo, bXB1S) == 0x000007, "Member 'FM1OptionPlatformInfo::bXB1S' has a wrong offset!");
static_assert(offsetof(FM1OptionPlatformInfo, bXB1X) == 0x000008, "Member 'FM1OptionPlatformInfo::bXB1X' has a wrong offset!");
static_assert(offsetof(FM1OptionPlatformInfo, bXSS) == 0x000009, "Member 'FM1OptionPlatformInfo::bXSS' has a wrong offset!");
static_assert(offsetof(FM1OptionPlatformInfo, bXSX) == 0x00000A, "Member 'FM1OptionPlatformInfo::bXSX' has a wrong offset!");

// ScriptStruct M1.M1OptionIndividualTableRow
// 0x0030 (0x0038 - 0x0008)
struct FM1OptionIndividualTableRow final : public FTableRowBase
{
public:
	class FName                                   DevName;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringId;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1OptionFeature                              Feature;                                           // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1OptionPlatformInfo                  Platform;                                          // 0x0029(0x000B)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1OptionIndividualTableRow) == 0x000008, "Wrong alignment on FM1OptionIndividualTableRow");
static_assert(sizeof(FM1OptionIndividualTableRow) == 0x000038, "Wrong size on FM1OptionIndividualTableRow");
static_assert(offsetof(FM1OptionIndividualTableRow, DevName) == 0x000008, "Member 'FM1OptionIndividualTableRow::DevName' has a wrong offset!");
static_assert(offsetof(FM1OptionIndividualTableRow, SortOrder) == 0x000010, "Member 'FM1OptionIndividualTableRow::SortOrder' has a wrong offset!");
static_assert(offsetof(FM1OptionIndividualTableRow, StringId) == 0x000018, "Member 'FM1OptionIndividualTableRow::StringId' has a wrong offset!");
static_assert(offsetof(FM1OptionIndividualTableRow, Feature) == 0x000028, "Member 'FM1OptionIndividualTableRow::Feature' has a wrong offset!");
static_assert(offsetof(FM1OptionIndividualTableRow, Platform) == 0x000029, "Member 'FM1OptionIndividualTableRow::Platform' has a wrong offset!");

// ScriptStruct M1.M1Request_CustomizingCharacter
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CustomizingCharacter final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1RequestCustomizingCharacter         Request;                                           // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CustomizingCharacter) == 0x000008, "Wrong alignment on FM1Request_CustomizingCharacter");
static_assert(sizeof(FM1Request_CustomizingCharacter) == 0x000010, "Wrong size on FM1Request_CustomizingCharacter");
static_assert(offsetof(FM1Request_CustomizingCharacter, AccountUid) == 0x000000, "Member 'FM1Request_CustomizingCharacter::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CustomizingCharacter, Request) == 0x000008, "Member 'FM1Request_CustomizingCharacter::Request' has a wrong offset!");

// ScriptStruct M1.M1Request_TakeOutFromWareHouse
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_TakeOutFromWareHouse final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemUidBox                          ItemUidBox;                                        // 0x0008(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_TakeOutFromWareHouse) == 0x000008, "Wrong alignment on FM1Request_TakeOutFromWareHouse");
static_assert(sizeof(FM1Request_TakeOutFromWareHouse) == 0x000018, "Wrong size on FM1Request_TakeOutFromWareHouse");
static_assert(offsetof(FM1Request_TakeOutFromWareHouse, AccountUid) == 0x000000, "Member 'FM1Request_TakeOutFromWareHouse::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_TakeOutFromWareHouse, ItemUidBox) == 0x000008, "Member 'FM1Request_TakeOutFromWareHouse::ItemUidBox' has a wrong offset!");

// ScriptStruct M1.M1Request_GetInventoryMaxCount
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_GetInventoryMaxCount final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1InventoryType                              InventoryType;                                     // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_GetInventoryMaxCount) == 0x000008, "Wrong alignment on FM1Request_GetInventoryMaxCount");
static_assert(sizeof(FM1Request_GetInventoryMaxCount) == 0x000010, "Wrong size on FM1Request_GetInventoryMaxCount");
static_assert(offsetof(FM1Request_GetInventoryMaxCount, AccountUid) == 0x000000, "Member 'FM1Request_GetInventoryMaxCount::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_GetInventoryMaxCount, InventoryType) == 0x000008, "Member 'FM1Request_GetInventoryMaxCount::InventoryType' has a wrong offset!");

// ScriptStruct M1.M1MonsterHpBarSetting
// 0x0008 (0x0008 - 0x0000)
struct FM1MonsterHpBarSetting final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterHpBarSetting) == 0x000004, "Wrong alignment on FM1MonsterHpBarSetting");
static_assert(sizeof(FM1MonsterHpBarSetting) == 0x000008, "Wrong size on FM1MonsterHpBarSetting");
static_assert(offsetof(FM1MonsterHpBarSetting, Duration) == 0x000000, "Member 'FM1MonsterHpBarSetting::Duration' has a wrong offset!");
static_assert(offsetof(FM1MonsterHpBarSetting, MaxCount) == 0x000004, "Member 'FM1MonsterHpBarSetting::MaxCount' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatClearAllUnlockedFieldAndCamp
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_CheatClearAllUnlockedFieldAndCamp final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatClearAllUnlockedFieldAndCamp) == 0x000008, "Wrong alignment on FM1Request_CheatClearAllUnlockedFieldAndCamp");
static_assert(sizeof(FM1Request_CheatClearAllUnlockedFieldAndCamp) == 0x000008, "Wrong size on FM1Request_CheatClearAllUnlockedFieldAndCamp");
static_assert(offsetof(FM1Request_CheatClearAllUnlockedFieldAndCamp, AccountUid) == 0x000000, "Member 'FM1Request_CheatClearAllUnlockedFieldAndCamp::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_ItemUpgrade
// 0x0028 (0x0028 - 0x0000)
struct FM1Request_ItemUpgrade final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemUidBox                          OrgWeaponUid;                                      // 0x0008(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1ItemUidBox                          ConsumWeaponUid;                                   // 0x0018(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_ItemUpgrade) == 0x000008, "Wrong alignment on FM1Request_ItemUpgrade");
static_assert(sizeof(FM1Request_ItemUpgrade) == 0x000028, "Wrong size on FM1Request_ItemUpgrade");
static_assert(offsetof(FM1Request_ItemUpgrade, AccountUid) == 0x000000, "Member 'FM1Request_ItemUpgrade::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_ItemUpgrade, OrgWeaponUid) == 0x000008, "Member 'FM1Request_ItemUpgrade::OrgWeaponUid' has a wrong offset!");
static_assert(offsetof(FM1Request_ItemUpgrade, ConsumWeaponUid) == 0x000018, "Member 'FM1Request_ItemUpgrade::ConsumWeaponUid' has a wrong offset!");

// ScriptStruct M1.M1Request_DecomposeItem
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_DecomposeItem final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemUidBox                          ItemUid;                                           // 0x0008(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_DecomposeItem) == 0x000008, "Wrong alignment on FM1Request_DecomposeItem");
static_assert(sizeof(FM1Request_DecomposeItem) == 0x000018, "Wrong size on FM1Request_DecomposeItem");
static_assert(offsetof(FM1Request_DecomposeItem, AccountUid) == 0x000000, "Member 'FM1Request_DecomposeItem::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_DecomposeItem, ItemUid) == 0x000008, "Member 'FM1Request_DecomposeItem::ItemUid' has a wrong offset!");

// ScriptStruct M1.M1Request_ReactorEnchant
// 0x0020 (0x0020 - 0x0000)
struct FM1Request_ReactorEnchant final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemUidBox                          ReactorEquipmentId;                                // 0x0008(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         UpToLv;                                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_ReactorEnchant) == 0x000008, "Wrong alignment on FM1Request_ReactorEnchant");
static_assert(sizeof(FM1Request_ReactorEnchant) == 0x000020, "Wrong size on FM1Request_ReactorEnchant");
static_assert(offsetof(FM1Request_ReactorEnchant, AccountUid) == 0x000000, "Member 'FM1Request_ReactorEnchant::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_ReactorEnchant, ReactorEquipmentId) == 0x000008, "Member 'FM1Request_ReactorEnchant::ReactorEquipmentId' has a wrong offset!");
static_assert(offsetof(FM1Request_ReactorEnchant, UpToLv) == 0x000018, "Member 'FM1Request_ReactorEnchant::UpToLv' has a wrong offset!");

// ScriptStruct M1.M1WorldObjectRow
// 0x00B8 (0x00C0 - 0x0008)
struct FM1WorldObjectRow final : public FTableRowBase
{
public:
	class FString                                 UIKey;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             IconImage;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<EM1MapType>                              DisplayMapType;                                    // 0x0020(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSet<class FName>                             DisplayDifficultyLevels;                           // 0x0070(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WorldObjectRow) == 0x000008, "Wrong alignment on FM1WorldObjectRow");
static_assert(sizeof(FM1WorldObjectRow) == 0x0000C0, "Wrong size on FM1WorldObjectRow");
static_assert(offsetof(FM1WorldObjectRow, UIKey) == 0x000008, "Member 'FM1WorldObjectRow::UIKey' has a wrong offset!");
static_assert(offsetof(FM1WorldObjectRow, IconImage) == 0x000018, "Member 'FM1WorldObjectRow::IconImage' has a wrong offset!");
static_assert(offsetof(FM1WorldObjectRow, DisplayMapType) == 0x000020, "Member 'FM1WorldObjectRow::DisplayMapType' has a wrong offset!");
static_assert(offsetof(FM1WorldObjectRow, DisplayDifficultyLevels) == 0x000070, "Member 'FM1WorldObjectRow::DisplayDifficultyLevels' has a wrong offset!");

// ScriptStruct M1.M1Request_DecomposeJunkItems
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_DecomposeJunkItems final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InWarehouse;                                       // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_DecomposeJunkItems) == 0x000008, "Wrong alignment on FM1Request_DecomposeJunkItems");
static_assert(sizeof(FM1Request_DecomposeJunkItems) == 0x000010, "Wrong size on FM1Request_DecomposeJunkItems");
static_assert(offsetof(FM1Request_DecomposeJunkItems, AccountUid) == 0x000000, "Member 'FM1Request_DecomposeJunkItems::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_DecomposeJunkItems, InWarehouse) == 0x000008, "Member 'FM1Request_DecomposeJunkItems::InWarehouse' has a wrong offset!");

// ScriptStruct M1.M1Request_GetInitializationData
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_GetInitializationData final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemType                                   ItemType;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_GetInitializationData) == 0x000008, "Wrong alignment on FM1Request_GetInitializationData");
static_assert(sizeof(FM1Request_GetInitializationData) == 0x000010, "Wrong size on FM1Request_GetInitializationData");
static_assert(offsetof(FM1Request_GetInitializationData, AccountUid) == 0x000000, "Member 'FM1Request_GetInitializationData::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_GetInitializationData, ItemType) == 0x000008, "Member 'FM1Request_GetInitializationData::ItemType' has a wrong offset!");

// ScriptStruct M1.M1Request_GetQuestInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_GetQuestInfo final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1QuestType                                  GetType;                                           // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_GetQuestInfo) == 0x000008, "Wrong alignment on FM1Request_GetQuestInfo");
static_assert(sizeof(FM1Request_GetQuestInfo) == 0x000010, "Wrong size on FM1Request_GetQuestInfo");
static_assert(offsetof(FM1Request_GetQuestInfo, AccountUid) == 0x000000, "Member 'FM1Request_GetQuestInfo::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_GetQuestInfo, GetType) == 0x000008, "Member 'FM1Request_GetQuestInfo::GetType' has a wrong offset!");

// ScriptStruct M1.M1Request_ChangeRandomOption
// 0x0028 (0x0028 - 0x0000)
struct FM1Request_ChangeRandomOption final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemUidBox                          EquipmentUid;                                      // 0x0008(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1FixedOptionIndexes                  FixedOptionIndexes;                                // 0x0018(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_ChangeRandomOption) == 0x000008, "Wrong alignment on FM1Request_ChangeRandomOption");
static_assert(sizeof(FM1Request_ChangeRandomOption) == 0x000028, "Wrong size on FM1Request_ChangeRandomOption");
static_assert(offsetof(FM1Request_ChangeRandomOption, AccountUid) == 0x000000, "Member 'FM1Request_ChangeRandomOption::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_ChangeRandomOption, EquipmentUid) == 0x000008, "Member 'FM1Request_ChangeRandomOption::EquipmentUid' has a wrong offset!");
static_assert(offsetof(FM1Request_ChangeRandomOption, FixedOptionIndexes) == 0x000018, "Member 'FM1Request_ChangeRandomOption::FixedOptionIndexes' has a wrong offset!");

// ScriptStruct M1.M1Request_GetBoostItemEffect
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_GetBoostItemEffect final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_GetBoostItemEffect) == 0x000008, "Wrong alignment on FM1Request_GetBoostItemEffect");
static_assert(sizeof(FM1Request_GetBoostItemEffect) == 0x000008, "Wrong size on FM1Request_GetBoostItemEffect");
static_assert(offsetof(FM1Request_GetBoostItemEffect, AccountUid) == 0x000000, "Member 'FM1Request_GetBoostItemEffect::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1SocialMotionAnimMontage
// 0x0060 (0x0060 - 0x0000)
struct FM1SocialMotionAnimMontage final
{
public:
	TSoftObjectPtr<class UAnimMontage>            Female;                                            // 0x0000(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Male;                                              // 0x0030(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SocialMotionAnimMontage) == 0x000008, "Wrong alignment on FM1SocialMotionAnimMontage");
static_assert(sizeof(FM1SocialMotionAnimMontage) == 0x000060, "Wrong size on FM1SocialMotionAnimMontage");
static_assert(offsetof(FM1SocialMotionAnimMontage, Female) == 0x000000, "Member 'FM1SocialMotionAnimMontage::Female' has a wrong offset!");
static_assert(offsetof(FM1SocialMotionAnimMontage, Male) == 0x000030, "Member 'FM1SocialMotionAnimMontage::Male' has a wrong offset!");

// ScriptStruct M1.M1Request_UncustomizingWeapon
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_UncustomizingWeapon final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1RequestCustomizingWeapon            Request;                                           // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_UncustomizingWeapon) == 0x000008, "Wrong alignment on FM1Request_UncustomizingWeapon");
static_assert(sizeof(FM1Request_UncustomizingWeapon) == 0x000010, "Wrong size on FM1Request_UncustomizingWeapon");
static_assert(offsetof(FM1Request_UncustomizingWeapon, AccountUid) == 0x000000, "Member 'FM1Request_UncustomizingWeapon::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_UncustomizingWeapon, Request) == 0x000008, "Member 'FM1Request_UncustomizingWeapon::Request' has a wrong offset!");

// ScriptStruct M1.M1Request_GetInventoryRevision
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_GetInventoryRevision final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_GetInventoryRevision) == 0x000008, "Wrong alignment on FM1Request_GetInventoryRevision");
static_assert(sizeof(FM1Request_GetInventoryRevision) == 0x000008, "Wrong size on FM1Request_GetInventoryRevision");
static_assert(offsetof(FM1Request_GetInventoryRevision, AccountUid) == 0x000000, "Member 'FM1Request_GetInventoryRevision::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatCreateItem
// 0x0020 (0x0020 - 0x0000)
struct FM1Request_CheatCreateItem final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemTidBox                          ItemTid;                                           // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerkLevel;                                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReactorEnchantLevel;                               // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatCreateItem) == 0x000008, "Wrong alignment on FM1Request_CheatCreateItem");
static_assert(sizeof(FM1Request_CheatCreateItem) == 0x000020, "Wrong size on FM1Request_CheatCreateItem");
static_assert(offsetof(FM1Request_CheatCreateItem, AccountUid) == 0x000000, "Member 'FM1Request_CheatCreateItem::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatCreateItem, ItemTid) == 0x000008, "Member 'FM1Request_CheatCreateItem::ItemTid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatCreateItem, Count) == 0x000010, "Member 'FM1Request_CheatCreateItem::Count' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatCreateItem, Level) == 0x000014, "Member 'FM1Request_CheatCreateItem::Level' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatCreateItem, PerkLevel) == 0x000018, "Member 'FM1Request_CheatCreateItem::PerkLevel' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatCreateItem, ReactorEnchantLevel) == 0x00001C, "Member 'FM1Request_CheatCreateItem::ReactorEnchantLevel' has a wrong offset!");

// ScriptStruct M1.M1MissionTaskDropElement
// 0x0018 (0x0018 - 0x0000)
struct FM1MissionTaskDropElement final
{
public:
	class FName                                   DropContainerRow;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ValueMin;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ValueMax;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Ratio;                                             // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionTaskDropElement) == 0x000008, "Wrong alignment on FM1MissionTaskDropElement");
static_assert(sizeof(FM1MissionTaskDropElement) == 0x000018, "Wrong size on FM1MissionTaskDropElement");
static_assert(offsetof(FM1MissionTaskDropElement, DropContainerRow) == 0x000000, "Member 'FM1MissionTaskDropElement::DropContainerRow' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskDropElement, ValueMin) == 0x000008, "Member 'FM1MissionTaskDropElement::ValueMin' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskDropElement, ValueMax) == 0x00000C, "Member 'FM1MissionTaskDropElement::ValueMax' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskDropElement, Ratio) == 0x000010, "Member 'FM1MissionTaskDropElement::Ratio' has a wrong offset!");

// ScriptStruct M1.M1MissionTaskDropGroup
// 0x0018 (0x0018 - 0x0000)
struct FM1MissionTaskDropGroup final
{
public:
	int64                                         Ratio;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1MissionTaskDropElement>      TaskDropElements;                                  // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionTaskDropGroup) == 0x000008, "Wrong alignment on FM1MissionTaskDropGroup");
static_assert(sizeof(FM1MissionTaskDropGroup) == 0x000018, "Wrong size on FM1MissionTaskDropGroup");
static_assert(offsetof(FM1MissionTaskDropGroup, Ratio) == 0x000000, "Member 'FM1MissionTaskDropGroup::Ratio' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskDropGroup, TaskDropElements) == 0x000008, "Member 'FM1MissionTaskDropGroup::TaskDropElements' has a wrong offset!");

// ScriptStruct M1.M1MissionTaskDropData
// 0x0018 (0x0020 - 0x0008)
struct FM1MissionTaskDropData final : public FTableRowBase
{
public:
	EM1MissionTaskDropType                        Type;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1MissionTaskDropGroup>        TaskDropGroups;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionTaskDropData) == 0x000008, "Wrong alignment on FM1MissionTaskDropData");
static_assert(sizeof(FM1MissionTaskDropData) == 0x000020, "Wrong size on FM1MissionTaskDropData");
static_assert(offsetof(FM1MissionTaskDropData, Type) == 0x000008, "Member 'FM1MissionTaskDropData::Type' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskDropData, TaskDropGroups) == 0x000010, "Member 'FM1MissionTaskDropData::TaskDropGroups' has a wrong offset!");

// ScriptStruct M1.M1Request_AcceptSupport
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_AcceptSupport final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Token;                                             // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_AcceptSupport) == 0x000008, "Wrong alignment on FM1Request_AcceptSupport");
static_assert(sizeof(FM1Request_AcceptSupport) == 0x000018, "Wrong size on FM1Request_AcceptSupport");
static_assert(offsetof(FM1Request_AcceptSupport, AccountUid) == 0x000000, "Member 'FM1Request_AcceptSupport::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_AcceptSupport, Token) == 0x000008, "Member 'FM1Request_AcceptSupport::Token' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatCreateCharacter
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CheatCreateCharacter final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_CheatCreateCharacter) == 0x000008, "Wrong alignment on FM1Request_CheatCreateCharacter");
static_assert(sizeof(FM1Request_CheatCreateCharacter) == 0x000010, "Wrong size on FM1Request_CheatCreateCharacter");
static_assert(offsetof(FM1Request_CheatCreateCharacter, AccountUid) == 0x000000, "Member 'FM1Request_CheatCreateCharacter::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatCreateCharacter, TemplateId) == 0x000008, "Member 'FM1Request_CheatCreateCharacter::TemplateId' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatCreateEquipment
// 0x0028 (0x0028 - 0x0000)
struct FM1Request_CheatCreateEquipment final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1CheatCreateEquipmentReq             Req;                                               // 0x0008(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatCreateEquipment) == 0x000008, "Wrong alignment on FM1Request_CheatCreateEquipment");
static_assert(sizeof(FM1Request_CheatCreateEquipment) == 0x000028, "Wrong size on FM1Request_CheatCreateEquipment");
static_assert(offsetof(FM1Request_CheatCreateEquipment, AccountUid) == 0x000000, "Member 'FM1Request_CheatCreateEquipment::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatCreateEquipment, Req) == 0x000008, "Member 'FM1Request_CheatCreateEquipment::Req' has a wrong offset!");

// ScriptStruct M1.M1MonsterDropData
// 0x0014 (0x0014 - 0x0000)
struct FM1MonsterDropData final
{
public:
	EM1MonsterCategory                            MonsterCategory;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MonsterSubType                             MonsterSubType;                                    // 0x0001(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DropItemRowName;                                   // 0x0004(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropEquipLevelRangeMin;                            // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropEquipLevelRangeMax;                            // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterDropData) == 0x000004, "Wrong alignment on FM1MonsterDropData");
static_assert(sizeof(FM1MonsterDropData) == 0x000014, "Wrong size on FM1MonsterDropData");
static_assert(offsetof(FM1MonsterDropData, MonsterCategory) == 0x000000, "Member 'FM1MonsterDropData::MonsterCategory' has a wrong offset!");
static_assert(offsetof(FM1MonsterDropData, MonsterSubType) == 0x000001, "Member 'FM1MonsterDropData::MonsterSubType' has a wrong offset!");
static_assert(offsetof(FM1MonsterDropData, DropItemRowName) == 0x000004, "Member 'FM1MonsterDropData::DropItemRowName' has a wrong offset!");
static_assert(offsetof(FM1MonsterDropData, DropEquipLevelRangeMin) == 0x00000C, "Member 'FM1MonsterDropData::DropEquipLevelRangeMin' has a wrong offset!");
static_assert(offsetof(FM1MonsterDropData, DropEquipLevelRangeMax) == 0x000010, "Member 'FM1MonsterDropData::DropEquipLevelRangeMax' has a wrong offset!");

// ScriptStruct M1.M1Request_ReceivePremiumExclusiveReward
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_ReceivePremiumExclusiveReward final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_ReceivePremiumExclusiveReward) == 0x000008, "Wrong alignment on FM1Request_ReceivePremiumExclusiveReward");
static_assert(sizeof(FM1Request_ReceivePremiumExclusiveReward) == 0x000008, "Wrong size on FM1Request_ReceivePremiumExclusiveReward");
static_assert(offsetof(FM1Request_ReceivePremiumExclusiveReward, AccountUid) == 0x000000, "Member 'FM1Request_ReceivePremiumExclusiveReward::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1UpperBodyAnimClass
// 0x0010 (0x0010 - 0x0000)
struct FM1UpperBodyAnimClass final
{
public:
	TSubclassOf<class UM1UpperBodyAnimInstance>   FemaleClass;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UM1UpperBodyAnimInstance>   MaleClass;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1UpperBodyAnimClass) == 0x000008, "Wrong alignment on FM1UpperBodyAnimClass");
static_assert(sizeof(FM1UpperBodyAnimClass) == 0x000010, "Wrong size on FM1UpperBodyAnimClass");
static_assert(offsetof(FM1UpperBodyAnimClass, FemaleClass) == 0x000000, "Member 'FM1UpperBodyAnimClass::FemaleClass' has a wrong offset!");
static_assert(offsetof(FM1UpperBodyAnimClass, MaleClass) == 0x000008, "Member 'FM1UpperBodyAnimClass::MaleClass' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatAddTime
// 0x000C (0x000C - 0x0000)
struct FM1Request_CheatAddTime final : public FM1Request
{
public:
	int32                                         Days;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hours;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Minutes;                                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatAddTime) == 0x000004, "Wrong alignment on FM1Request_CheatAddTime");
static_assert(sizeof(FM1Request_CheatAddTime) == 0x00000C, "Wrong size on FM1Request_CheatAddTime");
static_assert(offsetof(FM1Request_CheatAddTime, Days) == 0x000000, "Member 'FM1Request_CheatAddTime::Days' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatAddTime, Hours) == 0x000004, "Member 'FM1Request_CheatAddTime::Hours' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatAddTime, Minutes) == 0x000008, "Member 'FM1Request_CheatAddTime::Minutes' has a wrong offset!");

// ScriptStruct M1.M1MissionJoinedPlayers
// 0x0010 (0x0010 - 0x0000)
struct FM1MissionJoinedPlayers final
{
public:
	TArray<class UM1MissionControlComponent*>     Players;                                           // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionJoinedPlayers) == 0x000008, "Wrong alignment on FM1MissionJoinedPlayers");
static_assert(sizeof(FM1MissionJoinedPlayers) == 0x000010, "Wrong size on FM1MissionJoinedPlayers");
static_assert(offsetof(FM1MissionJoinedPlayers, Players) == 0x000000, "Member 'FM1MissionJoinedPlayers::Players' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatAddTickCount
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_CheatAddTickCount final : public FM1Request
{
public:
	int64                                         TickCount;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatAddTickCount) == 0x000008, "Wrong alignment on FM1Request_CheatAddTickCount");
static_assert(sizeof(FM1Request_CheatAddTickCount) == 0x000008, "Wrong size on FM1Request_CheatAddTickCount");
static_assert(offsetof(FM1Request_CheatAddTickCount, TickCount) == 0x000000, "Member 'FM1Request_CheatAddTickCount::TickCount' has a wrong offset!");

// ScriptStruct M1.M1Request_SavePreset
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_SavePreset final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PresetIndex;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_SavePreset) == 0x000008, "Wrong alignment on FM1Request_SavePreset");
static_assert(sizeof(FM1Request_SavePreset) == 0x000010, "Wrong size on FM1Request_SavePreset");
static_assert(offsetof(FM1Request_SavePreset, AccountUid) == 0x000000, "Member 'FM1Request_SavePreset::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_SavePreset, PresetIndex) == 0x000008, "Member 'FM1Request_SavePreset::PresetIndex' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatResetTime
// 0x0001 (0x0001 - 0x0000)
struct FM1Request_CheatResetTime final : public FM1Request
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_CheatResetTime) == 0x000001, "Wrong alignment on FM1Request_CheatResetTime");
static_assert(sizeof(FM1Request_CheatResetTime) == 0x000001, "Wrong size on FM1Request_CheatResetTime");

// ScriptStruct M1.M1MissionPlayInfo
// 0x0004 (0x0004 - 0x0000)
struct FM1MissionPlayInfo final
{
public:
	int32                                         RemainingRespawnCount;                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionPlayInfo) == 0x000004, "Wrong alignment on FM1MissionPlayInfo");
static_assert(sizeof(FM1MissionPlayInfo) == 0x000004, "Wrong size on FM1MissionPlayInfo");
static_assert(offsetof(FM1MissionPlayInfo, RemainingRespawnCount) == 0x000000, "Member 'FM1MissionPlayInfo::RemainingRespawnCount' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatDestroyCharacter
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CheatDestroyCharacter final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         CharacterUid;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatDestroyCharacter) == 0x000008, "Wrong alignment on FM1Request_CheatDestroyCharacter");
static_assert(sizeof(FM1Request_CheatDestroyCharacter) == 0x000010, "Wrong size on FM1Request_CheatDestroyCharacter");
static_assert(offsetof(FM1Request_CheatDestroyCharacter, AccountUid) == 0x000000, "Member 'FM1Request_CheatDestroyCharacter::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatDestroyCharacter, CharacterUid) == 0x000008, "Member 'FM1Request_CheatDestroyCharacter::CharacterUid' has a wrong offset!");

// ScriptStruct M1.UIDataInitParam
// 0x0010 (0x0010 - 0x0000)
struct FUIDataInitParam
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UM1UIData>                  DataClass;                                         // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIDataInitParam) == 0x000008, "Wrong alignment on FUIDataInitParam");
static_assert(sizeof(FUIDataInitParam) == 0x000010, "Wrong size on FUIDataInitParam");
static_assert(offsetof(FUIDataInitParam, DataClass) == 0x000008, "Member 'FUIDataInitParam::DataClass' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatDisableHeartbeat
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatDisableHeartbeat final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatDisableHeartbeat) == 0x000001, "Wrong alignment on FM1Response_CheatDisableHeartbeat");
static_assert(sizeof(FM1Response_CheatDisableHeartbeat) == 0x000001, "Wrong size on FM1Response_CheatDisableHeartbeat");
static_assert(offsetof(FM1Response_CheatDisableHeartbeat, Notification) == 0x000000, "Member 'FM1Response_CheatDisableHeartbeat::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatAdjustValue
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_CheatAdjustValue final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatAdjustValue) == 0x000008, "Wrong alignment on FM1Request_CheatAdjustValue");
static_assert(sizeof(FM1Request_CheatAdjustValue) == 0x000008, "Wrong size on FM1Request_CheatAdjustValue");
static_assert(offsetof(FM1Request_CheatAdjustValue, AccountUid) == 0x000000, "Member 'FM1Request_CheatAdjustValue::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatChangeInventoryLimit
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CheatChangeInventoryLimit final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1InventoryType                              InventoryType;                                     // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatChangeInventoryLimit) == 0x000008, "Wrong alignment on FM1Request_CheatChangeInventoryLimit");
static_assert(sizeof(FM1Request_CheatChangeInventoryLimit) == 0x000010, "Wrong size on FM1Request_CheatChangeInventoryLimit");
static_assert(offsetof(FM1Request_CheatChangeInventoryLimit, AccountUid) == 0x000000, "Member 'FM1Request_CheatChangeInventoryLimit::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatChangeInventoryLimit, InventoryType) == 0x000008, "Member 'FM1Request_CheatChangeInventoryLimit::InventoryType' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatChangeInventoryLimit, Count) == 0x00000C, "Member 'FM1Request_CheatChangeInventoryLimit::Count' has a wrong offset!");

// ScriptStruct M1.M1DropItemListByPlayer
// 0x0010 (0x0010 - 0x0000)
struct FM1DropItemListByPlayer final
{
public:
	TArray<class AM1DroppedItem*>                 DroppedItems;                                      // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DropItemListByPlayer) == 0x000008, "Wrong alignment on FM1DropItemListByPlayer");
static_assert(sizeof(FM1DropItemListByPlayer) == 0x000010, "Wrong size on FM1DropItemListByPlayer");
static_assert(offsetof(FM1DropItemListByPlayer, DroppedItems) == 0x000000, "Member 'FM1DropItemListByPlayer::DroppedItems' has a wrong offset!");

// ScriptStruct M1.M1InGameItemsList
// 0x00F0 (0x00F0 - 0x0000)
struct FM1InGameItemsList final
{
public:
	TMap<int32, class AM1DroppedItem*>            AllItems;                                          // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	TMap<uint32, struct FM1DropItemListByPlayer>  PrivateItems;                                      // 0x0050(0x0050)(NativeAccessSpecifierPublic)
	TSet<class AM1DroppedItem*>                   PublicItems;                                       // 0x00A0(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InGameItemsList) == 0x000008, "Wrong alignment on FM1InGameItemsList");
static_assert(sizeof(FM1InGameItemsList) == 0x0000F0, "Wrong size on FM1InGameItemsList");
static_assert(offsetof(FM1InGameItemsList, AllItems) == 0x000000, "Member 'FM1InGameItemsList::AllItems' has a wrong offset!");
static_assert(offsetof(FM1InGameItemsList, PrivateItems) == 0x000050, "Member 'FM1InGameItemsList::PrivateItems' has a wrong offset!");
static_assert(offsetof(FM1InGameItemsList, PublicItems) == 0x0000A0, "Member 'FM1InGameItemsList::PublicItems' has a wrong offset!");

// ScriptStruct M1.M1Request_GetSeasonInfo
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_GetSeasonInfo final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_GetSeasonInfo) == 0x000008, "Wrong alignment on FM1Request_GetSeasonInfo");
static_assert(sizeof(FM1Request_GetSeasonInfo) == 0x000008, "Wrong size on FM1Request_GetSeasonInfo");
static_assert(offsetof(FM1Request_GetSeasonInfo, AccountUid) == 0x000000, "Member 'FM1Request_GetSeasonInfo::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatItemReset
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CheatItemReset final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemType                                   ItemType;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_CheatItemReset) == 0x000008, "Wrong alignment on FM1Request_CheatItemReset");
static_assert(sizeof(FM1Request_CheatItemReset) == 0x000010, "Wrong size on FM1Request_CheatItemReset");
static_assert(offsetof(FM1Request_CheatItemReset, AccountUid) == 0x000000, "Member 'FM1Request_CheatItemReset::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatItemReset, ItemType) == 0x000008, "Member 'FM1Request_CheatItemReset::ItemType' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatStatAdjust
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CheatStatAdjust final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1StatType                                   StatType;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatStatAdjust) == 0x000008, "Wrong alignment on FM1Request_CheatStatAdjust");
static_assert(sizeof(FM1Request_CheatStatAdjust) == 0x000010, "Wrong size on FM1Request_CheatStatAdjust");
static_assert(offsetof(FM1Request_CheatStatAdjust, AccountUid) == 0x000000, "Member 'FM1Request_CheatStatAdjust::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatStatAdjust, StatType) == 0x000008, "Member 'FM1Request_CheatStatAdjust::StatType' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatStatAdjust, Value) == 0x00000C, "Member 'FM1Request_CheatStatAdjust::Value' has a wrong offset!");

// ScriptStruct M1.M1ConditionParamVoidFusion
// 0x0008 (0x0008 - 0x0000)
struct FM1ConditionParamVoidFusion final
{
public:
	int32                                         VoidPieceTemplateId;                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ConditionParamVoidFusion) == 0x000004, "Wrong alignment on FM1ConditionParamVoidFusion");
static_assert(sizeof(FM1ConditionParamVoidFusion) == 0x000008, "Wrong size on FM1ConditionParamVoidFusion");
static_assert(offsetof(FM1ConditionParamVoidFusion, VoidPieceTemplateId) == 0x000000, "Member 'FM1ConditionParamVoidFusion::VoidPieceTemplateId' has a wrong offset!");
static_assert(offsetof(FM1ConditionParamVoidFusion, Amount) == 0x000004, "Member 'FM1ConditionParamVoidFusion::Amount' has a wrong offset!");

// ScriptStruct M1.M1Request_GetCodexTrackingList
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_GetCodexTrackingList final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_GetCodexTrackingList) == 0x000008, "Wrong alignment on FM1Request_GetCodexTrackingList");
static_assert(sizeof(FM1Request_GetCodexTrackingList) == 0x000008, "Wrong size on FM1Request_GetCodexTrackingList");
static_assert(offsetof(FM1Request_GetCodexTrackingList, AccountUid) == 0x000000, "Member 'FM1Request_GetCodexTrackingList::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1WeaponCameraSetting
// 0x0048 (0x0048 - 0x0000)
struct FM1WeaponCameraSetting final
{
public:
	struct FM1CameraSetting                       CameraSetting;                                     // 0x0000(0x0048)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponCameraSetting) == 0x000004, "Wrong alignment on FM1WeaponCameraSetting");
static_assert(sizeof(FM1WeaponCameraSetting) == 0x000048, "Wrong size on FM1WeaponCameraSetting");
static_assert(offsetof(FM1WeaponCameraSetting, CameraSetting) == 0x000000, "Member 'FM1WeaponCameraSetting::CameraSetting' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatStatAdjustReset
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_CheatStatAdjustReset final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatStatAdjustReset) == 0x000008, "Wrong alignment on FM1Request_CheatStatAdjustReset");
static_assert(sizeof(FM1Request_CheatStatAdjustReset) == 0x000008, "Wrong size on FM1Request_CheatStatAdjustReset");
static_assert(offsetof(FM1Request_CheatStatAdjustReset, AccountUid) == 0x000000, "Member 'FM1Request_CheatStatAdjustReset::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1MissionJoinContextParam
// 0x0001 (0x0001 - 0x0000)
struct FM1MissionJoinContextParam final
{
public:
	EM1MissionJoinContext                         JoinContext;                                       // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1MissionJoinContextParam) == 0x000001, "Wrong alignment on FM1MissionJoinContextParam");
static_assert(sizeof(FM1MissionJoinContextParam) == 0x000001, "Wrong size on FM1MissionJoinContextParam");
static_assert(offsetof(FM1MissionJoinContextParam, JoinContext) == 0x000000, "Member 'FM1MissionJoinContextParam::JoinContext' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatResetInventoryLimit
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CheatResetInventoryLimit final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1InventoryType                              InventoryType;                                     // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_CheatResetInventoryLimit) == 0x000008, "Wrong alignment on FM1Request_CheatResetInventoryLimit");
static_assert(sizeof(FM1Request_CheatResetInventoryLimit) == 0x000010, "Wrong size on FM1Request_CheatResetInventoryLimit");
static_assert(offsetof(FM1Request_CheatResetInventoryLimit, AccountUid) == 0x000000, "Member 'FM1Request_CheatResetInventoryLimit::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatResetInventoryLimit, InventoryType) == 0x000008, "Member 'FM1Request_CheatResetInventoryLimit::InventoryType' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatAddSeasonExp
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CheatAddSeasonExp final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Exp;                                               // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatAddSeasonExp) == 0x000008, "Wrong alignment on FM1Request_CheatAddSeasonExp");
static_assert(sizeof(FM1Request_CheatAddSeasonExp) == 0x000010, "Wrong size on FM1Request_CheatAddSeasonExp");
static_assert(offsetof(FM1Request_CheatAddSeasonExp, AccountUid) == 0x000000, "Member 'FM1Request_CheatAddSeasonExp::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatAddSeasonExp, Exp) == 0x000008, "Member 'FM1Request_CheatAddSeasonExp::Exp' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatCustomizingEvolution
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CheatCustomizingEvolution final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          SkinTid;                                           // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_CheatCustomizingEvolution) == 0x000008, "Wrong alignment on FM1Request_CheatCustomizingEvolution");
static_assert(sizeof(FM1Request_CheatCustomizingEvolution) == 0x000010, "Wrong size on FM1Request_CheatCustomizingEvolution");
static_assert(offsetof(FM1Request_CheatCustomizingEvolution, AccountUid) == 0x000000, "Member 'FM1Request_CheatCustomizingEvolution::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatCustomizingEvolution, SkinTid) == 0x000008, "Member 'FM1Request_CheatCustomizingEvolution::SkinTid' has a wrong offset!");

// ScriptStruct M1.M1MissionActivationInfo
// 0x0008 (0x0008 - 0x0000)
struct FM1MissionActivationInfo final
{
public:
	struct FM1TemplateId                          MissionTid;                                        // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivated;                                        // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPenalty;                                       // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MissionActivationInfo) == 0x000004, "Wrong alignment on FM1MissionActivationInfo");
static_assert(sizeof(FM1MissionActivationInfo) == 0x000008, "Wrong size on FM1MissionActivationInfo");
static_assert(offsetof(FM1MissionActivationInfo, MissionTid) == 0x000000, "Member 'FM1MissionActivationInfo::MissionTid' has a wrong offset!");
static_assert(offsetof(FM1MissionActivationInfo, bActivated) == 0x000004, "Member 'FM1MissionActivationInfo::bActivated' has a wrong offset!");
static_assert(offsetof(FM1MissionActivationInfo, bHasPenalty) == 0x000005, "Member 'FM1MissionActivationInfo::bHasPenalty' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatRemoveAllBoostItemEffect
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_CheatRemoveAllBoostItemEffect final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatRemoveAllBoostItemEffect) == 0x000008, "Wrong alignment on FM1Request_CheatRemoveAllBoostItemEffect");
static_assert(sizeof(FM1Request_CheatRemoveAllBoostItemEffect) == 0x000008, "Wrong size on FM1Request_CheatRemoveAllBoostItemEffect");
static_assert(offsetof(FM1Request_CheatRemoveAllBoostItemEffect, AccountUid) == 0x000000, "Member 'FM1Request_CheatRemoveAllBoostItemEffect::AccountUid' has a wrong offset!");

// ScriptStruct M1.UIDataInitParamString
// 0x0010 (0x0020 - 0x0010)
struct FUIDataInitParamString final : public FUIDataInitParam
{
public:
	class FString                                 Value;                                             // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIDataInitParamString) == 0x000008, "Wrong alignment on FUIDataInitParamString");
static_assert(sizeof(FUIDataInitParamString) == 0x000020, "Wrong size on FUIDataInitParamString");
static_assert(offsetof(FUIDataInitParamString, Value) == 0x000010, "Member 'FUIDataInitParamString::Value' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatBattlePassAddExp
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_CheatBattlePassAddExp final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          BattlePassTid;                                     // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Exp;                                               // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatBattlePassAddExp) == 0x000008, "Wrong alignment on FM1Request_CheatBattlePassAddExp");
static_assert(sizeof(FM1Request_CheatBattlePassAddExp) == 0x000018, "Wrong size on FM1Request_CheatBattlePassAddExp");
static_assert(offsetof(FM1Request_CheatBattlePassAddExp, AccountUid) == 0x000000, "Member 'FM1Request_CheatBattlePassAddExp::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatBattlePassAddExp, BattlePassTid) == 0x000008, "Member 'FM1Request_CheatBattlePassAddExp::BattlePassTid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatBattlePassAddExp, Exp) == 0x000010, "Member 'FM1Request_CheatBattlePassAddExp::Exp' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatGetServerTimeDiff
// 0x0001 (0x0001 - 0x0000)
struct FM1Request_CheatGetServerTimeDiff final : public FM1Request
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_CheatGetServerTimeDiff) == 0x000001, "Wrong alignment on FM1Request_CheatGetServerTimeDiff");
static_assert(sizeof(FM1Request_CheatGetServerTimeDiff) == 0x000001, "Wrong size on FM1Request_CheatGetServerTimeDiff");

// ScriptStruct M1.M1Request_CheatDisableHeartbeat
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_CheatDisableHeartbeat final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatDisableHeartbeat) == 0x000008, "Wrong alignment on FM1Request_CheatDisableHeartbeat");
static_assert(sizeof(FM1Request_CheatDisableHeartbeat) == 0x000008, "Wrong size on FM1Request_CheatDisableHeartbeat");
static_assert(offsetof(FM1Request_CheatDisableHeartbeat, AccountUid) == 0x000000, "Member 'FM1Request_CheatDisableHeartbeat::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1MiniGameResult
// 0x000C (0x000C - 0x0000)
struct FM1MiniGameResult final
{
public:
	struct FM1TemplateId                          MiniGameTemplateId;                                // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          FieldDifficultyTemplateId;                         // 0x0004(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MiniGameResult                             Result;                                            // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MiniGameResult) == 0x000004, "Wrong alignment on FM1MiniGameResult");
static_assert(sizeof(FM1MiniGameResult) == 0x00000C, "Wrong size on FM1MiniGameResult");
static_assert(offsetof(FM1MiniGameResult, MiniGameTemplateId) == 0x000000, "Member 'FM1MiniGameResult::MiniGameTemplateId' has a wrong offset!");
static_assert(offsetof(FM1MiniGameResult, FieldDifficultyTemplateId) == 0x000004, "Member 'FM1MiniGameResult::FieldDifficultyTemplateId' has a wrong offset!");
static_assert(offsetof(FM1MiniGameResult, Result) == 0x000008, "Member 'FM1MiniGameResult::Result' has a wrong offset!");

// ScriptStruct M1.M1Response_GetResearachBookmarkData
// 0x0018 (0x0018 - 0x0000)
struct FM1Response_GetResearachBookmarkData final
{
public:
	struct FM1ResearchBookMarkDataBundle          Notification;                                      // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_GetResearachBookmarkData) == 0x000008, "Wrong alignment on FM1Response_GetResearachBookmarkData");
static_assert(sizeof(FM1Response_GetResearachBookmarkData) == 0x000018, "Wrong size on FM1Response_GetResearachBookmarkData");
static_assert(offsetof(FM1Response_GetResearachBookmarkData, Notification) == 0x000000, "Member 'FM1Response_GetResearachBookmarkData::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatProhibitGetCharacterExp
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CheatProhibitGetCharacterExp final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Unactive;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_CheatProhibitGetCharacterExp) == 0x000008, "Wrong alignment on FM1Request_CheatProhibitGetCharacterExp");
static_assert(sizeof(FM1Request_CheatProhibitGetCharacterExp) == 0x000010, "Wrong size on FM1Request_CheatProhibitGetCharacterExp");
static_assert(offsetof(FM1Request_CheatProhibitGetCharacterExp, AccountUid) == 0x000000, "Member 'FM1Request_CheatProhibitGetCharacterExp::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatProhibitGetCharacterExp, Unactive) == 0x000008, "Member 'FM1Request_CheatProhibitGetCharacterExp::Unactive' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatMinusPaidCurrency
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_CheatMinusPaidCurrency final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1CurrencyInternalType                       Type;                                              // 0x0008(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Count;                                             // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatMinusPaidCurrency) == 0x000008, "Wrong alignment on FM1Request_CheatMinusPaidCurrency");
static_assert(sizeof(FM1Request_CheatMinusPaidCurrency) == 0x000018, "Wrong size on FM1Request_CheatMinusPaidCurrency");
static_assert(offsetof(FM1Request_CheatMinusPaidCurrency, AccountUid) == 0x000000, "Member 'FM1Request_CheatMinusPaidCurrency::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatMinusPaidCurrency, Type) == 0x000008, "Member 'FM1Request_CheatMinusPaidCurrency::Type' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatMinusPaidCurrency, Count) == 0x000010, "Member 'FM1Request_CheatMinusPaidCurrency::Count' has a wrong offset!");

// ScriptStruct M1.M1MissionResearchBlockWaveCompleteInfo
// 0x000C (0x000C - 0x0000)
struct FM1MissionResearchBlockWaveCompleteInfo final
{
public:
	int32                                         CurrentMonsterKillCount;                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetMonsterkillCount;                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTargetMonsterInStealth;                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MissionResearchBlockWaveCompleteInfo) == 0x000004, "Wrong alignment on FM1MissionResearchBlockWaveCompleteInfo");
static_assert(sizeof(FM1MissionResearchBlockWaveCompleteInfo) == 0x00000C, "Wrong size on FM1MissionResearchBlockWaveCompleteInfo");
static_assert(offsetof(FM1MissionResearchBlockWaveCompleteInfo, CurrentMonsterKillCount) == 0x000000, "Member 'FM1MissionResearchBlockWaveCompleteInfo::CurrentMonsterKillCount' has a wrong offset!");
static_assert(offsetof(FM1MissionResearchBlockWaveCompleteInfo, TargetMonsterkillCount) == 0x000004, "Member 'FM1MissionResearchBlockWaveCompleteInfo::TargetMonsterkillCount' has a wrong offset!");
static_assert(offsetof(FM1MissionResearchBlockWaveCompleteInfo, bIsTargetMonsterInStealth) == 0x000008, "Member 'FM1MissionResearchBlockWaveCompleteInfo::bIsTargetMonsterInStealth' has a wrong offset!");

// ScriptStruct M1.M1Request_RemovePresetContents
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_RemovePresetContents final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PresetIndex;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_RemovePresetContents) == 0x000008, "Wrong alignment on FM1Request_RemovePresetContents");
static_assert(sizeof(FM1Request_RemovePresetContents) == 0x000010, "Wrong size on FM1Request_RemovePresetContents");
static_assert(offsetof(FM1Request_RemovePresetContents, AccountUid) == 0x000000, "Member 'FM1Request_RemovePresetContents::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_RemovePresetContents, PresetIndex) == 0x000008, "Member 'FM1Request_RemovePresetContents::PresetIndex' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatCreateItemCompilation
// 0x0030 (0x0030 - 0x0000)
struct FM1Request_CheatCreateItemCompilation final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1CheatCreateItemReq                  Req;                                               // 0x0008(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatCreateItemCompilation) == 0x000008, "Wrong alignment on FM1Request_CheatCreateItemCompilation");
static_assert(sizeof(FM1Request_CheatCreateItemCompilation) == 0x000030, "Wrong size on FM1Request_CheatCreateItemCompilation");
static_assert(offsetof(FM1Request_CheatCreateItemCompilation, AccountUid) == 0x000000, "Member 'FM1Request_CheatCreateItemCompilation::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatCreateItemCompilation, Req) == 0x000008, "Member 'FM1Request_CheatCreateItemCompilation::Req' has a wrong offset!");

// ScriptStruct M1.M1MissionTargetActorInfoToCollect
// 0x0018 (0x0018 - 0x0000)
struct FM1MissionTargetActorInfoToCollect final
{
public:
	EM1MissionTargetType                          Type;                                              // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ScaledInteger                       TakeDamage;                                        // 0x0008(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ScaledInteger                       TakeRecovery;                                      // 0x0010(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionTargetActorInfoToCollect) == 0x000008, "Wrong alignment on FM1MissionTargetActorInfoToCollect");
static_assert(sizeof(FM1MissionTargetActorInfoToCollect) == 0x000018, "Wrong size on FM1MissionTargetActorInfoToCollect");
static_assert(offsetof(FM1MissionTargetActorInfoToCollect, Type) == 0x000000, "Member 'FM1MissionTargetActorInfoToCollect::Type' has a wrong offset!");
static_assert(offsetof(FM1MissionTargetActorInfoToCollect, TakeDamage) == 0x000008, "Member 'FM1MissionTargetActorInfoToCollect::TakeDamage' has a wrong offset!");
static_assert(offsetof(FM1MissionTargetActorInfoToCollect, TakeRecovery) == 0x000010, "Member 'FM1MissionTargetActorInfoToCollect::TakeRecovery' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatCreateBulkEquipment
// 0x0028 (0x0028 - 0x0000)
struct FM1Request_CheatCreateBulkEquipment final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1CheatCreateBulkEquipmentReq         Req;                                               // 0x0008(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatCreateBulkEquipment) == 0x000008, "Wrong alignment on FM1Request_CheatCreateBulkEquipment");
static_assert(sizeof(FM1Request_CheatCreateBulkEquipment) == 0x000028, "Wrong size on FM1Request_CheatCreateBulkEquipment");
static_assert(offsetof(FM1Request_CheatCreateBulkEquipment, AccountUid) == 0x000000, "Member 'FM1Request_CheatCreateBulkEquipment::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatCreateBulkEquipment, Req) == 0x000008, "Member 'FM1Request_CheatCreateBulkEquipment::Req' has a wrong offset!");

// ScriptStruct M1.M1Response_UnlockCamp
// 0x0018 (0x0018 - 0x0000)
struct FM1Response_UnlockCamp final
{
public:
	EM1FieldUnlockResults                         Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CampEntryPointId;                                  // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_UnlockCamp) == 0x000008, "Wrong alignment on FM1Response_UnlockCamp");
static_assert(sizeof(FM1Response_UnlockCamp) == 0x000018, "Wrong size on FM1Response_UnlockCamp");
static_assert(offsetof(FM1Response_UnlockCamp, Notification) == 0x000000, "Member 'FM1Response_UnlockCamp::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_UnlockCamp, CampEntryPointId) == 0x000008, "Member 'FM1Response_UnlockCamp::CampEntryPointId' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatCreateBulkCharacter
// 0x0020 (0x0020 - 0x0000)
struct FM1Request_CheatCreateBulkCharacter final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1CheatCreateCharacterReq             Req;                                               // 0x0008(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatCreateBulkCharacter) == 0x000008, "Wrong alignment on FM1Request_CheatCreateBulkCharacter");
static_assert(sizeof(FM1Request_CheatCreateBulkCharacter) == 0x000020, "Wrong size on FM1Request_CheatCreateBulkCharacter");
static_assert(offsetof(FM1Request_CheatCreateBulkCharacter, AccountUid) == 0x000000, "Member 'FM1Request_CheatCreateBulkCharacter::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatCreateBulkCharacter, Req) == 0x000008, "Member 'FM1Request_CheatCreateBulkCharacter::Req' has a wrong offset!");

// ScriptStruct M1.M1TaskMonsterKillInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FM1TaskMonsterKillInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AppearanceCount;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeadMonsterCount;                                  // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredMonsterCountToKill;                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1TaskMonsterKillInfo) == 0x000008, "Wrong alignment on FM1TaskMonsterKillInfo");
static_assert(sizeof(FM1TaskMonsterKillInfo) == 0x000018, "Wrong size on FM1TaskMonsterKillInfo");
static_assert(offsetof(FM1TaskMonsterKillInfo, AppearanceCount) == 0x000008, "Member 'FM1TaskMonsterKillInfo::AppearanceCount' has a wrong offset!");
static_assert(offsetof(FM1TaskMonsterKillInfo, DeadMonsterCount) == 0x00000C, "Member 'FM1TaskMonsterKillInfo::DeadMonsterCount' has a wrong offset!");
static_assert(offsetof(FM1TaskMonsterKillInfo, RequiredMonsterCountToKill) == 0x000010, "Member 'FM1TaskMonsterKillInfo::RequiredMonsterCountToKill' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatRequestMatching
// 0x0020 (0x0020 - 0x0000)
struct FM1Request_CheatRequestMatching final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MapId;                                             // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1MapSubData                          MapSubData;                                        // 0x000C(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsPrivate;                                         // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_CheatRequestMatching) == 0x000008, "Wrong alignment on FM1Request_CheatRequestMatching");
static_assert(sizeof(FM1Request_CheatRequestMatching) == 0x000020, "Wrong size on FM1Request_CheatRequestMatching");
static_assert(offsetof(FM1Request_CheatRequestMatching, AccountUid) == 0x000000, "Member 'FM1Request_CheatRequestMatching::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatRequestMatching, MapId) == 0x000008, "Member 'FM1Request_CheatRequestMatching::MapId' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatRequestMatching, MapSubData) == 0x00000C, "Member 'FM1Request_CheatRequestMatching::MapSubData' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatRequestMatching, IsPrivate) == 0x00001C, "Member 'FM1Request_CheatRequestMatching::IsPrivate' has a wrong offset!");

// ScriptStruct M1.M1Request_AcquireDropItem
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_AcquireDropItem final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         DropOid;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_AcquireDropItem) == 0x000008, "Wrong alignment on FM1Request_AcquireDropItem");
static_assert(sizeof(FM1Request_AcquireDropItem) == 0x000010, "Wrong size on FM1Request_AcquireDropItem");
static_assert(offsetof(FM1Request_AcquireDropItem, AccountUid) == 0x000000, "Member 'FM1Request_AcquireDropItem::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_AcquireDropItem, DropOid) == 0x000008, "Member 'FM1Request_AcquireDropItem::DropOid' has a wrong offset!");

// ScriptStruct M1.M1EscortTargetHpEventInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1EscortTargetHpEventInfo final
{
public:
	float                                         HpRatio;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OptionalEventName;                                 // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActivated;                                      // 0x000C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1EscortTargetHpEventInfo) == 0x000004, "Wrong alignment on FM1EscortTargetHpEventInfo");
static_assert(sizeof(FM1EscortTargetHpEventInfo) == 0x000010, "Wrong size on FM1EscortTargetHpEventInfo");
static_assert(offsetof(FM1EscortTargetHpEventInfo, HpRatio) == 0x000000, "Member 'FM1EscortTargetHpEventInfo::HpRatio' has a wrong offset!");
static_assert(offsetof(FM1EscortTargetHpEventInfo, OptionalEventName) == 0x000004, "Member 'FM1EscortTargetHpEventInfo::OptionalEventName' has a wrong offset!");
static_assert(offsetof(FM1EscortTargetHpEventInfo, bIsActivated) == 0x00000C, "Member 'FM1EscortTargetHpEventInfo::bIsActivated' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatUnlockBattleZone
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatUnlockBattleZone final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatUnlockBattleZone) == 0x000001, "Wrong alignment on FM1Response_CheatUnlockBattleZone");
static_assert(sizeof(FM1Response_CheatUnlockBattleZone) == 0x000001, "Wrong size on FM1Response_CheatUnlockBattleZone");
static_assert(offsetof(FM1Response_CheatUnlockBattleZone, Notification) == 0x000000, "Member 'FM1Response_CheatUnlockBattleZone::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_BossKillDropItem
// 0x0028 (0x0028 - 0x0000)
struct FM1Request_BossKillDropItem final : public FM1Request
{
public:
	struct FM1BossKillDropItemRequest             Req;                                               // 0x0000(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_BossKillDropItem) == 0x000008, "Wrong alignment on FM1Request_BossKillDropItem");
static_assert(sizeof(FM1Request_BossKillDropItem) == 0x000028, "Wrong size on FM1Request_BossKillDropItem");
static_assert(offsetof(FM1Request_BossKillDropItem, Req) == 0x000000, "Member 'FM1Request_BossKillDropItem::Req' has a wrong offset!");

// ScriptStruct M1.M1Request_BossPartsDropItem
// 0x0030 (0x0030 - 0x0000)
struct FM1Request_BossPartsDropItem final : public FM1Request
{
public:
	struct FM1BossPartsDropItemRequest            Req;                                               // 0x0000(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_BossPartsDropItem) == 0x000008, "Wrong alignment on FM1Request_BossPartsDropItem");
static_assert(sizeof(FM1Request_BossPartsDropItem) == 0x000030, "Wrong size on FM1Request_BossPartsDropItem");
static_assert(offsetof(FM1Request_BossPartsDropItem, Req) == 0x000000, "Member 'FM1Request_BossPartsDropItem::Req' has a wrong offset!");

// ScriptStruct M1.M1DefenseTargetHpEventInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1DefenseTargetHpEventInfo final
{
public:
	float                                         HpRatio;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OptionalEventName;                                 // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActivated;                                      // 0x000C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1DefenseTargetHpEventInfo) == 0x000004, "Wrong alignment on FM1DefenseTargetHpEventInfo");
static_assert(sizeof(FM1DefenseTargetHpEventInfo) == 0x000010, "Wrong size on FM1DefenseTargetHpEventInfo");
static_assert(offsetof(FM1DefenseTargetHpEventInfo, HpRatio) == 0x000000, "Member 'FM1DefenseTargetHpEventInfo::HpRatio' has a wrong offset!");
static_assert(offsetof(FM1DefenseTargetHpEventInfo, OptionalEventName) == 0x000004, "Member 'FM1DefenseTargetHpEventInfo::OptionalEventName' has a wrong offset!");
static_assert(offsetof(FM1DefenseTargetHpEventInfo, bIsActivated) == 0x00000C, "Member 'FM1DefenseTargetHpEventInfo::bIsActivated' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatCharacterLevelMax
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_CheatCharacterLevelMax final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemUidBox                          CharcterUid;                                       // 0x0008(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheatCharacterLevelMax) == 0x000008, "Wrong alignment on FM1Request_CheatCharacterLevelMax");
static_assert(sizeof(FM1Request_CheatCharacterLevelMax) == 0x000018, "Wrong size on FM1Request_CheatCharacterLevelMax");
static_assert(offsetof(FM1Request_CheatCharacterLevelMax, AccountUid) == 0x000000, "Member 'FM1Request_CheatCharacterLevelMax::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatCharacterLevelMax, CharcterUid) == 0x000008, "Member 'FM1Request_CheatCharacterLevelMax::CharcterUid' has a wrong offset!");

// ScriptStruct M1.M1Request_MissionTaskDropItem
// 0x0038 (0x0038 - 0x0000)
struct FM1Request_MissionTaskDropItem final : public FM1Request
{
public:
	struct FM1MissionTaskDropItemRequest          Req;                                               // 0x0000(0x0038)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_MissionTaskDropItem) == 0x000008, "Wrong alignment on FM1Request_MissionTaskDropItem");
static_assert(sizeof(FM1Request_MissionTaskDropItem) == 0x000038, "Wrong size on FM1Request_MissionTaskDropItem");
static_assert(offsetof(FM1Request_MissionTaskDropItem, Req) == 0x000000, "Member 'FM1Request_MissionTaskDropItem::Req' has a wrong offset!");

// ScriptStruct M1.M1InteractionTargetInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1InteractionTargetInfo final
{
public:
	class UM1InteractableEntity*                  Entity;                                            // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1InteractionTargetInfo) == 0x000008, "Wrong alignment on FM1InteractionTargetInfo");
static_assert(sizeof(FM1InteractionTargetInfo) == 0x000020, "Wrong size on FM1InteractionTargetInfo");
static_assert(offsetof(FM1InteractionTargetInfo, Entity) == 0x000000, "Member 'FM1InteractionTargetInfo::Entity' has a wrong offset!");

// ScriptStruct M1.M1Request_MissionWaveDropItem
// 0x0038 (0x0038 - 0x0000)
struct FM1Request_MissionWaveDropItem final : public FM1Request
{
public:
	struct FM1MissionWaveDropItemRequest          Req;                                               // 0x0000(0x0038)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_MissionWaveDropItem) == 0x000008, "Wrong alignment on FM1Request_MissionWaveDropItem");
static_assert(sizeof(FM1Request_MissionWaveDropItem) == 0x000038, "Wrong size on FM1Request_MissionWaveDropItem");
static_assert(offsetof(FM1Request_MissionWaveDropItem, Req) == 0x000000, "Member 'FM1Request_MissionWaveDropItem::Req' has a wrong offset!");

// ScriptStruct M1.M1Response_StartQuestMultiple
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_StartQuestMultiple final
{
public:
	struct FM1QuestStartMultiple                  Notification;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_StartQuestMultiple) == 0x000008, "Wrong alignment on FM1Response_StartQuestMultiple");
static_assert(sizeof(FM1Response_StartQuestMultiple) == 0x000010, "Wrong size on FM1Response_StartQuestMultiple");
static_assert(offsetof(FM1Response_StartQuestMultiple, Notification) == 0x000000, "Member 'FM1Response_StartQuestMultiple::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_FieldObjectDropItem
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_FieldObjectDropItem final : public FM1Request
{
public:
	struct FM1FieldObjectDropItemRequest          Req;                                               // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_FieldObjectDropItem) == 0x000008, "Wrong alignment on FM1Request_FieldObjectDropItem");
static_assert(sizeof(FM1Request_FieldObjectDropItem) == 0x000018, "Wrong size on FM1Request_FieldObjectDropItem");
static_assert(offsetof(FM1Request_FieldObjectDropItem, Req) == 0x000000, "Member 'FM1Request_FieldObjectDropItem::Req' has a wrong offset!");

// ScriptStruct M1.M1MissionPlayerInfoToCollect
// 0x0090 (0x0090 - 0x0000)
struct FM1MissionPlayerInfoToCollect final
{
public:
	EM1MissionEndReason                           EndReason;                                         // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerLevelWhenStarted;                            // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerLevelWhenEnded;                              // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFirstMissionPlay;                               // 0x000C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1TemplateId                          CharacterTid;                                      // 0x0010(0x0004)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         DBNOCount;                                         // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         DeathCount;                                        // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DataCollectionCount;                               // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SupplyCount;                                       // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SupplyRate;                                        // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OccupiedTime;                                      // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CompletelyHackingCount;                            // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafetyStealLongestTime;                            // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastWaveIndex;                                     // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastClearWaveIndex;                                // 0x0044(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefenseObjectSafetyLongestTime;                    // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StopMiningCount;                                   // 0x004C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefenseObjectHpRate;                               // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EscortTime;                                        // 0x0054(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EscortLongestTime;                                 // 0x0058(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnescortedTime;                                    // 0x005C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StoppedEscortTime;                                 // 0x0060(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MultiCollectionCount;                              // 0x0064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MultiCollectionCompletelyCount;                    // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierActivatorRetreatRate;                       // 0x006C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ObtainedVoidPieceItem;                             // 0x0070(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VoidFusionTargetKillCount;                         // 0x0074(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VulgusObservationTowerDeactivatedCount;            // 0x0078(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VulgusPostPowerDeviceInteractedCount;              // 0x007C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CompetitiveOccupationTargetObjectDestructedCount;  // 0x0080(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CompetitiveOccupationHintObjectDestructedCount;    // 0x0084(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompetitiveOccupationTotalOccupiedTime;            // 0x0088(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CompetitiveOccupationCompletelyOccupiedCount;      // 0x008C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionPlayerInfoToCollect) == 0x000008, "Wrong alignment on FM1MissionPlayerInfoToCollect");
static_assert(sizeof(FM1MissionPlayerInfoToCollect) == 0x000090, "Wrong size on FM1MissionPlayerInfoToCollect");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, EndReason) == 0x000000, "Member 'FM1MissionPlayerInfoToCollect::EndReason' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, PlayerLevelWhenStarted) == 0x000004, "Member 'FM1MissionPlayerInfoToCollect::PlayerLevelWhenStarted' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, PlayerLevelWhenEnded) == 0x000008, "Member 'FM1MissionPlayerInfoToCollect::PlayerLevelWhenEnded' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, bIsFirstMissionPlay) == 0x00000C, "Member 'FM1MissionPlayerInfoToCollect::bIsFirstMissionPlay' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, CharacterTid) == 0x000010, "Member 'FM1MissionPlayerInfoToCollect::CharacterTid' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, DBNOCount) == 0x000018, "Member 'FM1MissionPlayerInfoToCollect::DBNOCount' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, DeathCount) == 0x000020, "Member 'FM1MissionPlayerInfoToCollect::DeathCount' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, DataCollectionCount) == 0x000028, "Member 'FM1MissionPlayerInfoToCollect::DataCollectionCount' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, SupplyCount) == 0x00002C, "Member 'FM1MissionPlayerInfoToCollect::SupplyCount' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, SupplyRate) == 0x000030, "Member 'FM1MissionPlayerInfoToCollect::SupplyRate' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, OccupiedTime) == 0x000034, "Member 'FM1MissionPlayerInfoToCollect::OccupiedTime' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, CompletelyHackingCount) == 0x000038, "Member 'FM1MissionPlayerInfoToCollect::CompletelyHackingCount' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, SafetyStealLongestTime) == 0x00003C, "Member 'FM1MissionPlayerInfoToCollect::SafetyStealLongestTime' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, LastWaveIndex) == 0x000040, "Member 'FM1MissionPlayerInfoToCollect::LastWaveIndex' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, LastClearWaveIndex) == 0x000044, "Member 'FM1MissionPlayerInfoToCollect::LastClearWaveIndex' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, DefenseObjectSafetyLongestTime) == 0x000048, "Member 'FM1MissionPlayerInfoToCollect::DefenseObjectSafetyLongestTime' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, StopMiningCount) == 0x00004C, "Member 'FM1MissionPlayerInfoToCollect::StopMiningCount' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, DefenseObjectHpRate) == 0x000050, "Member 'FM1MissionPlayerInfoToCollect::DefenseObjectHpRate' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, EscortTime) == 0x000054, "Member 'FM1MissionPlayerInfoToCollect::EscortTime' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, EscortLongestTime) == 0x000058, "Member 'FM1MissionPlayerInfoToCollect::EscortLongestTime' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, UnescortedTime) == 0x00005C, "Member 'FM1MissionPlayerInfoToCollect::UnescortedTime' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, StoppedEscortTime) == 0x000060, "Member 'FM1MissionPlayerInfoToCollect::StoppedEscortTime' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, MultiCollectionCount) == 0x000064, "Member 'FM1MissionPlayerInfoToCollect::MultiCollectionCount' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, MultiCollectionCompletelyCount) == 0x000068, "Member 'FM1MissionPlayerInfoToCollect::MultiCollectionCompletelyCount' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, BarrierActivatorRetreatRate) == 0x00006C, "Member 'FM1MissionPlayerInfoToCollect::BarrierActivatorRetreatRate' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, ObtainedVoidPieceItem) == 0x000070, "Member 'FM1MissionPlayerInfoToCollect::ObtainedVoidPieceItem' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, VoidFusionTargetKillCount) == 0x000074, "Member 'FM1MissionPlayerInfoToCollect::VoidFusionTargetKillCount' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, VulgusObservationTowerDeactivatedCount) == 0x000078, "Member 'FM1MissionPlayerInfoToCollect::VulgusObservationTowerDeactivatedCount' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, VulgusPostPowerDeviceInteractedCount) == 0x00007C, "Member 'FM1MissionPlayerInfoToCollect::VulgusPostPowerDeviceInteractedCount' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, CompetitiveOccupationTargetObjectDestructedCount) == 0x000080, "Member 'FM1MissionPlayerInfoToCollect::CompetitiveOccupationTargetObjectDestructedCount' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, CompetitiveOccupationHintObjectDestructedCount) == 0x000084, "Member 'FM1MissionPlayerInfoToCollect::CompetitiveOccupationHintObjectDestructedCount' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, CompetitiveOccupationTotalOccupiedTime) == 0x000088, "Member 'FM1MissionPlayerInfoToCollect::CompetitiveOccupationTotalOccupiedTime' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayerInfoToCollect, CompetitiveOccupationCompletelyOccupiedCount) == 0x00008C, "Member 'FM1MissionPlayerInfoToCollect::CompetitiveOccupationCompletelyOccupiedCount' has a wrong offset!");

// ScriptStruct M1.M1MissionStatistics
// 0x00A0 (0x00A0 - 0x0000)
struct FM1MissionStatistics final
{
public:
	struct FM1MissionPlayerInfoToCollect          PlayerInfo;                                        // 0x0000(0x0090)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FM1MissionTargetActorInfoToCollect> TargetActorInfos;                                  // 0x0090(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionStatistics) == 0x000008, "Wrong alignment on FM1MissionStatistics");
static_assert(sizeof(FM1MissionStatistics) == 0x0000A0, "Wrong size on FM1MissionStatistics");
static_assert(offsetof(FM1MissionStatistics, PlayerInfo) == 0x000000, "Member 'FM1MissionStatistics::PlayerInfo' has a wrong offset!");
static_assert(offsetof(FM1MissionStatistics, TargetActorInfos) == 0x000090, "Member 'FM1MissionStatistics::TargetActorInfos' has a wrong offset!");

// ScriptStruct M1.M1Request_MiniGameDropItem
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_MiniGameDropItem final : public FM1Request
{
public:
	struct FM1MiniGameDropItemRequest             Req;                                               // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_MiniGameDropItem) == 0x000008, "Wrong alignment on FM1Request_MiniGameDropItem");
static_assert(sizeof(FM1Request_MiniGameDropItem) == 0x000018, "Wrong size on FM1Request_MiniGameDropItem");
static_assert(offsetof(FM1Request_MiniGameDropItem, Req) == 0x000000, "Member 'FM1Request_MiniGameDropItem::Req' has a wrong offset!");

// ScriptStruct M1.M1Statistics
// 0x0020 (0x0020 - 0x0000)
struct FM1Statistics
{
public:
	class FString                                 LogName;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SessionId;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Statistics) == 0x000008, "Wrong alignment on FM1Statistics");
static_assert(sizeof(FM1Statistics) == 0x000020, "Wrong size on FM1Statistics");
static_assert(offsetof(FM1Statistics, LogName) == 0x000000, "Member 'FM1Statistics::LogName' has a wrong offset!");
static_assert(offsetof(FM1Statistics, SessionId) == 0x000010, "Member 'FM1Statistics::SessionId' has a wrong offset!");

// ScriptStruct M1.HowGameFailed
// 0x0010 (0x0030 - 0x0020)
struct FHowGameFailed final : public FM1Statistics
{
public:
	int32                                         PlayerCount;                                       // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DestroyedObjectCount;                              // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Phase;                                             // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHowGameFailed) == 0x000008, "Wrong alignment on FHowGameFailed");
static_assert(sizeof(FHowGameFailed) == 0x000030, "Wrong size on FHowGameFailed");
static_assert(offsetof(FHowGameFailed, PlayerCount) == 0x000020, "Member 'FHowGameFailed::PlayerCount' has a wrong offset!");
static_assert(offsetof(FHowGameFailed, DestroyedObjectCount) == 0x000024, "Member 'FHowGameFailed::DestroyedObjectCount' has a wrong offset!");
static_assert(offsetof(FHowGameFailed, Phase) == 0x000028, "Member 'FHowGameFailed::Phase' has a wrong offset!");

// ScriptStruct M1.M1Request_InitSpeicificShop
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_InitSpeicificShop final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ShopId;                                            // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ProductId;                                         // 0x000C(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_InitSpeicificShop) == 0x000008, "Wrong alignment on FM1Request_InitSpeicificShop");
static_assert(sizeof(FM1Request_InitSpeicificShop) == 0x000010, "Wrong size on FM1Request_InitSpeicificShop");
static_assert(offsetof(FM1Request_InitSpeicificShop, AccountUid) == 0x000000, "Member 'FM1Request_InitSpeicificShop::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_InitSpeicificShop, ShopId) == 0x000008, "Member 'FM1Request_InitSpeicificShop::ShopId' has a wrong offset!");
static_assert(offsetof(FM1Request_InitSpeicificShop, ProductId) == 0x00000C, "Member 'FM1Request_InitSpeicificShop::ProductId' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatAddExp
// 0x0020 (0x0020 - 0x0000)
struct FM1Request_CheatAddExp final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1MonsterRequestInfoBox               MonsterRequestInfoBox;                             // 0x0008(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Exp;                                               // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_CheatAddExp) == 0x000008, "Wrong alignment on FM1Request_CheatAddExp");
static_assert(sizeof(FM1Request_CheatAddExp) == 0x000020, "Wrong size on FM1Request_CheatAddExp");
static_assert(offsetof(FM1Request_CheatAddExp, AccountUid) == 0x000000, "Member 'FM1Request_CheatAddExp::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatAddExp, MonsterRequestInfoBox) == 0x000008, "Member 'FM1Request_CheatAddExp::MonsterRequestInfoBox' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatAddExp, Exp) == 0x000018, "Member 'FM1Request_CheatAddExp::Exp' has a wrong offset!");

// ScriptStruct M1.M1Request_KillMonster
// 0x0020 (0x0020 - 0x0000)
struct FM1Request_KillMonster final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1KilledMonsterInfo                   MonsterInfo;                                       // 0x0008(0x0014)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_KillMonster) == 0x000008, "Wrong alignment on FM1Request_KillMonster");
static_assert(sizeof(FM1Request_KillMonster) == 0x000020, "Wrong size on FM1Request_KillMonster");
static_assert(offsetof(FM1Request_KillMonster, AccountUid) == 0x000000, "Member 'FM1Request_KillMonster::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_KillMonster, MonsterInfo) == 0x000008, "Member 'FM1Request_KillMonster::MonsterInfo' has a wrong offset!");

// ScriptStruct M1.M1DefenseTargetHpWarningInfo
// 0x0008 (0x0008 - 0x0000)
struct FM1DefenseTargetHpWarningInfo final
{
public:
	float                                         HpWarningRatio;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasWarned;                                        // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1DefenseTargetHpWarningInfo) == 0x000004, "Wrong alignment on FM1DefenseTargetHpWarningInfo");
static_assert(sizeof(FM1DefenseTargetHpWarningInfo) == 0x000008, "Wrong size on FM1DefenseTargetHpWarningInfo");
static_assert(offsetof(FM1DefenseTargetHpWarningInfo, HpWarningRatio) == 0x000000, "Member 'FM1DefenseTargetHpWarningInfo::HpWarningRatio' has a wrong offset!");
static_assert(offsetof(FM1DefenseTargetHpWarningInfo, bHasWarned) == 0x000004, "Member 'FM1DefenseTargetHpWarningInfo::bHasWarned' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatDestroyCharacter
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatDestroyCharacter final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatDestroyCharacter) == 0x000001, "Wrong alignment on FM1Response_CheatDestroyCharacter");
static_assert(sizeof(FM1Response_CheatDestroyCharacter) == 0x000001, "Wrong size on FM1Response_CheatDestroyCharacter");
static_assert(offsetof(FM1Response_CheatDestroyCharacter, Notification) == 0x000000, "Member 'FM1Response_CheatDestroyCharacter::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_AttachRune
// 0x0038 (0x0038 - 0x0000)
struct FM1Request_AttachRune final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemTidBox                          OwnerTidBox;                                       // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         LoadoutSlotIndex;                                  // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1RunePositionBundle                  PositionBundle;                                    // 0x0018(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_AttachRune) == 0x000008, "Wrong alignment on FM1Request_AttachRune");
static_assert(sizeof(FM1Request_AttachRune) == 0x000038, "Wrong size on FM1Request_AttachRune");
static_assert(offsetof(FM1Request_AttachRune, AccountUid) == 0x000000, "Member 'FM1Request_AttachRune::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_AttachRune, OwnerTidBox) == 0x000008, "Member 'FM1Request_AttachRune::OwnerTidBox' has a wrong offset!");
static_assert(offsetof(FM1Request_AttachRune, LoadoutSlotIndex) == 0x000010, "Member 'FM1Request_AttachRune::LoadoutSlotIndex' has a wrong offset!");
static_assert(offsetof(FM1Request_AttachRune, PositionBundle) == 0x000018, "Member 'FM1Request_AttachRune::PositionBundle' has a wrong offset!");

// ScriptStruct M1.M1Request_RequestSelectLoadoutSlot
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_RequestSelectLoadoutSlot final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemTidBox                          OwnerTid;                                          // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         LoadoutSlotIndex;                                  // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_RequestSelectLoadoutSlot) == 0x000008, "Wrong alignment on FM1Request_RequestSelectLoadoutSlot");
static_assert(sizeof(FM1Request_RequestSelectLoadoutSlot) == 0x000018, "Wrong size on FM1Request_RequestSelectLoadoutSlot");
static_assert(offsetof(FM1Request_RequestSelectLoadoutSlot, AccountUid) == 0x000000, "Member 'FM1Request_RequestSelectLoadoutSlot::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_RequestSelectLoadoutSlot, OwnerTid) == 0x000008, "Member 'FM1Request_RequestSelectLoadoutSlot::OwnerTid' has a wrong offset!");
static_assert(offsetof(FM1Request_RequestSelectLoadoutSlot, LoadoutSlotIndex) == 0x000010, "Member 'FM1Request_RequestSelectLoadoutSlot::LoadoutSlotIndex' has a wrong offset!");

// ScriptStruct M1.M1MissionDerivMonsterReplicatedInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1MissionDerivMonsterReplicatedInfo final
{
public:
	class FString                                 MonsterName;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MonsterLifeTime;                                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MissionDerivMonsterReplicatedInfo) == 0x000008, "Wrong alignment on FM1MissionDerivMonsterReplicatedInfo");
static_assert(sizeof(FM1MissionDerivMonsterReplicatedInfo) == 0x000018, "Wrong size on FM1MissionDerivMonsterReplicatedInfo");
static_assert(offsetof(FM1MissionDerivMonsterReplicatedInfo, MonsterName) == 0x000000, "Member 'FM1MissionDerivMonsterReplicatedInfo::MonsterName' has a wrong offset!");
static_assert(offsetof(FM1MissionDerivMonsterReplicatedInfo, MonsterLifeTime) == 0x000010, "Member 'FM1MissionDerivMonsterReplicatedInfo::MonsterLifeTime' has a wrong offset!");

// ScriptStruct M1.M1Response_UseUpResourceItem
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_UseUpResourceItem final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_UseUpResourceItem) == 0x000001, "Wrong alignment on FM1Response_UseUpResourceItem");
static_assert(sizeof(FM1Response_UseUpResourceItem) == 0x000001, "Wrong size on FM1Response_UseUpResourceItem");
static_assert(offsetof(FM1Response_UseUpResourceItem, Notification) == 0x000000, "Member 'FM1Response_UseUpResourceItem::Notification' has a wrong offset!");

// ScriptStruct M1.M1CustomizeWireHookSkinInfo
// 0x0008 (0x0008 - 0x0000)
struct FM1CustomizeWireHookSkinInfo final
{
public:
	struct FM1TemplateId                          SkinTid;                                           // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitialSetup;                                     // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CustomizeWireHookSkinInfo) == 0x000004, "Wrong alignment on FM1CustomizeWireHookSkinInfo");
static_assert(sizeof(FM1CustomizeWireHookSkinInfo) == 0x000008, "Wrong size on FM1CustomizeWireHookSkinInfo");
static_assert(offsetof(FM1CustomizeWireHookSkinInfo, SkinTid) == 0x000000, "Member 'FM1CustomizeWireHookSkinInfo::SkinTid' has a wrong offset!");
static_assert(offsetof(FM1CustomizeWireHookSkinInfo, bInitialSetup) == 0x000004, "Member 'FM1CustomizeWireHookSkinInfo::bInitialSetup' has a wrong offset!");

// ScriptStruct M1.M1Request_IncreaseRuneCapacity
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_IncreaseRuneCapacity final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemTidBox                          OwnerTid;                                          // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_IncreaseRuneCapacity) == 0x000008, "Wrong alignment on FM1Request_IncreaseRuneCapacity");
static_assert(sizeof(FM1Request_IncreaseRuneCapacity) == 0x000010, "Wrong size on FM1Request_IncreaseRuneCapacity");
static_assert(offsetof(FM1Request_IncreaseRuneCapacity, AccountUid) == 0x000000, "Member 'FM1Request_IncreaseRuneCapacity::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_IncreaseRuneCapacity, OwnerTid) == 0x000008, "Member 'FM1Request_IncreaseRuneCapacity::OwnerTid' has a wrong offset!");

// ScriptStruct M1.M1InstanceDungeonDataTableRow
// 0x0040 (0x0048 - 0x0008)
struct FM1InstanceDungeonDataTableRow final : public FTableRowBase
{
public:
	class FName                                   InstanceDungeonStringId;                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          InstanceDungeonId;                                 // 0x0010(0x0004)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          InstanceDungeonMissionId;                          // 0x0014(0x0004)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MapTemplateId;                                     // 0x0018(0x0004)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MissionName;                                       // 0x001C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataLayerAsset*                        InstanceDungeonDataLayerAsset;                     // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1InstanceDungeonDifficulty                  Difficulty;                                        // 0x0030(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    MissionDataTableRowHandle;                         // 0x0038(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceDungeonDataTableRow) == 0x000008, "Wrong alignment on FM1InstanceDungeonDataTableRow");
static_assert(sizeof(FM1InstanceDungeonDataTableRow) == 0x000048, "Wrong size on FM1InstanceDungeonDataTableRow");
static_assert(offsetof(FM1InstanceDungeonDataTableRow, InstanceDungeonStringId) == 0x000008, "Member 'FM1InstanceDungeonDataTableRow::InstanceDungeonStringId' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonDataTableRow, InstanceDungeonId) == 0x000010, "Member 'FM1InstanceDungeonDataTableRow::InstanceDungeonId' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonDataTableRow, InstanceDungeonMissionId) == 0x000014, "Member 'FM1InstanceDungeonDataTableRow::InstanceDungeonMissionId' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonDataTableRow, MapTemplateId) == 0x000018, "Member 'FM1InstanceDungeonDataTableRow::MapTemplateId' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonDataTableRow, MissionName) == 0x00001C, "Member 'FM1InstanceDungeonDataTableRow::MissionName' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonDataTableRow, InstanceDungeonDataLayerAsset) == 0x000028, "Member 'FM1InstanceDungeonDataTableRow::InstanceDungeonDataLayerAsset' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonDataTableRow, Difficulty) == 0x000030, "Member 'FM1InstanceDungeonDataTableRow::Difficulty' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonDataTableRow, MissionDataTableRowHandle) == 0x000038, "Member 'FM1InstanceDungeonDataTableRow::MissionDataTableRowHandle' has a wrong offset!");

// ScriptStruct M1.M1Request_GrantRuneSocket
// 0x0020 (0x0020 - 0x0000)
struct FM1Request_GrantRuneSocket final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemTidBox                          OwnerTidBox;                                       // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	EM1RuneSubClassType                           SubClassType;                                      // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SocketIndex;                                       // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RuneSocketType                             SocketType;                                        // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_GrantRuneSocket) == 0x000008, "Wrong alignment on FM1Request_GrantRuneSocket");
static_assert(sizeof(FM1Request_GrantRuneSocket) == 0x000020, "Wrong size on FM1Request_GrantRuneSocket");
static_assert(offsetof(FM1Request_GrantRuneSocket, AccountUid) == 0x000000, "Member 'FM1Request_GrantRuneSocket::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_GrantRuneSocket, OwnerTidBox) == 0x000008, "Member 'FM1Request_GrantRuneSocket::OwnerTidBox' has a wrong offset!");
static_assert(offsetof(FM1Request_GrantRuneSocket, SubClassType) == 0x000010, "Member 'FM1Request_GrantRuneSocket::SubClassType' has a wrong offset!");
static_assert(offsetof(FM1Request_GrantRuneSocket, SocketIndex) == 0x000014, "Member 'FM1Request_GrantRuneSocket::SocketIndex' has a wrong offset!");
static_assert(offsetof(FM1Request_GrantRuneSocket, SocketType) == 0x000018, "Member 'FM1Request_GrantRuneSocket::SocketType' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatStatAdjust
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatStatAdjust final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatStatAdjust) == 0x000001, "Wrong alignment on FM1Response_CheatStatAdjust");
static_assert(sizeof(FM1Response_CheatStatAdjust) == 0x000001, "Wrong size on FM1Response_CheatStatAdjust");
static_assert(offsetof(FM1Response_CheatStatAdjust, Notification) == 0x000000, "Member 'FM1Response_CheatStatAdjust::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_EnchantRune
// 0x0020 (0x0020 - 0x0000)
struct FM1Request_EnchantRune final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemUidBox                          RuneUid;                                           // 0x0008(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         TargetEnchantLevel;                                // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_EnchantRune) == 0x000008, "Wrong alignment on FM1Request_EnchantRune");
static_assert(sizeof(FM1Request_EnchantRune) == 0x000020, "Wrong size on FM1Request_EnchantRune");
static_assert(offsetof(FM1Request_EnchantRune, AccountUid) == 0x000000, "Member 'FM1Request_EnchantRune::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_EnchantRune, RuneUid) == 0x000008, "Member 'FM1Request_EnchantRune::RuneUid' has a wrong offset!");
static_assert(offsetof(FM1Request_EnchantRune, TargetEnchantLevel) == 0x000018, "Member 'FM1Request_EnchantRune::TargetEnchantLevel' has a wrong offset!");

// ScriptStruct M1.M1ResearchSetting
// 0x0050 (0x0050 - 0x0000)
struct FM1ResearchSetting final
{
public:
	TMap<EM1ImportanceType, struct FSoftObjectPath> Sequences;                                         // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ResearchSetting) == 0x000008, "Wrong alignment on FM1ResearchSetting");
static_assert(sizeof(FM1ResearchSetting) == 0x000050, "Wrong size on FM1ResearchSetting");
static_assert(offsetof(FM1ResearchSetting, Sequences) == 0x000000, "Member 'FM1ResearchSetting::Sequences' has a wrong offset!");

// ScriptStruct M1.M1Request_CheckEnchantRune
// 0x0020 (0x0020 - 0x0000)
struct FM1Request_CheckEnchantRune final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemUidBox                          RuneUid;                                           // 0x0008(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         TargetEnchantLevel;                                // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_CheckEnchantRune) == 0x000008, "Wrong alignment on FM1Request_CheckEnchantRune");
static_assert(sizeof(FM1Request_CheckEnchantRune) == 0x000020, "Wrong size on FM1Request_CheckEnchantRune");
static_assert(offsetof(FM1Request_CheckEnchantRune, AccountUid) == 0x000000, "Member 'FM1Request_CheckEnchantRune::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheckEnchantRune, RuneUid) == 0x000008, "Member 'FM1Request_CheckEnchantRune::RuneUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheckEnchantRune, TargetEnchantLevel) == 0x000018, "Member 'FM1Request_CheckEnchantRune::TargetEnchantLevel' has a wrong offset!");

// ScriptStruct M1.M1JustLoggedInValues
// 0x0020 (0x0020 - 0x0000)
struct FM1JustLoggedInValues final
{
public:
	bool                                          bJustLoggedIn;                                     // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         SelectedCharacterUid;                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1WearingInfo>                 WearingEquipments;                                 // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1JustLoggedInValues) == 0x000008, "Wrong alignment on FM1JustLoggedInValues");
static_assert(sizeof(FM1JustLoggedInValues) == 0x000020, "Wrong size on FM1JustLoggedInValues");
static_assert(offsetof(FM1JustLoggedInValues, bJustLoggedIn) == 0x000000, "Member 'FM1JustLoggedInValues::bJustLoggedIn' has a wrong offset!");
static_assert(offsetof(FM1JustLoggedInValues, SelectedCharacterUid) == 0x000008, "Member 'FM1JustLoggedInValues::SelectedCharacterUid' has a wrong offset!");
static_assert(offsetof(FM1JustLoggedInValues, WearingEquipments) == 0x000010, "Member 'FM1JustLoggedInValues::WearingEquipments' has a wrong offset!");

// ScriptStruct M1.M1Request_MatchedGameEnd
// 0x0040 (0x0040 - 0x0000)
struct FM1Request_MatchedGameEnd final : public FM1Request
{
public:
	struct FM1AccountList                         AccountList;                                       // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	EM1MatchedGameEndType                         EndType;                                           // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1MatchingGameEndAttribute            Req_2;                                             // 0x0018(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_MatchedGameEnd) == 0x000008, "Wrong alignment on FM1Request_MatchedGameEnd");
static_assert(sizeof(FM1Request_MatchedGameEnd) == 0x000040, "Wrong size on FM1Request_MatchedGameEnd");
static_assert(offsetof(FM1Request_MatchedGameEnd, AccountList) == 0x000000, "Member 'FM1Request_MatchedGameEnd::AccountList' has a wrong offset!");
static_assert(offsetof(FM1Request_MatchedGameEnd, EndType) == 0x000010, "Member 'FM1Request_MatchedGameEnd::EndType' has a wrong offset!");
static_assert(offsetof(FM1Request_MatchedGameEnd, Req_2) == 0x000018, "Member 'FM1Request_MatchedGameEnd::Req_2' has a wrong offset!");

// ScriptStruct M1.M1Request_DecomposeRune
// 0x0020 (0x0020 - 0x0000)
struct FM1Request_DecomposeRune final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InventoryRevision;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemShortIndexBundle                IndexBundle;                                       // 0x0010(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_DecomposeRune) == 0x000008, "Wrong alignment on FM1Request_DecomposeRune");
static_assert(sizeof(FM1Request_DecomposeRune) == 0x000020, "Wrong size on FM1Request_DecomposeRune");
static_assert(offsetof(FM1Request_DecomposeRune, AccountUid) == 0x000000, "Member 'FM1Request_DecomposeRune::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_DecomposeRune, InventoryRevision) == 0x000008, "Member 'FM1Request_DecomposeRune::InventoryRevision' has a wrong offset!");
static_assert(offsetof(FM1Request_DecomposeRune, Count) == 0x00000C, "Member 'FM1Request_DecomposeRune::Count' has a wrong offset!");
static_assert(offsetof(FM1Request_DecomposeRune, IndexBundle) == 0x000010, "Member 'FM1Request_DecomposeRune::IndexBundle' has a wrong offset!");

// ScriptStruct M1.M1Request_ComposeRune
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_ComposeRune final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemBoxesInfo                       ComposeRunesInfo;                                  // 0x0008(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_ComposeRune) == 0x000008, "Wrong alignment on FM1Request_ComposeRune");
static_assert(sizeof(FM1Request_ComposeRune) == 0x000018, "Wrong size on FM1Request_ComposeRune");
static_assert(offsetof(FM1Request_ComposeRune, AccountUid) == 0x000000, "Member 'FM1Request_ComposeRune::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_ComposeRune, ComposeRunesInfo) == 0x000008, "Member 'FM1Request_ComposeRune::ComposeRunesInfo' has a wrong offset!");

// ScriptStruct M1.M1MissionDepedantInfo
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FM1MissionDepedantInfo final
{
public:
	bool                                          bActivated;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bParentTaskActivated;                              // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2[0xA];                                        // 0x0002(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MissionDepedantInfo) == 0x000004, "Wrong alignment on FM1MissionDepedantInfo");
static_assert(sizeof(FM1MissionDepedantInfo) == 0x00000C, "Wrong size on FM1MissionDepedantInfo");
static_assert(offsetof(FM1MissionDepedantInfo, bActivated) == 0x000000, "Member 'FM1MissionDepedantInfo::bActivated' has a wrong offset!");
static_assert(offsetof(FM1MissionDepedantInfo, bParentTaskActivated) == 0x000001, "Member 'FM1MissionDepedantInfo::bParentTaskActivated' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatRemoveAllBoostItemEffect
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatRemoveAllBoostItemEffect final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatRemoveAllBoostItemEffect) == 0x000001, "Wrong alignment on FM1Response_CheatRemoveAllBoostItemEffect");
static_assert(sizeof(FM1Response_CheatRemoveAllBoostItemEffect) == 0x000001, "Wrong size on FM1Response_CheatRemoveAllBoostItemEffect");
static_assert(offsetof(FM1Response_CheatRemoveAllBoostItemEffect, Notification) == 0x000000, "Member 'FM1Response_CheatRemoveAllBoostItemEffect::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_RequestRuneEquippedInfoBundle
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_RequestRuneEquippedInfoBundle final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_RequestRuneEquippedInfoBundle) == 0x000008, "Wrong alignment on FM1Request_RequestRuneEquippedInfoBundle");
static_assert(sizeof(FM1Request_RequestRuneEquippedInfoBundle) == 0x000008, "Wrong size on FM1Request_RequestRuneEquippedInfoBundle");
static_assert(offsetof(FM1Request_RequestRuneEquippedInfoBundle, AccountUid) == 0x000000, "Member 'FM1Request_RequestRuneEquippedInfoBundle::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_RequestRuneEquippedInfoBundleByOwnerTid
// 0x0020 (0x0020 - 0x0000)
struct FM1Request_RequestRuneEquippedInfoBundleByOwnerTid final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1RuneLoadoutReq                      Req_1;                                             // 0x0008(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_RequestRuneEquippedInfoBundleByOwnerTid) == 0x000008, "Wrong alignment on FM1Request_RequestRuneEquippedInfoBundleByOwnerTid");
static_assert(sizeof(FM1Request_RequestRuneEquippedInfoBundleByOwnerTid) == 0x000020, "Wrong size on FM1Request_RequestRuneEquippedInfoBundleByOwnerTid");
static_assert(offsetof(FM1Request_RequestRuneEquippedInfoBundleByOwnerTid, AccountUid) == 0x000000, "Member 'FM1Request_RequestRuneEquippedInfoBundleByOwnerTid::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_RequestRuneEquippedInfoBundleByOwnerTid, Req_1) == 0x000008, "Member 'FM1Request_RequestRuneEquippedInfoBundleByOwnerTid::Req_1' has a wrong offset!");

// ScriptStruct M1.M1MissionRewardBase
// 0x0028 (0x0028 - 0x0000)
struct FM1MissionRewardBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         DefaultValue;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         EventValue;                                        // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         BoostItemValue;                                    // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ItemOptionValue;                                   // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionRewardBase) == 0x000008, "Wrong alignment on FM1MissionRewardBase");
static_assert(sizeof(FM1MissionRewardBase) == 0x000028, "Wrong size on FM1MissionRewardBase");
static_assert(offsetof(FM1MissionRewardBase, DefaultValue) == 0x000008, "Member 'FM1MissionRewardBase::DefaultValue' has a wrong offset!");
static_assert(offsetof(FM1MissionRewardBase, EventValue) == 0x000010, "Member 'FM1MissionRewardBase::EventValue' has a wrong offset!");
static_assert(offsetof(FM1MissionRewardBase, BoostItemValue) == 0x000018, "Member 'FM1MissionRewardBase::BoostItemValue' has a wrong offset!");
static_assert(offsetof(FM1MissionRewardBase, ItemOptionValue) == 0x000020, "Member 'FM1MissionRewardBase::ItemOptionValue' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatCreateEquipment
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatCreateEquipment final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatCreateEquipment) == 0x000001, "Wrong alignment on FM1Response_CheatCreateEquipment");
static_assert(sizeof(FM1Response_CheatCreateEquipment) == 0x000001, "Wrong size on FM1Response_CheatCreateEquipment");
static_assert(offsetof(FM1Response_CheatCreateEquipment, Notification) == 0x000000, "Member 'FM1Response_CheatCreateEquipment::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_ChangeLoadoutSlotName
// 0x0038 (0x0038 - 0x0000)
struct FM1Request_ChangeLoadoutSlotName final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemTidBox                          OwnerTid;                                          // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         LoadoutSlotIndex;                                  // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Language;                                          // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_ChangeLoadoutSlotName) == 0x000008, "Wrong alignment on FM1Request_ChangeLoadoutSlotName");
static_assert(sizeof(FM1Request_ChangeLoadoutSlotName) == 0x000038, "Wrong size on FM1Request_ChangeLoadoutSlotName");
static_assert(offsetof(FM1Request_ChangeLoadoutSlotName, AccountUid) == 0x000000, "Member 'FM1Request_ChangeLoadoutSlotName::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_ChangeLoadoutSlotName, OwnerTid) == 0x000008, "Member 'FM1Request_ChangeLoadoutSlotName::OwnerTid' has a wrong offset!");
static_assert(offsetof(FM1Request_ChangeLoadoutSlotName, LoadoutSlotIndex) == 0x000010, "Member 'FM1Request_ChangeLoadoutSlotName::LoadoutSlotIndex' has a wrong offset!");
static_assert(offsetof(FM1Request_ChangeLoadoutSlotName, Language) == 0x000018, "Member 'FM1Request_ChangeLoadoutSlotName::Language' has a wrong offset!");
static_assert(offsetof(FM1Request_ChangeLoadoutSlotName, Name) == 0x000028, "Member 'FM1Request_ChangeLoadoutSlotName::Name' has a wrong offset!");

// ScriptStruct M1.M1TypedUITheme_Button
// 0x0418 (0x0440 - 0x0028)
struct FM1TypedUITheme_Button final : public FM1TypedUICustomizing
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FButtonStyle                           Style;                                             // 0x0030(0x03B0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         TextFont;                                          // 0x03E0(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseUIDecoBack;                                    // 0x0438(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseUIButtonDeco;                                  // 0x0439(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43A[0x6];                                      // 0x043A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1TypedUITheme_Button) == 0x000010, "Wrong alignment on FM1TypedUITheme_Button");
static_assert(sizeof(FM1TypedUITheme_Button) == 0x000440, "Wrong size on FM1TypedUITheme_Button");
static_assert(offsetof(FM1TypedUITheme_Button, Style) == 0x000030, "Member 'FM1TypedUITheme_Button::Style' has a wrong offset!");
static_assert(offsetof(FM1TypedUITheme_Button, TextFont) == 0x0003E0, "Member 'FM1TypedUITheme_Button::TextFont' has a wrong offset!");
static_assert(offsetof(FM1TypedUITheme_Button, bUseUIDecoBack) == 0x000438, "Member 'FM1TypedUITheme_Button::bUseUIDecoBack' has a wrong offset!");
static_assert(offsetof(FM1TypedUITheme_Button, bUseUIButtonDeco) == 0x000439, "Member 'FM1TypedUITheme_Button::bUseUIButtonDeco' has a wrong offset!");

// ScriptStruct M1.M1Request_BuyLoadoutSlot
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_BuyLoadoutSlot final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemTidBox                          OwnerTid;                                          // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_BuyLoadoutSlot) == 0x000008, "Wrong alignment on FM1Request_BuyLoadoutSlot");
static_assert(sizeof(FM1Request_BuyLoadoutSlot) == 0x000010, "Wrong size on FM1Request_BuyLoadoutSlot");
static_assert(offsetof(FM1Request_BuyLoadoutSlot, AccountUid) == 0x000000, "Member 'FM1Request_BuyLoadoutSlot::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_BuyLoadoutSlot, OwnerTid) == 0x000008, "Member 'FM1Request_BuyLoadoutSlot::OwnerTid' has a wrong offset!");

// ScriptStruct M1.M1Request_DecomposeRuneWithUid
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_DecomposeRuneWithUid final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemBoxesInfo                       RuneUidBundle;                                     // 0x0008(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_DecomposeRuneWithUid) == 0x000008, "Wrong alignment on FM1Request_DecomposeRuneWithUid");
static_assert(sizeof(FM1Request_DecomposeRuneWithUid) == 0x000018, "Wrong size on FM1Request_DecomposeRuneWithUid");
static_assert(offsetof(FM1Request_DecomposeRuneWithUid, AccountUid) == 0x000000, "Member 'FM1Request_DecomposeRuneWithUid::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_DecomposeRuneWithUid, RuneUidBundle) == 0x000008, "Member 'FM1Request_DecomposeRuneWithUid::RuneUidBundle' has a wrong offset!");

// ScriptStruct M1.M1ReceivedRewardExp
// 0x0020 (0x0020 - 0x0000)
struct FM1ReceivedRewardExp
{
public:
	int64                                         DefaultExp;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         EventExp;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         BoostItemExp;                                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ItemOptionExp;                                     // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ReceivedRewardExp) == 0x000008, "Wrong alignment on FM1ReceivedRewardExp");
static_assert(sizeof(FM1ReceivedRewardExp) == 0x000020, "Wrong size on FM1ReceivedRewardExp");
static_assert(offsetof(FM1ReceivedRewardExp, DefaultExp) == 0x000000, "Member 'FM1ReceivedRewardExp::DefaultExp' has a wrong offset!");
static_assert(offsetof(FM1ReceivedRewardExp, EventExp) == 0x000008, "Member 'FM1ReceivedRewardExp::EventExp' has a wrong offset!");
static_assert(offsetof(FM1ReceivedRewardExp, BoostItemExp) == 0x000010, "Member 'FM1ReceivedRewardExp::BoostItemExp' has a wrong offset!");
static_assert(offsetof(FM1ReceivedRewardExp, ItemOptionExp) == 0x000018, "Member 'FM1ReceivedRewardExp::ItemOptionExp' has a wrong offset!");

// ScriptStruct M1.M1Response_DestroyItem
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_DestroyItem final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_DestroyItem) == 0x000001, "Wrong alignment on FM1Response_DestroyItem");
static_assert(sizeof(FM1Response_DestroyItem) == 0x000001, "Wrong size on FM1Response_DestroyItem");
static_assert(offsetof(FM1Response_DestroyItem, Notification) == 0x000000, "Member 'FM1Response_DestroyItem::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_SellItemRequest
// 0x0020 (0x0020 - 0x0000)
struct FM1Request_SellItemRequest final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemUidBox                          ItemUid;                                           // 0x0008(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_SellItemRequest) == 0x000008, "Wrong alignment on FM1Request_SellItemRequest");
static_assert(sizeof(FM1Request_SellItemRequest) == 0x000020, "Wrong size on FM1Request_SellItemRequest");
static_assert(offsetof(FM1Request_SellItemRequest, AccountUid) == 0x000000, "Member 'FM1Request_SellItemRequest::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_SellItemRequest, ItemUid) == 0x000008, "Member 'FM1Request_SellItemRequest::ItemUid' has a wrong offset!");
static_assert(offsetof(FM1Request_SellItemRequest, Count) == 0x000018, "Member 'FM1Request_SellItemRequest::Count' has a wrong offset!");

// ScriptStruct M1.M1Request_BuyItemRequest
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_BuyItemRequest final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1BuyItemDataBundle                   Bundle;                                            // 0x0008(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_BuyItemRequest) == 0x000008, "Wrong alignment on FM1Request_BuyItemRequest");
static_assert(sizeof(FM1Request_BuyItemRequest) == 0x000018, "Wrong size on FM1Request_BuyItemRequest");
static_assert(offsetof(FM1Request_BuyItemRequest, AccountUid) == 0x000000, "Member 'FM1Request_BuyItemRequest::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_BuyItemRequest, Bundle) == 0x000008, "Member 'FM1Request_BuyItemRequest::Bundle' has a wrong offset!");

// ScriptStruct M1.M1MissionMonsterSpawnHistory
// 0x0050 (0x0050 - 0x0000)
struct FM1MissionMonsterSpawnHistory final
{
public:
	TMap<struct FM1TemplateId, int32>             MonsterCountByType;                                // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionMonsterSpawnHistory) == 0x000008, "Wrong alignment on FM1MissionMonsterSpawnHistory");
static_assert(sizeof(FM1MissionMonsterSpawnHistory) == 0x000050, "Wrong size on FM1MissionMonsterSpawnHistory");
static_assert(offsetof(FM1MissionMonsterSpawnHistory, MonsterCountByType) == 0x000000, "Member 'FM1MissionMonsterSpawnHistory::MonsterCountByType' has a wrong offset!");

// ScriptStruct M1.M1MissionPlayHistory
// 0x0128 (0x0128 - 0x0000)
struct FM1MissionPlayHistory final
{
public:
	TMap<class FString, struct FM1MissionPlayerInfoToCollect> PlayersInfo;                                       // 0x0000(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<class FString, struct FM1MissionMonsterSpawnHistory> MonsterSpawnHistory;                               // 0x0050(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<class FString, struct FM1MissionTargetActorInfoToCollect> TargetActorInfo;                                   // 0x00A0(0x0050)(Transient, NativeAccessSpecifierPublic)
	EM1MissionStatus                              Status;                                            // 0x00F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AM1MissionTaskActor>        LastMissionTaskActorClass;                         // 0x00F8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWorldMission;                                   // 0x0100(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              StartTime;                                         // 0x0108(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndTime;                                           // 0x0110(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x10];                                     // 0x0118(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MissionPlayHistory) == 0x000008, "Wrong alignment on FM1MissionPlayHistory");
static_assert(sizeof(FM1MissionPlayHistory) == 0x000128, "Wrong size on FM1MissionPlayHistory");
static_assert(offsetof(FM1MissionPlayHistory, PlayersInfo) == 0x000000, "Member 'FM1MissionPlayHistory::PlayersInfo' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayHistory, MonsterSpawnHistory) == 0x000050, "Member 'FM1MissionPlayHistory::MonsterSpawnHistory' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayHistory, TargetActorInfo) == 0x0000A0, "Member 'FM1MissionPlayHistory::TargetActorInfo' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayHistory, Status) == 0x0000F0, "Member 'FM1MissionPlayHistory::Status' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayHistory, LastMissionTaskActorClass) == 0x0000F8, "Member 'FM1MissionPlayHistory::LastMissionTaskActorClass' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayHistory, bIsWorldMission) == 0x000100, "Member 'FM1MissionPlayHistory::bIsWorldMission' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayHistory, StartTime) == 0x000108, "Member 'FM1MissionPlayHistory::StartTime' has a wrong offset!");
static_assert(offsetof(FM1MissionPlayHistory, EndTime) == 0x000110, "Member 'FM1MissionPlayHistory::EndTime' has a wrong offset!");

// ScriptStruct M1.M1Request_SetBattlePassPremium
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_SetBattlePassPremium final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_SetBattlePassPremium) == 0x000008, "Wrong alignment on FM1Request_SetBattlePassPremium");
static_assert(sizeof(FM1Request_SetBattlePassPremium) == 0x000008, "Wrong size on FM1Request_SetBattlePassPremium");
static_assert(offsetof(FM1Request_SetBattlePassPremium, AccountUid) == 0x000000, "Member 'FM1Request_SetBattlePassPremium::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_SellJunkItemRequest
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_SellJunkItemRequest final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemType                                   ItemType;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_SellJunkItemRequest) == 0x000008, "Wrong alignment on FM1Request_SellJunkItemRequest");
static_assert(sizeof(FM1Request_SellJunkItemRequest) == 0x000010, "Wrong size on FM1Request_SellJunkItemRequest");
static_assert(offsetof(FM1Request_SellJunkItemRequest, AccountUid) == 0x000000, "Member 'FM1Request_SellJunkItemRequest::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_SellJunkItemRequest, ItemType) == 0x000008, "Member 'FM1Request_SellJunkItemRequest::ItemType' has a wrong offset!");

// ScriptStruct M1.M1Request_RequestShopBuyData
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_RequestShopBuyData final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_RequestShopBuyData) == 0x000008, "Wrong alignment on FM1Request_RequestShopBuyData");
static_assert(sizeof(FM1Request_RequestShopBuyData) == 0x000008, "Wrong size on FM1Request_RequestShopBuyData");
static_assert(offsetof(FM1Request_RequestShopBuyData, AccountUid) == 0x000000, "Member 'FM1Request_RequestShopBuyData::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1EquipmentPerkInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FM1EquipmentPerkInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1EquipmentPerkInfo) == 0x000008, "Wrong alignment on FM1EquipmentPerkInfo");
static_assert(sizeof(FM1EquipmentPerkInfo) == 0x000010, "Wrong size on FM1EquipmentPerkInfo");

// ScriptStruct M1.M1Response_CheatResetInventoryLimit
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatResetInventoryLimit final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatResetInventoryLimit) == 0x000001, "Wrong alignment on FM1Response_CheatResetInventoryLimit");
static_assert(sizeof(FM1Response_CheatResetInventoryLimit) == 0x000001, "Wrong size on FM1Response_CheatResetInventoryLimit");
static_assert(offsetof(FM1Response_CheatResetInventoryLimit, Notification) == 0x000000, "Member 'FM1Response_CheatResetInventoryLimit::Notification' has a wrong offset!");

// ScriptStruct M1.M1UIGameTopPriorityRow
// 0x0028 (0x0030 - 0x0008)
struct FM1UIGameTopPriorityRow final : public FTableRowBase
{
public:
	struct FSoftClassPath                         WidgetPath;                                        // 0x0008(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIGameTopPriorityRow) == 0x000008, "Wrong alignment on FM1UIGameTopPriorityRow");
static_assert(sizeof(FM1UIGameTopPriorityRow) == 0x000030, "Wrong size on FM1UIGameTopPriorityRow");
static_assert(offsetof(FM1UIGameTopPriorityRow, WidgetPath) == 0x000008, "Member 'FM1UIGameTopPriorityRow::WidgetPath' has a wrong offset!");
static_assert(offsetof(FM1UIGameTopPriorityRow, Priority) == 0x000028, "Member 'FM1UIGameTopPriorityRow::Priority' has a wrong offset!");

// ScriptStruct M1.M1Request_RequestCurrencyInternalTranBundle
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_RequestCurrencyInternalTranBundle final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_RequestCurrencyInternalTranBundle) == 0x000008, "Wrong alignment on FM1Request_RequestCurrencyInternalTranBundle");
static_assert(sizeof(FM1Request_RequestCurrencyInternalTranBundle) == 0x000008, "Wrong size on FM1Request_RequestCurrencyInternalTranBundle");
static_assert(offsetof(FM1Request_RequestCurrencyInternalTranBundle, AccountUid) == 0x000000, "Member 'FM1Request_RequestCurrencyInternalTranBundle::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1GameGuideEndCondition
// 0x0038 (0x0038 - 0x0000)
struct FM1GameGuideEndCondition final
{
public:
	EM1GameGuideEndConditionType                  ConditionType;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DurationTime;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1SystemKey                                  SystemKey;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1BattleKey                                  BattleKey;                                         // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         WidgetClassPath;                                   // 0x0010(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ItemRowName;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GameGuideEndCondition) == 0x000008, "Wrong alignment on FM1GameGuideEndCondition");
static_assert(sizeof(FM1GameGuideEndCondition) == 0x000038, "Wrong size on FM1GameGuideEndCondition");
static_assert(offsetof(FM1GameGuideEndCondition, ConditionType) == 0x000000, "Member 'FM1GameGuideEndCondition::ConditionType' has a wrong offset!");
static_assert(offsetof(FM1GameGuideEndCondition, DurationTime) == 0x000004, "Member 'FM1GameGuideEndCondition::DurationTime' has a wrong offset!");
static_assert(offsetof(FM1GameGuideEndCondition, SystemKey) == 0x000008, "Member 'FM1GameGuideEndCondition::SystemKey' has a wrong offset!");
static_assert(offsetof(FM1GameGuideEndCondition, BattleKey) == 0x000009, "Member 'FM1GameGuideEndCondition::BattleKey' has a wrong offset!");
static_assert(offsetof(FM1GameGuideEndCondition, WidgetClassPath) == 0x000010, "Member 'FM1GameGuideEndCondition::WidgetClassPath' has a wrong offset!");
static_assert(offsetof(FM1GameGuideEndCondition, ItemRowName) == 0x000030, "Member 'FM1GameGuideEndCondition::ItemRowName' has a wrong offset!");

// ScriptStruct M1.M1Request_RequestShopRestrictionInfo
// 0x0001 (0x0001 - 0x0000)
struct FM1Request_RequestShopRestrictionInfo final : public FM1Request
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_RequestShopRestrictionInfo) == 0x000001, "Wrong alignment on FM1Request_RequestShopRestrictionInfo");
static_assert(sizeof(FM1Request_RequestShopRestrictionInfo) == 0x000001, "Wrong size on FM1Request_RequestShopRestrictionInfo");

// ScriptStruct M1.M1Request_RequestBattlePassSeasonData
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_RequestBattlePassSeasonData final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_RequestBattlePassSeasonData) == 0x000008, "Wrong alignment on FM1Request_RequestBattlePassSeasonData");
static_assert(sizeof(FM1Request_RequestBattlePassSeasonData) == 0x000008, "Wrong size on FM1Request_RequestBattlePassSeasonData");
static_assert(offsetof(FM1Request_RequestBattlePassSeasonData, AccountUid) == 0x000000, "Member 'FM1Request_RequestBattlePassSeasonData::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_RequestPaidProductLog
// 0x0028 (0x0028 - 0x0000)
struct FM1Request_RequestPaidProductLog final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ToyResult;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Pid;                                               // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RealCash;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_RequestPaidProductLog) == 0x000008, "Wrong alignment on FM1Request_RequestPaidProductLog");
static_assert(sizeof(FM1Request_RequestPaidProductLog) == 0x000028, "Wrong size on FM1Request_RequestPaidProductLog");
static_assert(offsetof(FM1Request_RequestPaidProductLog, AccountUid) == 0x000000, "Member 'FM1Request_RequestPaidProductLog::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_RequestPaidProductLog, ToyResult) == 0x000008, "Member 'FM1Request_RequestPaidProductLog::ToyResult' has a wrong offset!");
static_assert(offsetof(FM1Request_RequestPaidProductLog, Pid) == 0x000010, "Member 'FM1Request_RequestPaidProductLog::Pid' has a wrong offset!");
static_assert(offsetof(FM1Request_RequestPaidProductLog, RealCash) == 0x000020, "Member 'FM1Request_RequestPaidProductLog::RealCash' has a wrong offset!");

// ScriptStruct M1.M1UIShopGroupCategory
// 0x0088 (0x0090 - 0x0008)
struct FM1UIShopGroupCategory final : public FTableRowBase
{
public:
	class FString                                 StringId;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ImagePath;                                         // 0x0018(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        RewardImagePath;                                   // 0x0038(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        RewardBGImagePath;                                 // 0x0058(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              EntryPadding;                                      // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              EntrySize;                                         // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIShopGroupCategory) == 0x000008, "Wrong alignment on FM1UIShopGroupCategory");
static_assert(sizeof(FM1UIShopGroupCategory) == 0x000090, "Wrong size on FM1UIShopGroupCategory");
static_assert(offsetof(FM1UIShopGroupCategory, StringId) == 0x000008, "Member 'FM1UIShopGroupCategory::StringId' has a wrong offset!");
static_assert(offsetof(FM1UIShopGroupCategory, ImagePath) == 0x000018, "Member 'FM1UIShopGroupCategory::ImagePath' has a wrong offset!");
static_assert(offsetof(FM1UIShopGroupCategory, RewardImagePath) == 0x000038, "Member 'FM1UIShopGroupCategory::RewardImagePath' has a wrong offset!");
static_assert(offsetof(FM1UIShopGroupCategory, RewardBGImagePath) == 0x000058, "Member 'FM1UIShopGroupCategory::RewardBGImagePath' has a wrong offset!");
static_assert(offsetof(FM1UIShopGroupCategory, EntryPadding) == 0x000078, "Member 'FM1UIShopGroupCategory::EntryPadding' has a wrong offset!");
static_assert(offsetof(FM1UIShopGroupCategory, EntrySize) == 0x000080, "Member 'FM1UIShopGroupCategory::EntrySize' has a wrong offset!");
static_assert(offsetof(FM1UIShopGroupCategory, Priority) == 0x000088, "Member 'FM1UIShopGroupCategory::Priority' has a wrong offset!");

// ScriptStruct M1.M1Request_CheckResearchStatus
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_CheckResearchStatus final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CheckResearchStatus) == 0x000008, "Wrong alignment on FM1Request_CheckResearchStatus");
static_assert(sizeof(FM1Request_CheckResearchStatus) == 0x000008, "Wrong size on FM1Request_CheckResearchStatus");
static_assert(offsetof(FM1Request_CheckResearchStatus, AccountUid) == 0x000000, "Member 'FM1Request_CheckResearchStatus::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1NXRecRuneSlotInfo
// 0x0002 (0x0002 - 0x0000)
struct FM1NXRecRuneSlotInfo final
{
public:
	EM1RuneSubClassType                           Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1RuneSocketType                             Socket;                                            // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NXRecRuneSlotInfo) == 0x000001, "Wrong alignment on FM1NXRecRuneSlotInfo");
static_assert(sizeof(FM1NXRecRuneSlotInfo) == 0x000002, "Wrong size on FM1NXRecRuneSlotInfo");
static_assert(offsetof(FM1NXRecRuneSlotInfo, Type) == 0x000000, "Member 'FM1NXRecRuneSlotInfo::Type' has a wrong offset!");
static_assert(offsetof(FM1NXRecRuneSlotInfo, Socket) == 0x000001, "Member 'FM1NXRecRuneSlotInfo::Socket' has a wrong offset!");

// ScriptStruct M1.M1NXRecRuneInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1NXRecRuneInfo final
{
public:
	int64                                         Tid;                                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         EnchantLevel;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NXRecRuneInfo) == 0x000008, "Wrong alignment on FM1NXRecRuneInfo");
static_assert(sizeof(FM1NXRecRuneInfo) == 0x000010, "Wrong size on FM1NXRecRuneInfo");
static_assert(offsetof(FM1NXRecRuneInfo, Tid) == 0x000000, "Member 'FM1NXRecRuneInfo::Tid' has a wrong offset!");
static_assert(offsetof(FM1NXRecRuneInfo, EnchantLevel) == 0x000008, "Member 'FM1NXRecRuneInfo::EnchantLevel' has a wrong offset!");

// ScriptStruct M1.M1NXRunePak
// 0x0018 (0x0018 - 0x0000)
struct FM1NXRunePak final
{
public:
	struct FM1NXRecRuneSlotInfo                   Slot;                                              // 0x0000(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1NXRecRuneInfo                       Module;                                            // 0x0008(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NXRunePak) == 0x000008, "Wrong alignment on FM1NXRunePak");
static_assert(sizeof(FM1NXRunePak) == 0x000018, "Wrong size on FM1NXRunePak");
static_assert(offsetof(FM1NXRunePak, Slot) == 0x000000, "Member 'FM1NXRunePak::Slot' has a wrong offset!");
static_assert(offsetof(FM1NXRunePak, Module) == 0x000008, "Member 'FM1NXRunePak::Module' has a wrong offset!");

// ScriptStruct M1.M1Response_TakeOutFromWareHouse
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_TakeOutFromWareHouse final
{
public:
	EM1ItemReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_TakeOutFromWareHouse) == 0x000004, "Wrong alignment on FM1Response_TakeOutFromWareHouse");
static_assert(sizeof(FM1Response_TakeOutFromWareHouse) == 0x000004, "Wrong size on FM1Response_TakeOutFromWareHouse");
static_assert(offsetof(FM1Response_TakeOutFromWareHouse, Notification) == 0x000000, "Member 'FM1Response_TakeOutFromWareHouse::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_RequestResearch
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_RequestResearch final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ResearchTemplateId;                                // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepeatCount;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_RequestResearch) == 0x000008, "Wrong alignment on FM1Request_RequestResearch");
static_assert(sizeof(FM1Request_RequestResearch) == 0x000010, "Wrong size on FM1Request_RequestResearch");
static_assert(offsetof(FM1Request_RequestResearch, AccountUid) == 0x000000, "Member 'FM1Request_RequestResearch::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_RequestResearch, ResearchTemplateId) == 0x000008, "Member 'FM1Request_RequestResearch::ResearchTemplateId' has a wrong offset!");
static_assert(offsetof(FM1Request_RequestResearch, RepeatCount) == 0x00000C, "Member 'FM1Request_RequestResearch::RepeatCount' has a wrong offset!");

// ScriptStruct M1.M1Request_BoostResearch
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_BoostResearch final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ResearchTemplateId;                                // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_BoostResearch) == 0x000008, "Wrong alignment on FM1Request_BoostResearch");
static_assert(sizeof(FM1Request_BoostResearch) == 0x000010, "Wrong size on FM1Request_BoostResearch");
static_assert(offsetof(FM1Request_BoostResearch, AccountUid) == 0x000000, "Member 'FM1Request_BoostResearch::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_BoostResearch, ResearchTemplateId) == 0x000008, "Member 'FM1Request_BoostResearch::ResearchTemplateId' has a wrong offset!");

// ScriptStruct M1.M1PlayerInteractionAnimInfo
// 0x0048 (0x0048 - 0x0000)
struct FM1PlayerInteractionAnimInfo final
{
public:
	EM1PlayerInteractionAnimType                  Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveToInteractableLocation;                       // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Offset;                                            // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UNiagaraSystem>          InteractableAreaFx;                                // 0x0018(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PlayerInteractionAnimInfo) == 0x000008, "Wrong alignment on FM1PlayerInteractionAnimInfo");
static_assert(sizeof(FM1PlayerInteractionAnimInfo) == 0x000048, "Wrong size on FM1PlayerInteractionAnimInfo");
static_assert(offsetof(FM1PlayerInteractionAnimInfo, Type) == 0x000000, "Member 'FM1PlayerInteractionAnimInfo::Type' has a wrong offset!");
static_assert(offsetof(FM1PlayerInteractionAnimInfo, bMoveToInteractableLocation) == 0x000001, "Member 'FM1PlayerInteractionAnimInfo::bMoveToInteractableLocation' has a wrong offset!");
static_assert(offsetof(FM1PlayerInteractionAnimInfo, Offset) == 0x000004, "Member 'FM1PlayerInteractionAnimInfo::Offset' has a wrong offset!");
static_assert(offsetof(FM1PlayerInteractionAnimInfo, Range) == 0x000010, "Member 'FM1PlayerInteractionAnimInfo::Range' has a wrong offset!");
static_assert(offsetof(FM1PlayerInteractionAnimInfo, InteractableAreaFx) == 0x000018, "Member 'FM1PlayerInteractionAnimInfo::InteractableAreaFx' has a wrong offset!");

// ScriptStruct M1.M1Request_SetTitle
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_SetTitle final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          PrefixTitleId;                                     // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          SuffixTitleId;                                     // 0x000C(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_SetTitle) == 0x000008, "Wrong alignment on FM1Request_SetTitle");
static_assert(sizeof(FM1Request_SetTitle) == 0x000010, "Wrong size on FM1Request_SetTitle");
static_assert(offsetof(FM1Request_SetTitle, AccountUid) == 0x000000, "Member 'FM1Request_SetTitle::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_SetTitle, PrefixTitleId) == 0x000008, "Member 'FM1Request_SetTitle::PrefixTitleId' has a wrong offset!");
static_assert(offsetof(FM1Request_SetTitle, SuffixTitleId) == 0x00000C, "Member 'FM1Request_SetTitle::SuffixTitleId' has a wrong offset!");

// ScriptStruct M1.M1Request_CancelResearch
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CancelResearch final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ResearchTemplateId;                                // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_CancelResearch) == 0x000008, "Wrong alignment on FM1Request_CancelResearch");
static_assert(sizeof(FM1Request_CancelResearch) == 0x000010, "Wrong size on FM1Request_CancelResearch");
static_assert(offsetof(FM1Request_CancelResearch, AccountUid) == 0x000000, "Member 'FM1Request_CancelResearch::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CancelResearch, ResearchTemplateId) == 0x000008, "Member 'FM1Request_CancelResearch::ResearchTemplateId' has a wrong offset!");

// ScriptStruct M1.M1Request_ReceiveResearch
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_ReceiveResearch final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ResearchTemplateId;                                // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_ReceiveResearch) == 0x000008, "Wrong alignment on FM1Request_ReceiveResearch");
static_assert(sizeof(FM1Request_ReceiveResearch) == 0x000010, "Wrong size on FM1Request_ReceiveResearch");
static_assert(offsetof(FM1Request_ReceiveResearch, AccountUid) == 0x000000, "Member 'FM1Request_ReceiveResearch::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_ReceiveResearch, ResearchTemplateId) == 0x000008, "Member 'FM1Request_ReceiveResearch::ResearchTemplateId' has a wrong offset!");

// ScriptStruct M1.M1SequenceTrackData
// 0x0030 (0x0038 - 0x0008)
struct FM1SequenceTrackData : public FTableRowBase
{
public:
	EM1SequencePlayType                           PlayType;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartDelay;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopInterval;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFadeEffect;                                    // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1FadeInterval                               FadeInterval;                                      // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeTime;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStoppableByKeyInput;                              // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStoppableByMouseInput;                            // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AM1LevelSequenceActor>> SequenceActorList;                                 // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SequenceTrackData) == 0x000008, "Wrong alignment on FM1SequenceTrackData");
static_assert(sizeof(FM1SequenceTrackData) == 0x000038, "Wrong size on FM1SequenceTrackData");
static_assert(offsetof(FM1SequenceTrackData, PlayType) == 0x000008, "Member 'FM1SequenceTrackData::PlayType' has a wrong offset!");
static_assert(offsetof(FM1SequenceTrackData, StartDelay) == 0x00000C, "Member 'FM1SequenceTrackData::StartDelay' has a wrong offset!");
static_assert(offsetof(FM1SequenceTrackData, bLoop) == 0x000010, "Member 'FM1SequenceTrackData::bLoop' has a wrong offset!");
static_assert(offsetof(FM1SequenceTrackData, LoopInterval) == 0x000014, "Member 'FM1SequenceTrackData::LoopInterval' has a wrong offset!");
static_assert(offsetof(FM1SequenceTrackData, bUseFadeEffect) == 0x000018, "Member 'FM1SequenceTrackData::bUseFadeEffect' has a wrong offset!");
static_assert(offsetof(FM1SequenceTrackData, FadeInterval) == 0x000019, "Member 'FM1SequenceTrackData::FadeInterval' has a wrong offset!");
static_assert(offsetof(FM1SequenceTrackData, FadeTime) == 0x00001C, "Member 'FM1SequenceTrackData::FadeTime' has a wrong offset!");
static_assert(offsetof(FM1SequenceTrackData, bStoppableByKeyInput) == 0x000020, "Member 'FM1SequenceTrackData::bStoppableByKeyInput' has a wrong offset!");
static_assert(offsetof(FM1SequenceTrackData, bStoppableByMouseInput) == 0x000021, "Member 'FM1SequenceTrackData::bStoppableByMouseInput' has a wrong offset!");
static_assert(offsetof(FM1SequenceTrackData, SequenceActorList) == 0x000028, "Member 'FM1SequenceTrackData::SequenceActorList' has a wrong offset!");

// ScriptStruct M1.M1MissionBalanceDumpDataWithTemplateId
// 0x0008 (0x0008 - 0x0000)
struct FM1MissionBalanceDumpDataWithTemplateId final
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionBalanceDumpDataWithTemplateId) == 0x000004, "Wrong alignment on FM1MissionBalanceDumpDataWithTemplateId");
static_assert(sizeof(FM1MissionBalanceDumpDataWithTemplateId) == 0x000008, "Wrong size on FM1MissionBalanceDumpDataWithTemplateId");
static_assert(offsetof(FM1MissionBalanceDumpDataWithTemplateId, TemplateId) == 0x000000, "Member 'FM1MissionBalanceDumpDataWithTemplateId::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1MissionBalanceDumpDataWithTemplateId, Count) == 0x000004, "Member 'FM1MissionBalanceDumpDataWithTemplateId::Count' has a wrong offset!");

// ScriptStruct M1.M1Request_RequestSetResearchBookmark
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_RequestSetResearchBookmark final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ResearchTemplateId;                                // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_RequestSetResearchBookmark) == 0x000008, "Wrong alignment on FM1Request_RequestSetResearchBookmark");
static_assert(sizeof(FM1Request_RequestSetResearchBookmark) == 0x000010, "Wrong size on FM1Request_RequestSetResearchBookmark");
static_assert(offsetof(FM1Request_RequestSetResearchBookmark, AccountUid) == 0x000000, "Member 'FM1Request_RequestSetResearchBookmark::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_RequestSetResearchBookmark, ResearchTemplateId) == 0x000008, "Member 'FM1Request_RequestSetResearchBookmark::ResearchTemplateId' has a wrong offset!");

// ScriptStruct M1.M1Request_SetCodexTracker
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_SetCodexTracker final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1CodexTrackingData                   Info;                                              // 0x0008(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_SetCodexTracker) == 0x000008, "Wrong alignment on FM1Request_SetCodexTracker");
static_assert(sizeof(FM1Request_SetCodexTracker) == 0x000018, "Wrong size on FM1Request_SetCodexTracker");
static_assert(offsetof(FM1Request_SetCodexTracker, AccountUid) == 0x000000, "Member 'FM1Request_SetCodexTracker::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_SetCodexTracker, Info) == 0x000008, "Member 'FM1Request_SetCodexTracker::Info' has a wrong offset!");

// ScriptStruct M1.M1Request_RequestUnSetResearchBookmark
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_RequestUnSetResearchBookmark final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ResearchTemplateId;                                // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_RequestUnSetResearchBookmark) == 0x000008, "Wrong alignment on FM1Request_RequestUnSetResearchBookmark");
static_assert(sizeof(FM1Request_RequestUnSetResearchBookmark) == 0x000010, "Wrong size on FM1Request_RequestUnSetResearchBookmark");
static_assert(offsetof(FM1Request_RequestUnSetResearchBookmark, AccountUid) == 0x000000, "Member 'FM1Request_RequestUnSetResearchBookmark::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_RequestUnSetResearchBookmark, ResearchTemplateId) == 0x000008, "Member 'FM1Request_RequestUnSetResearchBookmark::ResearchTemplateId' has a wrong offset!");

// ScriptStruct M1.M1TrapStaticMeshOption
// 0x0040 (0x0040 - 0x0000)
struct FM1TrapStaticMeshOption final
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 AOESkipIndexes;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         HeightOffset;                                      // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Yaw;                                               // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCollisionProfileName                  MeshCollisionProfile;                              // 0x0028(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCanEverAffectNavigation;                          // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPairMesh;                                         // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PairWidth;                                         // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPairFlip;                                         // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1TrapStaticMeshOption) == 0x000008, "Wrong alignment on FM1TrapStaticMeshOption");
static_assert(sizeof(FM1TrapStaticMeshOption) == 0x000040, "Wrong size on FM1TrapStaticMeshOption");
static_assert(offsetof(FM1TrapStaticMeshOption, Mesh) == 0x000000, "Member 'FM1TrapStaticMeshOption::Mesh' has a wrong offset!");
static_assert(offsetof(FM1TrapStaticMeshOption, Count) == 0x000008, "Member 'FM1TrapStaticMeshOption::Count' has a wrong offset!");
static_assert(offsetof(FM1TrapStaticMeshOption, AOESkipIndexes) == 0x000010, "Member 'FM1TrapStaticMeshOption::AOESkipIndexes' has a wrong offset!");
static_assert(offsetof(FM1TrapStaticMeshOption, HeightOffset) == 0x000020, "Member 'FM1TrapStaticMeshOption::HeightOffset' has a wrong offset!");
static_assert(offsetof(FM1TrapStaticMeshOption, Yaw) == 0x000024, "Member 'FM1TrapStaticMeshOption::Yaw' has a wrong offset!");
static_assert(offsetof(FM1TrapStaticMeshOption, MeshCollisionProfile) == 0x000028, "Member 'FM1TrapStaticMeshOption::MeshCollisionProfile' has a wrong offset!");
static_assert(offsetof(FM1TrapStaticMeshOption, bCanEverAffectNavigation) == 0x000030, "Member 'FM1TrapStaticMeshOption::bCanEverAffectNavigation' has a wrong offset!");
static_assert(offsetof(FM1TrapStaticMeshOption, bPairMesh) == 0x000031, "Member 'FM1TrapStaticMeshOption::bPairMesh' has a wrong offset!");
static_assert(offsetof(FM1TrapStaticMeshOption, PairWidth) == 0x000034, "Member 'FM1TrapStaticMeshOption::PairWidth' has a wrong offset!");
static_assert(offsetof(FM1TrapStaticMeshOption, bPairFlip) == 0x000038, "Member 'FM1TrapStaticMeshOption::bPairFlip' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatChangeInventoryLimit
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatChangeInventoryLimit final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatChangeInventoryLimit) == 0x000001, "Wrong alignment on FM1Response_CheatChangeInventoryLimit");
static_assert(sizeof(FM1Response_CheatChangeInventoryLimit) == 0x000001, "Wrong size on FM1Response_CheatChangeInventoryLimit");
static_assert(offsetof(FM1Response_CheatChangeInventoryLimit, Notification) == 0x000000, "Member 'FM1Response_CheatChangeInventoryLimit::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_GetMissionInfo
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_GetMissionInfo final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_GetMissionInfo) == 0x000008, "Wrong alignment on FM1Request_GetMissionInfo");
static_assert(sizeof(FM1Request_GetMissionInfo) == 0x000008, "Wrong size on FM1Request_GetMissionInfo");
static_assert(offsetof(FM1Request_GetMissionInfo, AccountUid) == 0x000000, "Member 'FM1Request_GetMissionInfo::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_SuccessMission
// 0x0028 (0x0028 - 0x0000)
struct FM1Request_SuccessMission final : public FM1Request
{
public:
	struct FM1SuccessMissionRequest               Request;                                           // 0x0000(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_SuccessMission) == 0x000008, "Wrong alignment on FM1Request_SuccessMission");
static_assert(sizeof(FM1Request_SuccessMission) == 0x000028, "Wrong size on FM1Request_SuccessMission");
static_assert(offsetof(FM1Request_SuccessMission, Request) == 0x000000, "Member 'FM1Request_SuccessMission::Request' has a wrong offset!");

// ScriptStruct M1.M1Request_GiveMissionWaveMidResult
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_GiveMissionWaveMidResult final : public FM1Request
{
public:
	struct FM1MissionMidRewardRequest             Request;                                           // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_GiveMissionWaveMidResult) == 0x000008, "Wrong alignment on FM1Request_GiveMissionWaveMidResult");
static_assert(sizeof(FM1Request_GiveMissionWaveMidResult) == 0x000018, "Wrong size on FM1Request_GiveMissionWaveMidResult");
static_assert(offsetof(FM1Request_GiveMissionWaveMidResult, Request) == 0x000000, "Member 'FM1Request_GiveMissionWaveMidResult::Request' has a wrong offset!");

// ScriptStruct M1.M1Request_EndMission
// 0x0028 (0x0028 - 0x0000)
struct FM1Request_EndMission final : public FM1Request
{
public:
	struct FM1MissionRequest                      Request;                                           // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	EM1MissionEndType                             EndType;                                           // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_EndMission) == 0x000008, "Wrong alignment on FM1Request_EndMission");
static_assert(sizeof(FM1Request_EndMission) == 0x000028, "Wrong size on FM1Request_EndMission");
static_assert(offsetof(FM1Request_EndMission, Request) == 0x000000, "Member 'FM1Request_EndMission::Request' has a wrong offset!");
static_assert(offsetof(FM1Request_EndMission, EndType) == 0x000020, "Member 'FM1Request_EndMission::EndType' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatUnlockFieldType
// 0x0020 (0x0020 - 0x0000)
struct FM1Request_CheatUnlockFieldType final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MapTemplateId;                                     // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1MapSubData                          MapSubData;                                        // 0x000C(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_CheatUnlockFieldType) == 0x000008, "Wrong alignment on FM1Request_CheatUnlockFieldType");
static_assert(sizeof(FM1Request_CheatUnlockFieldType) == 0x000020, "Wrong size on FM1Request_CheatUnlockFieldType");
static_assert(offsetof(FM1Request_CheatUnlockFieldType, AccountUid) == 0x000000, "Member 'FM1Request_CheatUnlockFieldType::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatUnlockFieldType, MapTemplateId) == 0x000008, "Member 'FM1Request_CheatUnlockFieldType::MapTemplateId' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatUnlockFieldType, MapSubData) == 0x00000C, "Member 'FM1Request_CheatUnlockFieldType::MapSubData' has a wrong offset!");

// ScriptStruct M1.M1Request_StartQuest
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_StartQuest final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          QuestTid;                                          // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_StartQuest) == 0x000008, "Wrong alignment on FM1Request_StartQuest");
static_assert(sizeof(FM1Request_StartQuest) == 0x000010, "Wrong size on FM1Request_StartQuest");
static_assert(offsetof(FM1Request_StartQuest, AccountUid) == 0x000000, "Member 'FM1Request_StartQuest::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_StartQuest, QuestTid) == 0x000008, "Member 'FM1Request_StartQuest::QuestTid' has a wrong offset!");

// ScriptStruct M1.M1Request_IncQuestProgress
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_IncQuestProgress final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          QuestTid;                                          // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParamIndex;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IncCount;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1QuestType                                  QuestType;                                         // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_IncQuestProgress) == 0x000008, "Wrong alignment on FM1Request_IncQuestProgress");
static_assert(sizeof(FM1Request_IncQuestProgress) == 0x000018, "Wrong size on FM1Request_IncQuestProgress");
static_assert(offsetof(FM1Request_IncQuestProgress, AccountUid) == 0x000000, "Member 'FM1Request_IncQuestProgress::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_IncQuestProgress, QuestTid) == 0x000008, "Member 'FM1Request_IncQuestProgress::QuestTid' has a wrong offset!");
static_assert(offsetof(FM1Request_IncQuestProgress, ParamIndex) == 0x00000C, "Member 'FM1Request_IncQuestProgress::ParamIndex' has a wrong offset!");
static_assert(offsetof(FM1Request_IncQuestProgress, IncCount) == 0x000010, "Member 'FM1Request_IncQuestProgress::IncCount' has a wrong offset!");
static_assert(offsetof(FM1Request_IncQuestProgress, QuestType) == 0x000014, "Member 'FM1Request_IncQuestProgress::QuestType' has a wrong offset!");

// ScriptStruct M1.M1Request_IncQuestProgressMultiple
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_IncQuestProgressMultiple final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1IncQuestProgressReqList             RequestList;                                       // 0x0008(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_IncQuestProgressMultiple) == 0x000008, "Wrong alignment on FM1Request_IncQuestProgressMultiple");
static_assert(sizeof(FM1Request_IncQuestProgressMultiple) == 0x000018, "Wrong size on FM1Request_IncQuestProgressMultiple");
static_assert(offsetof(FM1Request_IncQuestProgressMultiple, AccountUid) == 0x000000, "Member 'FM1Request_IncQuestProgressMultiple::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_IncQuestProgressMultiple, RequestList) == 0x000008, "Member 'FM1Request_IncQuestProgressMultiple::RequestList' has a wrong offset!");

// ScriptStruct M1.M1Request_UnSetQuestTracker
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_UnSetQuestTracker final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          QuestTid;                                          // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_UnSetQuestTracker) == 0x000008, "Wrong alignment on FM1Request_UnSetQuestTracker");
static_assert(sizeof(FM1Request_UnSetQuestTracker) == 0x000010, "Wrong size on FM1Request_UnSetQuestTracker");
static_assert(offsetof(FM1Request_UnSetQuestTracker, AccountUid) == 0x000000, "Member 'FM1Request_UnSetQuestTracker::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_UnSetQuestTracker, QuestTid) == 0x000008, "Member 'FM1Request_UnSetQuestTracker::QuestTid' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatJumpMainQuest
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CheatJumpMainQuest final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          QuestTid;                                          // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_CheatJumpMainQuest) == 0x000008, "Wrong alignment on FM1Request_CheatJumpMainQuest");
static_assert(sizeof(FM1Request_CheatJumpMainQuest) == 0x000010, "Wrong size on FM1Request_CheatJumpMainQuest");
static_assert(offsetof(FM1Request_CheatJumpMainQuest, AccountUid) == 0x000000, "Member 'FM1Request_CheatJumpMainQuest::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatJumpMainQuest, QuestTid) == 0x000008, "Member 'FM1Request_CheatJumpMainQuest::QuestTid' has a wrong offset!");

// ScriptStruct M1.M1Request_MasteryLevelUpRequest
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_MasteryLevelUpRequest final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_MasteryLevelUpRequest) == 0x000008, "Wrong alignment on FM1Request_MasteryLevelUpRequest");
static_assert(sizeof(FM1Request_MasteryLevelUpRequest) == 0x000008, "Wrong size on FM1Request_MasteryLevelUpRequest");
static_assert(offsetof(FM1Request_MasteryLevelUpRequest, AccountUid) == 0x000000, "Member 'FM1Request_MasteryLevelUpRequest::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_GetVoidBattleEntranceInfo
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_GetVoidBattleEntranceInfo final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_GetVoidBattleEntranceInfo) == 0x000008, "Wrong alignment on FM1Request_GetVoidBattleEntranceInfo");
static_assert(sizeof(FM1Request_GetVoidBattleEntranceInfo) == 0x000008, "Wrong size on FM1Request_GetVoidBattleEntranceInfo");
static_assert(offsetof(FM1Request_GetVoidBattleEntranceInfo, AccountUid) == 0x000000, "Member 'FM1Request_GetVoidBattleEntranceInfo::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_RequestMatching
// 0x0080 (0x0080 - 0x0000)
struct FM1Request_RequestMatching final : public FM1Request
{
public:
	struct FM1MatchingAuidList                    AccountUids;                                       // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MapId;                                             // 0x0010(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1MapSubData                          MapSubData;                                        // 0x0014(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1RegionLatencyInfosMs                Req_3;                                             // 0x0028(0x0010)(NativeAccessSpecifierPublic)
	struct FM1MatchingStartAttribute              Req_4;                                             // 0x0038(0x0040)(NativeAccessSpecifierPublic)
	bool                                          IsPrivate;                                         // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_RequestMatching) == 0x000008, "Wrong alignment on FM1Request_RequestMatching");
static_assert(sizeof(FM1Request_RequestMatching) == 0x000080, "Wrong size on FM1Request_RequestMatching");
static_assert(offsetof(FM1Request_RequestMatching, AccountUids) == 0x000000, "Member 'FM1Request_RequestMatching::AccountUids' has a wrong offset!");
static_assert(offsetof(FM1Request_RequestMatching, MapId) == 0x000010, "Member 'FM1Request_RequestMatching::MapId' has a wrong offset!");
static_assert(offsetof(FM1Request_RequestMatching, MapSubData) == 0x000014, "Member 'FM1Request_RequestMatching::MapSubData' has a wrong offset!");
static_assert(offsetof(FM1Request_RequestMatching, Req_3) == 0x000028, "Member 'FM1Request_RequestMatching::Req_3' has a wrong offset!");
static_assert(offsetof(FM1Request_RequestMatching, Req_4) == 0x000038, "Member 'FM1Request_RequestMatching::Req_4' has a wrong offset!");
static_assert(offsetof(FM1Request_RequestMatching, IsPrivate) == 0x000078, "Member 'FM1Request_RequestMatching::IsPrivate' has a wrong offset!");

// ScriptStruct M1.M1Request_MatchedGameStart
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_MatchedGameStart final : public FM1Request
{
public:
	struct FM1AccountList                         AccountList;                                       // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_MatchedGameStart) == 0x000008, "Wrong alignment on FM1Request_MatchedGameStart");
static_assert(sizeof(FM1Request_MatchedGameStart) == 0x000010, "Wrong size on FM1Request_MatchedGameStart");
static_assert(offsetof(FM1Request_MatchedGameStart, AccountList) == 0x000000, "Member 'FM1Request_MatchedGameStart::AccountList' has a wrong offset!");

// ScriptStruct M1.M1Request_InstanceDungeonSelectMODReroll
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_InstanceDungeonSelectMODReroll final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1InstanceDungeonSelectMODRerollRequest Request;                                           // 0x0008(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_InstanceDungeonSelectMODReroll) == 0x000008, "Wrong alignment on FM1Request_InstanceDungeonSelectMODReroll");
static_assert(sizeof(FM1Request_InstanceDungeonSelectMODReroll) == 0x000010, "Wrong size on FM1Request_InstanceDungeonSelectMODReroll");
static_assert(offsetof(FM1Request_InstanceDungeonSelectMODReroll, AccountUid) == 0x000000, "Member 'FM1Request_InstanceDungeonSelectMODReroll::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_InstanceDungeonSelectMODReroll, Request) == 0x000008, "Member 'FM1Request_InstanceDungeonSelectMODReroll::Request' has a wrong offset!");

// ScriptStruct M1.M1Request_GetInvasionEntranceInfo
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_GetInvasionEntranceInfo final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_GetInvasionEntranceInfo) == 0x000008, "Wrong alignment on FM1Request_GetInvasionEntranceInfo");
static_assert(sizeof(FM1Request_GetInvasionEntranceInfo) == 0x000008, "Wrong size on FM1Request_GetInvasionEntranceInfo");
static_assert(offsetof(FM1Request_GetInvasionEntranceInfo, AccountUid) == 0x000000, "Member 'FM1Request_GetInvasionEntranceInfo::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_GetMailList
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_GetMailList final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MailType                                   MailType;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         LastMailId;                                        // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_GetMailList) == 0x000008, "Wrong alignment on FM1Request_GetMailList");
static_assert(sizeof(FM1Request_GetMailList) == 0x000018, "Wrong size on FM1Request_GetMailList");
static_assert(offsetof(FM1Request_GetMailList, AccountUid) == 0x000000, "Member 'FM1Request_GetMailList::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_GetMailList, MailType) == 0x000008, "Member 'FM1Request_GetMailList::MailType' has a wrong offset!");
static_assert(offsetof(FM1Request_GetMailList, LastMailId) == 0x000010, "Member 'FM1Request_GetMailList::LastMailId' has a wrong offset!");

// ScriptStruct M1.M1Request_ReadMail
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_ReadMail final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MailId;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_ReadMail) == 0x000008, "Wrong alignment on FM1Request_ReadMail");
static_assert(sizeof(FM1Request_ReadMail) == 0x000010, "Wrong size on FM1Request_ReadMail");
static_assert(offsetof(FM1Request_ReadMail, AccountUid) == 0x000000, "Member 'FM1Request_ReadMail::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_ReadMail, MailId) == 0x000008, "Member 'FM1Request_ReadMail::MailId' has a wrong offset!");

// ScriptStruct M1.M1Request_ReceiveMailAttachment
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_ReceiveMailAttachment final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MailId;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_ReceiveMailAttachment) == 0x000008, "Wrong alignment on FM1Request_ReceiveMailAttachment");
static_assert(sizeof(FM1Request_ReceiveMailAttachment) == 0x000018, "Wrong size on FM1Request_ReceiveMailAttachment");
static_assert(offsetof(FM1Request_ReceiveMailAttachment, AccountUid) == 0x000000, "Member 'FM1Request_ReceiveMailAttachment::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_ReceiveMailAttachment, MailId) == 0x000008, "Member 'FM1Request_ReceiveMailAttachment::MailId' has a wrong offset!");
static_assert(offsetof(FM1Request_ReceiveMailAttachment, Index) == 0x000010, "Member 'FM1Request_ReceiveMailAttachment::Index' has a wrong offset!");

// ScriptStruct M1.M1Request_SendMailForCheat2
// 0x0048 (0x0048 - 0x0000)
struct FM1Request_SendMailForCheat2 final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MailType                                   MailType;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1Locale                                     Locale;                                            // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Sender;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Content;                                           // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Minutes;                                           // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          DropGroupTemplateId;                               // 0x0044(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_SendMailForCheat2) == 0x000008, "Wrong alignment on FM1Request_SendMailForCheat2");
static_assert(sizeof(FM1Request_SendMailForCheat2) == 0x000048, "Wrong size on FM1Request_SendMailForCheat2");
static_assert(offsetof(FM1Request_SendMailForCheat2, AccountUid) == 0x000000, "Member 'FM1Request_SendMailForCheat2::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_SendMailForCheat2, MailType) == 0x000008, "Member 'FM1Request_SendMailForCheat2::MailType' has a wrong offset!");
static_assert(offsetof(FM1Request_SendMailForCheat2, Locale) == 0x000009, "Member 'FM1Request_SendMailForCheat2::Locale' has a wrong offset!");
static_assert(offsetof(FM1Request_SendMailForCheat2, Sender) == 0x000010, "Member 'FM1Request_SendMailForCheat2::Sender' has a wrong offset!");
static_assert(offsetof(FM1Request_SendMailForCheat2, Title) == 0x000020, "Member 'FM1Request_SendMailForCheat2::Title' has a wrong offset!");
static_assert(offsetof(FM1Request_SendMailForCheat2, Content) == 0x000030, "Member 'FM1Request_SendMailForCheat2::Content' has a wrong offset!");
static_assert(offsetof(FM1Request_SendMailForCheat2, Minutes) == 0x000040, "Member 'FM1Request_SendMailForCheat2::Minutes' has a wrong offset!");
static_assert(offsetof(FM1Request_SendMailForCheat2, DropGroupTemplateId) == 0x000044, "Member 'FM1Request_SendMailForCheat2::DropGroupTemplateId' has a wrong offset!");

// ScriptStruct M1.M1NormalMonsterHitReactionData
// 0x0058 (0x0058 - 0x0000)
struct FM1NormalMonsterHitReactionData final
{
public:
	bool                                          bHitStopData;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PartsName;                                         // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           BoneNames;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimSequence*                          FrontAnim;                                         // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BackAnim;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  HitStopAnims;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bFront;                                            // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ContinuousPlayCount;                               // 0x0044(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0048(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandomHitStopAnimIndex;                            // 0x004C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitStopReset;                                      // 0x0050(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1NormalMonsterHitReactionData) == 0x000008, "Wrong alignment on FM1NormalMonsterHitReactionData");
static_assert(sizeof(FM1NormalMonsterHitReactionData) == 0x000058, "Wrong size on FM1NormalMonsterHitReactionData");
static_assert(offsetof(FM1NormalMonsterHitReactionData, bHitStopData) == 0x000000, "Member 'FM1NormalMonsterHitReactionData::bHitStopData' has a wrong offset!");
static_assert(offsetof(FM1NormalMonsterHitReactionData, PartsName) == 0x000004, "Member 'FM1NormalMonsterHitReactionData::PartsName' has a wrong offset!");
static_assert(offsetof(FM1NormalMonsterHitReactionData, BoneNames) == 0x000010, "Member 'FM1NormalMonsterHitReactionData::BoneNames' has a wrong offset!");
static_assert(offsetof(FM1NormalMonsterHitReactionData, FrontAnim) == 0x000020, "Member 'FM1NormalMonsterHitReactionData::FrontAnim' has a wrong offset!");
static_assert(offsetof(FM1NormalMonsterHitReactionData, BackAnim) == 0x000028, "Member 'FM1NormalMonsterHitReactionData::BackAnim' has a wrong offset!");
static_assert(offsetof(FM1NormalMonsterHitReactionData, HitStopAnims) == 0x000030, "Member 'FM1NormalMonsterHitReactionData::HitStopAnims' has a wrong offset!");
static_assert(offsetof(FM1NormalMonsterHitReactionData, bFront) == 0x000040, "Member 'FM1NormalMonsterHitReactionData::bFront' has a wrong offset!");
static_assert(offsetof(FM1NormalMonsterHitReactionData, ContinuousPlayCount) == 0x000044, "Member 'FM1NormalMonsterHitReactionData::ContinuousPlayCount' has a wrong offset!");
static_assert(offsetof(FM1NormalMonsterHitReactionData, Damage) == 0x000048, "Member 'FM1NormalMonsterHitReactionData::Damage' has a wrong offset!");
static_assert(offsetof(FM1NormalMonsterHitReactionData, RandomHitStopAnimIndex) == 0x00004C, "Member 'FM1NormalMonsterHitReactionData::RandomHitStopAnimIndex' has a wrong offset!");
static_assert(offsetof(FM1NormalMonsterHitReactionData, HitStopReset) == 0x000050, "Member 'FM1NormalMonsterHitReactionData::HitStopReset' has a wrong offset!");

// ScriptStruct M1.M1Request_ReceiveMailAttachmentAll
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_ReceiveMailAttachmentAll final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MailId;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_ReceiveMailAttachmentAll) == 0x000008, "Wrong alignment on FM1Request_ReceiveMailAttachmentAll");
static_assert(sizeof(FM1Request_ReceiveMailAttachmentAll) == 0x000010, "Wrong size on FM1Request_ReceiveMailAttachmentAll");
static_assert(offsetof(FM1Request_ReceiveMailAttachmentAll, AccountUid) == 0x000000, "Member 'FM1Request_ReceiveMailAttachmentAll::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_ReceiveMailAttachmentAll, MailId) == 0x000008, "Member 'FM1Request_ReceiveMailAttachmentAll::MailId' has a wrong offset!");

// ScriptStruct M1.M1Request_ReceiveMultipleMailAttachment
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_ReceiveMultipleMailAttachment final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1MailMultiRequestInfo                MultiMailRequest;                                  // 0x0008(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_ReceiveMultipleMailAttachment) == 0x000008, "Wrong alignment on FM1Request_ReceiveMultipleMailAttachment");
static_assert(sizeof(FM1Request_ReceiveMultipleMailAttachment) == 0x000018, "Wrong size on FM1Request_ReceiveMultipleMailAttachment");
static_assert(offsetof(FM1Request_ReceiveMultipleMailAttachment, AccountUid) == 0x000000, "Member 'FM1Request_ReceiveMultipleMailAttachment::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_ReceiveMultipleMailAttachment, MultiMailRequest) == 0x000008, "Member 'FM1Request_ReceiveMultipleMailAttachment::MultiMailRequest' has a wrong offset!");

// ScriptStruct M1.M1Request_CustomizingWeapon
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CustomizingWeapon final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1RequestCustomizingWeapon            Request;                                           // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CustomizingWeapon) == 0x000008, "Wrong alignment on FM1Request_CustomizingWeapon");
static_assert(sizeof(FM1Request_CustomizingWeapon) == 0x000010, "Wrong size on FM1Request_CustomizingWeapon");
static_assert(offsetof(FM1Request_CustomizingWeapon, AccountUid) == 0x000000, "Member 'FM1Request_CustomizingWeapon::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CustomizingWeapon, Request) == 0x000008, "Member 'FM1Request_CustomizingWeapon::Request' has a wrong offset!");

// ScriptStruct M1.M1Request_CustomizingSkinPaints
// 0x0020 (0x0020 - 0x0000)
struct FM1Request_CustomizingSkinPaints final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1RequestCustomizingSkinPaints        Request;                                           // 0x0008(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CustomizingSkinPaints) == 0x000008, "Wrong alignment on FM1Request_CustomizingSkinPaints");
static_assert(sizeof(FM1Request_CustomizingSkinPaints) == 0x000020, "Wrong size on FM1Request_CustomizingSkinPaints");
static_assert(offsetof(FM1Request_CustomizingSkinPaints, AccountUid) == 0x000000, "Member 'FM1Request_CustomizingSkinPaints::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CustomizingSkinPaints, Request) == 0x000008, "Member 'FM1Request_CustomizingSkinPaints::Request' has a wrong offset!");

// ScriptStruct M1.M1Request_CustomizingEtc
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CustomizingEtc final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1RequestCustomizingEtc               Request;                                           // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CustomizingEtc) == 0x000008, "Wrong alignment on FM1Request_CustomizingEtc");
static_assert(sizeof(FM1Request_CustomizingEtc) == 0x000010, "Wrong size on FM1Request_CustomizingEtc");
static_assert(offsetof(FM1Request_CustomizingEtc, AccountUid) == 0x000000, "Member 'FM1Request_CustomizingEtc::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CustomizingEtc, Request) == 0x000008, "Member 'FM1Request_CustomizingEtc::Request' has a wrong offset!");

// ScriptStruct M1.M1Request_UncustomizingCharacter
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_UncustomizingCharacter final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1RequestCustomizingCharacter         Request;                                           // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_UncustomizingCharacter) == 0x000008, "Wrong alignment on FM1Request_UncustomizingCharacter");
static_assert(sizeof(FM1Request_UncustomizingCharacter) == 0x000010, "Wrong size on FM1Request_UncustomizingCharacter");
static_assert(offsetof(FM1Request_UncustomizingCharacter, AccountUid) == 0x000000, "Member 'FM1Request_UncustomizingCharacter::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_UncustomizingCharacter, Request) == 0x000008, "Member 'FM1Request_UncustomizingCharacter::Request' has a wrong offset!");

// ScriptStruct M1.M1Request_UncustomizingSkinPaint
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_UncustomizingSkinPaint final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1RequestCustomizingSkinPaint         Request;                                           // 0x0008(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_UncustomizingSkinPaint) == 0x000008, "Wrong alignment on FM1Request_UncustomizingSkinPaint");
static_assert(sizeof(FM1Request_UncustomizingSkinPaint) == 0x000018, "Wrong size on FM1Request_UncustomizingSkinPaint");
static_assert(offsetof(FM1Request_UncustomizingSkinPaint, AccountUid) == 0x000000, "Member 'FM1Request_UncustomizingSkinPaint::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_UncustomizingSkinPaint, Request) == 0x000008, "Member 'FM1Request_UncustomizingSkinPaint::Request' has a wrong offset!");

// ScriptStruct M1.M1Request_UncustomizingEtc
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_UncustomizingEtc final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1RequestCustomizingEtc               Request;                                           // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_UncustomizingEtc) == 0x000008, "Wrong alignment on FM1Request_UncustomizingEtc");
static_assert(sizeof(FM1Request_UncustomizingEtc) == 0x000010, "Wrong size on FM1Request_UncustomizingEtc");
static_assert(offsetof(FM1Request_UncustomizingEtc, AccountUid) == 0x000000, "Member 'FM1Request_UncustomizingEtc::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_UncustomizingEtc, Request) == 0x000008, "Member 'FM1Request_UncustomizingEtc::Request' has a wrong offset!");

// ScriptStruct M1.M1Request_CustomizingEvolutionChange
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CustomizingEvolutionChange final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1RequestCustomizingEvolution         Request;                                           // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_CustomizingEvolutionChange) == 0x000008, "Wrong alignment on FM1Request_CustomizingEvolutionChange");
static_assert(sizeof(FM1Request_CustomizingEvolutionChange) == 0x000010, "Wrong size on FM1Request_CustomizingEvolutionChange");
static_assert(offsetof(FM1Request_CustomizingEvolutionChange, AccountUid) == 0x000000, "Member 'FM1Request_CustomizingEvolutionChange::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CustomizingEvolutionChange, Request) == 0x000008, "Member 'FM1Request_CustomizingEvolutionChange::Request' has a wrong offset!");

// ScriptStruct M1.M1Request_OpenPackageItem
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_OpenPackageItem final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          PackageOpenerTid;                                  // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          PackageItemTid;                                    // 0x000C(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          KeyItemTid;                                        // 0x0010(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_OpenPackageItem) == 0x000008, "Wrong alignment on FM1Request_OpenPackageItem");
static_assert(sizeof(FM1Request_OpenPackageItem) == 0x000018, "Wrong size on FM1Request_OpenPackageItem");
static_assert(offsetof(FM1Request_OpenPackageItem, AccountUid) == 0x000000, "Member 'FM1Request_OpenPackageItem::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_OpenPackageItem, PackageOpenerTid) == 0x000008, "Member 'FM1Request_OpenPackageItem::PackageOpenerTid' has a wrong offset!");
static_assert(offsetof(FM1Request_OpenPackageItem, PackageItemTid) == 0x00000C, "Member 'FM1Request_OpenPackageItem::PackageItemTid' has a wrong offset!");
static_assert(offsetof(FM1Request_OpenPackageItem, KeyItemTid) == 0x000010, "Member 'FM1Request_OpenPackageItem::KeyItemTid' has a wrong offset!");

// ScriptStruct M1.M1Request_PerkEnchant
// 0x0030 (0x0030 - 0x0000)
struct FM1Request_PerkEnchant final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemUidBox                          ItemUid;                                           // 0x0008(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1ItemUidBox                          ResourceItemUid;                                   // 0x0018(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          Perk;                                              // 0x0028(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_PerkEnchant) == 0x000008, "Wrong alignment on FM1Request_PerkEnchant");
static_assert(sizeof(FM1Request_PerkEnchant) == 0x000030, "Wrong size on FM1Request_PerkEnchant");
static_assert(offsetof(FM1Request_PerkEnchant, AccountUid) == 0x000000, "Member 'FM1Request_PerkEnchant::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_PerkEnchant, ItemUid) == 0x000008, "Member 'FM1Request_PerkEnchant::ItemUid' has a wrong offset!");
static_assert(offsetof(FM1Request_PerkEnchant, ResourceItemUid) == 0x000018, "Member 'FM1Request_PerkEnchant::ResourceItemUid' has a wrong offset!");
static_assert(offsetof(FM1Request_PerkEnchant, Perk) == 0x000028, "Member 'FM1Request_PerkEnchant::Perk' has a wrong offset!");

// ScriptStruct M1.M1Request_SavePlatformAchievementData
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_SavePlatformAchievementData final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          AchievementId;                                     // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ContentsPlatformType                       PlatformType;                                      // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_SavePlatformAchievementData) == 0x000008, "Wrong alignment on FM1Request_SavePlatformAchievementData");
static_assert(sizeof(FM1Request_SavePlatformAchievementData) == 0x000010, "Wrong size on FM1Request_SavePlatformAchievementData");
static_assert(offsetof(FM1Request_SavePlatformAchievementData, AccountUid) == 0x000000, "Member 'FM1Request_SavePlatformAchievementData::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_SavePlatformAchievementData, AchievementId) == 0x000008, "Member 'FM1Request_SavePlatformAchievementData::AchievementId' has a wrong offset!");
static_assert(offsetof(FM1Request_SavePlatformAchievementData, PlatformType) == 0x00000C, "Member 'FM1Request_SavePlatformAchievementData::PlatformType' has a wrong offset!");

// ScriptStruct M1.M1NavTile
// 0x0068 (0x0068 - 0x0000)
struct FM1NavTile final
{
public:
	TSet<uint64>                                  PolyRefs;                                          // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	bool                                          bEnableNav;                                        // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PolyCount;                                         // 0x0054(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetViewTarget;                                    // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DirtyAreaIndex;                                    // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InvasionAreaIndex;                                 // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1NavTile) == 0x000008, "Wrong alignment on FM1NavTile");
static_assert(sizeof(FM1NavTile) == 0x000068, "Wrong size on FM1NavTile");
static_assert(offsetof(FM1NavTile, PolyRefs) == 0x000000, "Member 'FM1NavTile::PolyRefs' has a wrong offset!");
static_assert(offsetof(FM1NavTile, bEnableNav) == 0x000050, "Member 'FM1NavTile::bEnableNav' has a wrong offset!");
static_assert(offsetof(FM1NavTile, PolyCount) == 0x000054, "Member 'FM1NavTile::PolyCount' has a wrong offset!");
static_assert(offsetof(FM1NavTile, bSetViewTarget) == 0x000058, "Member 'FM1NavTile::bSetViewTarget' has a wrong offset!");
static_assert(offsetof(FM1NavTile, DirtyAreaIndex) == 0x00005C, "Member 'FM1NavTile::DirtyAreaIndex' has a wrong offset!");
static_assert(offsetof(FM1NavTile, InvasionAreaIndex) == 0x000060, "Member 'FM1NavTile::InvasionAreaIndex' has a wrong offset!");

// ScriptStruct M1.M1Request_BattlePassCompile
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_BattlePassCompile final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_BattlePassCompile) == 0x000008, "Wrong alignment on FM1Request_BattlePassCompile");
static_assert(sizeof(FM1Request_BattlePassCompile) == 0x000008, "Wrong size on FM1Request_BattlePassCompile");
static_assert(offsetof(FM1Request_BattlePassCompile, AccountUid) == 0x000000, "Member 'FM1Request_BattlePassCompile::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_RequestBattlePassLevelUp
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_RequestBattlePassLevelUp final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BundleBuy;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_RequestBattlePassLevelUp) == 0x000008, "Wrong alignment on FM1Request_RequestBattlePassLevelUp");
static_assert(sizeof(FM1Request_RequestBattlePassLevelUp) == 0x000010, "Wrong size on FM1Request_RequestBattlePassLevelUp");
static_assert(offsetof(FM1Request_RequestBattlePassLevelUp, AccountUid) == 0x000000, "Member 'FM1Request_RequestBattlePassLevelUp::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_RequestBattlePassLevelUp, BundleBuy) == 0x000008, "Member 'FM1Request_RequestBattlePassLevelUp::BundleBuy' has a wrong offset!");
static_assert(offsetof(FM1Request_RequestBattlePassLevelUp, Count) == 0x00000C, "Member 'FM1Request_RequestBattlePassLevelUp::Count' has a wrong offset!");

// ScriptStruct M1.M1Request_BattlePassReset
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_BattlePassReset final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          BattlePassTid;                                     // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_BattlePassReset) == 0x000008, "Wrong alignment on FM1Request_BattlePassReset");
static_assert(sizeof(FM1Request_BattlePassReset) == 0x000010, "Wrong size on FM1Request_BattlePassReset");
static_assert(offsetof(FM1Request_BattlePassReset, AccountUid) == 0x000000, "Member 'FM1Request_BattlePassReset::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_BattlePassReset, BattlePassTid) == 0x000008, "Member 'FM1Request_BattlePassReset::BattlePassTid' has a wrong offset!");

// ScriptStruct M1.M1Request_GetTitleItemInvenvory
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_GetTitleItemInvenvory final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_GetTitleItemInvenvory) == 0x000008, "Wrong alignment on FM1Request_GetTitleItemInvenvory");
static_assert(sizeof(FM1Request_GetTitleItemInvenvory) == 0x000008, "Wrong size on FM1Request_GetTitleItemInvenvory");
static_assert(offsetof(FM1Request_GetTitleItemInvenvory, AccountUid) == 0x000000, "Member 'FM1Request_GetTitleItemInvenvory::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_GetCodexDataList
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_GetCodexDataList final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_GetCodexDataList) == 0x000008, "Wrong alignment on FM1Request_GetCodexDataList");
static_assert(sizeof(FM1Request_GetCodexDataList) == 0x000008, "Wrong size on FM1Request_GetCodexDataList");
static_assert(offsetof(FM1Request_GetCodexDataList, AccountUid) == 0x000000, "Member 'FM1Request_GetCodexDataList::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_UnSetCodexTracker
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_UnSetCodexTracker final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          SlotIndex;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_UnSetCodexTracker) == 0x000008, "Wrong alignment on FM1Request_UnSetCodexTracker");
static_assert(sizeof(FM1Request_UnSetCodexTracker) == 0x000010, "Wrong size on FM1Request_UnSetCodexTracker");
static_assert(offsetof(FM1Request_UnSetCodexTracker, AccountUid) == 0x000000, "Member 'FM1Request_UnSetCodexTracker::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_UnSetCodexTracker, SlotIndex) == 0x000008, "Member 'FM1Request_UnSetCodexTracker::SlotIndex' has a wrong offset!");

// ScriptStruct M1.M1Request_RequestSupport
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_RequestSupport final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MissionTid;                                        // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheatAllMaps;                                      // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_RequestSupport) == 0x000008, "Wrong alignment on FM1Request_RequestSupport");
static_assert(sizeof(FM1Request_RequestSupport) == 0x000010, "Wrong size on FM1Request_RequestSupport");
static_assert(offsetof(FM1Request_RequestSupport, AccountUid) == 0x000000, "Member 'FM1Request_RequestSupport::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_RequestSupport, MissionTid) == 0x000008, "Member 'FM1Request_RequestSupport::MissionTid' has a wrong offset!");
static_assert(offsetof(FM1Request_RequestSupport, CheatAllMaps) == 0x00000C, "Member 'FM1Request_RequestSupport::CheatAllMaps' has a wrong offset!");

// ScriptStruct M1.M1RegionLatencyInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1RegionLatencyInfo final
{
public:
	class FString                                 RegionName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RegionLatency;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RegionLatencyInfo) == 0x000008, "Wrong alignment on FM1RegionLatencyInfo");
static_assert(sizeof(FM1RegionLatencyInfo) == 0x000018, "Wrong size on FM1RegionLatencyInfo");
static_assert(offsetof(FM1RegionLatencyInfo, RegionName) == 0x000000, "Member 'FM1RegionLatencyInfo::RegionName' has a wrong offset!");
static_assert(offsetof(FM1RegionLatencyInfo, RegionLatency) == 0x000010, "Member 'FM1RegionLatencyInfo::RegionLatency' has a wrong offset!");

// ScriptStruct M1.M1Request_InitShop
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_InitShop final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_InitShop) == 0x000008, "Wrong alignment on FM1Request_InitShop");
static_assert(sizeof(FM1Request_InitShop) == 0x000008, "Wrong size on FM1Request_InitShop");
static_assert(offsetof(FM1Request_InitShop, AccountUid) == 0x000000, "Member 'FM1Request_InitShop::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_GetPresetInfoBundle
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_GetPresetInfoBundle final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_GetPresetInfoBundle) == 0x000008, "Wrong alignment on FM1Request_GetPresetInfoBundle");
static_assert(sizeof(FM1Request_GetPresetInfoBundle) == 0x000008, "Wrong size on FM1Request_GetPresetInfoBundle");
static_assert(offsetof(FM1Request_GetPresetInfoBundle, AccountUid) == 0x000000, "Member 'FM1Request_GetPresetInfoBundle::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_ChangePresetName
// 0x0030 (0x0030 - 0x0000)
struct FM1Request_ChangePresetName final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PresetIndex;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Language;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_ChangePresetName) == 0x000008, "Wrong alignment on FM1Request_ChangePresetName");
static_assert(sizeof(FM1Request_ChangePresetName) == 0x000030, "Wrong size on FM1Request_ChangePresetName");
static_assert(offsetof(FM1Request_ChangePresetName, AccountUid) == 0x000000, "Member 'FM1Request_ChangePresetName::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_ChangePresetName, PresetIndex) == 0x000008, "Member 'FM1Request_ChangePresetName::PresetIndex' has a wrong offset!");
static_assert(offsetof(FM1Request_ChangePresetName, Language) == 0x000010, "Member 'FM1Request_ChangePresetName::Language' has a wrong offset!");
static_assert(offsetof(FM1Request_ChangePresetName, Name) == 0x000020, "Member 'FM1Request_ChangePresetName::Name' has a wrong offset!");

// ScriptStruct M1.M1Request_ApplyPreset
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_ApplyPreset final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PresetIndex;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_ApplyPreset) == 0x000008, "Wrong alignment on FM1Request_ApplyPreset");
static_assert(sizeof(FM1Request_ApplyPreset) == 0x000010, "Wrong size on FM1Request_ApplyPreset");
static_assert(offsetof(FM1Request_ApplyPreset, AccountUid) == 0x000000, "Member 'FM1Request_ApplyPreset::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_ApplyPreset, PresetIndex) == 0x000008, "Member 'FM1Request_ApplyPreset::PresetIndex' has a wrong offset!");

// ScriptStruct M1.M1Request_Login
// 0x0040 (0x0040 - 0x0000)
struct FM1Request_Login final : public FM1Request
{
public:
	class FString                                 LoginId;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameLanguage;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ExternalLinkerType                         ExternalLinkerType;                                // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ExternalLinkerData;                                // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreator;                                          // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_Login) == 0x000008, "Wrong alignment on FM1Request_Login");
static_assert(sizeof(FM1Request_Login) == 0x000040, "Wrong size on FM1Request_Login");
static_assert(offsetof(FM1Request_Login, LoginId) == 0x000000, "Member 'FM1Request_Login::LoginId' has a wrong offset!");
static_assert(offsetof(FM1Request_Login, GameLanguage) == 0x000010, "Member 'FM1Request_Login::GameLanguage' has a wrong offset!");
static_assert(offsetof(FM1Request_Login, ExternalLinkerType) == 0x000020, "Member 'FM1Request_Login::ExternalLinkerType' has a wrong offset!");
static_assert(offsetof(FM1Request_Login, ExternalLinkerData) == 0x000028, "Member 'FM1Request_Login::ExternalLinkerData' has a wrong offset!");
static_assert(offsetof(FM1Request_Login, bCreator) == 0x000038, "Member 'FM1Request_Login::bCreator' has a wrong offset!");

// ScriptStruct M1.M1Request_TryUnlockReinforce
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_TryUnlockReinforce final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroupIndex;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_TryUnlockReinforce) == 0x000008, "Wrong alignment on FM1Request_TryUnlockReinforce");
static_assert(sizeof(FM1Request_TryUnlockReinforce) == 0x000010, "Wrong size on FM1Request_TryUnlockReinforce");
static_assert(offsetof(FM1Request_TryUnlockReinforce, AccountUid) == 0x000000, "Member 'FM1Request_TryUnlockReinforce::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_TryUnlockReinforce, GroupIndex) == 0x000008, "Member 'FM1Request_TryUnlockReinforce::GroupIndex' has a wrong offset!");
static_assert(offsetof(FM1Request_TryUnlockReinforce, SlotIndex) == 0x00000C, "Member 'FM1Request_TryUnlockReinforce::SlotIndex' has a wrong offset!");

// ScriptStruct M1.M1PlayerSprinted
// 0x0008 (0x0028 - 0x0020)
struct FM1PlayerSprinted final : public FM1Statistics
{
public:
	float                                         ElaspedTimeSeconds;                                // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PlayerSprinted) == 0x000008, "Wrong alignment on FM1PlayerSprinted");
static_assert(sizeof(FM1PlayerSprinted) == 0x000028, "Wrong size on FM1PlayerSprinted");
static_assert(offsetof(FM1PlayerSprinted, ElaspedTimeSeconds) == 0x000020, "Member 'FM1PlayerSprinted::ElaspedTimeSeconds' has a wrong offset!");

// ScriptStruct M1.M1Request_TryEquipReinforce
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_TryEquipReinforce final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroupIndex;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquip;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_TryEquipReinforce) == 0x000008, "Wrong alignment on FM1Request_TryEquipReinforce");
static_assert(sizeof(FM1Request_TryEquipReinforce) == 0x000018, "Wrong size on FM1Request_TryEquipReinforce");
static_assert(offsetof(FM1Request_TryEquipReinforce, AccountUid) == 0x000000, "Member 'FM1Request_TryEquipReinforce::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_TryEquipReinforce, GroupIndex) == 0x000008, "Member 'FM1Request_TryEquipReinforce::GroupIndex' has a wrong offset!");
static_assert(offsetof(FM1Request_TryEquipReinforce, SlotIndex) == 0x00000C, "Member 'FM1Request_TryEquipReinforce::SlotIndex' has a wrong offset!");
static_assert(offsetof(FM1Request_TryEquipReinforce, bEquip) == 0x000010, "Member 'FM1Request_TryEquipReinforce::bEquip' has a wrong offset!");

// ScriptStruct M1.M1Request_ClearReinforce
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_ClearReinforce final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_ClearReinforce) == 0x000008, "Wrong alignment on FM1Request_ClearReinforce");
static_assert(sizeof(FM1Request_ClearReinforce) == 0x000008, "Wrong size on FM1Request_ClearReinforce");
static_assert(offsetof(FM1Request_ClearReinforce, AccountUid) == 0x000000, "Member 'FM1Request_ClearReinforce::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1Request_CheatClearSeasonLevel
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_CheatClearSeasonLevel final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SessionTid;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_CheatClearSeasonLevel) == 0x000008, "Wrong alignment on FM1Request_CheatClearSeasonLevel");
static_assert(sizeof(FM1Request_CheatClearSeasonLevel) == 0x000010, "Wrong size on FM1Request_CheatClearSeasonLevel");
static_assert(offsetof(FM1Request_CheatClearSeasonLevel, AccountUid) == 0x000000, "Member 'FM1Request_CheatClearSeasonLevel::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_CheatClearSeasonLevel, SessionTid) == 0x000008, "Member 'FM1Request_CheatClearSeasonLevel::SessionTid' has a wrong offset!");

// ScriptStruct M1.M1Response_WearEquipment
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_WearEquipment final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_WearEquipment) == 0x000001, "Wrong alignment on FM1Response_WearEquipment");
static_assert(sizeof(FM1Response_WearEquipment) == 0x000001, "Wrong size on FM1Response_WearEquipment");
static_assert(offsetof(FM1Response_WearEquipment, Notification) == 0x000000, "Member 'FM1Response_WearEquipment::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_TakeOffEquipment
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_TakeOffEquipment final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_TakeOffEquipment) == 0x000001, "Wrong alignment on FM1Response_TakeOffEquipment");
static_assert(sizeof(FM1Response_TakeOffEquipment) == 0x000001, "Wrong size on FM1Response_TakeOffEquipment");
static_assert(offsetof(FM1Response_TakeOffEquipment, Notification) == 0x000000, "Member 'FM1Response_TakeOffEquipment::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_SetItemTagsWithByte
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_SetItemTagsWithByte final
{
public:
	EM1ItemReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_SetItemTagsWithByte) == 0x000004, "Wrong alignment on FM1Response_SetItemTagsWithByte");
static_assert(sizeof(FM1Response_SetItemTagsWithByte) == 0x000004, "Wrong size on FM1Response_SetItemTagsWithByte");
static_assert(offsetof(FM1Response_SetItemTagsWithByte, Notification) == 0x000000, "Member 'FM1Response_SetItemTagsWithByte::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_MoveEquipmentToWareHouse
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_MoveEquipmentToWareHouse final
{
public:
	EM1ItemReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_MoveEquipmentToWareHouse) == 0x000004, "Wrong alignment on FM1Response_MoveEquipmentToWareHouse");
static_assert(sizeof(FM1Response_MoveEquipmentToWareHouse) == 0x000004, "Wrong size on FM1Response_MoveEquipmentToWareHouse");
static_assert(offsetof(FM1Response_MoveEquipmentToWareHouse, Notification) == 0x000000, "Member 'FM1Response_MoveEquipmentToWareHouse::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_GetInventoryRevision
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_GetInventoryRevision final
{
public:
	int32                                         Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_GetInventoryRevision) == 0x000004, "Wrong alignment on FM1Response_GetInventoryRevision");
static_assert(sizeof(FM1Response_GetInventoryRevision) == 0x000004, "Wrong size on FM1Response_GetInventoryRevision");
static_assert(offsetof(FM1Response_GetInventoryRevision, Notification) == 0x000000, "Member 'FM1Response_GetInventoryRevision::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatAddTime
// 0x0008 (0x0008 - 0x0000)
struct FM1Response_CheatAddTime final
{
public:
	int64                                         Notification;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatAddTime) == 0x000008, "Wrong alignment on FM1Response_CheatAddTime");
static_assert(sizeof(FM1Response_CheatAddTime) == 0x000008, "Wrong size on FM1Response_CheatAddTime");
static_assert(offsetof(FM1Response_CheatAddTime, Notification) == 0x000000, "Member 'FM1Response_CheatAddTime::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatAdjustValue
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatAdjustValue final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatAdjustValue) == 0x000001, "Wrong alignment on FM1Response_CheatAdjustValue");
static_assert(sizeof(FM1Response_CheatAdjustValue) == 0x000001, "Wrong size on FM1Response_CheatAdjustValue");
static_assert(offsetof(FM1Response_CheatAdjustValue, Notification) == 0x000000, "Member 'FM1Response_CheatAdjustValue::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatStatAdjustReset
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatStatAdjustReset final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatStatAdjustReset) == 0x000001, "Wrong alignment on FM1Response_CheatStatAdjustReset");
static_assert(sizeof(FM1Response_CheatStatAdjustReset) == 0x000001, "Wrong size on FM1Response_CheatStatAdjustReset");
static_assert(offsetof(FM1Response_CheatStatAdjustReset, Notification) == 0x000000, "Member 'FM1Response_CheatStatAdjustReset::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatCustomizingEvolution
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatCustomizingEvolution final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatCustomizingEvolution) == 0x000001, "Wrong alignment on FM1Response_CheatCustomizingEvolution");
static_assert(sizeof(FM1Response_CheatCustomizingEvolution) == 0x000001, "Wrong size on FM1Response_CheatCustomizingEvolution");
static_assert(offsetof(FM1Response_CheatCustomizingEvolution, Notification) == 0x000000, "Member 'FM1Response_CheatCustomizingEvolution::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatProhibitGetCharacterExp
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatProhibitGetCharacterExp final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatProhibitGetCharacterExp) == 0x000001, "Wrong alignment on FM1Response_CheatProhibitGetCharacterExp");
static_assert(sizeof(FM1Response_CheatProhibitGetCharacterExp) == 0x000001, "Wrong size on FM1Response_CheatProhibitGetCharacterExp");
static_assert(offsetof(FM1Response_CheatProhibitGetCharacterExp, Notification) == 0x000000, "Member 'FM1Response_CheatProhibitGetCharacterExp::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatCreateItemCompilation
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatCreateItemCompilation final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatCreateItemCompilation) == 0x000001, "Wrong alignment on FM1Response_CheatCreateItemCompilation");
static_assert(sizeof(FM1Response_CheatCreateItemCompilation) == 0x000001, "Wrong size on FM1Response_CheatCreateItemCompilation");
static_assert(offsetof(FM1Response_CheatCreateItemCompilation, Notification) == 0x000000, "Member 'FM1Response_CheatCreateItemCompilation::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatCreateBulkCharacter
// 0x0030 (0x0030 - 0x0000)
struct FM1Response_CheatCreateBulkCharacter final
{
public:
	struct FM1CheatCreateCharacterRes             Notification;                                      // 0x0000(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatCreateBulkCharacter) == 0x000008, "Wrong alignment on FM1Response_CheatCreateBulkCharacter");
static_assert(sizeof(FM1Response_CheatCreateBulkCharacter) == 0x000030, "Wrong size on FM1Response_CheatCreateBulkCharacter");
static_assert(offsetof(FM1Response_CheatCreateBulkCharacter, Notification) == 0x000000, "Member 'FM1Response_CheatCreateBulkCharacter::Notification' has a wrong offset!");

// ScriptStruct M1.M1DropItemInfo
// 0x0030 (0x0030 - 0x0000)
struct FM1DropItemInfo final
{
public:
	bool                                          bPublicItem;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ItemOwner;                                         // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Count;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemTidBox                          ItemBox;                                           // 0x0014(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ItemOid;                                           // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MonsterUid;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DropItemInfo) == 0x000008, "Wrong alignment on FM1DropItemInfo");
static_assert(sizeof(FM1DropItemInfo) == 0x000030, "Wrong size on FM1DropItemInfo");
static_assert(offsetof(FM1DropItemInfo, bPublicItem) == 0x000000, "Member 'FM1DropItemInfo::bPublicItem' has a wrong offset!");
static_assert(offsetof(FM1DropItemInfo, ItemOwner) == 0x000008, "Member 'FM1DropItemInfo::ItemOwner' has a wrong offset!");
static_assert(offsetof(FM1DropItemInfo, Count) == 0x000010, "Member 'FM1DropItemInfo::Count' has a wrong offset!");
static_assert(offsetof(FM1DropItemInfo, ItemBox) == 0x000014, "Member 'FM1DropItemInfo::ItemBox' has a wrong offset!");
static_assert(offsetof(FM1DropItemInfo, ItemOid) == 0x000020, "Member 'FM1DropItemInfo::ItemOid' has a wrong offset!");
static_assert(offsetof(FM1DropItemInfo, MonsterUid) == 0x000028, "Member 'FM1DropItemInfo::MonsterUid' has a wrong offset!");

// ScriptStruct M1.M1DropItemInfoList
// 0x0010 (0x0010 - 0x0000)
struct FM1DropItemInfoList final
{
public:
	TArray<struct FM1DropItemInfo>                DropItemInfos;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DropItemInfoList) == 0x000008, "Wrong alignment on FM1DropItemInfoList");
static_assert(sizeof(FM1DropItemInfoList) == 0x000010, "Wrong size on FM1DropItemInfoList");
static_assert(offsetof(FM1DropItemInfoList, DropItemInfos) == 0x000000, "Member 'FM1DropItemInfoList::DropItemInfos' has a wrong offset!");

// ScriptStruct M1.M1DroppedItemByMiniGame
// 0x0058 (0x0058 - 0x0000)
struct FM1DroppedItemByMiniGame final
{
public:
	int64                                         MiniGameUid;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int64, struct FM1DropItemInfoList>       DropItemInfoListForAccount;                        // 0x0008(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DroppedItemByMiniGame) == 0x000008, "Wrong alignment on FM1DroppedItemByMiniGame");
static_assert(sizeof(FM1DroppedItemByMiniGame) == 0x000058, "Wrong size on FM1DroppedItemByMiniGame");
static_assert(offsetof(FM1DroppedItemByMiniGame, MiniGameUid) == 0x000000, "Member 'FM1DroppedItemByMiniGame::MiniGameUid' has a wrong offset!");
static_assert(offsetof(FM1DroppedItemByMiniGame, DropItemInfoListForAccount) == 0x000008, "Member 'FM1DroppedItemByMiniGame::DropItemInfoListForAccount' has a wrong offset!");

// ScriptStruct M1.M1Response_AcquireDropItem
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_AcquireDropItem final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_AcquireDropItem) == 0x000001, "Wrong alignment on FM1Response_AcquireDropItem");
static_assert(sizeof(FM1Response_AcquireDropItem) == 0x000001, "Wrong size on FM1Response_AcquireDropItem");
static_assert(offsetof(FM1Response_AcquireDropItem, Notification) == 0x000000, "Member 'FM1Response_AcquireDropItem::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_BossKillDropItem
// 0x0020 (0x0020 - 0x0000)
struct FM1Response_BossKillDropItem final
{
public:
	struct FM1DropItemInfoNoti                    Notification;                                      // 0x0000(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_BossKillDropItem) == 0x000008, "Wrong alignment on FM1Response_BossKillDropItem");
static_assert(sizeof(FM1Response_BossKillDropItem) == 0x000020, "Wrong size on FM1Response_BossKillDropItem");
static_assert(offsetof(FM1Response_BossKillDropItem, Notification) == 0x000000, "Member 'FM1Response_BossKillDropItem::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_BossPartsDropItem
// 0x0020 (0x0020 - 0x0000)
struct FM1Response_BossPartsDropItem final
{
public:
	struct FM1DropItemInfoNoti                    Notification;                                      // 0x0000(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_BossPartsDropItem) == 0x000008, "Wrong alignment on FM1Response_BossPartsDropItem");
static_assert(sizeof(FM1Response_BossPartsDropItem) == 0x000020, "Wrong size on FM1Response_BossPartsDropItem");
static_assert(offsetof(FM1Response_BossPartsDropItem, Notification) == 0x000000, "Member 'FM1Response_BossPartsDropItem::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_MissionTaskDropItem
// 0x0020 (0x0020 - 0x0000)
struct FM1Response_MissionTaskDropItem final
{
public:
	struct FM1DropItemInfoNoti                    Notification;                                      // 0x0000(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_MissionTaskDropItem) == 0x000008, "Wrong alignment on FM1Response_MissionTaskDropItem");
static_assert(sizeof(FM1Response_MissionTaskDropItem) == 0x000020, "Wrong size on FM1Response_MissionTaskDropItem");
static_assert(offsetof(FM1Response_MissionTaskDropItem, Notification) == 0x000000, "Member 'FM1Response_MissionTaskDropItem::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_MissionWaveDropItem
// 0x0020 (0x0020 - 0x0000)
struct FM1Response_MissionWaveDropItem final
{
public:
	struct FM1DropItemInfoNoti                    Notification;                                      // 0x0000(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_MissionWaveDropItem) == 0x000008, "Wrong alignment on FM1Response_MissionWaveDropItem");
static_assert(sizeof(FM1Response_MissionWaveDropItem) == 0x000020, "Wrong size on FM1Response_MissionWaveDropItem");
static_assert(offsetof(FM1Response_MissionWaveDropItem, Notification) == 0x000000, "Member 'FM1Response_MissionWaveDropItem::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_MiniGameDropItem
// 0x0020 (0x0020 - 0x0000)
struct FM1Response_MiniGameDropItem final
{
public:
	struct FM1DropItemInfoNoti                    Notification;                                      // 0x0000(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_MiniGameDropItem) == 0x000008, "Wrong alignment on FM1Response_MiniGameDropItem");
static_assert(sizeof(FM1Response_MiniGameDropItem) == 0x000020, "Wrong size on FM1Response_MiniGameDropItem");
static_assert(offsetof(FM1Response_MiniGameDropItem, Notification) == 0x000000, "Member 'FM1Response_MiniGameDropItem::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatAddExp
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatAddExp final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatAddExp) == 0x000001, "Wrong alignment on FM1Response_CheatAddExp");
static_assert(sizeof(FM1Response_CheatAddExp) == 0x000001, "Wrong size on FM1Response_CheatAddExp");
static_assert(offsetof(FM1Response_CheatAddExp, Notification) == 0x000000, "Member 'FM1Response_CheatAddExp::Notification' has a wrong offset!");

// ScriptStruct M1.M1EquipItemsInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1EquipItemsInfo final
{
public:
	EM1EquipmentSlotType                          SlotType;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ItemUid;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EquipItemsInfo) == 0x000008, "Wrong alignment on FM1EquipItemsInfo");
static_assert(sizeof(FM1EquipItemsInfo) == 0x000010, "Wrong size on FM1EquipItemsInfo");
static_assert(offsetof(FM1EquipItemsInfo, SlotType) == 0x000000, "Member 'FM1EquipItemsInfo::SlotType' has a wrong offset!");
static_assert(offsetof(FM1EquipItemsInfo, ItemUid) == 0x000008, "Member 'FM1EquipItemsInfo::ItemUid' has a wrong offset!");

// ScriptStruct M1.M1Response_EnchantRune
// 0x0020 (0x0020 - 0x0000)
struct FM1Response_EnchantRune final
{
public:
	EM1RuneReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ItemUidBox                          RuneUid;                                           // 0x0008(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         TargetEnchantLevel;                                // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Response_EnchantRune) == 0x000008, "Wrong alignment on FM1Response_EnchantRune");
static_assert(sizeof(FM1Response_EnchantRune) == 0x000020, "Wrong size on FM1Response_EnchantRune");
static_assert(offsetof(FM1Response_EnchantRune, Notification) == 0x000000, "Member 'FM1Response_EnchantRune::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_EnchantRune, RuneUid) == 0x000008, "Member 'FM1Response_EnchantRune::RuneUid' has a wrong offset!");
static_assert(offsetof(FM1Response_EnchantRune, TargetEnchantLevel) == 0x000018, "Member 'FM1Response_EnchantRune::TargetEnchantLevel' has a wrong offset!");

// ScriptStruct M1.M1Response_DecomposeRune
// 0x0018 (0x0018 - 0x0000)
struct FM1Response_DecomposeRune final
{
public:
	EM1RuneReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ItemBoxesInfo                       RuneUidsInfo;                                      // 0x0008(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_DecomposeRune) == 0x000008, "Wrong alignment on FM1Response_DecomposeRune");
static_assert(sizeof(FM1Response_DecomposeRune) == 0x000018, "Wrong size on FM1Response_DecomposeRune");
static_assert(offsetof(FM1Response_DecomposeRune, Notification) == 0x000000, "Member 'FM1Response_DecomposeRune::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_DecomposeRune, RuneUidsInfo) == 0x000008, "Member 'FM1Response_DecomposeRune::RuneUidsInfo' has a wrong offset!");

// ScriptStruct M1.M1Response_ComposeRune
// 0x0008 (0x0008 - 0x0000)
struct FM1Response_ComposeRune final
{
public:
	struct FM1RuneComposeResult                   Notification;                                      // 0x0000(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_ComposeRune) == 0x000004, "Wrong alignment on FM1Response_ComposeRune");
static_assert(sizeof(FM1Response_ComposeRune) == 0x000008, "Wrong size on FM1Response_ComposeRune");
static_assert(offsetof(FM1Response_ComposeRune, Notification) == 0x000000, "Member 'FM1Response_ComposeRune::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_RequestRuneEquippedInfoBundle
// 0x0018 (0x0018 - 0x0000)
struct FM1Response_RequestRuneEquippedInfoBundle final
{
public:
	struct FM1RuneEquippedInfoBundle              Notification;                                      // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_RequestRuneEquippedInfoBundle) == 0x000008, "Wrong alignment on FM1Response_RequestRuneEquippedInfoBundle");
static_assert(sizeof(FM1Response_RequestRuneEquippedInfoBundle) == 0x000018, "Wrong size on FM1Response_RequestRuneEquippedInfoBundle");
static_assert(offsetof(FM1Response_RequestRuneEquippedInfoBundle, Notification) == 0x000000, "Member 'FM1Response_RequestRuneEquippedInfoBundle::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_ChangeLoadoutSlotName
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_ChangeLoadoutSlotName final
{
public:
	EM1RuneReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_ChangeLoadoutSlotName) == 0x000004, "Wrong alignment on FM1Response_ChangeLoadoutSlotName");
static_assert(sizeof(FM1Response_ChangeLoadoutSlotName) == 0x000004, "Wrong size on FM1Response_ChangeLoadoutSlotName");
static_assert(offsetof(FM1Response_ChangeLoadoutSlotName, Notification) == 0x000000, "Member 'FM1Response_ChangeLoadoutSlotName::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_DecomposeRuneWithByte
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_DecomposeRuneWithByte final
{
public:
	EM1RuneReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_DecomposeRuneWithByte) == 0x000004, "Wrong alignment on FM1Response_DecomposeRuneWithByte");
static_assert(sizeof(FM1Response_DecomposeRuneWithByte) == 0x000004, "Wrong size on FM1Response_DecomposeRuneWithByte");
static_assert(offsetof(FM1Response_DecomposeRuneWithByte, Notification) == 0x000000, "Member 'FM1Response_DecomposeRuneWithByte::Notification' has a wrong offset!");

// ScriptStruct M1.M1PlayerMiniGameAnimSet
// 0x0058 (0x0058 - 0x0000)
struct FM1PlayerMiniGameAnimSet final
{
public:
	TMap<EM1CharacterGender, TSoftObjectPtr<class UAnimMontage>> AnimMontages;                                      // 0x0000(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	class FName                                   AnimMontageEndSectionName;                         // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PlayerMiniGameAnimSet) == 0x000008, "Wrong alignment on FM1PlayerMiniGameAnimSet");
static_assert(sizeof(FM1PlayerMiniGameAnimSet) == 0x000058, "Wrong size on FM1PlayerMiniGameAnimSet");
static_assert(offsetof(FM1PlayerMiniGameAnimSet, AnimMontages) == 0x000000, "Member 'FM1PlayerMiniGameAnimSet::AnimMontages' has a wrong offset!");
static_assert(offsetof(FM1PlayerMiniGameAnimSet, AnimMontageEndSectionName) == 0x000050, "Member 'FM1PlayerMiniGameAnimSet::AnimMontageEndSectionName' has a wrong offset!");

// ScriptStruct M1.M1Response_DecomposeRuneWithUid
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_DecomposeRuneWithUid final
{
public:
	EM1RuneReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_DecomposeRuneWithUid) == 0x000004, "Wrong alignment on FM1Response_DecomposeRuneWithUid");
static_assert(sizeof(FM1Response_DecomposeRuneWithUid) == 0x000004, "Wrong size on FM1Response_DecomposeRuneWithUid");
static_assert(offsetof(FM1Response_DecomposeRuneWithUid, Notification) == 0x000000, "Member 'FM1Response_DecomposeRuneWithUid::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_SellItemRequest
// 0x0020 (0x0020 - 0x0000)
struct FM1Response_SellItemRequest final
{
public:
	struct FM1ShopSellInfoNoti                    Notification;                                      // 0x0000(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_SellItemRequest) == 0x000008, "Wrong alignment on FM1Response_SellItemRequest");
static_assert(sizeof(FM1Response_SellItemRequest) == 0x000020, "Wrong size on FM1Response_SellItemRequest");
static_assert(offsetof(FM1Response_SellItemRequest, Notification) == 0x000000, "Member 'FM1Response_SellItemRequest::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_SellJunkItemRequest
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_SellJunkItemRequest final
{
public:
	EM1CommonShopResultType                       Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_SellJunkItemRequest) == 0x000004, "Wrong alignment on FM1Response_SellJunkItemRequest");
static_assert(sizeof(FM1Response_SellJunkItemRequest) == 0x000004, "Wrong size on FM1Response_SellJunkItemRequest");
static_assert(offsetof(FM1Response_SellJunkItemRequest, Notification) == 0x000000, "Member 'FM1Response_SellJunkItemRequest::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_RequestCurrencyInternalTranBundle
// 0x0018 (0x0018 - 0x0000)
struct FM1Response_RequestCurrencyInternalTranBundle final
{
public:
	struct FM1CurrencyInternalTranBundle          Notification;                                      // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_RequestCurrencyInternalTranBundle) == 0x000008, "Wrong alignment on FM1Response_RequestCurrencyInternalTranBundle");
static_assert(sizeof(FM1Response_RequestCurrencyInternalTranBundle) == 0x000018, "Wrong size on FM1Response_RequestCurrencyInternalTranBundle");
static_assert(offsetof(FM1Response_RequestCurrencyInternalTranBundle, Notification) == 0x000000, "Member 'FM1Response_RequestCurrencyInternalTranBundle::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CheckResearchStatus
// 0x0018 (0x0018 - 0x0000)
struct FM1Response_CheckResearchStatus final
{
public:
	struct FM1ResearchDataNoti                    Notification;                                      // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheckResearchStatus) == 0x000008, "Wrong alignment on FM1Response_CheckResearchStatus");
static_assert(sizeof(FM1Response_CheckResearchStatus) == 0x000018, "Wrong size on FM1Response_CheckResearchStatus");
static_assert(offsetof(FM1Response_CheckResearchStatus, Notification) == 0x000000, "Member 'FM1Response_CheckResearchStatus::Notification' has a wrong offset!");

// ScriptStruct M1.M1CustomizeSkinInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1CustomizeSkinInfo final
{
public:
	struct FM1TemplateId                          SkinTid;                                           // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1TemplateId>                  PaintArray;                                        // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         EvolutionIdx;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CustomizeSkinInfo) == 0x000008, "Wrong alignment on FM1CustomizeSkinInfo");
static_assert(sizeof(FM1CustomizeSkinInfo) == 0x000020, "Wrong size on FM1CustomizeSkinInfo");
static_assert(offsetof(FM1CustomizeSkinInfo, SkinTid) == 0x000000, "Member 'FM1CustomizeSkinInfo::SkinTid' has a wrong offset!");
static_assert(offsetof(FM1CustomizeSkinInfo, PaintArray) == 0x000008, "Member 'FM1CustomizeSkinInfo::PaintArray' has a wrong offset!");
static_assert(offsetof(FM1CustomizeSkinInfo, EvolutionIdx) == 0x000018, "Member 'FM1CustomizeSkinInfo::EvolutionIdx' has a wrong offset!");

// ScriptStruct M1.M1Response_RequestResearch
// 0x0020 (0x0020 - 0x0000)
struct FM1Response_RequestResearch final
{
public:
	struct FM1ResearchResultNoti                  Notification;                                      // 0x0000(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_RequestResearch) == 0x000008, "Wrong alignment on FM1Response_RequestResearch");
static_assert(sizeof(FM1Response_RequestResearch) == 0x000020, "Wrong size on FM1Response_RequestResearch");
static_assert(offsetof(FM1Response_RequestResearch, Notification) == 0x000000, "Member 'FM1Response_RequestResearch::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_BoostResearch
// 0x0020 (0x0020 - 0x0000)
struct FM1Response_BoostResearch final
{
public:
	struct FM1ResearchResultNoti                  Notification;                                      // 0x0000(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_BoostResearch) == 0x000008, "Wrong alignment on FM1Response_BoostResearch");
static_assert(sizeof(FM1Response_BoostResearch) == 0x000020, "Wrong size on FM1Response_BoostResearch");
static_assert(offsetof(FM1Response_BoostResearch, Notification) == 0x000000, "Member 'FM1Response_BoostResearch::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_ReceiveResearch
// 0x0020 (0x0020 - 0x0000)
struct FM1Response_ReceiveResearch final
{
public:
	struct FM1ResearchResultNoti                  Notification;                                      // 0x0000(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_ReceiveResearch) == 0x000008, "Wrong alignment on FM1Response_ReceiveResearch");
static_assert(sizeof(FM1Response_ReceiveResearch) == 0x000020, "Wrong size on FM1Response_ReceiveResearch");
static_assert(offsetof(FM1Response_ReceiveResearch, Notification) == 0x000000, "Member 'FM1Response_ReceiveResearch::Notification' has a wrong offset!");

// ScriptStruct M1.M1NxLog_FireIntervalValidationError
// 0x00F0 (0x00F0 - 0x0000)
struct FM1NxLog_FireIntervalValidationError final
{
public:
	class FString                                 Actionid;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Userlevel;                                         // 0x0010(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Usernickname;                                      // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tfdplayeritemid;                                   // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Tfdplayeritemlevel;                                // 0x0040(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Tfdweaponitemid;                                   // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Tfdweaponitemlevel;                                // 0x0060(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 FieldId;                                           // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldUid;                                          // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Validationnum;                                     // 0x0090(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1NxLogDouble                         Fireinterval;                                      // 0x00A0(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1NxLogDouble                         Avgserverfireinterval;                             // 0x00B0(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1NxLogDouble                         Avgserverfireintervaldelta;                        // 0x00C0(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1NxLogDouble                         Avgclientfireintervaldelta;                        // 0x00D0(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1NxLogDouble                         Validationrate;                                    // 0x00E0(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_FireIntervalValidationError) == 0x000008, "Wrong alignment on FM1NxLog_FireIntervalValidationError");
static_assert(sizeof(FM1NxLog_FireIntervalValidationError) == 0x0000F0, "Wrong size on FM1NxLog_FireIntervalValidationError");
static_assert(offsetof(FM1NxLog_FireIntervalValidationError, Actionid) == 0x000000, "Member 'FM1NxLog_FireIntervalValidationError::Actionid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireIntervalValidationError, Userlevel) == 0x000010, "Member 'FM1NxLog_FireIntervalValidationError::Userlevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireIntervalValidationError, Usernickname) == 0x000020, "Member 'FM1NxLog_FireIntervalValidationError::Usernickname' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireIntervalValidationError, Tfdplayeritemid) == 0x000030, "Member 'FM1NxLog_FireIntervalValidationError::Tfdplayeritemid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireIntervalValidationError, Tfdplayeritemlevel) == 0x000040, "Member 'FM1NxLog_FireIntervalValidationError::Tfdplayeritemlevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireIntervalValidationError, Tfdweaponitemid) == 0x000050, "Member 'FM1NxLog_FireIntervalValidationError::Tfdweaponitemid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireIntervalValidationError, Tfdweaponitemlevel) == 0x000060, "Member 'FM1NxLog_FireIntervalValidationError::Tfdweaponitemlevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireIntervalValidationError, FieldId) == 0x000070, "Member 'FM1NxLog_FireIntervalValidationError::FieldId' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireIntervalValidationError, FieldUid) == 0x000080, "Member 'FM1NxLog_FireIntervalValidationError::FieldUid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireIntervalValidationError, Validationnum) == 0x000090, "Member 'FM1NxLog_FireIntervalValidationError::Validationnum' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireIntervalValidationError, Fireinterval) == 0x0000A0, "Member 'FM1NxLog_FireIntervalValidationError::Fireinterval' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireIntervalValidationError, Avgserverfireinterval) == 0x0000B0, "Member 'FM1NxLog_FireIntervalValidationError::Avgserverfireinterval' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireIntervalValidationError, Avgserverfireintervaldelta) == 0x0000C0, "Member 'FM1NxLog_FireIntervalValidationError::Avgserverfireintervaldelta' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireIntervalValidationError, Avgclientfireintervaldelta) == 0x0000D0, "Member 'FM1NxLog_FireIntervalValidationError::Avgclientfireintervaldelta' has a wrong offset!");
static_assert(offsetof(FM1NxLog_FireIntervalValidationError, Validationrate) == 0x0000E0, "Member 'FM1NxLog_FireIntervalValidationError::Validationrate' has a wrong offset!");

// ScriptStruct M1.M1Response_RequestResearchAllAtOnce
// 0x0020 (0x0020 - 0x0000)
struct FM1Response_RequestResearchAllAtOnce final
{
public:
	struct FM1ResearchResultNoti                  Notification;                                      // 0x0000(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_RequestResearchAllAtOnce) == 0x000008, "Wrong alignment on FM1Response_RequestResearchAllAtOnce");
static_assert(sizeof(FM1Response_RequestResearchAllAtOnce) == 0x000020, "Wrong size on FM1Response_RequestResearchAllAtOnce");
static_assert(offsetof(FM1Response_RequestResearchAllAtOnce, Notification) == 0x000000, "Member 'FM1Response_RequestResearchAllAtOnce::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_RequestUnSetResearchBookmark
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_RequestUnSetResearchBookmark final
{
public:
	EM1ResearchReason                             Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_RequestUnSetResearchBookmark) == 0x000004, "Wrong alignment on FM1Response_RequestUnSetResearchBookmark");
static_assert(sizeof(FM1Response_RequestUnSetResearchBookmark) == 0x000004, "Wrong size on FM1Response_RequestUnSetResearchBookmark");
static_assert(offsetof(FM1Response_RequestUnSetResearchBookmark, Notification) == 0x000000, "Member 'FM1Response_RequestUnSetResearchBookmark::Notification' has a wrong offset!");

// ScriptStruct M1.M1Request_MissionWaveSucceeded
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_MissionWaveSucceeded final
{
public:
	TArray<int64>                                 AccountUids;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MissionWaveTemplateId;                             // 0x0010(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_MissionWaveSucceeded) == 0x000008, "Wrong alignment on FM1Request_MissionWaveSucceeded");
static_assert(sizeof(FM1Request_MissionWaveSucceeded) == 0x000018, "Wrong size on FM1Request_MissionWaveSucceeded");
static_assert(offsetof(FM1Request_MissionWaveSucceeded, AccountUids) == 0x000000, "Member 'FM1Request_MissionWaveSucceeded::AccountUids' has a wrong offset!");
static_assert(offsetof(FM1Request_MissionWaveSucceeded, MissionWaveTemplateId) == 0x000010, "Member 'FM1Request_MissionWaveSucceeded::MissionWaveTemplateId' has a wrong offset!");

// ScriptStruct M1.M1Response_GetMissionInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1Response_GetMissionInfo final
{
public:
	struct FM1MissionInfoList                     Notification;                                      // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_GetMissionInfo) == 0x000008, "Wrong alignment on FM1Response_GetMissionInfo");
static_assert(sizeof(FM1Response_GetMissionInfo) == 0x000018, "Wrong size on FM1Response_GetMissionInfo");
static_assert(offsetof(FM1Response_GetMissionInfo, Notification) == 0x000000, "Member 'FM1Response_GetMissionInfo::Notification' has a wrong offset!");

// ScriptStruct M1.M1FindTargetQueryInfo
// 0x0030 (0x0030 - 0x0000)
struct FM1FindTargetQueryInfo final
{
public:
	TArray<struct FGameplayTagContainer>          TargetIdTags;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  IgnoreTargetIdTags;                                // 0x0010(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FindTargetQueryInfo) == 0x000008, "Wrong alignment on FM1FindTargetQueryInfo");
static_assert(sizeof(FM1FindTargetQueryInfo) == 0x000030, "Wrong size on FM1FindTargetQueryInfo");
static_assert(offsetof(FM1FindTargetQueryInfo, TargetIdTags) == 0x000000, "Member 'FM1FindTargetQueryInfo::TargetIdTags' has a wrong offset!");
static_assert(offsetof(FM1FindTargetQueryInfo, IgnoreTargetIdTags) == 0x000010, "Member 'FM1FindTargetQueryInfo::IgnoreTargetIdTags' has a wrong offset!");

// ScriptStruct M1.M1Response_SuccessMission
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_SuccessMission final
{
public:
	struct FM1SuccessMissionRes                   Notification;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_SuccessMission) == 0x000008, "Wrong alignment on FM1Response_SuccessMission");
static_assert(sizeof(FM1Response_SuccessMission) == 0x000010, "Wrong size on FM1Response_SuccessMission");
static_assert(offsetof(FM1Response_SuccessMission, Notification) == 0x000000, "Member 'FM1Response_SuccessMission::Notification' has a wrong offset!");

// ScriptStruct M1.M1Notice_FieldUnlockedNoti
// 0x0040 (0x0040 - 0x0000)
struct FM1Notice_FieldUnlockedNoti final
{
public:
	struct FM1FieldUnlockedNoti                   Notification;                                      // 0x0000(0x0040)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_FieldUnlockedNoti) == 0x000008, "Wrong alignment on FM1Notice_FieldUnlockedNoti");
static_assert(sizeof(FM1Notice_FieldUnlockedNoti) == 0x000040, "Wrong size on FM1Notice_FieldUnlockedNoti");
static_assert(offsetof(FM1Notice_FieldUnlockedNoti, Notification) == 0x000000, "Member 'FM1Notice_FieldUnlockedNoti::Notification' has a wrong offset!");

// ScriptStruct M1.M1GameServiceJoinGameResult
// 0x00D0 (0x00D0 - 0x0000)
struct FM1GameServiceJoinGameResult final
{
public:
	struct FM1JoinDedicatedServerRes              JoinGameResult;                                    // 0x0000(0x00B0)(NativeAccessSpecifierPublic)
	struct FM1TemplateId                          BattleZoneId;                                      // 0x00B0(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StartLocationId;                                   // 0x00B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrivate;                                          // 0x00C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1GameServiceJoinGameResult) == 0x000008, "Wrong alignment on FM1GameServiceJoinGameResult");
static_assert(sizeof(FM1GameServiceJoinGameResult) == 0x0000D0, "Wrong size on FM1GameServiceJoinGameResult");
static_assert(offsetof(FM1GameServiceJoinGameResult, JoinGameResult) == 0x000000, "Member 'FM1GameServiceJoinGameResult::JoinGameResult' has a wrong offset!");
static_assert(offsetof(FM1GameServiceJoinGameResult, BattleZoneId) == 0x0000B0, "Member 'FM1GameServiceJoinGameResult::BattleZoneId' has a wrong offset!");
static_assert(offsetof(FM1GameServiceJoinGameResult, StartLocationId) == 0x0000B8, "Member 'FM1GameServiceJoinGameResult::StartLocationId' has a wrong offset!");
static_assert(offsetof(FM1GameServiceJoinGameResult, bPrivate) == 0x0000C8, "Member 'FM1GameServiceJoinGameResult::bPrivate' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatCompleteBattleZone
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatCompleteBattleZone final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatCompleteBattleZone) == 0x000001, "Wrong alignment on FM1Response_CheatCompleteBattleZone");
static_assert(sizeof(FM1Response_CheatCompleteBattleZone) == 0x000001, "Wrong size on FM1Response_CheatCompleteBattleZone");
static_assert(offsetof(FM1Response_CheatCompleteBattleZone, Notification) == 0x000000, "Member 'FM1Response_CheatCompleteBattleZone::Notification' has a wrong offset!");

// ScriptStruct M1.M1TickableDelegateBaseContext
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FM1TickableDelegateBaseContext
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1TickableDelegateBaseContext) == 0x000008, "Wrong alignment on FM1TickableDelegateBaseContext");
static_assert(sizeof(FM1TickableDelegateBaseContext) == 0x000018, "Wrong size on FM1TickableDelegateBaseContext");

// ScriptStruct M1.M1TickableDelegateDurationContext
// 0x0018 (0x0030 - 0x0018)
struct FM1TickableDelegateDurationContext : public FM1TickableDelegateBaseContext
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1TickableDelegateDurationContext) == 0x000008, "Wrong alignment on FM1TickableDelegateDurationContext");
static_assert(sizeof(FM1TickableDelegateDurationContext) == 0x000030, "Wrong size on FM1TickableDelegateDurationContext");

// ScriptStruct M1.M1TickableDelegateScriptDurationContext
// 0x0010 (0x0040 - 0x0030)
struct FM1TickableDelegateScriptDurationContext final : public FM1TickableDelegateDurationContext
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1TickableDelegateScriptDurationContext) == 0x000008, "Wrong alignment on FM1TickableDelegateScriptDurationContext");
static_assert(sizeof(FM1TickableDelegateScriptDurationContext) == 0x000040, "Wrong size on FM1TickableDelegateScriptDurationContext");

// ScriptStruct M1.M1Response_CheatClearAllUnlockedFieldAndCamp
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatClearAllUnlockedFieldAndCamp final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatClearAllUnlockedFieldAndCamp) == 0x000001, "Wrong alignment on FM1Response_CheatClearAllUnlockedFieldAndCamp");
static_assert(sizeof(FM1Response_CheatClearAllUnlockedFieldAndCamp) == 0x000001, "Wrong size on FM1Response_CheatClearAllUnlockedFieldAndCamp");
static_assert(offsetof(FM1Response_CheatClearAllUnlockedFieldAndCamp, Notification) == 0x000000, "Member 'FM1Response_CheatClearAllUnlockedFieldAndCamp::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_StartQuest
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_StartQuest final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_StartQuest) == 0x000001, "Wrong alignment on FM1Response_StartQuest");
static_assert(sizeof(FM1Response_StartQuest) == 0x000001, "Wrong size on FM1Response_StartQuest");
static_assert(offsetof(FM1Response_StartQuest, Notification) == 0x000000, "Member 'FM1Response_StartQuest::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_IncQuestProgress
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_IncQuestProgress final
{
public:
	struct FM1IncQuestProgressRes                 Notification;                                      // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_IncQuestProgress) == 0x000004, "Wrong alignment on FM1Response_IncQuestProgress");
static_assert(sizeof(FM1Response_IncQuestProgress) == 0x000010, "Wrong size on FM1Response_IncQuestProgress");
static_assert(offsetof(FM1Response_IncQuestProgress, Notification) == 0x000000, "Member 'FM1Response_IncQuestProgress::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_GetQuestInfo
// 0x0028 (0x0028 - 0x0000)
struct FM1Response_GetQuestInfo final
{
public:
	struct FM1QuestInfoList                       Notification;                                      // 0x0000(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_GetQuestInfo) == 0x000008, "Wrong alignment on FM1Response_GetQuestInfo");
static_assert(sizeof(FM1Response_GetQuestInfo) == 0x000028, "Wrong size on FM1Response_GetQuestInfo");
static_assert(offsetof(FM1Response_GetQuestInfo, Notification) == 0x000000, "Member 'FM1Response_GetQuestInfo::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_IncQuestProgressMultiple
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_IncQuestProgressMultiple final
{
public:
	struct FM1IncQuestProgressResList             Notification;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_IncQuestProgressMultiple) == 0x000008, "Wrong alignment on FM1Response_IncQuestProgressMultiple");
static_assert(sizeof(FM1Response_IncQuestProgressMultiple) == 0x000010, "Wrong size on FM1Response_IncQuestProgressMultiple");
static_assert(offsetof(FM1Response_IncQuestProgressMultiple, Notification) == 0x000000, "Member 'FM1Response_IncQuestProgressMultiple::Notification' has a wrong offset!");

// ScriptStruct M1.M1Notice_SetQuestTrackerNoti
// 0x0010 (0x0010 - 0x0000)
struct FM1Notice_SetQuestTrackerNoti final
{
public:
	struct FM1SetQuestTrackerNoti                 Notification;                                      // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_SetQuestTrackerNoti) == 0x000008, "Wrong alignment on FM1Notice_SetQuestTrackerNoti");
static_assert(sizeof(FM1Notice_SetQuestTrackerNoti) == 0x000010, "Wrong size on FM1Notice_SetQuestTrackerNoti");
static_assert(offsetof(FM1Notice_SetQuestTrackerNoti, Notification) == 0x000000, "Member 'FM1Notice_SetQuestTrackerNoti::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatAddWeaponProficiencyPoint
// 0x0018 (0x0018 - 0x0000)
struct FM1Response_CheatAddWeaponProficiencyPoint final
{
public:
	struct FM1AddWeaponProficiencyPointRes        Notification;                                      // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatAddWeaponProficiencyPoint) == 0x000008, "Wrong alignment on FM1Response_CheatAddWeaponProficiencyPoint");
static_assert(sizeof(FM1Response_CheatAddWeaponProficiencyPoint) == 0x000018, "Wrong size on FM1Response_CheatAddWeaponProficiencyPoint");
static_assert(offsetof(FM1Response_CheatAddWeaponProficiencyPoint, Notification) == 0x000000, "Member 'FM1Response_CheatAddWeaponProficiencyPoint::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatMasteryExpUp
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatMasteryExpUp final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatMasteryExpUp) == 0x000001, "Wrong alignment on FM1Response_CheatMasteryExpUp");
static_assert(sizeof(FM1Response_CheatMasteryExpUp) == 0x000001, "Wrong size on FM1Response_CheatMasteryExpUp");
static_assert(offsetof(FM1Response_CheatMasteryExpUp, Notification) == 0x000000, "Member 'FM1Response_CheatMasteryExpUp::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_GetVoidBattleEntranceInfo
// 0x0028 (0x0028 - 0x0000)
struct FM1Response_GetVoidBattleEntranceInfo final
{
public:
	struct FM1VoidBattleEntranceInfoList          Notification;                                      // 0x0000(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_GetVoidBattleEntranceInfo) == 0x000008, "Wrong alignment on FM1Response_GetVoidBattleEntranceInfo");
static_assert(sizeof(FM1Response_GetVoidBattleEntranceInfo) == 0x000028, "Wrong size on FM1Response_GetVoidBattleEntranceInfo");
static_assert(offsetof(FM1Response_GetVoidBattleEntranceInfo, Notification) == 0x000000, "Member 'FM1Response_GetVoidBattleEntranceInfo::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_InstanceDungeonComplete
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_InstanceDungeonComplete final
{
public:
	struct FM1InstanceDungeonCompleteResult       Notification;                                      // 0x0000(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_InstanceDungeonComplete) == 0x000004, "Wrong alignment on FM1Response_InstanceDungeonComplete");
static_assert(sizeof(FM1Response_InstanceDungeonComplete) == 0x000004, "Wrong size on FM1Response_InstanceDungeonComplete");
static_assert(offsetof(FM1Response_InstanceDungeonComplete, Notification) == 0x000000, "Member 'FM1Response_InstanceDungeonComplete::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_InvasionDungeonComplete
// 0x0028 (0x0028 - 0x0000)
struct FM1Response_InvasionDungeonComplete final
{
public:
	struct FM1InvasionDungeonCompleteResult       Notification;                                      // 0x0000(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_InvasionDungeonComplete) == 0x000008, "Wrong alignment on FM1Response_InvasionDungeonComplete");
static_assert(sizeof(FM1Response_InvasionDungeonComplete) == 0x000028, "Wrong size on FM1Response_InvasionDungeonComplete");
static_assert(offsetof(FM1Response_InvasionDungeonComplete, Notification) == 0x000000, "Member 'FM1Response_InvasionDungeonComplete::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_GetMailList
// 0x0018 (0x0018 - 0x0000)
struct FM1Response_GetMailList final
{
public:
	struct FM1MailInfoBundle                      Notification;                                      // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_GetMailList) == 0x000008, "Wrong alignment on FM1Response_GetMailList");
static_assert(sizeof(FM1Response_GetMailList) == 0x000018, "Wrong size on FM1Response_GetMailList");
static_assert(offsetof(FM1Response_GetMailList, Notification) == 0x000000, "Member 'FM1Response_GetMailList::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_ReadMail
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_ReadMail final
{
public:
	EM1MailReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_ReadMail) == 0x000004, "Wrong alignment on FM1Response_ReadMail");
static_assert(sizeof(FM1Response_ReadMail) == 0x000004, "Wrong size on FM1Response_ReadMail");
static_assert(offsetof(FM1Response_ReadMail, Notification) == 0x000000, "Member 'FM1Response_ReadMail::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_DeleteMail
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_DeleteMail final
{
public:
	EM1MailReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_DeleteMail) == 0x000004, "Wrong alignment on FM1Response_DeleteMail");
static_assert(sizeof(FM1Response_DeleteMail) == 0x000004, "Wrong size on FM1Response_DeleteMail");
static_assert(offsetof(FM1Response_DeleteMail, Notification) == 0x000000, "Member 'FM1Response_DeleteMail::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_SendMailForCheat
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_SendMailForCheat final
{
public:
	EM1MailReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_SendMailForCheat) == 0x000004, "Wrong alignment on FM1Response_SendMailForCheat");
static_assert(sizeof(FM1Response_SendMailForCheat) == 0x000004, "Wrong size on FM1Response_SendMailForCheat");
static_assert(offsetof(FM1Response_SendMailForCheat, Notification) == 0x000000, "Member 'FM1Response_SendMailForCheat::Notification' has a wrong offset!");

// ScriptStruct M1.M1Notice_MailArriveNoti
// 0x0020 (0x0020 - 0x0000)
struct FM1Notice_MailArriveNoti final
{
public:
	struct FM1NewMailPushInfo                     Notification;                                      // 0x0000(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Notice_MailArriveNoti) == 0x000008, "Wrong alignment on FM1Notice_MailArriveNoti");
static_assert(sizeof(FM1Notice_MailArriveNoti) == 0x000020, "Wrong size on FM1Notice_MailArriveNoti");
static_assert(offsetof(FM1Notice_MailArriveNoti, Notification) == 0x000000, "Member 'FM1Notice_MailArriveNoti::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_ReceiveMailAttachmentAll
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_ReceiveMailAttachmentAll final
{
public:
	EM1MailReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_ReceiveMailAttachmentAll) == 0x000004, "Wrong alignment on FM1Response_ReceiveMailAttachmentAll");
static_assert(sizeof(FM1Response_ReceiveMailAttachmentAll) == 0x000004, "Wrong size on FM1Response_ReceiveMailAttachmentAll");
static_assert(offsetof(FM1Response_ReceiveMailAttachmentAll, Notification) == 0x000000, "Member 'FM1Response_ReceiveMailAttachmentAll::Notification' has a wrong offset!");

// ScriptStruct M1.M1BattleKeySetting
// 0x0080 (0x0080 - 0x0000)
struct FM1BattleKeySetting final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1BattleKey                                  BattleKey;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1BattleInputChord>            Chords;                                            // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EM1UIPlatform, struct FM1CustomKeySymbolContent> CustomSymbolSet;                                   // 0x0020(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 ActionStringKey;                                   // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattleKeySetting) == 0x000008, "Wrong alignment on FM1BattleKeySetting");
static_assert(sizeof(FM1BattleKeySetting) == 0x000080, "Wrong size on FM1BattleKeySetting");
static_assert(offsetof(FM1BattleKeySetting, ActionName) == 0x000000, "Member 'FM1BattleKeySetting::ActionName' has a wrong offset!");
static_assert(offsetof(FM1BattleKeySetting, BattleKey) == 0x000008, "Member 'FM1BattleKeySetting::BattleKey' has a wrong offset!");
static_assert(offsetof(FM1BattleKeySetting, Chords) == 0x000010, "Member 'FM1BattleKeySetting::Chords' has a wrong offset!");
static_assert(offsetof(FM1BattleKeySetting, CustomSymbolSet) == 0x000020, "Member 'FM1BattleKeySetting::CustomSymbolSet' has a wrong offset!");
static_assert(offsetof(FM1BattleKeySetting, ActionStringKey) == 0x000070, "Member 'FM1BattleKeySetting::ActionStringKey' has a wrong offset!");

// ScriptStruct M1.M1Response_SendMailForCheat3
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_SendMailForCheat3 final
{
public:
	EM1MailReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_SendMailForCheat3) == 0x000004, "Wrong alignment on FM1Response_SendMailForCheat3");
static_assert(sizeof(FM1Response_SendMailForCheat3) == 0x000004, "Wrong size on FM1Response_SendMailForCheat3");
static_assert(offsetof(FM1Response_SendMailForCheat3, Notification) == 0x000000, "Member 'FM1Response_SendMailForCheat3::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CustomizingCharacter
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_CustomizingCharacter final
{
public:
	EM1CustomizeReason                            Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CustomizingCharacter) == 0x000004, "Wrong alignment on FM1Response_CustomizingCharacter");
static_assert(sizeof(FM1Response_CustomizingCharacter) == 0x000004, "Wrong size on FM1Response_CustomizingCharacter");
static_assert(offsetof(FM1Response_CustomizingCharacter, Notification) == 0x000000, "Member 'FM1Response_CustomizingCharacter::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CustomizingSkinPaint
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_CustomizingSkinPaint final
{
public:
	EM1CustomizeReason                            Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CustomizingSkinPaint) == 0x000004, "Wrong alignment on FM1Response_CustomizingSkinPaint");
static_assert(sizeof(FM1Response_CustomizingSkinPaint) == 0x000004, "Wrong size on FM1Response_CustomizingSkinPaint");
static_assert(offsetof(FM1Response_CustomizingSkinPaint, Notification) == 0x000000, "Member 'FM1Response_CustomizingSkinPaint::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CustomizingSkinPaints
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_CustomizingSkinPaints final
{
public:
	EM1CustomizeReason                            Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CustomizingSkinPaints) == 0x000004, "Wrong alignment on FM1Response_CustomizingSkinPaints");
static_assert(sizeof(FM1Response_CustomizingSkinPaints) == 0x000004, "Wrong size on FM1Response_CustomizingSkinPaints");
static_assert(offsetof(FM1Response_CustomizingSkinPaints, Notification) == 0x000000, "Member 'FM1Response_CustomizingSkinPaints::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CustomizingRingSlot
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_CustomizingRingSlot final
{
public:
	EM1CustomizeReason                            Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CustomizingRingSlot) == 0x000004, "Wrong alignment on FM1Response_CustomizingRingSlot");
static_assert(sizeof(FM1Response_CustomizingRingSlot) == 0x000004, "Wrong size on FM1Response_CustomizingRingSlot");
static_assert(offsetof(FM1Response_CustomizingRingSlot, Notification) == 0x000000, "Member 'FM1Response_CustomizingRingSlot::Notification' has a wrong offset!");

// ScriptStruct M1.M1AbilityCacheInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1AbilityCacheInfo final
{
public:
	class UM1AbilityOpCalc*                       OpCalc;                                            // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AbilityCacheInfo) == 0x000008, "Wrong alignment on FM1AbilityCacheInfo");
static_assert(sizeof(FM1AbilityCacheInfo) == 0x000010, "Wrong size on FM1AbilityCacheInfo");
static_assert(offsetof(FM1AbilityCacheInfo, OpCalc) == 0x000000, "Member 'FM1AbilityCacheInfo::OpCalc' has a wrong offset!");

// ScriptStruct M1.M1Response_GetCustomizeInventory
// 0x0098 (0x0098 - 0x0000)
struct FM1Response_GetCustomizeInventory final
{
public:
	struct FM1CustomizeInvenvory                  Notification;                                      // 0x0000(0x0098)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_GetCustomizeInventory) == 0x000008, "Wrong alignment on FM1Response_GetCustomizeInventory");
static_assert(sizeof(FM1Response_GetCustomizeInventory) == 0x000098, "Wrong size on FM1Response_GetCustomizeInventory");
static_assert(offsetof(FM1Response_GetCustomizeInventory, Notification) == 0x000000, "Member 'FM1Response_GetCustomizeInventory::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_UncustomizingRingSlot
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_UncustomizingRingSlot final
{
public:
	EM1CustomizeReason                            Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_UncustomizingRingSlot) == 0x000004, "Wrong alignment on FM1Response_UncustomizingRingSlot");
static_assert(sizeof(FM1Response_UncustomizingRingSlot) == 0x000004, "Wrong size on FM1Response_UncustomizingRingSlot");
static_assert(offsetof(FM1Response_UncustomizingRingSlot, Notification) == 0x000000, "Member 'FM1Response_UncustomizingRingSlot::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CustomizingEvolution
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_CustomizingEvolution final
{
public:
	EM1CustomizeReason                            Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CustomizingEvolution) == 0x000004, "Wrong alignment on FM1Response_CustomizingEvolution");
static_assert(sizeof(FM1Response_CustomizingEvolution) == 0x000004, "Wrong size on FM1Response_CustomizingEvolution");
static_assert(offsetof(FM1Response_CustomizingEvolution, Notification) == 0x000000, "Member 'FM1Response_CustomizingEvolution::Notification' has a wrong offset!");

// ScriptStruct M1.M1DediServerInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1DediServerInfo final
{
public:
	int64                                         FieldMasterUid;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJoinInProgressDisabled;                           // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1DediServerInfo) == 0x000008, "Wrong alignment on FM1DediServerInfo");
static_assert(sizeof(FM1DediServerInfo) == 0x000010, "Wrong size on FM1DediServerInfo");
static_assert(offsetof(FM1DediServerInfo, FieldMasterUid) == 0x000000, "Member 'FM1DediServerInfo::FieldMasterUid' has a wrong offset!");
static_assert(offsetof(FM1DediServerInfo, bJoinInProgressDisabled) == 0x000008, "Member 'FM1DediServerInfo::bJoinInProgressDisabled' has a wrong offset!");

// ScriptStruct M1.M1Response_ExtractPaint
// 0x0018 (0x0018 - 0x0000)
struct FM1Response_ExtractPaint final
{
public:
	struct FM1ExtractPaintRes                     Notification;                                      // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_ExtractPaint) == 0x000008, "Wrong alignment on FM1Response_ExtractPaint");
static_assert(sizeof(FM1Response_ExtractPaint) == 0x000018, "Wrong size on FM1Response_ExtractPaint");
static_assert(offsetof(FM1Response_ExtractPaint, Notification) == 0x000000, "Member 'FM1Response_ExtractPaint::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_PerkEnchant
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_PerkEnchant final
{
public:
	EM1PerkReason                                 Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_PerkEnchant) == 0x000004, "Wrong alignment on FM1Response_PerkEnchant");
static_assert(sizeof(FM1Response_PerkEnchant) == 0x000004, "Wrong size on FM1Response_PerkEnchant");
static_assert(offsetof(FM1Response_PerkEnchant, Notification) == 0x000000, "Member 'FM1Response_PerkEnchant::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_ReactorEnchant
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_ReactorEnchant final
{
public:
	EM1ReactorReason                              Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_ReactorEnchant) == 0x000004, "Wrong alignment on FM1Response_ReactorEnchant");
static_assert(sizeof(FM1Response_ReactorEnchant) == 0x000004, "Wrong size on FM1Response_ReactorEnchant");
static_assert(offsetof(FM1Response_ReactorEnchant, Notification) == 0x000000, "Member 'FM1Response_ReactorEnchant::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_SetBattlePassPremium
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_SetBattlePassPremium final
{
public:
	EM1BattlePassReason                           Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_SetBattlePassPremium) == 0x000004, "Wrong alignment on FM1Response_SetBattlePassPremium");
static_assert(sizeof(FM1Response_SetBattlePassPremium) == 0x000004, "Wrong size on FM1Response_SetBattlePassPremium");
static_assert(offsetof(FM1Response_SetBattlePassPremium, Notification) == 0x000000, "Member 'FM1Response_SetBattlePassPremium::Notification' has a wrong offset!");

// ScriptStruct M1.M1WorldMissionDataList
// 0x0010 (0x0010 - 0x0000)
struct FM1WorldMissionDataList final
{
public:
	TArray<class UM1WorldMissionDataHolder*>      Missions;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WorldMissionDataList) == 0x000008, "Wrong alignment on FM1WorldMissionDataList");
static_assert(sizeof(FM1WorldMissionDataList) == 0x000010, "Wrong size on FM1WorldMissionDataList");
static_assert(offsetof(FM1WorldMissionDataList, Missions) == 0x000000, "Member 'FM1WorldMissionDataList::Missions' has a wrong offset!");

// ScriptStruct M1.M1Response_RequestBattlePassSeasonData
// 0x0018 (0x0018 - 0x0000)
struct FM1Response_RequestBattlePassSeasonData final
{
public:
	struct FM1BattlePassSeasonInfoBundle          Notification;                                      // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_RequestBattlePassSeasonData) == 0x000008, "Wrong alignment on FM1Response_RequestBattlePassSeasonData");
static_assert(sizeof(FM1Response_RequestBattlePassSeasonData) == 0x000018, "Wrong size on FM1Response_RequestBattlePassSeasonData");
static_assert(offsetof(FM1Response_RequestBattlePassSeasonData, Notification) == 0x000000, "Member 'FM1Response_RequestBattlePassSeasonData::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_ReceivePremiumExclusiveReward
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_ReceivePremiumExclusiveReward final
{
public:
	EM1BattlePassReason                           Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_ReceivePremiumExclusiveReward) == 0x000004, "Wrong alignment on FM1Response_ReceivePremiumExclusiveReward");
static_assert(sizeof(FM1Response_ReceivePremiumExclusiveReward) == 0x000004, "Wrong size on FM1Response_ReceivePremiumExclusiveReward");
static_assert(offsetof(FM1Response_ReceivePremiumExclusiveReward, Notification) == 0x000000, "Member 'FM1Response_ReceivePremiumExclusiveReward::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_RequireAchievementReward
// 0x0008 (0x0008 - 0x0000)
struct FM1Response_RequireAchievementReward final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1TemplateId                          QuestTemplateId;                                   // 0x0004(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_RequireAchievementReward) == 0x000004, "Wrong alignment on FM1Response_RequireAchievementReward");
static_assert(sizeof(FM1Response_RequireAchievementReward) == 0x000008, "Wrong size on FM1Response_RequireAchievementReward");
static_assert(offsetof(FM1Response_RequireAchievementReward, Notification) == 0x000000, "Member 'FM1Response_RequireAchievementReward::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_RequireAchievementReward, QuestTemplateId) == 0x000004, "Member 'FM1Response_RequireAchievementReward::QuestTemplateId' has a wrong offset!");

// ScriptStruct M1.M1DroppedItemByMonsterParam
// 0x0020 (0x0020 - 0x0000)
struct FM1DroppedItemByMonsterParam final
{
public:
	TArray<class AM1Character*>                   WhoKilledMonsters;                                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class AM1Monster*                             MonsterKilled;                                     // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterLevel;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MonsterSpawnGroupId;                               // 0x001C(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DroppedItemByMonsterParam) == 0x000008, "Wrong alignment on FM1DroppedItemByMonsterParam");
static_assert(sizeof(FM1DroppedItemByMonsterParam) == 0x000020, "Wrong size on FM1DroppedItemByMonsterParam");
static_assert(offsetof(FM1DroppedItemByMonsterParam, WhoKilledMonsters) == 0x000000, "Member 'FM1DroppedItemByMonsterParam::WhoKilledMonsters' has a wrong offset!");
static_assert(offsetof(FM1DroppedItemByMonsterParam, MonsterKilled) == 0x000010, "Member 'FM1DroppedItemByMonsterParam::MonsterKilled' has a wrong offset!");
static_assert(offsetof(FM1DroppedItemByMonsterParam, MonsterLevel) == 0x000018, "Member 'FM1DroppedItemByMonsterParam::MonsterLevel' has a wrong offset!");
static_assert(offsetof(FM1DroppedItemByMonsterParam, MonsterSpawnGroupId) == 0x00001C, "Member 'FM1DroppedItemByMonsterParam::MonsterSpawnGroupId' has a wrong offset!");

// ScriptStruct M1.M1Response_RequireRecord
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_RequireRecord final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_RequireRecord) == 0x000001, "Wrong alignment on FM1Response_RequireRecord");
static_assert(sizeof(FM1Response_RequireRecord) == 0x000001, "Wrong size on FM1Response_RequireRecord");
static_assert(offsetof(FM1Response_RequireRecord, Notification) == 0x000000, "Member 'FM1Response_RequireRecord::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_InitShop
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_InitShop final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_InitShop) == 0x000001, "Wrong alignment on FM1Response_InitShop");
static_assert(sizeof(FM1Response_InitShop) == 0x000001, "Wrong size on FM1Response_InitShop");
static_assert(offsetof(FM1Response_InitShop, Notification) == 0x000000, "Member 'FM1Response_InitShop::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_GetPresetInfoBundle
// 0x0010 (0x0010 - 0x0000)
struct FM1Response_GetPresetInfoBundle final
{
public:
	struct FM1PresetInfoBundle                    Notification;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_GetPresetInfoBundle) == 0x000008, "Wrong alignment on FM1Response_GetPresetInfoBundle");
static_assert(sizeof(FM1Response_GetPresetInfoBundle) == 0x000010, "Wrong size on FM1Response_GetPresetInfoBundle");
static_assert(offsetof(FM1Response_GetPresetInfoBundle, Notification) == 0x000000, "Member 'FM1Response_GetPresetInfoBundle::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_ChangePresetName
// 0x0018 (0x0018 - 0x0000)
struct FM1Response_ChangePresetName final
{
public:
	EM1PresetReason                               Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PresetIndex;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_ChangePresetName) == 0x000008, "Wrong alignment on FM1Response_ChangePresetName");
static_assert(sizeof(FM1Response_ChangePresetName) == 0x000018, "Wrong size on FM1Response_ChangePresetName");
static_assert(offsetof(FM1Response_ChangePresetName, Notification) == 0x000000, "Member 'FM1Response_ChangePresetName::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_ChangePresetName, PresetIndex) == 0x000004, "Member 'FM1Response_ChangePresetName::PresetIndex' has a wrong offset!");
static_assert(offsetof(FM1Response_ChangePresetName, Name) == 0x000008, "Member 'FM1Response_ChangePresetName::Name' has a wrong offset!");

// ScriptStruct M1.M1Response_ApplyPreset
// 0x0038 (0x0038 - 0x0000)
struct FM1Response_ApplyPreset final
{
public:
	struct FM1ApplyPresetRes                      Notification;                                      // 0x0000(0x0038)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_ApplyPreset) == 0x000008, "Wrong alignment on FM1Response_ApplyPreset");
static_assert(sizeof(FM1Response_ApplyPreset) == 0x000038, "Wrong size on FM1Response_ApplyPreset");
static_assert(offsetof(FM1Response_ApplyPreset, Notification) == 0x000000, "Member 'FM1Response_ApplyPreset::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_TryUnlockReinforce
// 0x000C (0x000C - 0x0000)
struct FM1Response_TryUnlockReinforce final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GroupIndex;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_TryUnlockReinforce) == 0x000004, "Wrong alignment on FM1Response_TryUnlockReinforce");
static_assert(sizeof(FM1Response_TryUnlockReinforce) == 0x00000C, "Wrong size on FM1Response_TryUnlockReinforce");
static_assert(offsetof(FM1Response_TryUnlockReinforce, Notification) == 0x000000, "Member 'FM1Response_TryUnlockReinforce::Notification' has a wrong offset!");
static_assert(offsetof(FM1Response_TryUnlockReinforce, GroupIndex) == 0x000004, "Member 'FM1Response_TryUnlockReinforce::GroupIndex' has a wrong offset!");
static_assert(offsetof(FM1Response_TryUnlockReinforce, SlotIndex) == 0x000008, "Member 'FM1Response_TryUnlockReinforce::SlotIndex' has a wrong offset!");

// ScriptStruct M1.M1Response_ClearReinforce
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_ClearReinforce final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_ClearReinforce) == 0x000001, "Wrong alignment on FM1Response_ClearReinforce");
static_assert(sizeof(FM1Response_ClearReinforce) == 0x000001, "Wrong size on FM1Response_ClearReinforce");
static_assert(offsetof(FM1Response_ClearReinforce, Notification) == 0x000000, "Member 'FM1Response_ClearReinforce::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatClearSeasonLevel
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatClearSeasonLevel final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatClearSeasonLevel) == 0x000001, "Wrong alignment on FM1Response_CheatClearSeasonLevel");
static_assert(sizeof(FM1Response_CheatClearSeasonLevel) == 0x000001, "Wrong size on FM1Response_CheatClearSeasonLevel");
static_assert(offsetof(FM1Response_CheatClearSeasonLevel, Notification) == 0x000000, "Member 'FM1Response_CheatClearSeasonLevel::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_CheatWeaponProficiencyMax
// 0x0001 (0x0001 - 0x0000)
struct FM1Response_CheatWeaponProficiencyMax final
{
public:
	bool                                          Notification;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_CheatWeaponProficiencyMax) == 0x000001, "Wrong alignment on FM1Response_CheatWeaponProficiencyMax");
static_assert(sizeof(FM1Response_CheatWeaponProficiencyMax) == 0x000001, "Wrong size on FM1Response_CheatWeaponProficiencyMax");
static_assert(offsetof(FM1Response_CheatWeaponProficiencyMax, Notification) == 0x000000, "Member 'FM1Response_CheatWeaponProficiencyMax::Notification' has a wrong offset!");

// ScriptStruct M1.M1AbilityEventData_WeaponSlotType
// 0x0008 (0x0010 - 0x0008)
struct FM1AbilityEventData_WeaponSlotType final : public FM1AbilityEventData
{
public:
	EM1EquipmentSlotType                          From;                                              // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1EquipmentSlotType                          To;                                                // 0x0009(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1EquipmentSlotType                          Current;                                           // 0x000A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AbilityEventData_WeaponSlotType) == 0x000008, "Wrong alignment on FM1AbilityEventData_WeaponSlotType");
static_assert(sizeof(FM1AbilityEventData_WeaponSlotType) == 0x000010, "Wrong size on FM1AbilityEventData_WeaponSlotType");
static_assert(offsetof(FM1AbilityEventData_WeaponSlotType, From) == 0x000008, "Member 'FM1AbilityEventData_WeaponSlotType::From' has a wrong offset!");
static_assert(offsetof(FM1AbilityEventData_WeaponSlotType, To) == 0x000009, "Member 'FM1AbilityEventData_WeaponSlotType::To' has a wrong offset!");
static_assert(offsetof(FM1AbilityEventData_WeaponSlotType, Current) == 0x00000A, "Member 'FM1AbilityEventData_WeaponSlotType::Current' has a wrong offset!");

// ScriptStruct M1.M1AbilityEventData_DamageInfo
// 0x0138 (0x0140 - 0x0008)
struct FM1AbilityEventData_DamageInfo final : public FM1AbilityEventData
{
public:
	struct FM1CalcDamageInfo                      DamageInfo;                                        // 0x0008(0x0138)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityEventData_DamageInfo) == 0x000008, "Wrong alignment on FM1AbilityEventData_DamageInfo");
static_assert(sizeof(FM1AbilityEventData_DamageInfo) == 0x000140, "Wrong size on FM1AbilityEventData_DamageInfo");
static_assert(offsetof(FM1AbilityEventData_DamageInfo, DamageInfo) == 0x000008, "Member 'FM1AbilityEventData_DamageInfo::DamageInfo' has a wrong offset!");

// ScriptStruct M1.M1AbilityEventData_ReconcileDamage
// 0x0148 (0x0150 - 0x0008)
struct FM1AbilityEventData_ReconcileDamage final : public FM1AbilityEventData
{
public:
	struct FM1ScaledInteger                       InAppliedDamage;                                   // 0x0008(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ScaledInteger                       OutReconciledDamage;                               // 0x0010(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1CalcDamageInfo                      DamageInfo;                                        // 0x0018(0x0138)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityEventData_ReconcileDamage) == 0x000008, "Wrong alignment on FM1AbilityEventData_ReconcileDamage");
static_assert(sizeof(FM1AbilityEventData_ReconcileDamage) == 0x000150, "Wrong size on FM1AbilityEventData_ReconcileDamage");
static_assert(offsetof(FM1AbilityEventData_ReconcileDamage, InAppliedDamage) == 0x000008, "Member 'FM1AbilityEventData_ReconcileDamage::InAppliedDamage' has a wrong offset!");
static_assert(offsetof(FM1AbilityEventData_ReconcileDamage, OutReconciledDamage) == 0x000010, "Member 'FM1AbilityEventData_ReconcileDamage::OutReconciledDamage' has a wrong offset!");
static_assert(offsetof(FM1AbilityEventData_ReconcileDamage, DamageInfo) == 0x000018, "Member 'FM1AbilityEventData_ReconcileDamage::DamageInfo' has a wrong offset!");

// ScriptStruct M1.M1AbilityEventData_AddTraitTags
// 0x0158 (0x0160 - 0x0008)
struct FM1AbilityEventData_AddTraitTags final : public FM1AbilityEventData
{
public:
	struct FGameplayTagContainer                  OutTraitTags;                                      // 0x0008(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FM1CalcDamageInfo                      DamageInfo;                                        // 0x0028(0x0138)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityEventData_AddTraitTags) == 0x000008, "Wrong alignment on FM1AbilityEventData_AddTraitTags");
static_assert(sizeof(FM1AbilityEventData_AddTraitTags) == 0x000160, "Wrong size on FM1AbilityEventData_AddTraitTags");
static_assert(offsetof(FM1AbilityEventData_AddTraitTags, OutTraitTags) == 0x000008, "Member 'FM1AbilityEventData_AddTraitTags::OutTraitTags' has a wrong offset!");
static_assert(offsetof(FM1AbilityEventData_AddTraitTags, DamageInfo) == 0x000028, "Member 'FM1AbilityEventData_AddTraitTags::DamageInfo' has a wrong offset!");

// ScriptStruct M1.M1StatTypeOpValue
// 0x0010 (0x0010 - 0x0000)
struct FM1StatTypeOpValue final
{
public:
	EM1StatType                                   StatType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1StatModifierOp                             ModOp;                                             // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ScaledInteger                       Value;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StatTypeOpValue) == 0x000008, "Wrong alignment on FM1StatTypeOpValue");
static_assert(sizeof(FM1StatTypeOpValue) == 0x000010, "Wrong size on FM1StatTypeOpValue");
static_assert(offsetof(FM1StatTypeOpValue, StatType) == 0x000000, "Member 'FM1StatTypeOpValue::StatType' has a wrong offset!");
static_assert(offsetof(FM1StatTypeOpValue, ModOp) == 0x000001, "Member 'FM1StatTypeOpValue::ModOp' has a wrong offset!");
static_assert(offsetof(FM1StatTypeOpValue, Value) == 0x000008, "Member 'FM1StatTypeOpValue::Value' has a wrong offset!");

// ScriptStruct M1.M1AbilityEventData_DamageCalculation
// 0x00D8 (0x00E0 - 0x0008)
struct FM1AbilityEventData_DamageCalculation final : public FM1AbilityEventData
{
public:
	struct FHitResult                             HitResult;                                         // 0x0008(0x009C)(BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EM1WeaponDamageType                           WeaponDamageType;                                  // 0x00A4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1StatTypeOpValue>             OutSourceStatModifiers;                            // 0x00A8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DamageTraitTags;                                   // 0x00B8(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         DamageCauserUniqueId;                              // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AbilityEventData_DamageCalculation) == 0x000008, "Wrong alignment on FM1AbilityEventData_DamageCalculation");
static_assert(sizeof(FM1AbilityEventData_DamageCalculation) == 0x0000E0, "Wrong size on FM1AbilityEventData_DamageCalculation");
static_assert(offsetof(FM1AbilityEventData_DamageCalculation, HitResult) == 0x000008, "Member 'FM1AbilityEventData_DamageCalculation::HitResult' has a wrong offset!");
static_assert(offsetof(FM1AbilityEventData_DamageCalculation, WeaponDamageType) == 0x0000A4, "Member 'FM1AbilityEventData_DamageCalculation::WeaponDamageType' has a wrong offset!");
static_assert(offsetof(FM1AbilityEventData_DamageCalculation, OutSourceStatModifiers) == 0x0000A8, "Member 'FM1AbilityEventData_DamageCalculation::OutSourceStatModifiers' has a wrong offset!");
static_assert(offsetof(FM1AbilityEventData_DamageCalculation, DamageTraitTags) == 0x0000B8, "Member 'FM1AbilityEventData_DamageCalculation::DamageTraitTags' has a wrong offset!");
static_assert(offsetof(FM1AbilityEventData_DamageCalculation, DamageCauserUniqueId) == 0x0000D8, "Member 'FM1AbilityEventData_DamageCalculation::DamageCauserUniqueId' has a wrong offset!");

// ScriptStruct M1.M1AbilityEventData_PlayerRevive
// 0x0008 (0x0010 - 0x0008)
struct FM1AbilityEventData_PlayerRevive final : public FM1AbilityEventData
{
public:
	EM1RecoverSupplyType                          RecoverType;                                       // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInMission;                                        // 0x0009(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AbilityEventData_PlayerRevive) == 0x000008, "Wrong alignment on FM1AbilityEventData_PlayerRevive");
static_assert(sizeof(FM1AbilityEventData_PlayerRevive) == 0x000010, "Wrong size on FM1AbilityEventData_PlayerRevive");
static_assert(offsetof(FM1AbilityEventData_PlayerRevive, RecoverType) == 0x000008, "Member 'FM1AbilityEventData_PlayerRevive::RecoverType' has a wrong offset!");
static_assert(offsetof(FM1AbilityEventData_PlayerRevive, bInMission) == 0x000009, "Member 'FM1AbilityEventData_PlayerRevive::bInMission' has a wrong offset!");

// ScriptStruct M1.M1AbilityEventData_WeaponAttack
// 0x0008 (0x0010 - 0x0008)
struct FM1AbilityEventData_WeaponAttack final : public FM1AbilityEventData
{
public:
	bool                                          bAutoFireWeapon;                                   // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AbilityEventData_WeaponAttack) == 0x000008, "Wrong alignment on FM1AbilityEventData_WeaponAttack");
static_assert(sizeof(FM1AbilityEventData_WeaponAttack) == 0x000010, "Wrong size on FM1AbilityEventData_WeaponAttack");
static_assert(offsetof(FM1AbilityEventData_WeaponAttack, bAutoFireWeapon) == 0x000008, "Member 'FM1AbilityEventData_WeaponAttack::bAutoFireWeapon' has a wrong offset!");

// ScriptStruct M1.M1AbilityEventData_DBNO
// 0x0010 (0x0018 - 0x0008)
struct FM1AbilityEventData_DBNO final : public FM1AbilityEventData
{
public:
	EM1DBNOContentsType                           CurrentContentsType;                               // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 RescueTarget;                                      // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityEventData_DBNO) == 0x000008, "Wrong alignment on FM1AbilityEventData_DBNO");
static_assert(sizeof(FM1AbilityEventData_DBNO) == 0x000018, "Wrong size on FM1AbilityEventData_DBNO");
static_assert(offsetof(FM1AbilityEventData_DBNO, CurrentContentsType) == 0x000008, "Member 'FM1AbilityEventData_DBNO::CurrentContentsType' has a wrong offset!");
static_assert(offsetof(FM1AbilityEventData_DBNO, RescueTarget) == 0x000010, "Member 'FM1AbilityEventData_DBNO::RescueTarget' has a wrong offset!");

// ScriptStruct M1.M1MissionCollectionReturnInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1MissionCollectionReturnInfo final
{
public:
	TWeakObjectPtr<class AM1Player>               Player;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CollectibleCapacity;                               // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentCollectionCount;                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionCollectionReturnInfo) == 0x000004, "Wrong alignment on FM1MissionCollectionReturnInfo");
static_assert(sizeof(FM1MissionCollectionReturnInfo) == 0x000010, "Wrong size on FM1MissionCollectionReturnInfo");
static_assert(offsetof(FM1MissionCollectionReturnInfo, Player) == 0x000000, "Member 'FM1MissionCollectionReturnInfo::Player' has a wrong offset!");
static_assert(offsetof(FM1MissionCollectionReturnInfo, CollectibleCapacity) == 0x000008, "Member 'FM1MissionCollectionReturnInfo::CollectibleCapacity' has a wrong offset!");
static_assert(offsetof(FM1MissionCollectionReturnInfo, CurrentCollectionCount) == 0x00000C, "Member 'FM1MissionCollectionReturnInfo::CurrentCollectionCount' has a wrong offset!");

// ScriptStruct M1.M1AbilityEventData_AnimNotify
// 0x0010 (0x0018 - 0x0008)
struct FM1AbilityEventData_AnimNotify : public FM1AbilityEventData
{
public:
	class UAnimSequenceBase*                      Animation;                                         // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MontageInstanceID;                                 // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AbilityEventData_AnimNotify) == 0x000008, "Wrong alignment on FM1AbilityEventData_AnimNotify");
static_assert(sizeof(FM1AbilityEventData_AnimNotify) == 0x000018, "Wrong size on FM1AbilityEventData_AnimNotify");
static_assert(offsetof(FM1AbilityEventData_AnimNotify, Animation) == 0x000008, "Member 'FM1AbilityEventData_AnimNotify::Animation' has a wrong offset!");
static_assert(offsetof(FM1AbilityEventData_AnimNotify, MontageInstanceID) == 0x000010, "Member 'FM1AbilityEventData_AnimNotify::MontageInstanceID' has a wrong offset!");

// ScriptStruct M1.M1AbilityEventData_AnimNotifyAbilityFX
// 0x0008 (0x0020 - 0x0018)
struct FM1AbilityEventData_AnimNotifyAbilityFX final : public FM1AbilityEventData_AnimNotify
{
public:
	class FName                                   FXName;                                            // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityEventData_AnimNotifyAbilityFX) == 0x000008, "Wrong alignment on FM1AbilityEventData_AnimNotifyAbilityFX");
static_assert(sizeof(FM1AbilityEventData_AnimNotifyAbilityFX) == 0x000020, "Wrong size on FM1AbilityEventData_AnimNotifyAbilityFX");
static_assert(offsetof(FM1AbilityEventData_AnimNotifyAbilityFX, FXName) == 0x000018, "Member 'FM1AbilityEventData_AnimNotifyAbilityFX::FXName' has a wrong offset!");

// ScriptStruct M1.M1AbilityEventData_AnimNotifySubSkillMeshSpawn
// 0x0010 (0x0028 - 0x0018)
struct FM1AbilityEventData_AnimNotifySubSkillMeshSpawn final : public FM1AbilityEventData_AnimNotify
{
public:
	class AM1SkeletalMeshActor*                   SpawnedMesh;                                       // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocketName;                                  // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityEventData_AnimNotifySubSkillMeshSpawn) == 0x000008, "Wrong alignment on FM1AbilityEventData_AnimNotifySubSkillMeshSpawn");
static_assert(sizeof(FM1AbilityEventData_AnimNotifySubSkillMeshSpawn) == 0x000028, "Wrong size on FM1AbilityEventData_AnimNotifySubSkillMeshSpawn");
static_assert(offsetof(FM1AbilityEventData_AnimNotifySubSkillMeshSpawn, SpawnedMesh) == 0x000018, "Member 'FM1AbilityEventData_AnimNotifySubSkillMeshSpawn::SpawnedMesh' has a wrong offset!");
static_assert(offsetof(FM1AbilityEventData_AnimNotifySubSkillMeshSpawn, AttachSocketName) == 0x000020, "Member 'FM1AbilityEventData_AnimNotifySubSkillMeshSpawn::AttachSocketName' has a wrong offset!");

// ScriptStruct M1.M1DefenseTargetInfo
// 0x000C (0x000C - 0x0000)
struct FM1DefenseTargetInfo final
{
public:
	struct FM1TemplateId                          MissionTargetTemplateId;                           // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentHPRatio;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentShieldRatio;                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DefenseTargetInfo) == 0x000004, "Wrong alignment on FM1DefenseTargetInfo");
static_assert(sizeof(FM1DefenseTargetInfo) == 0x00000C, "Wrong size on FM1DefenseTargetInfo");
static_assert(offsetof(FM1DefenseTargetInfo, MissionTargetTemplateId) == 0x000000, "Member 'FM1DefenseTargetInfo::MissionTargetTemplateId' has a wrong offset!");
static_assert(offsetof(FM1DefenseTargetInfo, CurrentHPRatio) == 0x000004, "Member 'FM1DefenseTargetInfo::CurrentHPRatio' has a wrong offset!");
static_assert(offsetof(FM1DefenseTargetInfo, CurrentShieldRatio) == 0x000008, "Member 'FM1DefenseTargetInfo::CurrentShieldRatio' has a wrong offset!");

// ScriptStruct M1.M1TaskDefenseInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1TaskDefenseInfo final
{
public:
	TArray<struct FM1DefenseTargetInfo>           DefenseTargetInfo;                                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         RemainingTime;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1TaskDefenseInfo) == 0x000008, "Wrong alignment on FM1TaskDefenseInfo");
static_assert(sizeof(FM1TaskDefenseInfo) == 0x000018, "Wrong size on FM1TaskDefenseInfo");
static_assert(offsetof(FM1TaskDefenseInfo, DefenseTargetInfo) == 0x000000, "Member 'FM1TaskDefenseInfo::DefenseTargetInfo' has a wrong offset!");
static_assert(offsetof(FM1TaskDefenseInfo, RemainingTime) == 0x000010, "Member 'FM1TaskDefenseInfo::RemainingTime' has a wrong offset!");

// ScriptStruct M1.M1AbilityEventData_MonsterPhase
// 0x0008 (0x0010 - 0x0008)
struct FM1AbilityEventData_MonsterPhase final : public FM1AbilityEventData
{
public:
	int32                                         CurrentPhaseIndex;                                 // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalPhaseCount;                                   // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityEventData_MonsterPhase) == 0x000008, "Wrong alignment on FM1AbilityEventData_MonsterPhase");
static_assert(sizeof(FM1AbilityEventData_MonsterPhase) == 0x000010, "Wrong size on FM1AbilityEventData_MonsterPhase");
static_assert(offsetof(FM1AbilityEventData_MonsterPhase, CurrentPhaseIndex) == 0x000008, "Member 'FM1AbilityEventData_MonsterPhase::CurrentPhaseIndex' has a wrong offset!");
static_assert(offsetof(FM1AbilityEventData_MonsterPhase, TotalPhaseCount) == 0x00000C, "Member 'FM1AbilityEventData_MonsterPhase::TotalPhaseCount' has a wrong offset!");

// ScriptStruct M1.M1AbilityEventData_SkillAppliedCooltime
// 0x0008 (0x0010 - 0x0008)
struct FM1AbilityEventData_SkillAppliedCooltime final : public FM1AbilityEventData
{
public:
	EM1SkillActiveType                            ActiveType;                                        // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AbilityEventData_SkillAppliedCooltime) == 0x000008, "Wrong alignment on FM1AbilityEventData_SkillAppliedCooltime");
static_assert(sizeof(FM1AbilityEventData_SkillAppliedCooltime) == 0x000010, "Wrong size on FM1AbilityEventData_SkillAppliedCooltime");
static_assert(offsetof(FM1AbilityEventData_SkillAppliedCooltime, ActiveType) == 0x000008, "Member 'FM1AbilityEventData_SkillAppliedCooltime::ActiveType' has a wrong offset!");

// ScriptStruct M1.M1AbilityIDList
// 0x0010 (0x0010 - 0x0000)
struct FM1AbilityIDList final
{
public:
	TArray<struct FM1AbilityId>                   AbilityIDs;                                        // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityIDList) == 0x000008, "Wrong alignment on FM1AbilityIDList");
static_assert(sizeof(FM1AbilityIDList) == 0x000010, "Wrong size on FM1AbilityIDList");
static_assert(offsetof(FM1AbilityIDList, AbilityIDs) == 0x000000, "Member 'FM1AbilityIDList::AbilityIDs' has a wrong offset!");

// ScriptStruct M1.M1AbilityOperation
// 0x0198 (0x0198 - 0x0000)
struct FM1AbilityOperation
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UM1AbilityOpCalc*                       UsingCalc;                                         // 0x0020(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28[0x170];                                     // 0x0028(0x0170)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AbilityOperation) == 0x000008, "Wrong alignment on FM1AbilityOperation");
static_assert(sizeof(FM1AbilityOperation) == 0x000198, "Wrong size on FM1AbilityOperation");
static_assert(offsetof(FM1AbilityOperation, UsingCalc) == 0x000020, "Member 'FM1AbilityOperation::UsingCalc' has a wrong offset!");

// ScriptStruct M1.M1AbilityOpCalcResult
// 0x0030 (0x0030 - 0x0000)
struct FM1AbilityOpCalcResult final
{
public:
	struct FGameplayTagContainer                  TraitTags;                                         // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	TArray<struct FM1StatTypeOpValue>             Modifiers;                                         // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityOpCalcResult) == 0x000008, "Wrong alignment on FM1AbilityOpCalcResult");
static_assert(sizeof(FM1AbilityOpCalcResult) == 0x000030, "Wrong size on FM1AbilityOpCalcResult");
static_assert(offsetof(FM1AbilityOpCalcResult, TraitTags) == 0x000000, "Member 'FM1AbilityOpCalcResult::TraitTags' has a wrong offset!");
static_assert(offsetof(FM1AbilityOpCalcResult, Modifiers) == 0x000020, "Member 'FM1AbilityOpCalcResult::Modifiers' has a wrong offset!");

// ScriptStruct M1.M1MovementHistoryInfo
// 0x0014 (0x0014 - 0x0000)
struct FM1MovementHistoryInfo final
{
public:
	EMovementMode                                 MoveMode;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasRootMotion;                                    // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MovementHistoryInfo) == 0x000004, "Wrong alignment on FM1MovementHistoryInfo");
static_assert(sizeof(FM1MovementHistoryInfo) == 0x000014, "Wrong size on FM1MovementHistoryInfo");
static_assert(offsetof(FM1MovementHistoryInfo, MoveMode) == 0x000000, "Member 'FM1MovementHistoryInfo::MoveMode' has a wrong offset!");
static_assert(offsetof(FM1MovementHistoryInfo, Location) == 0x000004, "Member 'FM1MovementHistoryInfo::Location' has a wrong offset!");
static_assert(offsetof(FM1MovementHistoryInfo, bHasRootMotion) == 0x000010, "Member 'FM1MovementHistoryInfo::bHasRootMotion' has a wrong offset!");

// ScriptStruct M1.M1ActiveAbilityOperation
// 0x0038 (0x01D0 - 0x0198)
struct FM1ActiveAbilityOperation final : public FM1AbilityOperation
{
public:
	uint8                                         Pad_198[0x38];                                     // 0x0198(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ActiveAbilityOperation) == 0x000008, "Wrong alignment on FM1ActiveAbilityOperation");
static_assert(sizeof(FM1ActiveAbilityOperation) == 0x0001D0, "Wrong size on FM1ActiveAbilityOperation");

// ScriptStruct M1.M1AbilityOpCalcParam
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FM1AbilityOpCalcParam final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AbilityOpCalcParam) == 0x000008, "Wrong alignment on FM1AbilityOpCalcParam");
static_assert(sizeof(FM1AbilityOpCalcParam) == 0x000008, "Wrong size on FM1AbilityOpCalcParam");

// ScriptStruct M1.M1AbilityOpExecCalcOutput
// 0x0010 (0x0010 - 0x0000)
struct FM1AbilityOpExecCalcOutput final
{
public:
	TArray<struct FM1StatTypeOpValue>             OutModifiers;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityOpExecCalcOutput) == 0x000008, "Wrong alignment on FM1AbilityOpExecCalcOutput");
static_assert(sizeof(FM1AbilityOpExecCalcOutput) == 0x000010, "Wrong size on FM1AbilityOpExecCalcOutput");
static_assert(offsetof(FM1AbilityOpExecCalcOutput, OutModifiers) == 0x000000, "Member 'FM1AbilityOpExecCalcOutput::OutModifiers' has a wrong offset!");

// ScriptStruct M1.M1NpcSpawnSettings
// 0x0060 (0x0060 - 0x0000)
struct FM1NpcSpawnSettings final
{
public:
	TSoftObjectPtr<class UAnimMontage>            SpawnAnimMontage;                                  // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            DespawnAnimMontage;                                // 0x0030(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NpcSpawnSettings) == 0x000008, "Wrong alignment on FM1NpcSpawnSettings");
static_assert(sizeof(FM1NpcSpawnSettings) == 0x000060, "Wrong size on FM1NpcSpawnSettings");
static_assert(offsetof(FM1NpcSpawnSettings, SpawnAnimMontage) == 0x000000, "Member 'FM1NpcSpawnSettings::SpawnAnimMontage' has a wrong offset!");
static_assert(offsetof(FM1NpcSpawnSettings, DespawnAnimMontage) == 0x000030, "Member 'FM1NpcSpawnSettings::DespawnAnimMontage' has a wrong offset!");

// ScriptStruct M1.M1CalcDamageNetInfo
// 0x00F0 (0x00F0 - 0x0000)
struct FM1CalcDamageNetInfo final
{
public:
	TWeakObjectPtr<class AActor>                  Instigator;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0008(0x009C)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ScaledInteger                       TotalDamage;                                       // 0x00A8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1WeaponDamageType                           WeaponDamageType;                                  // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1AdvantageCalcResult                        AdvantageCalcResult;                               // 0x00B1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ElementalDamageChannel                     RepresentativeElementalDamageType;                 // 0x00B2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B3[0x5];                                       // 0x00B3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1ScaledInteger>               ElementalDamages;                                  // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TraitTags;                                         // 0x00C8(0x0020)(NativeAccessSpecifierPublic)
	uint8                                         bHasDied : 1;                                      // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWeakness : 1;                                     // 0x00E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCritical : 1;                                     // 0x00E8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bImmune : 1;                                       // 0x00E8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CalcDamageNetInfo) == 0x000008, "Wrong alignment on FM1CalcDamageNetInfo");
static_assert(sizeof(FM1CalcDamageNetInfo) == 0x0000F0, "Wrong size on FM1CalcDamageNetInfo");
static_assert(offsetof(FM1CalcDamageNetInfo, Instigator) == 0x000000, "Member 'FM1CalcDamageNetInfo::Instigator' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageNetInfo, HitResult) == 0x000008, "Member 'FM1CalcDamageNetInfo::HitResult' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageNetInfo, TotalDamage) == 0x0000A8, "Member 'FM1CalcDamageNetInfo::TotalDamage' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageNetInfo, WeaponDamageType) == 0x0000B0, "Member 'FM1CalcDamageNetInfo::WeaponDamageType' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageNetInfo, AdvantageCalcResult) == 0x0000B1, "Member 'FM1CalcDamageNetInfo::AdvantageCalcResult' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageNetInfo, RepresentativeElementalDamageType) == 0x0000B2, "Member 'FM1CalcDamageNetInfo::RepresentativeElementalDamageType' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageNetInfo, ElementalDamages) == 0x0000B8, "Member 'FM1CalcDamageNetInfo::ElementalDamages' has a wrong offset!");
static_assert(offsetof(FM1CalcDamageNetInfo, TraitTags) == 0x0000C8, "Member 'FM1CalcDamageNetInfo::TraitTags' has a wrong offset!");

// ScriptStruct M1.M1AbilityProjectilePathDebugDrawParams
// 0x0008 (0x0008 - 0x0000)
struct FM1AbilityProjectilePathDebugDrawParams
{
public:
	bool                                          bDebugDraw;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawDebugTime;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityProjectilePathDebugDrawParams) == 0x000004, "Wrong alignment on FM1AbilityProjectilePathDebugDrawParams");
static_assert(sizeof(FM1AbilityProjectilePathDebugDrawParams) == 0x000008, "Wrong size on FM1AbilityProjectilePathDebugDrawParams");
static_assert(offsetof(FM1AbilityProjectilePathDebugDrawParams, bDebugDraw) == 0x000000, "Member 'FM1AbilityProjectilePathDebugDrawParams::bDebugDraw' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathDebugDrawParams, DrawDebugType) == 0x000001, "Member 'FM1AbilityProjectilePathDebugDrawParams::DrawDebugType' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathDebugDrawParams, DrawDebugTime) == 0x000004, "Member 'FM1AbilityProjectilePathDebugDrawParams::DrawDebugTime' has a wrong offset!");

// ScriptStruct M1.M1AbilityProjectilePathFollowDebugDrawParams
// 0x005C (0x0064 - 0x0008)
struct FM1AbilityProjectilePathFollowDebugDrawParams final : public FM1AbilityProjectilePathDebugDrawParams
{
public:
	float                                         DrawRadius;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawArrowLength;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawArrowSize;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawThickness;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawPrediction;                              // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           PathPointColor;                                    // 0x001C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           PathSegmentColor;                                  // 0x002C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawTrajectory;                              // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TrajectoryPointColor;                              // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TrajectorySegmentColor;                            // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawRawPrediction;                           // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AbilityProjectilePathFollowDebugDrawParams) == 0x000004, "Wrong alignment on FM1AbilityProjectilePathFollowDebugDrawParams");
static_assert(sizeof(FM1AbilityProjectilePathFollowDebugDrawParams) == 0x000064, "Wrong size on FM1AbilityProjectilePathFollowDebugDrawParams");
static_assert(offsetof(FM1AbilityProjectilePathFollowDebugDrawParams, DrawRadius) == 0x000008, "Member 'FM1AbilityProjectilePathFollowDebugDrawParams::DrawRadius' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathFollowDebugDrawParams, DrawArrowLength) == 0x00000C, "Member 'FM1AbilityProjectilePathFollowDebugDrawParams::DrawArrowLength' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathFollowDebugDrawParams, DrawArrowSize) == 0x000010, "Member 'FM1AbilityProjectilePathFollowDebugDrawParams::DrawArrowSize' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathFollowDebugDrawParams, DrawThickness) == 0x000014, "Member 'FM1AbilityProjectilePathFollowDebugDrawParams::DrawThickness' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathFollowDebugDrawParams, bDebugDrawPrediction) == 0x000018, "Member 'FM1AbilityProjectilePathFollowDebugDrawParams::bDebugDrawPrediction' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathFollowDebugDrawParams, PathPointColor) == 0x00001C, "Member 'FM1AbilityProjectilePathFollowDebugDrawParams::PathPointColor' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathFollowDebugDrawParams, PathSegmentColor) == 0x00002C, "Member 'FM1AbilityProjectilePathFollowDebugDrawParams::PathSegmentColor' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathFollowDebugDrawParams, bDebugDrawTrajectory) == 0x00003C, "Member 'FM1AbilityProjectilePathFollowDebugDrawParams::bDebugDrawTrajectory' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathFollowDebugDrawParams, TrajectoryPointColor) == 0x000040, "Member 'FM1AbilityProjectilePathFollowDebugDrawParams::TrajectoryPointColor' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathFollowDebugDrawParams, TrajectorySegmentColor) == 0x000050, "Member 'FM1AbilityProjectilePathFollowDebugDrawParams::TrajectorySegmentColor' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathFollowDebugDrawParams, bDebugDrawRawPrediction) == 0x000060, "Member 'FM1AbilityProjectilePathFollowDebugDrawParams::bDebugDrawRawPrediction' has a wrong offset!");

// ScriptStruct M1.M1AbilityTargetInfo
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FM1AbilityTargetInfo
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AbilityTargetInfo) == 0x000008, "Wrong alignment on FM1AbilityTargetInfo");
static_assert(sizeof(FM1AbilityTargetInfo) == 0x000008, "Wrong size on FM1AbilityTargetInfo");

// ScriptStruct M1.M1AbilityTargetInfo_Actor
// 0x0028 (0x0030 - 0x0008)
struct FM1AbilityTargetInfo_Actor final : public FM1AbilityTargetInfo
{
public:
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  TargetActor;                                       // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                TargetLastLocation;                                // 0x0020(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AbilityTargetInfo_Actor) == 0x000008, "Wrong alignment on FM1AbilityTargetInfo_Actor");
static_assert(sizeof(FM1AbilityTargetInfo_Actor) == 0x000030, "Wrong size on FM1AbilityTargetInfo_Actor");
static_assert(offsetof(FM1AbilityTargetInfo_Actor, TargetActor) == 0x000018, "Member 'FM1AbilityTargetInfo_Actor::TargetActor' has a wrong offset!");
static_assert(offsetof(FM1AbilityTargetInfo_Actor, TargetLastLocation) == 0x000020, "Member 'FM1AbilityTargetInfo_Actor::TargetLastLocation' has a wrong offset!");

// ScriptStruct M1.M1MissionRewardInvasionSeasonExp
// 0x0010 (0x0010 - 0x0000)
struct FM1MissionRewardInvasionSeasonExp final
{
public:
	int32                                         DefaultValue;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BonusValue;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalBefore;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalAfter;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionRewardInvasionSeasonExp) == 0x000004, "Wrong alignment on FM1MissionRewardInvasionSeasonExp");
static_assert(sizeof(FM1MissionRewardInvasionSeasonExp) == 0x000010, "Wrong size on FM1MissionRewardInvasionSeasonExp");
static_assert(offsetof(FM1MissionRewardInvasionSeasonExp, DefaultValue) == 0x000000, "Member 'FM1MissionRewardInvasionSeasonExp::DefaultValue' has a wrong offset!");
static_assert(offsetof(FM1MissionRewardInvasionSeasonExp, BonusValue) == 0x000004, "Member 'FM1MissionRewardInvasionSeasonExp::BonusValue' has a wrong offset!");
static_assert(offsetof(FM1MissionRewardInvasionSeasonExp, TotalBefore) == 0x000008, "Member 'FM1MissionRewardInvasionSeasonExp::TotalBefore' has a wrong offset!");
static_assert(offsetof(FM1MissionRewardInvasionSeasonExp, TotalAfter) == 0x00000C, "Member 'FM1MissionRewardInvasionSeasonExp::TotalAfter' has a wrong offset!");

// ScriptStruct M1.M1AbilityTargetInfo_ActorArray
// 0x0030 (0x0038 - 0x0008)
struct FM1AbilityTargetInfo_ActorArray final : public FM1AbilityTargetInfo
{
public:
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          TargetActorArray;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FVector                                FirstTargetLastLocation;                           // 0x0028(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AbilityTargetInfo_ActorArray) == 0x000008, "Wrong alignment on FM1AbilityTargetInfo_ActorArray");
static_assert(sizeof(FM1AbilityTargetInfo_ActorArray) == 0x000038, "Wrong size on FM1AbilityTargetInfo_ActorArray");
static_assert(offsetof(FM1AbilityTargetInfo_ActorArray, TargetActorArray) == 0x000018, "Member 'FM1AbilityTargetInfo_ActorArray::TargetActorArray' has a wrong offset!");
static_assert(offsetof(FM1AbilityTargetInfo_ActorArray, FirstTargetLastLocation) == 0x000028, "Member 'FM1AbilityTargetInfo_ActorArray::FirstTargetLastLocation' has a wrong offset!");

// ScriptStruct M1.M1AbilityTargetInfo_SingleTargetHit
// 0x00A0 (0x00A8 - 0x0008)
struct FM1AbilityTargetInfo_SingleTargetHit final : public FM1AbilityTargetInfo
{
public:
	struct FHitResult                             HitResult;                                         // 0x0008(0x009C)(Edit, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AbilityTargetInfo_SingleTargetHit) == 0x000008, "Wrong alignment on FM1AbilityTargetInfo_SingleTargetHit");
static_assert(sizeof(FM1AbilityTargetInfo_SingleTargetHit) == 0x0000A8, "Wrong size on FM1AbilityTargetInfo_SingleTargetHit");
static_assert(offsetof(FM1AbilityTargetInfo_SingleTargetHit, HitResult) == 0x000008, "Member 'FM1AbilityTargetInfo_SingleTargetHit::HitResult' has a wrong offset!");

// ScriptStruct M1.M1RootMotionSource_MoveToDynamicForce
// 0x0010 (0x00E0 - 0x00D0)
struct FM1RootMotionSource_MoveToDynamicForce final : public FRootMotionSource_MoveToDynamicForce
{
public:
	bool                                          bEnableGravityWhenFalling;                         // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PreviousMovementMode;                              // 0x00D1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           MovePathFractionCurve;                             // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RootMotionSource_MoveToDynamicForce) == 0x000010, "Wrong alignment on FM1RootMotionSource_MoveToDynamicForce");
static_assert(sizeof(FM1RootMotionSource_MoveToDynamicForce) == 0x0000E0, "Wrong size on FM1RootMotionSource_MoveToDynamicForce");
static_assert(offsetof(FM1RootMotionSource_MoveToDynamicForce, bEnableGravityWhenFalling) == 0x0000D0, "Member 'FM1RootMotionSource_MoveToDynamicForce::bEnableGravityWhenFalling' has a wrong offset!");
static_assert(offsetof(FM1RootMotionSource_MoveToDynamicForce, PreviousMovementMode) == 0x0000D1, "Member 'FM1RootMotionSource_MoveToDynamicForce::PreviousMovementMode' has a wrong offset!");
static_assert(offsetof(FM1RootMotionSource_MoveToDynamicForce, MovePathFractionCurve) == 0x0000D8, "Member 'FM1RootMotionSource_MoveToDynamicForce::MovePathFractionCurve' has a wrong offset!");

// ScriptStruct M1.M1StatRefDesc
// 0x0003 (0x0003 - 0x0000)
struct FM1StatRefDesc final
{
public:
	EM1StatType                                   StatType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1StatRefType                                StatRefType;                                       // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreOverride;                                    // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StatRefDesc) == 0x000001, "Wrong alignment on FM1StatRefDesc");
static_assert(sizeof(FM1StatRefDesc) == 0x000003, "Wrong size on FM1StatRefDesc");
static_assert(offsetof(FM1StatRefDesc, StatType) == 0x000000, "Member 'FM1StatRefDesc::StatType' has a wrong offset!");
static_assert(offsetof(FM1StatRefDesc, StatRefType) == 0x000001, "Member 'FM1StatRefDesc::StatRefType' has a wrong offset!");
static_assert(offsetof(FM1StatRefDesc, IgnoreOverride) == 0x000002, "Member 'FM1StatRefDesc::IgnoreOverride' has a wrong offset!");

// ScriptStruct M1.M1ActiveAbilityOperationId
// 0x0000 (0x0010 - 0x0010)
struct FM1ActiveAbilityOperationId final : public FM1IntegerId
{
};
static_assert(alignof(FM1ActiveAbilityOperationId) == 0x000008, "Wrong alignment on FM1ActiveAbilityOperationId");
static_assert(sizeof(FM1ActiveAbilityOperationId) == 0x000010, "Wrong size on FM1ActiveAbilityOperationId");

// ScriptStruct M1.M1NxLog_Asset
// 0x0030 (0x0030 - 0x0000)
struct FM1NxLog_Asset final
{
public:
	class FString                                 Assetcategory;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Assettype;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Cnt;                                               // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_Asset) == 0x000008, "Wrong alignment on FM1NxLog_Asset");
static_assert(sizeof(FM1NxLog_Asset) == 0x000030, "Wrong size on FM1NxLog_Asset");
static_assert(offsetof(FM1NxLog_Asset, Assetcategory) == 0x000000, "Member 'FM1NxLog_Asset::Assetcategory' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Asset, Assettype) == 0x000010, "Member 'FM1NxLog_Asset::Assettype' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Asset, Cnt) == 0x000020, "Member 'FM1NxLog_Asset::Cnt' has a wrong offset!");

// ScriptStruct M1.M1AbilityOperationHandle
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FM1AbilityOperationHandle final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AbilityOperationHandle) == 0x000008, "Wrong alignment on FM1AbilityOperationHandle");
static_assert(sizeof(FM1AbilityOperationHandle) == 0x000010, "Wrong size on FM1AbilityOperationHandle");

// ScriptStruct M1.M1TaggedAbilityOperationHandle
// 0x0018 (0x0018 - 0x0000)
struct FM1TaggedAbilityOperationHandle final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1AbilityOperationHandle              Operation;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TaggedAbilityOperationHandle) == 0x000008, "Wrong alignment on FM1TaggedAbilityOperationHandle");
static_assert(sizeof(FM1TaggedAbilityOperationHandle) == 0x000018, "Wrong size on FM1TaggedAbilityOperationHandle");
static_assert(offsetof(FM1TaggedAbilityOperationHandle, Tag) == 0x000000, "Member 'FM1TaggedAbilityOperationHandle::Tag' has a wrong offset!");
static_assert(offsetof(FM1TaggedAbilityOperationHandle, Operation) == 0x000008, "Member 'FM1TaggedAbilityOperationHandle::Operation' has a wrong offset!");

// ScriptStruct M1.M1AbilityOwnerInfo
// 0x0038 (0x0038 - 0x0000)
struct FM1AbilityOwnerInfo final
{
public:
	TWeakObjectPtr<class AActor>                  OwnerActor;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UM1AbilityComponent>     AbilityComponent;                                  // 0x0008(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UM1StatusEffectComponent> StatusEffectComponent;                             // 0x0010(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UM1StatComponent>        StatComponent;                                     // 0x0018(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USkeletalMeshComponent>  SkeletalMeshComponent;                             // 0x0020(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UMovementComponent>      MovementComponent;                                 // 0x0028(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UM1QueryServiceComponent> QueryServiceComponent;                             // 0x0030(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityOwnerInfo) == 0x000004, "Wrong alignment on FM1AbilityOwnerInfo");
static_assert(sizeof(FM1AbilityOwnerInfo) == 0x000038, "Wrong size on FM1AbilityOwnerInfo");
static_assert(offsetof(FM1AbilityOwnerInfo, OwnerActor) == 0x000000, "Member 'FM1AbilityOwnerInfo::OwnerActor' has a wrong offset!");
static_assert(offsetof(FM1AbilityOwnerInfo, AbilityComponent) == 0x000008, "Member 'FM1AbilityOwnerInfo::AbilityComponent' has a wrong offset!");
static_assert(offsetof(FM1AbilityOwnerInfo, StatusEffectComponent) == 0x000010, "Member 'FM1AbilityOwnerInfo::StatusEffectComponent' has a wrong offset!");
static_assert(offsetof(FM1AbilityOwnerInfo, StatComponent) == 0x000018, "Member 'FM1AbilityOwnerInfo::StatComponent' has a wrong offset!");
static_assert(offsetof(FM1AbilityOwnerInfo, SkeletalMeshComponent) == 0x000020, "Member 'FM1AbilityOwnerInfo::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(FM1AbilityOwnerInfo, MovementComponent) == 0x000028, "Member 'FM1AbilityOwnerInfo::MovementComponent' has a wrong offset!");
static_assert(offsetof(FM1AbilityOwnerInfo, QueryServiceComponent) == 0x000030, "Member 'FM1AbilityOwnerInfo::QueryServiceComponent' has a wrong offset!");

// ScriptStruct M1.M1AbilityContext
// 0x0080 (0x0080 - 0x0000)
struct FM1AbilityContext final
{
public:
	TWeakObjectPtr<class AActor>                  Instigator;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AActor>                  Causer;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         InstigatorTeamId;                                  // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UM1Ability>              Ability;                                           // 0x0014(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1AbilityTargetInfoHandle             TargetInfo;                                        // 0x0020(0x0020)(Transient, NativeAccessSpecifierPublic)
	TArray<struct FM1TaggedAbilityOperationHandle> Operations;                                        // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1AbilityParamData>            Params;                                            // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1TaggedAbilityParamData>      TaggedParams;                                      // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AActor>>          DamageEventObservers;                              // 0x0070(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityContext) == 0x000008, "Wrong alignment on FM1AbilityContext");
static_assert(sizeof(FM1AbilityContext) == 0x000080, "Wrong size on FM1AbilityContext");
static_assert(offsetof(FM1AbilityContext, Instigator) == 0x000000, "Member 'FM1AbilityContext::Instigator' has a wrong offset!");
static_assert(offsetof(FM1AbilityContext, Causer) == 0x000008, "Member 'FM1AbilityContext::Causer' has a wrong offset!");
static_assert(offsetof(FM1AbilityContext, InstigatorTeamId) == 0x000010, "Member 'FM1AbilityContext::InstigatorTeamId' has a wrong offset!");
static_assert(offsetof(FM1AbilityContext, Ability) == 0x000014, "Member 'FM1AbilityContext::Ability' has a wrong offset!");
static_assert(offsetof(FM1AbilityContext, TargetInfo) == 0x000020, "Member 'FM1AbilityContext::TargetInfo' has a wrong offset!");
static_assert(offsetof(FM1AbilityContext, Operations) == 0x000040, "Member 'FM1AbilityContext::Operations' has a wrong offset!");
static_assert(offsetof(FM1AbilityContext, Params) == 0x000050, "Member 'FM1AbilityContext::Params' has a wrong offset!");
static_assert(offsetof(FM1AbilityContext, TaggedParams) == 0x000060, "Member 'FM1AbilityContext::TaggedParams' has a wrong offset!");
static_assert(offsetof(FM1AbilityContext, DamageEventObservers) == 0x000070, "Member 'FM1AbilityContext::DamageEventObservers' has a wrong offset!");

// ScriptStruct M1.M1DropContainerParam
// 0x0020 (0x0020 - 0x0000)
struct FM1DropContainerParam final
{
public:
	class AM1Monster*                             Monster;                                           // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UM1MonsterPartsComponent*               Parts;                                             // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AM1Player*>                      ObtainablePlayers;                                 // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DropContainerParam) == 0x000008, "Wrong alignment on FM1DropContainerParam");
static_assert(sizeof(FM1DropContainerParam) == 0x000020, "Wrong size on FM1DropContainerParam");
static_assert(offsetof(FM1DropContainerParam, Monster) == 0x000000, "Member 'FM1DropContainerParam::Monster' has a wrong offset!");
static_assert(offsetof(FM1DropContainerParam, Parts) == 0x000008, "Member 'FM1DropContainerParam::Parts' has a wrong offset!");
static_assert(offsetof(FM1DropContainerParam, ObtainablePlayers) == 0x000010, "Member 'FM1DropContainerParam::ObtainablePlayers' has a wrong offset!");

// ScriptStruct M1.M1WeaponPreviewCustomInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1WeaponPreviewCustomInfo final
{
public:
	struct FVector                                Offset;                                            // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraDistance;                                    // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponPreviewCustomInfo) == 0x000004, "Wrong alignment on FM1WeaponPreviewCustomInfo");
static_assert(sizeof(FM1WeaponPreviewCustomInfo) == 0x000020, "Wrong size on FM1WeaponPreviewCustomInfo");
static_assert(offsetof(FM1WeaponPreviewCustomInfo, Offset) == 0x000000, "Member 'FM1WeaponPreviewCustomInfo::Offset' has a wrong offset!");
static_assert(offsetof(FM1WeaponPreviewCustomInfo, Rotation) == 0x00000C, "Member 'FM1WeaponPreviewCustomInfo::Rotation' has a wrong offset!");
static_assert(offsetof(FM1WeaponPreviewCustomInfo, Scale) == 0x000018, "Member 'FM1WeaponPreviewCustomInfo::Scale' has a wrong offset!");
static_assert(offsetof(FM1WeaponPreviewCustomInfo, CameraDistance) == 0x00001C, "Member 'FM1WeaponPreviewCustomInfo::CameraDistance' has a wrong offset!");

// ScriptStruct M1.M1AbilityOperationParam
// 0x00B0 (0x00B0 - 0x0000)
struct FM1AbilityOperationParam final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x009C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1AbilityParamData>            Params;                                            // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityOperationParam) == 0x000008, "Wrong alignment on FM1AbilityOperationParam");
static_assert(sizeof(FM1AbilityOperationParam) == 0x0000B0, "Wrong size on FM1AbilityOperationParam");
static_assert(offsetof(FM1AbilityOperationParam, HitResult) == 0x000000, "Member 'FM1AbilityOperationParam::HitResult' has a wrong offset!");
static_assert(offsetof(FM1AbilityOperationParam, Params) == 0x0000A0, "Member 'FM1AbilityOperationParam::Params' has a wrong offset!");

// ScriptStruct M1.M1PlayerReviveSuccessed
// 0x0000 (0x0020 - 0x0020)
struct FM1PlayerReviveSuccessed final : public FM1Statistics
{
};
static_assert(alignof(FM1PlayerReviveSuccessed) == 0x000008, "Wrong alignment on FM1PlayerReviveSuccessed");
static_assert(sizeof(FM1PlayerReviveSuccessed) == 0x000020, "Wrong size on FM1PlayerReviveSuccessed");

// ScriptStruct M1.M1AbilityInputEvent
// 0x0002 (0x0002 - 0x0000)
struct FM1AbilityInputEvent final
{
public:
	EM1BattleKey                                  GameKey;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputEvent                                   InputEvent;                                        // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityInputEvent) == 0x000001, "Wrong alignment on FM1AbilityInputEvent");
static_assert(sizeof(FM1AbilityInputEvent) == 0x000002, "Wrong size on FM1AbilityInputEvent");
static_assert(offsetof(FM1AbilityInputEvent, GameKey) == 0x000000, "Member 'FM1AbilityInputEvent::GameKey' has a wrong offset!");
static_assert(offsetof(FM1AbilityInputEvent, InputEvent) == 0x000001, "Member 'FM1AbilityInputEvent::InputEvent' has a wrong offset!");

// ScriptStruct M1.M1WeaponFireAnimParams
// 0x0008 (0x0008 - 0x0000)
struct FM1WeaponFireAnimParams final
{
public:
	float                                         PlayRate;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayTime;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponFireAnimParams) == 0x000004, "Wrong alignment on FM1WeaponFireAnimParams");
static_assert(sizeof(FM1WeaponFireAnimParams) == 0x000008, "Wrong size on FM1WeaponFireAnimParams");
static_assert(offsetof(FM1WeaponFireAnimParams, PlayRate) == 0x000000, "Member 'FM1WeaponFireAnimParams::PlayRate' has a wrong offset!");
static_assert(offsetof(FM1WeaponFireAnimParams, PlayTime) == 0x000004, "Member 'FM1WeaponFireAnimParams::PlayTime' has a wrong offset!");

// ScriptStruct M1.WhichGameStarted
// 0x0008 (0x0028 - 0x0020)
struct FWhichGameStarted final : public FM1Statistics
{
public:
	int32                                         InPlayerCount;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWhichGameStarted) == 0x000008, "Wrong alignment on FWhichGameStarted");
static_assert(sizeof(FWhichGameStarted) == 0x000028, "Wrong size on FWhichGameStarted");
static_assert(offsetof(FWhichGameStarted, InPlayerCount) == 0x000020, "Member 'FWhichGameStarted::InPlayerCount' has a wrong offset!");

// ScriptStruct M1.M1AbilityAutoExecuteTags
// 0x00A0 (0x00A0 - 0x0000)
struct FM1AbilityAutoExecuteTags final
{
public:
	struct FGameplayTagContainer                  ExecuteOperationTags;                              // 0x0000(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InvokeStatusEffectTags;                            // 0x0020(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ForwardOperationTags_ToStatusEffect;               // 0x0040(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  SpawnAbilityActorTags;                             // 0x0060(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ForwardOperationTags_ToAbilityActor;               // 0x0080(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityAutoExecuteTags) == 0x000008, "Wrong alignment on FM1AbilityAutoExecuteTags");
static_assert(sizeof(FM1AbilityAutoExecuteTags) == 0x0000A0, "Wrong size on FM1AbilityAutoExecuteTags");
static_assert(offsetof(FM1AbilityAutoExecuteTags, ExecuteOperationTags) == 0x000000, "Member 'FM1AbilityAutoExecuteTags::ExecuteOperationTags' has a wrong offset!");
static_assert(offsetof(FM1AbilityAutoExecuteTags, InvokeStatusEffectTags) == 0x000020, "Member 'FM1AbilityAutoExecuteTags::InvokeStatusEffectTags' has a wrong offset!");
static_assert(offsetof(FM1AbilityAutoExecuteTags, ForwardOperationTags_ToStatusEffect) == 0x000040, "Member 'FM1AbilityAutoExecuteTags::ForwardOperationTags_ToStatusEffect' has a wrong offset!");
static_assert(offsetof(FM1AbilityAutoExecuteTags, SpawnAbilityActorTags) == 0x000060, "Member 'FM1AbilityAutoExecuteTags::SpawnAbilityActorTags' has a wrong offset!");
static_assert(offsetof(FM1AbilityAutoExecuteTags, ForwardOperationTags_ToAbilityActor) == 0x000080, "Member 'FM1AbilityAutoExecuteTags::ForwardOperationTags_ToAbilityActor' has a wrong offset!");

// ScriptStruct M1.M1MonsterTargetDebugData
// 0x0010 (0x0010 - 0x0000)
struct FM1MonsterTargetDebugData final
{
public:
	bool                                          bTargetValid;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTargetVisible;                                    // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VisibleCheckLocation;                              // 0x0004(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterTargetDebugData) == 0x000004, "Wrong alignment on FM1MonsterTargetDebugData");
static_assert(sizeof(FM1MonsterTargetDebugData) == 0x000010, "Wrong size on FM1MonsterTargetDebugData");
static_assert(offsetof(FM1MonsterTargetDebugData, bTargetValid) == 0x000000, "Member 'FM1MonsterTargetDebugData::bTargetValid' has a wrong offset!");
static_assert(offsetof(FM1MonsterTargetDebugData, bTargetVisible) == 0x000001, "Member 'FM1MonsterTargetDebugData::bTargetVisible' has a wrong offset!");
static_assert(offsetof(FM1MonsterTargetDebugData, VisibleCheckLocation) == 0x000004, "Member 'FM1MonsterTargetDebugData::VisibleCheckLocation' has a wrong offset!");

// ScriptStruct M1.M1AbilityProjectilePathPoint
// 0x0040 (0x0040 - 0x0000)
struct FM1AbilityProjectilePathPoint final
{
public:
	float                                         EstimatedTime;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityProjectilePathPoint) == 0x000010, "Wrong alignment on FM1AbilityProjectilePathPoint");
static_assert(sizeof(FM1AbilityProjectilePathPoint) == 0x000040, "Wrong size on FM1AbilityProjectilePathPoint");
static_assert(offsetof(FM1AbilityProjectilePathPoint, EstimatedTime) == 0x000000, "Member 'FM1AbilityProjectilePathPoint::EstimatedTime' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathPoint, Transform) == 0x000010, "Member 'FM1AbilityProjectilePathPoint::Transform' has a wrong offset!");

// ScriptStruct M1.M1AbilityProjectilePathData
// 0x0010 (0x0010 - 0x0000)
struct FM1AbilityProjectilePathData final
{
public:
	TArray<struct FM1AbilityProjectilePathPoint>  Points;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityProjectilePathData) == 0x000008, "Wrong alignment on FM1AbilityProjectilePathData");
static_assert(sizeof(FM1AbilityProjectilePathData) == 0x000010, "Wrong size on FM1AbilityProjectilePathData");
static_assert(offsetof(FM1AbilityProjectilePathData, Points) == 0x000000, "Member 'FM1AbilityProjectilePathData::Points' has a wrong offset!");

// ScriptStruct M1.M1AbilityProjectilePathPoint_NetQuantize
// 0x0010 (0x0010 - 0x0000)
struct FM1AbilityProjectilePathPoint_NetQuantize final
{
public:
	float                                         EstimatedTime;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    Location;                                          // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityProjectilePathPoint_NetQuantize) == 0x000004, "Wrong alignment on FM1AbilityProjectilePathPoint_NetQuantize");
static_assert(sizeof(FM1AbilityProjectilePathPoint_NetQuantize) == 0x000010, "Wrong size on FM1AbilityProjectilePathPoint_NetQuantize");
static_assert(offsetof(FM1AbilityProjectilePathPoint_NetQuantize, EstimatedTime) == 0x000000, "Member 'FM1AbilityProjectilePathPoint_NetQuantize::EstimatedTime' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathPoint_NetQuantize, Location) == 0x000004, "Member 'FM1AbilityProjectilePathPoint_NetQuantize::Location' has a wrong offset!");

// ScriptStruct M1.M1AbilityProjectilePathData_NetQuantize
// 0x0020 (0x0020 - 0x0000)
struct FM1AbilityProjectilePathData_NetQuantize final
{
public:
	struct FVector_NetQuantize                    InitialDir;                                        // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1AbilityProjectilePathPoint_NetQuantize> Points;                                            // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityProjectilePathData_NetQuantize) == 0x000008, "Wrong alignment on FM1AbilityProjectilePathData_NetQuantize");
static_assert(sizeof(FM1AbilityProjectilePathData_NetQuantize) == 0x000020, "Wrong size on FM1AbilityProjectilePathData_NetQuantize");
static_assert(offsetof(FM1AbilityProjectilePathData_NetQuantize, InitialDir) == 0x000000, "Member 'FM1AbilityProjectilePathData_NetQuantize::InitialDir' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathData_NetQuantize, Points) == 0x000010, "Member 'FM1AbilityProjectilePathData_NetQuantize::Points' has a wrong offset!");

// ScriptStruct M1.M1AbilityProjectilePathPredictionParams_CustomArc
// 0x0048 (0x0048 - 0x0000)
struct FM1AbilityProjectilePathPredictionParams_CustomArc final
{
public:
	struct FVector                                StartLocation;                                     // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArcValue;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileRadius;                                  // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceWithCollision;                               // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSimTime;                                        // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimFrequency;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AbilityProjectilePathPredictionParams_CustomArc) == 0x000008, "Wrong alignment on FM1AbilityProjectilePathPredictionParams_CustomArc");
static_assert(sizeof(FM1AbilityProjectilePathPredictionParams_CustomArc) == 0x000048, "Wrong size on FM1AbilityProjectilePathPredictionParams_CustomArc");
static_assert(offsetof(FM1AbilityProjectilePathPredictionParams_CustomArc, StartLocation) == 0x000000, "Member 'FM1AbilityProjectilePathPredictionParams_CustomArc::StartLocation' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathPredictionParams_CustomArc, TargetLocation) == 0x00000C, "Member 'FM1AbilityProjectilePathPredictionParams_CustomArc::TargetLocation' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathPredictionParams_CustomArc, ArcValue) == 0x000018, "Member 'FM1AbilityProjectilePathPredictionParams_CustomArc::ArcValue' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathPredictionParams_CustomArc, ProjectileRadius) == 0x00001C, "Member 'FM1AbilityProjectilePathPredictionParams_CustomArc::ProjectileRadius' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathPredictionParams_CustomArc, bTraceWithCollision) == 0x000020, "Member 'FM1AbilityProjectilePathPredictionParams_CustomArc::bTraceWithCollision' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathPredictionParams_CustomArc, TraceChannel) == 0x000021, "Member 'FM1AbilityProjectilePathPredictionParams_CustomArc::TraceChannel' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathPredictionParams_CustomArc, ObjectTypes) == 0x000028, "Member 'FM1AbilityProjectilePathPredictionParams_CustomArc::ObjectTypes' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathPredictionParams_CustomArc, bTraceComplex) == 0x000038, "Member 'FM1AbilityProjectilePathPredictionParams_CustomArc::bTraceComplex' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathPredictionParams_CustomArc, MaxSimTime) == 0x00003C, "Member 'FM1AbilityProjectilePathPredictionParams_CustomArc::MaxSimTime' has a wrong offset!");
static_assert(offsetof(FM1AbilityProjectilePathPredictionParams_CustomArc, SimFrequency) == 0x000040, "Member 'FM1AbilityProjectilePathPredictionParams_CustomArc::SimFrequency' has a wrong offset!");

// ScriptStruct M1.M1MiniGameItemChangeInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1MiniGameItemChangeInfo final
{
public:
	bool                                          bIncrease;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ItemUid;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ItemTid;                                           // 0x0010(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChangeCount;                                       // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeforeChangeCount;                                 // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AfterChangeCount;                                  // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MiniGameItemChangeInfo) == 0x000008, "Wrong alignment on FM1MiniGameItemChangeInfo");
static_assert(sizeof(FM1MiniGameItemChangeInfo) == 0x000020, "Wrong size on FM1MiniGameItemChangeInfo");
static_assert(offsetof(FM1MiniGameItemChangeInfo, bIncrease) == 0x000000, "Member 'FM1MiniGameItemChangeInfo::bIncrease' has a wrong offset!");
static_assert(offsetof(FM1MiniGameItemChangeInfo, ItemUid) == 0x000008, "Member 'FM1MiniGameItemChangeInfo::ItemUid' has a wrong offset!");
static_assert(offsetof(FM1MiniGameItemChangeInfo, ItemTid) == 0x000010, "Member 'FM1MiniGameItemChangeInfo::ItemTid' has a wrong offset!");
static_assert(offsetof(FM1MiniGameItemChangeInfo, ChangeCount) == 0x000014, "Member 'FM1MiniGameItemChangeInfo::ChangeCount' has a wrong offset!");
static_assert(offsetof(FM1MiniGameItemChangeInfo, BeforeChangeCount) == 0x000018, "Member 'FM1MiniGameItemChangeInfo::BeforeChangeCount' has a wrong offset!");
static_assert(offsetof(FM1MiniGameItemChangeInfo, AfterChangeCount) == 0x00001C, "Member 'FM1MiniGameItemChangeInfo::AfterChangeCount' has a wrong offset!");

// ScriptStruct M1.M1WeaponChangeAnimation
// 0x0020 (0x0020 - 0x0000)
struct FM1WeaponChangeAnimation final
{
public:
	class UAnimSequence*                          EquipAnim;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          UnEquipAnim;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EquipPlayRate;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnEquipPlayRate;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGetEquipAnimFromWeapon;                           // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGetUnEquipAnimFromWeapon;                         // 0x0019(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipTargetWeaponEquipAnim;                        // 0x001A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipSourceWeaponUnEquipAnim;                      // 0x001B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1WeaponChangeAnimation) == 0x000008, "Wrong alignment on FM1WeaponChangeAnimation");
static_assert(sizeof(FM1WeaponChangeAnimation) == 0x000020, "Wrong size on FM1WeaponChangeAnimation");
static_assert(offsetof(FM1WeaponChangeAnimation, EquipAnim) == 0x000000, "Member 'FM1WeaponChangeAnimation::EquipAnim' has a wrong offset!");
static_assert(offsetof(FM1WeaponChangeAnimation, UnEquipAnim) == 0x000008, "Member 'FM1WeaponChangeAnimation::UnEquipAnim' has a wrong offset!");
static_assert(offsetof(FM1WeaponChangeAnimation, EquipPlayRate) == 0x000010, "Member 'FM1WeaponChangeAnimation::EquipPlayRate' has a wrong offset!");
static_assert(offsetof(FM1WeaponChangeAnimation, UnEquipPlayRate) == 0x000014, "Member 'FM1WeaponChangeAnimation::UnEquipPlayRate' has a wrong offset!");
static_assert(offsetof(FM1WeaponChangeAnimation, bGetEquipAnimFromWeapon) == 0x000018, "Member 'FM1WeaponChangeAnimation::bGetEquipAnimFromWeapon' has a wrong offset!");
static_assert(offsetof(FM1WeaponChangeAnimation, bGetUnEquipAnimFromWeapon) == 0x000019, "Member 'FM1WeaponChangeAnimation::bGetUnEquipAnimFromWeapon' has a wrong offset!");
static_assert(offsetof(FM1WeaponChangeAnimation, bSkipTargetWeaponEquipAnim) == 0x00001A, "Member 'FM1WeaponChangeAnimation::bSkipTargetWeaponEquipAnim' has a wrong offset!");
static_assert(offsetof(FM1WeaponChangeAnimation, bSkipSourceWeaponUnEquipAnim) == 0x00001B, "Member 'FM1WeaponChangeAnimation::bSkipSourceWeaponUnEquipAnim' has a wrong offset!");

// ScriptStruct M1.M1WeaponChangeAnimationSetting
// 0x0040 (0x0040 - 0x0000)
struct FM1WeaponChangeAnimationSetting final
{
public:
	struct FM1WeaponChangeAnimation               MaleAnimation;                                     // 0x0000(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1WeaponChangeAnimation               FemaleAnimation;                                   // 0x0020(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponChangeAnimationSetting) == 0x000008, "Wrong alignment on FM1WeaponChangeAnimationSetting");
static_assert(sizeof(FM1WeaponChangeAnimationSetting) == 0x000040, "Wrong size on FM1WeaponChangeAnimationSetting");
static_assert(offsetof(FM1WeaponChangeAnimationSetting, MaleAnimation) == 0x000000, "Member 'FM1WeaponChangeAnimationSetting::MaleAnimation' has a wrong offset!");
static_assert(offsetof(FM1WeaponChangeAnimationSetting, FemaleAnimation) == 0x000020, "Member 'FM1WeaponChangeAnimationSetting::FemaleAnimation' has a wrong offset!");

// ScriptStruct M1.M1BattlePassSeasonInfoWrapper
// 0x0028 (0x0028 - 0x0000)
struct FM1BattlePassSeasonInfoWrapper final
{
public:
	struct FM1BattlePassSeasonInfo                SeasonInfo;                                        // 0x0000(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEventSeason;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1BattlePassSeasonInfoWrapper) == 0x000008, "Wrong alignment on FM1BattlePassSeasonInfoWrapper");
static_assert(sizeof(FM1BattlePassSeasonInfoWrapper) == 0x000028, "Wrong size on FM1BattlePassSeasonInfoWrapper");
static_assert(offsetof(FM1BattlePassSeasonInfoWrapper, SeasonInfo) == 0x000000, "Member 'FM1BattlePassSeasonInfoWrapper::SeasonInfo' has a wrong offset!");
static_assert(offsetof(FM1BattlePassSeasonInfoWrapper, bEventSeason) == 0x000020, "Member 'FM1BattlePassSeasonInfoWrapper::bEventSeason' has a wrong offset!");

// ScriptStruct M1.M1MonsterBattlePattern
// 0x0030 (0x0050 - 0x0020)
struct FM1MonsterBattlePattern final : public FM1Statistics
{
public:
	class FString                                 WeaponName;                                        // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHit;                                              // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 HitCharacterIDs;                                   // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         TotalDamage;                                       // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitCharacterLength;                                // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterBattlePattern) == 0x000008, "Wrong alignment on FM1MonsterBattlePattern");
static_assert(sizeof(FM1MonsterBattlePattern) == 0x000050, "Wrong size on FM1MonsterBattlePattern");
static_assert(offsetof(FM1MonsterBattlePattern, WeaponName) == 0x000020, "Member 'FM1MonsterBattlePattern::WeaponName' has a wrong offset!");
static_assert(offsetof(FM1MonsterBattlePattern, bHit) == 0x000030, "Member 'FM1MonsterBattlePattern::bHit' has a wrong offset!");
static_assert(offsetof(FM1MonsterBattlePattern, HitCharacterIDs) == 0x000038, "Member 'FM1MonsterBattlePattern::HitCharacterIDs' has a wrong offset!");
static_assert(offsetof(FM1MonsterBattlePattern, TotalDamage) == 0x000048, "Member 'FM1MonsterBattlePattern::TotalDamage' has a wrong offset!");
static_assert(offsetof(FM1MonsterBattlePattern, HitCharacterLength) == 0x00004C, "Member 'FM1MonsterBattlePattern::HitCharacterLength' has a wrong offset!");

// ScriptStruct M1.M1BattlePassLevelPurchaseInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1BattlePassLevelPurchaseInfo final
{
public:
	int32                                         OldLevel;                                          // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldExp;                                            // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldRequiredExp;                                    // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewLevel;                                          // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewExp;                                            // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewRequiredExp;                                    // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattlePassLevelPurchaseInfo) == 0x000004, "Wrong alignment on FM1BattlePassLevelPurchaseInfo");
static_assert(sizeof(FM1BattlePassLevelPurchaseInfo) == 0x000018, "Wrong size on FM1BattlePassLevelPurchaseInfo");
static_assert(offsetof(FM1BattlePassLevelPurchaseInfo, OldLevel) == 0x000000, "Member 'FM1BattlePassLevelPurchaseInfo::OldLevel' has a wrong offset!");
static_assert(offsetof(FM1BattlePassLevelPurchaseInfo, OldExp) == 0x000004, "Member 'FM1BattlePassLevelPurchaseInfo::OldExp' has a wrong offset!");
static_assert(offsetof(FM1BattlePassLevelPurchaseInfo, OldRequiredExp) == 0x000008, "Member 'FM1BattlePassLevelPurchaseInfo::OldRequiredExp' has a wrong offset!");
static_assert(offsetof(FM1BattlePassLevelPurchaseInfo, NewLevel) == 0x00000C, "Member 'FM1BattlePassLevelPurchaseInfo::NewLevel' has a wrong offset!");
static_assert(offsetof(FM1BattlePassLevelPurchaseInfo, NewExp) == 0x000010, "Member 'FM1BattlePassLevelPurchaseInfo::NewExp' has a wrong offset!");
static_assert(offsetof(FM1BattlePassLevelPurchaseInfo, NewRequiredExp) == 0x000014, "Member 'FM1BattlePassLevelPurchaseInfo::NewRequiredExp' has a wrong offset!");

// ScriptStruct M1.M1WeaponReloadingState
// 0x0004 (0x0004 - 0x0000)
struct FM1WeaponReloadingState final
{
public:
	EM1WeaponReloadState                          WeaponReloadState;                                 // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponReloadingState) == 0x000004, "Wrong alignment on FM1WeaponReloadingState");
static_assert(sizeof(FM1WeaponReloadingState) == 0x000004, "Wrong size on FM1WeaponReloadingState");
static_assert(offsetof(FM1WeaponReloadingState, WeaponReloadState) == 0x000000, "Member 'FM1WeaponReloadingState::WeaponReloadState' has a wrong offset!");

// ScriptStruct M1.M1PlayerReviveFailed
// 0x0008 (0x0028 - 0x0020)
struct FM1PlayerReviveFailed final : public FM1Statistics
{
public:
	float                                         InteractionTime;                                   // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PlayerReviveFailed) == 0x000008, "Wrong alignment on FM1PlayerReviveFailed");
static_assert(sizeof(FM1PlayerReviveFailed) == 0x000028, "Wrong size on FM1PlayerReviveFailed");
static_assert(offsetof(FM1PlayerReviveFailed, InteractionTime) == 0x000020, "Member 'FM1PlayerReviveFailed::InteractionTime' has a wrong offset!");

// ScriptStruct M1.M1BoostInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FM1BoostInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1BoostInfo) == 0x000008, "Wrong alignment on FM1BoostInfo");
static_assert(sizeof(FM1BoostInfo) == 0x000018, "Wrong size on FM1BoostInfo");

// ScriptStruct M1.M1MissionTargetMarkerInfo
// 0x0028 (0x0028 - 0x0000)
struct FM1MissionTargetMarkerInfo final
{
public:
	EM1MissionTargetType                          Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Marker;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            Color;                                             // 0x0010(0x0014)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MissionTargetMarkerInfo) == 0x000008, "Wrong alignment on FM1MissionTargetMarkerInfo");
static_assert(sizeof(FM1MissionTargetMarkerInfo) == 0x000028, "Wrong size on FM1MissionTargetMarkerInfo");
static_assert(offsetof(FM1MissionTargetMarkerInfo, Type) == 0x000000, "Member 'FM1MissionTargetMarkerInfo::Type' has a wrong offset!");
static_assert(offsetof(FM1MissionTargetMarkerInfo, Marker) == 0x000008, "Member 'FM1MissionTargetMarkerInfo::Marker' has a wrong offset!");
static_assert(offsetof(FM1MissionTargetMarkerInfo, Color) == 0x000010, "Member 'FM1MissionTargetMarkerInfo::Color' has a wrong offset!");

// ScriptStruct M1.M1InvasionDungeonInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1InvasionDungeonInfo final
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AcquierdSeasonExp;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1TemplateId>                  ModifierTids;                                      // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InvasionDungeonInfo) == 0x000008, "Wrong alignment on FM1InvasionDungeonInfo");
static_assert(sizeof(FM1InvasionDungeonInfo) == 0x000018, "Wrong size on FM1InvasionDungeonInfo");
static_assert(offsetof(FM1InvasionDungeonInfo, TemplateId) == 0x000000, "Member 'FM1InvasionDungeonInfo::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonInfo, AcquierdSeasonExp) == 0x000004, "Member 'FM1InvasionDungeonInfo::AcquierdSeasonExp' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonInfo, ModifierTids) == 0x000008, "Member 'FM1InvasionDungeonInfo::ModifierTids' has a wrong offset!");

// ScriptStruct M1.M1OptionalDummyItemCreationParam
// 0x0020 (0x0020 - 0x0000)
struct FM1OptionalDummyItemCreationParam final
{
public:
	int64                                         Count;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1EquipmentRandomOptionInfo>   EquipmentItemRandomOpts;                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1OptionalDummyItemCreationParam) == 0x000008, "Wrong alignment on FM1OptionalDummyItemCreationParam");
static_assert(sizeof(FM1OptionalDummyItemCreationParam) == 0x000020, "Wrong size on FM1OptionalDummyItemCreationParam");
static_assert(offsetof(FM1OptionalDummyItemCreationParam, Count) == 0x000000, "Member 'FM1OptionalDummyItemCreationParam::Count' has a wrong offset!");
static_assert(offsetof(FM1OptionalDummyItemCreationParam, Level) == 0x000008, "Member 'FM1OptionalDummyItemCreationParam::Level' has a wrong offset!");
static_assert(offsetof(FM1OptionalDummyItemCreationParam, EquipmentItemRandomOpts) == 0x000010, "Member 'FM1OptionalDummyItemCreationParam::EquipmentItemRandomOpts' has a wrong offset!");

// ScriptStruct M1.M1InventoryItemList
// 0x0050 (0x0050 - 0x0000)
struct FM1InventoryItemList final
{
public:
	TMap<int64, class UM1InventoryItem*>          Items;                                             // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InventoryItemList) == 0x000008, "Wrong alignment on FM1InventoryItemList");
static_assert(sizeof(FM1InventoryItemList) == 0x000050, "Wrong size on FM1InventoryItemList");
static_assert(offsetof(FM1InventoryItemList, Items) == 0x000000, "Member 'FM1InventoryItemList::Items' has a wrong offset!");

// ScriptStruct M1.M1WeaponProficiency
// 0x0010 (0x0010 - 0x0000)
struct FM1WeaponProficiency final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Exp;                                               // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponProficiency) == 0x000008, "Wrong alignment on FM1WeaponProficiency");
static_assert(sizeof(FM1WeaponProficiency) == 0x000010, "Wrong size on FM1WeaponProficiency");
static_assert(offsetof(FM1WeaponProficiency, Level) == 0x000000, "Member 'FM1WeaponProficiency::Level' has a wrong offset!");
static_assert(offsetof(FM1WeaponProficiency, Exp) == 0x000008, "Member 'FM1WeaponProficiency::Exp' has a wrong offset!");

// ScriptStruct M1.M1TickableDelegateContext
// 0x0010 (0x0028 - 0x0018)
struct FM1TickableDelegateContext final : public FM1TickableDelegateBaseContext
{
public:
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1TickableDelegateContext) == 0x000008, "Wrong alignment on FM1TickableDelegateContext");
static_assert(sizeof(FM1TickableDelegateContext) == 0x000028, "Wrong size on FM1TickableDelegateContext");

// ScriptStruct M1.M1BattleStatistics_Skill
// 0x0028 (0x0028 - 0x0000)
struct FM1BattleStatistics_Skill final
{
public:
	struct FGameplayTag                           TraitTag;                                          // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SkillId;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         UseCount;                                          // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ScaledInteger                       TotalDamage;                                       // 0x0020(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattleStatistics_Skill) == 0x000008, "Wrong alignment on FM1BattleStatistics_Skill");
static_assert(sizeof(FM1BattleStatistics_Skill) == 0x000028, "Wrong size on FM1BattleStatistics_Skill");
static_assert(offsetof(FM1BattleStatistics_Skill, TraitTag) == 0x000000, "Member 'FM1BattleStatistics_Skill::TraitTag' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_Skill, SkillId) == 0x000008, "Member 'FM1BattleStatistics_Skill::SkillId' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_Skill, UseCount) == 0x000018, "Member 'FM1BattleStatistics_Skill::UseCount' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_Skill, TotalDamage) == 0x000020, "Member 'FM1BattleStatistics_Skill::TotalDamage' has a wrong offset!");

// ScriptStruct M1.M1BattleStatistics_Weapon
// 0x0038 (0x0038 - 0x0000)
struct FM1BattleStatistics_Weapon final
{
public:
	struct FM1TemplateId                          ItemId;                                            // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ItemUid;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ItemLevel;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemTierType                               ItemTier;                                          // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ShootCount;                                        // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MonsterHitCount;                                   // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         WeaknessHitCount;                                  // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattleStatistics_Weapon) == 0x000008, "Wrong alignment on FM1BattleStatistics_Weapon");
static_assert(sizeof(FM1BattleStatistics_Weapon) == 0x000038, "Wrong size on FM1BattleStatistics_Weapon");
static_assert(offsetof(FM1BattleStatistics_Weapon, ItemId) == 0x000000, "Member 'FM1BattleStatistics_Weapon::ItemId' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_Weapon, ItemUid) == 0x000008, "Member 'FM1BattleStatistics_Weapon::ItemUid' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_Weapon, ItemLevel) == 0x000010, "Member 'FM1BattleStatistics_Weapon::ItemLevel' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_Weapon, ItemTier) == 0x000018, "Member 'FM1BattleStatistics_Weapon::ItemTier' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_Weapon, ShootCount) == 0x000020, "Member 'FM1BattleStatistics_Weapon::ShootCount' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_Weapon, MonsterHitCount) == 0x000028, "Member 'FM1BattleStatistics_Weapon::MonsterHitCount' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_Weapon, WeaknessHitCount) == 0x000030, "Member 'FM1BattleStatistics_Weapon::WeaknessHitCount' has a wrong offset!");

// ScriptStruct M1.M1BattleStatistics_GiveDamage
// 0x0088 (0x0088 - 0x0000)
struct FM1BattleStatistics_GiveDamage final
{
public:
	struct FM1ScaledInteger                       WeaponDamage;                                      // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1ScaledInteger>               WeaponElementalDamages;                            // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1ScaledInteger>               SkillDamagesForElemental;                          // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1ScaledInteger>               SkillDamagesForArcheType;                          // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1BattleStatistics_Skill>      SkillUseDataArray;                                 // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1BattleStatistics_Weapon>     WeaponUseDataArray;                                // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FM1ScaledInteger                       SubSkillDamage;                                    // 0x0058(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ScaledInteger                       EtcDamage;                                         // 0x0060(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         WeaknessDamageCount;                               // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ScaledInteger                       WeaknessDamage;                                    // 0x0070(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ScaledInteger                       CriticalDamage;                                    // 0x0078(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         GiveDamageCount;                                   // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattleStatistics_GiveDamage) == 0x000008, "Wrong alignment on FM1BattleStatistics_GiveDamage");
static_assert(sizeof(FM1BattleStatistics_GiveDamage) == 0x000088, "Wrong size on FM1BattleStatistics_GiveDamage");
static_assert(offsetof(FM1BattleStatistics_GiveDamage, WeaponDamage) == 0x000000, "Member 'FM1BattleStatistics_GiveDamage::WeaponDamage' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_GiveDamage, WeaponElementalDamages) == 0x000008, "Member 'FM1BattleStatistics_GiveDamage::WeaponElementalDamages' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_GiveDamage, SkillDamagesForElemental) == 0x000018, "Member 'FM1BattleStatistics_GiveDamage::SkillDamagesForElemental' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_GiveDamage, SkillDamagesForArcheType) == 0x000028, "Member 'FM1BattleStatistics_GiveDamage::SkillDamagesForArcheType' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_GiveDamage, SkillUseDataArray) == 0x000038, "Member 'FM1BattleStatistics_GiveDamage::SkillUseDataArray' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_GiveDamage, WeaponUseDataArray) == 0x000048, "Member 'FM1BattleStatistics_GiveDamage::WeaponUseDataArray' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_GiveDamage, SubSkillDamage) == 0x000058, "Member 'FM1BattleStatistics_GiveDamage::SubSkillDamage' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_GiveDamage, EtcDamage) == 0x000060, "Member 'FM1BattleStatistics_GiveDamage::EtcDamage' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_GiveDamage, WeaknessDamageCount) == 0x000068, "Member 'FM1BattleStatistics_GiveDamage::WeaknessDamageCount' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_GiveDamage, WeaknessDamage) == 0x000070, "Member 'FM1BattleStatistics_GiveDamage::WeaknessDamage' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_GiveDamage, CriticalDamage) == 0x000078, "Member 'FM1BattleStatistics_GiveDamage::CriticalDamage' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_GiveDamage, GiveDamageCount) == 0x000080, "Member 'FM1BattleStatistics_GiveDamage::GiveDamageCount' has a wrong offset!");

// ScriptStruct M1.M1BattleStatistics_TakeDamage
// 0x0028 (0x0028 - 0x0000)
struct FM1BattleStatistics_TakeDamage final
{
public:
	struct FM1ScaledInteger                       TakeDamage;                                        // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ScaledInteger                       NormalDamage;                                      // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1ScaledInteger>               ElementalDamages;                                  // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int64                                         TakeDamageCount;                                   // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattleStatistics_TakeDamage) == 0x000008, "Wrong alignment on FM1BattleStatistics_TakeDamage");
static_assert(sizeof(FM1BattleStatistics_TakeDamage) == 0x000028, "Wrong size on FM1BattleStatistics_TakeDamage");
static_assert(offsetof(FM1BattleStatistics_TakeDamage, TakeDamage) == 0x000000, "Member 'FM1BattleStatistics_TakeDamage::TakeDamage' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_TakeDamage, NormalDamage) == 0x000008, "Member 'FM1BattleStatistics_TakeDamage::NormalDamage' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_TakeDamage, ElementalDamages) == 0x000010, "Member 'FM1BattleStatistics_TakeDamage::ElementalDamages' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_TakeDamage, TakeDamageCount) == 0x000020, "Member 'FM1BattleStatistics_TakeDamage::TakeDamageCount' has a wrong offset!");

// ScriptStruct M1.M1BattleStatistics_Recovery
// 0x0020 (0x0020 - 0x0000)
struct FM1BattleStatistics_Recovery final
{
public:
	struct FM1ScaledInteger                       HpRecovery;                                        // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ScaledInteger                       MpRecovery;                                        // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ScaledInteger                       EnergyShieldRecovery;                              // 0x0010(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ScaledInteger                       CommonGaugeRecovery;                               // 0x0018(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattleStatistics_Recovery) == 0x000008, "Wrong alignment on FM1BattleStatistics_Recovery");
static_assert(sizeof(FM1BattleStatistics_Recovery) == 0x000020, "Wrong size on FM1BattleStatistics_Recovery");
static_assert(offsetof(FM1BattleStatistics_Recovery, HpRecovery) == 0x000000, "Member 'FM1BattleStatistics_Recovery::HpRecovery' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_Recovery, MpRecovery) == 0x000008, "Member 'FM1BattleStatistics_Recovery::MpRecovery' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_Recovery, EnergyShieldRecovery) == 0x000010, "Member 'FM1BattleStatistics_Recovery::EnergyShieldRecovery' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_Recovery, CommonGaugeRecovery) == 0x000018, "Member 'FM1BattleStatistics_Recovery::CommonGaugeRecovery' has a wrong offset!");

// ScriptStruct M1.M1BattleStatistics_StatusEffect
// 0x0010 (0x0010 - 0x0000)
struct FM1BattleStatistics_StatusEffect final
{
public:
	int64                                         BuffCount;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         DebuffCount;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattleStatistics_StatusEffect) == 0x000008, "Wrong alignment on FM1BattleStatistics_StatusEffect");
static_assert(sizeof(FM1BattleStatistics_StatusEffect) == 0x000010, "Wrong size on FM1BattleStatistics_StatusEffect");
static_assert(offsetof(FM1BattleStatistics_StatusEffect, BuffCount) == 0x000000, "Member 'FM1BattleStatistics_StatusEffect::BuffCount' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_StatusEffect, DebuffCount) == 0x000008, "Member 'FM1BattleStatistics_StatusEffect::DebuffCount' has a wrong offset!");

// ScriptStruct M1.M1BattleStatistics_DBNO
// 0x0020 (0x0020 - 0x0000)
struct FM1BattleStatistics_DBNO final
{
public:
	int64                                         DBNOCount;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         DeathCount;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         RescueCount;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReviveByRescueCount;                               // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattleStatistics_DBNO) == 0x000008, "Wrong alignment on FM1BattleStatistics_DBNO");
static_assert(sizeof(FM1BattleStatistics_DBNO) == 0x000020, "Wrong size on FM1BattleStatistics_DBNO");
static_assert(offsetof(FM1BattleStatistics_DBNO, DBNOCount) == 0x000000, "Member 'FM1BattleStatistics_DBNO::DBNOCount' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_DBNO, DeathCount) == 0x000008, "Member 'FM1BattleStatistics_DBNO::DeathCount' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_DBNO, RescueCount) == 0x000010, "Member 'FM1BattleStatistics_DBNO::RescueCount' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_DBNO, ReviveByRescueCount) == 0x000018, "Member 'FM1BattleStatistics_DBNO::ReviveByRescueCount' has a wrong offset!");

// ScriptStruct M1.M1BattleStatistics_Kill
// 0x0050 (0x0050 - 0x0000)
struct FM1BattleStatistics_Kill final
{
public:
	TArray<int64>                                 CategoryKillCounts;                                // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int64>                                 LegionKillCounts;                                  // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int64                                         EliteKillCount;                                    // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         WeaponKillCount;                                   // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         SkillKillCount;                                    // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         SubSkillKillCount;                                 // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         EtcKillCount;                                      // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         WeaknessKillCount;                                 // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattleStatistics_Kill) == 0x000008, "Wrong alignment on FM1BattleStatistics_Kill");
static_assert(sizeof(FM1BattleStatistics_Kill) == 0x000050, "Wrong size on FM1BattleStatistics_Kill");
static_assert(offsetof(FM1BattleStatistics_Kill, CategoryKillCounts) == 0x000000, "Member 'FM1BattleStatistics_Kill::CategoryKillCounts' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_Kill, LegionKillCounts) == 0x000010, "Member 'FM1BattleStatistics_Kill::LegionKillCounts' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_Kill, EliteKillCount) == 0x000020, "Member 'FM1BattleStatistics_Kill::EliteKillCount' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_Kill, WeaponKillCount) == 0x000028, "Member 'FM1BattleStatistics_Kill::WeaponKillCount' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_Kill, SkillKillCount) == 0x000030, "Member 'FM1BattleStatistics_Kill::SkillKillCount' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_Kill, SubSkillKillCount) == 0x000038, "Member 'FM1BattleStatistics_Kill::SubSkillKillCount' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_Kill, EtcKillCount) == 0x000040, "Member 'FM1BattleStatistics_Kill::EtcKillCount' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_Kill, WeaknessKillCount) == 0x000048, "Member 'FM1BattleStatistics_Kill::WeaknessKillCount' has a wrong offset!");

// ScriptStruct M1.M1BattleStatistics_PartsDestroyByPartsId
// 0x0020 (0x0020 - 0x0000)
struct FM1BattleStatistics_PartsDestroyByPartsId final
{
public:
	struct FM1TemplateId                          PartsId;                                           // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         DestroyCount;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         DeboneCount;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         TryDeboneCount;                                    // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattleStatistics_PartsDestroyByPartsId) == 0x000008, "Wrong alignment on FM1BattleStatistics_PartsDestroyByPartsId");
static_assert(sizeof(FM1BattleStatistics_PartsDestroyByPartsId) == 0x000020, "Wrong size on FM1BattleStatistics_PartsDestroyByPartsId");
static_assert(offsetof(FM1BattleStatistics_PartsDestroyByPartsId, PartsId) == 0x000000, "Member 'FM1BattleStatistics_PartsDestroyByPartsId::PartsId' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_PartsDestroyByPartsId, DestroyCount) == 0x000008, "Member 'FM1BattleStatistics_PartsDestroyByPartsId::DestroyCount' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_PartsDestroyByPartsId, DeboneCount) == 0x000010, "Member 'FM1BattleStatistics_PartsDestroyByPartsId::DeboneCount' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_PartsDestroyByPartsId, TryDeboneCount) == 0x000018, "Member 'FM1BattleStatistics_PartsDestroyByPartsId::TryDeboneCount' has a wrong offset!");

// ScriptStruct M1.M1BattleStatistics_PartsDestroy
// 0x0020 (0x0020 - 0x0000)
struct FM1BattleStatistics_PartsDestroy final
{
public:
	int64                                         TotalDestroyCount;                                 // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         TotalDeboneCount;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1BattleStatistics_PartsDestroyByPartsId> PartsDestroyRecordsByPartsId;                      // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattleStatistics_PartsDestroy) == 0x000008, "Wrong alignment on FM1BattleStatistics_PartsDestroy");
static_assert(sizeof(FM1BattleStatistics_PartsDestroy) == 0x000020, "Wrong size on FM1BattleStatistics_PartsDestroy");
static_assert(offsetof(FM1BattleStatistics_PartsDestroy, TotalDestroyCount) == 0x000000, "Member 'FM1BattleStatistics_PartsDestroy::TotalDestroyCount' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_PartsDestroy, TotalDeboneCount) == 0x000008, "Member 'FM1BattleStatistics_PartsDestroy::TotalDeboneCount' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics_PartsDestroy, PartsDestroyRecordsByPartsId) == 0x000010, "Member 'FM1BattleStatistics_PartsDestroy::PartsDestroyRecordsByPartsId' has a wrong offset!");

// ScriptStruct M1.M1BattleStatistics
// 0x01C8 (0x01C8 - 0x0000)
struct FM1BattleStatistics final
{
public:
	struct FM1BattleStatistics_GiveDamage         GiveDamageData;                                    // 0x0000(0x0088)(NativeAccessSpecifierPublic)
	struct FM1BattleStatistics_TakeDamage         TakeDamageData;                                    // 0x0088(0x0028)(NativeAccessSpecifierPublic)
	struct FM1BattleStatistics_Recovery           GiveRecoveryToOtherData;                           // 0x00B0(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1BattleStatistics_Recovery           GiveRecoveryToSelfData;                            // 0x00D0(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1BattleStatistics_Recovery           TakeRecoveryFromOtherData;                         // 0x00F0(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1BattleStatistics_StatusEffect       GiveStatusEffectToOtherData;                       // 0x0110(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1BattleStatistics_StatusEffect       TakeStatusEffectFromOtherData;                     // 0x0120(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1BattleStatistics_DBNO               DBNOData;                                          // 0x0130(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1BattleStatistics_Kill               KillData;                                          // 0x0150(0x0050)(NativeAccessSpecifierPublic)
	struct FDateTime                              StartTime;                                         // 0x01A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1BattleStatistics_PartsDestroy       PartsDestroyData;                                  // 0x01A8(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattleStatistics) == 0x000008, "Wrong alignment on FM1BattleStatistics");
static_assert(sizeof(FM1BattleStatistics) == 0x0001C8, "Wrong size on FM1BattleStatistics");
static_assert(offsetof(FM1BattleStatistics, GiveDamageData) == 0x000000, "Member 'FM1BattleStatistics::GiveDamageData' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics, TakeDamageData) == 0x000088, "Member 'FM1BattleStatistics::TakeDamageData' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics, GiveRecoveryToOtherData) == 0x0000B0, "Member 'FM1BattleStatistics::GiveRecoveryToOtherData' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics, GiveRecoveryToSelfData) == 0x0000D0, "Member 'FM1BattleStatistics::GiveRecoveryToSelfData' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics, TakeRecoveryFromOtherData) == 0x0000F0, "Member 'FM1BattleStatistics::TakeRecoveryFromOtherData' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics, GiveStatusEffectToOtherData) == 0x000110, "Member 'FM1BattleStatistics::GiveStatusEffectToOtherData' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics, TakeStatusEffectFromOtherData) == 0x000120, "Member 'FM1BattleStatistics::TakeStatusEffectFromOtherData' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics, DBNOData) == 0x000130, "Member 'FM1BattleStatistics::DBNOData' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics, KillData) == 0x000150, "Member 'FM1BattleStatistics::KillData' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics, StartTime) == 0x0001A0, "Member 'FM1BattleStatistics::StartTime' has a wrong offset!");
static_assert(offsetof(FM1BattleStatistics, PartsDestroyData) == 0x0001A8, "Member 'FM1BattleStatistics::PartsDestroyData' has a wrong offset!");

// ScriptStruct M1.M1InGameStatistics
// 0x0268 (0x0268 - 0x0000)
struct FM1InGameStatistics final
{
public:
	struct FM1BattleStatistics                    BattleStatistics;                                  // 0x0000(0x01C8)(Transient, NativeAccessSpecifierPublic)
	struct FM1MissionStatistics                   MissionStatistics;                                 // 0x01C8(0x00A0)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InGameStatistics) == 0x000008, "Wrong alignment on FM1InGameStatistics");
static_assert(sizeof(FM1InGameStatistics) == 0x000268, "Wrong size on FM1InGameStatistics");
static_assert(offsetof(FM1InGameStatistics, BattleStatistics) == 0x000000, "Member 'FM1InGameStatistics::BattleStatistics' has a wrong offset!");
static_assert(offsetof(FM1InGameStatistics, MissionStatistics) == 0x0001C8, "Member 'FM1InGameStatistics::MissionStatistics' has a wrong offset!");

// ScriptStruct M1.M1MultiCollectionOccupiedInfo
// 0x0030 (0x0030 - 0x0000)
struct FM1MultiCollectionOccupiedInfo final
{
public:
	TArray<TWeakObjectPtr<class AM1Player>>       BeginPlayers;                                      // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AM1Player>>       OccupiedPlayers;                                   // 0x0010(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AM1Player>>       CancelPlayers;                                     // 0x0020(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MultiCollectionOccupiedInfo) == 0x000008, "Wrong alignment on FM1MultiCollectionOccupiedInfo");
static_assert(sizeof(FM1MultiCollectionOccupiedInfo) == 0x000030, "Wrong size on FM1MultiCollectionOccupiedInfo");
static_assert(offsetof(FM1MultiCollectionOccupiedInfo, BeginPlayers) == 0x000000, "Member 'FM1MultiCollectionOccupiedInfo::BeginPlayers' has a wrong offset!");
static_assert(offsetof(FM1MultiCollectionOccupiedInfo, OccupiedPlayers) == 0x000010, "Member 'FM1MultiCollectionOccupiedInfo::OccupiedPlayers' has a wrong offset!");
static_assert(offsetof(FM1MultiCollectionOccupiedInfo, CancelPlayers) == 0x000020, "Member 'FM1MultiCollectionOccupiedInfo::CancelPlayers' has a wrong offset!");

// ScriptStruct M1.M1CustomizeList
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FM1CustomizeList final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CustomizeList) == 0x000008, "Wrong alignment on FM1CustomizeList");
static_assert(sizeof(FM1CustomizeList) == 0x000010, "Wrong size on FM1CustomizeList");

// ScriptStruct M1.M1CustomizeEncyclopedia
// 0x0050 (0x0050 - 0x0000)
struct FM1CustomizeEncyclopedia final
{
public:
	TMap<struct FM1TemplateId, struct FM1CustomizeList> EquippableSkinsByWeapon;                           // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizeEncyclopedia) == 0x000008, "Wrong alignment on FM1CustomizeEncyclopedia");
static_assert(sizeof(FM1CustomizeEncyclopedia) == 0x000050, "Wrong size on FM1CustomizeEncyclopedia");
static_assert(offsetof(FM1CustomizeEncyclopedia, EquippableSkinsByWeapon) == 0x000000, "Member 'FM1CustomizeEncyclopedia::EquippableSkinsByWeapon' has a wrong offset!");

// ScriptStruct M1.M1AccessorySetOptionInfo
// 0x0068 (0x0068 - 0x0000)
struct FM1AccessorySetOptionInfo final
{
public:
	struct FM1TemplateId                          SetOptionTemplateId;                               // 0x0000(0x0004)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1TemplateId>                  EquippedAccessories;                               // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TMap<int32, struct FM1AbilityId>              ActiveAbilityIds;                                  // 0x0018(0x0050)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AccessorySetOptionInfo) == 0x000008, "Wrong alignment on FM1AccessorySetOptionInfo");
static_assert(sizeof(FM1AccessorySetOptionInfo) == 0x000068, "Wrong size on FM1AccessorySetOptionInfo");
static_assert(offsetof(FM1AccessorySetOptionInfo, SetOptionTemplateId) == 0x000000, "Member 'FM1AccessorySetOptionInfo::SetOptionTemplateId' has a wrong offset!");
static_assert(offsetof(FM1AccessorySetOptionInfo, EquippedAccessories) == 0x000008, "Member 'FM1AccessorySetOptionInfo::EquippedAccessories' has a wrong offset!");
static_assert(offsetof(FM1AccessorySetOptionInfo, ActiveAbilityIds) == 0x000018, "Member 'FM1AccessorySetOptionInfo::ActiveAbilityIds' has a wrong offset!");

// ScriptStruct M1.M1PresetItem
// 0x0020 (0x0020 - 0x0000)
struct FM1PresetItem final
{
public:
	EM1PresetSlotType                             PresetSlotType;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ItemUid;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoadoutSlotIndex;                                  // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemType                                   ItemType;                                          // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ItemTid;                                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PresetItem) == 0x000008, "Wrong alignment on FM1PresetItem");
static_assert(sizeof(FM1PresetItem) == 0x000020, "Wrong size on FM1PresetItem");
static_assert(offsetof(FM1PresetItem, PresetSlotType) == 0x000000, "Member 'FM1PresetItem::PresetSlotType' has a wrong offset!");
static_assert(offsetof(FM1PresetItem, ItemUid) == 0x000008, "Member 'FM1PresetItem::ItemUid' has a wrong offset!");
static_assert(offsetof(FM1PresetItem, LoadoutSlotIndex) == 0x000010, "Member 'FM1PresetItem::LoadoutSlotIndex' has a wrong offset!");
static_assert(offsetof(FM1PresetItem, ItemType) == 0x000014, "Member 'FM1PresetItem::ItemType' has a wrong offset!");
static_assert(offsetof(FM1PresetItem, ItemTid) == 0x000018, "Member 'FM1PresetItem::ItemTid' has a wrong offset!");
static_assert(offsetof(FM1PresetItem, Level) == 0x00001C, "Member 'FM1PresetItem::Level' has a wrong offset!");

// ScriptStruct M1.M1MissionWaveCheckPointInfo
// 0x0070 (0x0070 - 0x0000)
struct FM1MissionWaveCheckPointInfo final
{
public:
	int64                                         Uid;                                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCompleted;                                      // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCurrentWave;                                    // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLastWave;                                         // 0x000E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1MissionRewards                      Rewards;                                           // 0x0010(0x0060)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionWaveCheckPointInfo) == 0x000008, "Wrong alignment on FM1MissionWaveCheckPointInfo");
static_assert(sizeof(FM1MissionWaveCheckPointInfo) == 0x000070, "Wrong size on FM1MissionWaveCheckPointInfo");
static_assert(offsetof(FM1MissionWaveCheckPointInfo, Uid) == 0x000000, "Member 'FM1MissionWaveCheckPointInfo::Uid' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveCheckPointInfo, Index) == 0x000008, "Member 'FM1MissionWaveCheckPointInfo::Index' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveCheckPointInfo, bIsCompleted) == 0x00000C, "Member 'FM1MissionWaveCheckPointInfo::bIsCompleted' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveCheckPointInfo, bIsCurrentWave) == 0x00000D, "Member 'FM1MissionWaveCheckPointInfo::bIsCurrentWave' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveCheckPointInfo, bLastWave) == 0x00000E, "Member 'FM1MissionWaveCheckPointInfo::bLastWave' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveCheckPointInfo, Rewards) == 0x000010, "Member 'FM1MissionWaveCheckPointInfo::Rewards' has a wrong offset!");

// ScriptStruct M1.M1PresetSlot
// 0x0068 (0x0068 - 0x0000)
struct FM1PresetSlot final
{
public:
	int32                                         PresetIndex;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PresetName;                                        // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EM1PresetSlotType, struct FM1PresetItem> PresetItemBySlotType;                              // 0x0018(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PresetSlot) == 0x000008, "Wrong alignment on FM1PresetSlot");
static_assert(sizeof(FM1PresetSlot) == 0x000068, "Wrong size on FM1PresetSlot");
static_assert(offsetof(FM1PresetSlot, PresetIndex) == 0x000000, "Member 'FM1PresetSlot::PresetIndex' has a wrong offset!");
static_assert(offsetof(FM1PresetSlot, PresetName) == 0x000008, "Member 'FM1PresetSlot::PresetName' has a wrong offset!");
static_assert(offsetof(FM1PresetSlot, PresetItemBySlotType) == 0x000018, "Member 'FM1PresetSlot::PresetItemBySlotType' has a wrong offset!");

// ScriptStruct M1.M1ToyLastLoginInfo
// 0x0030 (0x0030 - 0x0000)
struct FM1ToyLastLoginInfo final
{
public:
	bool                                          IsValid;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Guid;                                              // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         PlatformType;                                      // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlatformUserId;                                    // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ToyLastLoginInfo) == 0x000008, "Wrong alignment on FM1ToyLastLoginInfo");
static_assert(sizeof(FM1ToyLastLoginInfo) == 0x000030, "Wrong size on FM1ToyLastLoginInfo");
static_assert(offsetof(FM1ToyLastLoginInfo, IsValid) == 0x000000, "Member 'FM1ToyLastLoginInfo::IsValid' has a wrong offset!");
static_assert(offsetof(FM1ToyLastLoginInfo, Guid) == 0x000008, "Member 'FM1ToyLastLoginInfo::Guid' has a wrong offset!");
static_assert(offsetof(FM1ToyLastLoginInfo, PlatformType) == 0x000018, "Member 'FM1ToyLastLoginInfo::PlatformType' has a wrong offset!");
static_assert(offsetof(FM1ToyLastLoginInfo, PlatformUserId) == 0x000020, "Member 'FM1ToyLastLoginInfo::PlatformUserId' has a wrong offset!");

// ScriptStruct M1.M1ProgressQuestInfo
// 0x0058 (0x0058 - 0x0000)
struct FM1ProgressQuestInfo final
{
public:
	struct FM1TemplateId                          QuestId;                                           // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FM1QuestParam>             QuestParams;                                       // 0x0008(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ProgressQuestInfo) == 0x000008, "Wrong alignment on FM1ProgressQuestInfo");
static_assert(sizeof(FM1ProgressQuestInfo) == 0x000058, "Wrong size on FM1ProgressQuestInfo");
static_assert(offsetof(FM1ProgressQuestInfo, QuestId) == 0x000000, "Member 'FM1ProgressQuestInfo::QuestId' has a wrong offset!");
static_assert(offsetof(FM1ProgressQuestInfo, QuestParams) == 0x000008, "Member 'FM1ProgressQuestInfo::QuestParams' has a wrong offset!");

// ScriptStruct M1.M1QuestTemplateIdList
// 0x0010 (0x0010 - 0x0000)
struct FM1QuestTemplateIdList final
{
public:
	TArray<struct FM1TemplateId>                  QuestTemplateIds;                                  // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1QuestTemplateIdList) == 0x000008, "Wrong alignment on FM1QuestTemplateIdList");
static_assert(sizeof(FM1QuestTemplateIdList) == 0x000010, "Wrong size on FM1QuestTemplateIdList");
static_assert(offsetof(FM1QuestTemplateIdList, QuestTemplateIds) == 0x000000, "Member 'FM1QuestTemplateIdList::QuestTemplateIds' has a wrong offset!");

// ScriptStruct M1.M1PhaseSettingForCollection
// 0x0008 (0x0008 - 0x0000)
struct FM1PhaseSettingForCollection final
{
public:
	int32                                         PhaseIndex;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropPercentageOverride;                            // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PhaseSettingForCollection) == 0x000004, "Wrong alignment on FM1PhaseSettingForCollection");
static_assert(sizeof(FM1PhaseSettingForCollection) == 0x000008, "Wrong size on FM1PhaseSettingForCollection");
static_assert(offsetof(FM1PhaseSettingForCollection, PhaseIndex) == 0x000000, "Member 'FM1PhaseSettingForCollection::PhaseIndex' has a wrong offset!");
static_assert(offsetof(FM1PhaseSettingForCollection, DropPercentageOverride) == 0x000004, "Member 'FM1PhaseSettingForCollection::DropPercentageOverride' has a wrong offset!");

// ScriptStruct M1.M1ActiveChallengeInfo
// 0x0008 (0x0008 - 0x0000)
struct FM1ActiveChallengeInfo final
{
public:
	struct FM1TemplateId                          DailyChallengeTemplateId;                          // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          LatestWeeklyChallengeTemplateId;                   // 0x0004(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ActiveChallengeInfo) == 0x000004, "Wrong alignment on FM1ActiveChallengeInfo");
static_assert(sizeof(FM1ActiveChallengeInfo) == 0x000008, "Wrong size on FM1ActiveChallengeInfo");
static_assert(offsetof(FM1ActiveChallengeInfo, DailyChallengeTemplateId) == 0x000000, "Member 'FM1ActiveChallengeInfo::DailyChallengeTemplateId' has a wrong offset!");
static_assert(offsetof(FM1ActiveChallengeInfo, LatestWeeklyChallengeTemplateId) == 0x000004, "Member 'FM1ActiveChallengeInfo::LatestWeeklyChallengeTemplateId' has a wrong offset!");

// ScriptStruct M1.M1ReinforceSlotInfoWrapper
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FM1ReinforceSlotInfoWrapper final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ReinforceSlotInfoWrapper) == 0x000008, "Wrong alignment on FM1ReinforceSlotInfoWrapper");
static_assert(sizeof(FM1ReinforceSlotInfoWrapper) == 0x000040, "Wrong size on FM1ReinforceSlotInfoWrapper");

// ScriptStruct M1.M1ReinforceWrapper
// 0x0010 (0x0010 - 0x0000)
struct FM1ReinforceWrapper final
{
public:
	int32                                         GroupIndex;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              CooldownEndTime;                                   // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ReinforceWrapper) == 0x000008, "Wrong alignment on FM1ReinforceWrapper");
static_assert(sizeof(FM1ReinforceWrapper) == 0x000010, "Wrong size on FM1ReinforceWrapper");
static_assert(offsetof(FM1ReinforceWrapper, GroupIndex) == 0x000000, "Member 'FM1ReinforceWrapper::GroupIndex' has a wrong offset!");
static_assert(offsetof(FM1ReinforceWrapper, SlotIndex) == 0x000004, "Member 'FM1ReinforceWrapper::SlotIndex' has a wrong offset!");
static_assert(offsetof(FM1ReinforceWrapper, CooldownEndTime) == 0x000008, "Member 'FM1ReinforceWrapper::CooldownEndTime' has a wrong offset!");

// ScriptStruct M1.M1ShopProductSet
// 0x0050 (0x0050 - 0x0000)
struct FM1ShopProductSet final
{
public:
	TMap<struct FM1TemplateId, class UM1ShopProduct*> ProductMap;                                        // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ShopProductSet) == 0x000008, "Wrong alignment on FM1ShopProductSet");
static_assert(sizeof(FM1ShopProductSet) == 0x000050, "Wrong size on FM1ShopProductSet");
static_assert(offsetof(FM1ShopProductSet, ProductMap) == 0x000000, "Member 'FM1ShopProductSet::ProductMap' has a wrong offset!");

// ScriptStruct M1.M1ItemMap
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FM1ItemMap final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ItemMap) == 0x000008, "Wrong alignment on FM1ItemMap");
static_assert(sizeof(FM1ItemMap) == 0x000050, "Wrong size on FM1ItemMap");

// ScriptStruct M1.M1NxLog_User_MonsterKill
// 0x00A0 (0x00A0 - 0x0000)
struct FM1NxLog_User_MonsterKill final
{
public:
	class FString                                 Actionid;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldId;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldUid;                                          // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MonsterId;                                         // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        MonsterLevel;                                      // 0x0040(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Monstertype;                                       // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Userlevel;                                         // 0x0060(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Usernickname;                                      // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tfdplayeritemid;                                   // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Tfdplayeritemlevel;                                // 0x0090(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_User_MonsterKill) == 0x000008, "Wrong alignment on FM1NxLog_User_MonsterKill");
static_assert(sizeof(FM1NxLog_User_MonsterKill) == 0x0000A0, "Wrong size on FM1NxLog_User_MonsterKill");
static_assert(offsetof(FM1NxLog_User_MonsterKill, Actionid) == 0x000000, "Member 'FM1NxLog_User_MonsterKill::Actionid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_MonsterKill, FieldId) == 0x000010, "Member 'FM1NxLog_User_MonsterKill::FieldId' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_MonsterKill, FieldUid) == 0x000020, "Member 'FM1NxLog_User_MonsterKill::FieldUid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_MonsterKill, MonsterId) == 0x000030, "Member 'FM1NxLog_User_MonsterKill::MonsterId' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_MonsterKill, MonsterLevel) == 0x000040, "Member 'FM1NxLog_User_MonsterKill::MonsterLevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_MonsterKill, Monstertype) == 0x000050, "Member 'FM1NxLog_User_MonsterKill::Monstertype' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_MonsterKill, Userlevel) == 0x000060, "Member 'FM1NxLog_User_MonsterKill::Userlevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_MonsterKill, Usernickname) == 0x000070, "Member 'FM1NxLog_User_MonsterKill::Usernickname' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_MonsterKill, Tfdplayeritemid) == 0x000080, "Member 'FM1NxLog_User_MonsterKill::Tfdplayeritemid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_MonsterKill, Tfdplayeritemlevel) == 0x000090, "Member 'FM1NxLog_User_MonsterKill::Tfdplayeritemlevel' has a wrong offset!");

// ScriptStruct M1.M1PlayerActionPermissionInfo
// 0x0002 (0x0002 - 0x0000)
struct FM1PlayerActionPermissionInfo final
{
public:
	EM1PlayerAction                               Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPermitted;                                      // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PlayerActionPermissionInfo) == 0x000001, "Wrong alignment on FM1PlayerActionPermissionInfo");
static_assert(sizeof(FM1PlayerActionPermissionInfo) == 0x000002, "Wrong size on FM1PlayerActionPermissionInfo");
static_assert(offsetof(FM1PlayerActionPermissionInfo, Type) == 0x000000, "Member 'FM1PlayerActionPermissionInfo::Type' has a wrong offset!");
static_assert(offsetof(FM1PlayerActionPermissionInfo, bIsPermitted) == 0x000001, "Member 'FM1PlayerActionPermissionInfo::bIsPermitted' has a wrong offset!");

// ScriptStruct M1.M1TriggerTarget
// 0x0014 (0x0014 - 0x0000)
struct FM1TriggerTarget final
{
public:
	TWeakObjectPtr<class AActor>                  ReferencedActor;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ComponentName;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBeginOverlap;                                     // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1TriggerTarget) == 0x000004, "Wrong alignment on FM1TriggerTarget");
static_assert(sizeof(FM1TriggerTarget) == 0x000014, "Wrong size on FM1TriggerTarget");
static_assert(offsetof(FM1TriggerTarget, ReferencedActor) == 0x000000, "Member 'FM1TriggerTarget::ReferencedActor' has a wrong offset!");
static_assert(offsetof(FM1TriggerTarget, ComponentName) == 0x000008, "Member 'FM1TriggerTarget::ComponentName' has a wrong offset!");
static_assert(offsetof(FM1TriggerTarget, bBeginOverlap) == 0x000010, "Member 'FM1TriggerTarget::bBeginOverlap' has a wrong offset!");

// ScriptStruct M1.M1ActorFollowParams
// 0x000C (0x000C - 0x0000)
struct FM1ActorFollowParams final
{
public:
	bool                                          bIsCosmetic;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FollowActorSocketName;                             // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ActorFollowParams) == 0x000004, "Wrong alignment on FM1ActorFollowParams");
static_assert(sizeof(FM1ActorFollowParams) == 0x00000C, "Wrong size on FM1ActorFollowParams");
static_assert(offsetof(FM1ActorFollowParams, bIsCosmetic) == 0x000000, "Member 'FM1ActorFollowParams::bIsCosmetic' has a wrong offset!");
static_assert(offsetof(FM1ActorFollowParams, FollowActorSocketName) == 0x000004, "Member 'FM1ActorFollowParams::FollowActorSocketName' has a wrong offset!");

// ScriptStruct M1.M1JumpUpRangeData
// 0x0060 (0x0060 - 0x0000)
struct FM1JumpUpRangeData final
{
public:
	float                                         MinRange;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpSpeed;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EM1JumpAnimType, class UAnimMontage*>    JumpMontageSet;                                    // 0x0010(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1JumpUpRangeData) == 0x000008, "Wrong alignment on FM1JumpUpRangeData");
static_assert(sizeof(FM1JumpUpRangeData) == 0x000060, "Wrong size on FM1JumpUpRangeData");
static_assert(offsetof(FM1JumpUpRangeData, MinRange) == 0x000000, "Member 'FM1JumpUpRangeData::MinRange' has a wrong offset!");
static_assert(offsetof(FM1JumpUpRangeData, MaxRange) == 0x000004, "Member 'FM1JumpUpRangeData::MaxRange' has a wrong offset!");
static_assert(offsetof(FM1JumpUpRangeData, JumpSpeed) == 0x000008, "Member 'FM1JumpUpRangeData::JumpSpeed' has a wrong offset!");
static_assert(offsetof(FM1JumpUpRangeData, JumpMontageSet) == 0x000010, "Member 'FM1JumpUpRangeData::JumpMontageSet' has a wrong offset!");

// ScriptStruct M1.M1ActorSpawnParameter
// 0x0008 (0x0008 - 0x0000)
struct FM1ActorSpawnParameter
{
public:
	class FName                                   DataRowName;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ActorSpawnParameter) == 0x000004, "Wrong alignment on FM1ActorSpawnParameter");
static_assert(sizeof(FM1ActorSpawnParameter) == 0x000008, "Wrong size on FM1ActorSpawnParameter");
static_assert(offsetof(FM1ActorSpawnParameter, DataRowName) == 0x000000, "Member 'FM1ActorSpawnParameter::DataRowName' has a wrong offset!");

// ScriptStruct M1.M1AbilityActorSpawnParameter
// 0x0010 (0x0018 - 0x0008)
struct FM1AbilityActorSpawnParameter final : public FM1ActorSpawnParameter
{
public:
	struct FM1AbilityContextHandle                AbilityContext;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AbilityActorSpawnParameter) == 0x000008, "Wrong alignment on FM1AbilityActorSpawnParameter");
static_assert(sizeof(FM1AbilityActorSpawnParameter) == 0x000018, "Wrong size on FM1AbilityActorSpawnParameter");
static_assert(offsetof(FM1AbilityActorSpawnParameter, AbilityContext) == 0x000008, "Member 'FM1AbilityActorSpawnParameter::AbilityContext' has a wrong offset!");

// ScriptStruct M1.M1ActorMaterialContext
// 0x00C0 (0x00C0 - 0x0000)
struct FM1ActorMaterialContext final
{
public:
	TArray<class UMaterialInstanceDynamic*>       OrigDynamicMaterials;                              // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       DynamicMaterials;                                  // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0xA0];                                      // 0x0020(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ActorMaterialContext) == 0x000008, "Wrong alignment on FM1ActorMaterialContext");
static_assert(sizeof(FM1ActorMaterialContext) == 0x0000C0, "Wrong size on FM1ActorMaterialContext");
static_assert(offsetof(FM1ActorMaterialContext, OrigDynamicMaterials) == 0x000000, "Member 'FM1ActorMaterialContext::OrigDynamicMaterials' has a wrong offset!");
static_assert(offsetof(FM1ActorMaterialContext, DynamicMaterials) == 0x000010, "Member 'FM1ActorMaterialContext::DynamicMaterials' has a wrong offset!");

// ScriptStruct M1.M1ActorVFXKey
// 0x0008 (0x0008 - 0x0000)
struct FM1ActorVFXKey final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ActorVFXKey) == 0x000004, "Wrong alignment on FM1ActorVFXKey");
static_assert(sizeof(FM1ActorVFXKey) == 0x000008, "Wrong size on FM1ActorVFXKey");
static_assert(offsetof(FM1ActorVFXKey, Tag) == 0x000000, "Member 'FM1ActorVFXKey::Tag' has a wrong offset!");

// ScriptStruct M1.M1DataVisualFX_ParticleMaterial
// 0x0028 (0x0028 - 0x0000)
struct FM1DataVisualFX_ParticleMaterial final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1DataVisualFX_ScalarParameter> Scalars;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1DataVisualFX_VectorParameter> Vectors;                                           // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DataVisualFX_ParticleMaterial) == 0x000008, "Wrong alignment on FM1DataVisualFX_ParticleMaterial");
static_assert(sizeof(FM1DataVisualFX_ParticleMaterial) == 0x000028, "Wrong size on FM1DataVisualFX_ParticleMaterial");
static_assert(offsetof(FM1DataVisualFX_ParticleMaterial, ParamName) == 0x000000, "Member 'FM1DataVisualFX_ParticleMaterial::ParamName' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_ParticleMaterial, Scalars) == 0x000008, "Member 'FM1DataVisualFX_ParticleMaterial::Scalars' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_ParticleMaterial, Vectors) == 0x000018, "Member 'FM1DataVisualFX_ParticleMaterial::Vectors' has a wrong offset!");

// ScriptStruct M1.M1DataVisualFX_Particle
// 0x00B0 (0x00B0 - 0x0000)
struct FM1DataVisualFX_Particle final
{
public:
	bool                                          bForAllCharacterSize;                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1CharacterSize                              CharacterSize;                                     // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToMesh;                                     // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeapon;                                           // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1DataVisualFX_Filter_WeaponClass     WeaponClassFilter;                                 // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UM1DataBodyPart*                        BodyPart;                                          // 0x0020(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Sockets;                                           // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UFXSystemAsset*                         Asset;                                             // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmitterDelayTime;                                  // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowDuplicating;                                 // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1DataVisualFX_ScalarParameter> Scalars;                                           // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1DataVisualFX_VectorParameter> Vectors;                                           // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1DataVisualFX_ParticleMaterial> ParticleMaterials;                                 // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EM1DataVisualFXTransformRule                  TransformRule;                                     // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0080(0x0030)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DataVisualFX_Particle) == 0x000010, "Wrong alignment on FM1DataVisualFX_Particle");
static_assert(sizeof(FM1DataVisualFX_Particle) == 0x0000B0, "Wrong size on FM1DataVisualFX_Particle");
static_assert(offsetof(FM1DataVisualFX_Particle, bForAllCharacterSize) == 0x000000, "Member 'FM1DataVisualFX_Particle::bForAllCharacterSize' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Particle, CharacterSize) == 0x000001, "Member 'FM1DataVisualFX_Particle::CharacterSize' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Particle, bAttachToMesh) == 0x000002, "Member 'FM1DataVisualFX_Particle::bAttachToMesh' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Particle, bWeapon) == 0x000003, "Member 'FM1DataVisualFX_Particle::bWeapon' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Particle, WeaponClassFilter) == 0x000008, "Member 'FM1DataVisualFX_Particle::WeaponClassFilter' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Particle, BodyPart) == 0x000020, "Member 'FM1DataVisualFX_Particle::BodyPart' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Particle, Sockets) == 0x000028, "Member 'FM1DataVisualFX_Particle::Sockets' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Particle, Asset) == 0x000038, "Member 'FM1DataVisualFX_Particle::Asset' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Particle, EmitterDelayTime) == 0x000040, "Member 'FM1DataVisualFX_Particle::EmitterDelayTime' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Particle, bAllowDuplicating) == 0x000044, "Member 'FM1DataVisualFX_Particle::bAllowDuplicating' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Particle, Scalars) == 0x000048, "Member 'FM1DataVisualFX_Particle::Scalars' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Particle, Vectors) == 0x000058, "Member 'FM1DataVisualFX_Particle::Vectors' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Particle, ParticleMaterials) == 0x000068, "Member 'FM1DataVisualFX_Particle::ParticleMaterials' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Particle, TransformRule) == 0x000078, "Member 'FM1DataVisualFX_Particle::TransformRule' has a wrong offset!");
static_assert(offsetof(FM1DataVisualFX_Particle, Transform) == 0x000080, "Member 'FM1DataVisualFX_Particle::Transform' has a wrong offset!");

// ScriptStruct M1.M1ActorVFXInfo
// 0x0058 (0x0058 - 0x0000)
struct FM1ActorVFXInfo final
{
public:
	TArray<struct FM1DataVisualFX_Particle>       Particles;                                         // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FM1DataVisualFX_Material>       Materials;                                         // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UFXSystemComponent>> ManagedFXCs;                                       // 0x0030(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         ElapsedTime;                                       // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFadeOut;                                          // 0x0044(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeOutTime;                                       // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UMeshComponent>          ApplyOnlyMeshPtr;                                  // 0x004C(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ActorVFXInfo) == 0x000008, "Wrong alignment on FM1ActorVFXInfo");
static_assert(sizeof(FM1ActorVFXInfo) == 0x000058, "Wrong size on FM1ActorVFXInfo");
static_assert(offsetof(FM1ActorVFXInfo, Particles) == 0x000000, "Member 'FM1ActorVFXInfo::Particles' has a wrong offset!");
static_assert(offsetof(FM1ActorVFXInfo, Materials) == 0x000010, "Member 'FM1ActorVFXInfo::Materials' has a wrong offset!");
static_assert(offsetof(FM1ActorVFXInfo, Priority) == 0x000020, "Member 'FM1ActorVFXInfo::Priority' has a wrong offset!");
static_assert(offsetof(FM1ActorVFXInfo, StackCount) == 0x000024, "Member 'FM1ActorVFXInfo::StackCount' has a wrong offset!");
static_assert(offsetof(FM1ActorVFXInfo, Duration) == 0x000028, "Member 'FM1ActorVFXInfo::Duration' has a wrong offset!");
static_assert(offsetof(FM1ActorVFXInfo, ManagedFXCs) == 0x000030, "Member 'FM1ActorVFXInfo::ManagedFXCs' has a wrong offset!");
static_assert(offsetof(FM1ActorVFXInfo, ElapsedTime) == 0x000040, "Member 'FM1ActorVFXInfo::ElapsedTime' has a wrong offset!");
static_assert(offsetof(FM1ActorVFXInfo, bFadeOut) == 0x000044, "Member 'FM1ActorVFXInfo::bFadeOut' has a wrong offset!");
static_assert(offsetof(FM1ActorVFXInfo, FadeOutTime) == 0x000048, "Member 'FM1ActorVFXInfo::FadeOutTime' has a wrong offset!");
static_assert(offsetof(FM1ActorVFXInfo, ApplyOnlyMeshPtr) == 0x00004C, "Member 'FM1ActorVFXInfo::ApplyOnlyMeshPtr' has a wrong offset!");

// ScriptStruct M1.M1NxLog_WeaponUseCount
// 0x0070 (0x0070 - 0x0000)
struct FM1NxLog_WeaponUseCount final
{
public:
	class FString                                 ItemId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemUid;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemLevel;                                         // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Itemgrade;                                         // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Weaponshootcnt;                                    // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Monsterhitcnt;                                     // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Weaknesshitcnt;                                    // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_WeaponUseCount) == 0x000008, "Wrong alignment on FM1NxLog_WeaponUseCount");
static_assert(sizeof(FM1NxLog_WeaponUseCount) == 0x000070, "Wrong size on FM1NxLog_WeaponUseCount");
static_assert(offsetof(FM1NxLog_WeaponUseCount, ItemId) == 0x000000, "Member 'FM1NxLog_WeaponUseCount::ItemId' has a wrong offset!");
static_assert(offsetof(FM1NxLog_WeaponUseCount, ItemUid) == 0x000010, "Member 'FM1NxLog_WeaponUseCount::ItemUid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_WeaponUseCount, ItemLevel) == 0x000020, "Member 'FM1NxLog_WeaponUseCount::ItemLevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_WeaponUseCount, Itemgrade) == 0x000030, "Member 'FM1NxLog_WeaponUseCount::Itemgrade' has a wrong offset!");
static_assert(offsetof(FM1NxLog_WeaponUseCount, Weaponshootcnt) == 0x000040, "Member 'FM1NxLog_WeaponUseCount::Weaponshootcnt' has a wrong offset!");
static_assert(offsetof(FM1NxLog_WeaponUseCount, Monsterhitcnt) == 0x000050, "Member 'FM1NxLog_WeaponUseCount::Monsterhitcnt' has a wrong offset!");
static_assert(offsetof(FM1NxLog_WeaponUseCount, Weaknesshitcnt) == 0x000060, "Member 'FM1NxLog_WeaponUseCount::Weaknesshitcnt' has a wrong offset!");

// ScriptStruct M1.M1ActorVFX
// 0x0060 (0x0060 - 0x0000)
struct FM1ActorVFX final
{
public:
	struct FM1ActorVFXKey                         Key;                                               // 0x0000(0x0008)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1ActorVFXInfo                        Info;                                              // 0x0008(0x0058)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ActorVFX) == 0x000008, "Wrong alignment on FM1ActorVFX");
static_assert(sizeof(FM1ActorVFX) == 0x000060, "Wrong size on FM1ActorVFX");
static_assert(offsetof(FM1ActorVFX, Key) == 0x000000, "Member 'FM1ActorVFX::Key' has a wrong offset!");
static_assert(offsetof(FM1ActorVFX, Info) == 0x000008, "Member 'FM1ActorVFX::Info' has a wrong offset!");

// ScriptStruct M1.M1ActorWidgetSetting
// 0x0008 (0x0008 - 0x0000)
struct FM1ActorWidgetSetting final
{
public:
	float                                         VisibleDistanceInCityInMeters;                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VisibleDistanceInFieldInMeters;                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1ActorWidgetSetting) == 0x000004, "Wrong alignment on FM1ActorWidgetSetting");
static_assert(sizeof(FM1ActorWidgetSetting) == 0x000008, "Wrong size on FM1ActorWidgetSetting");
static_assert(offsetof(FM1ActorWidgetSetting, VisibleDistanceInCityInMeters) == 0x000000, "Member 'FM1ActorWidgetSetting::VisibleDistanceInCityInMeters' has a wrong offset!");
static_assert(offsetof(FM1ActorWidgetSetting, VisibleDistanceInFieldInMeters) == 0x000004, "Member 'FM1ActorWidgetSetting::VisibleDistanceInFieldInMeters' has a wrong offset!");

// ScriptStruct M1.M1MoveAdjustDistParam
// 0x0030 (0x0030 - 0x0000)
struct FM1MoveAdjustDistParam final
{
public:
	bool                                          bUseBBKey;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBKey;                                             // 0x0008(0x0028)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MoveAdjustDistParam) == 0x000008, "Wrong alignment on FM1MoveAdjustDistParam");
static_assert(sizeof(FM1MoveAdjustDistParam) == 0x000030, "Wrong size on FM1MoveAdjustDistParam");
static_assert(offsetof(FM1MoveAdjustDistParam, bUseBBKey) == 0x000000, "Member 'FM1MoveAdjustDistParam::bUseBBKey' has a wrong offset!");
static_assert(offsetof(FM1MoveAdjustDistParam, Value) == 0x000004, "Member 'FM1MoveAdjustDistParam::Value' has a wrong offset!");
static_assert(offsetof(FM1MoveAdjustDistParam, BBKey) == 0x000008, "Member 'FM1MoveAdjustDistParam::BBKey' has a wrong offset!");

// ScriptStruct M1.M1ExpUIData
// 0x0038 (0x0038 - 0x0000)
struct FM1ExpUIData final
{
public:
	TSoftObjectPtr<class UTexture2D>              ExpIcon;                                           // 0x0000(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExpStringId;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ExpUIData) == 0x000008, "Wrong alignment on FM1ExpUIData");
static_assert(sizeof(FM1ExpUIData) == 0x000038, "Wrong size on FM1ExpUIData");
static_assert(offsetof(FM1ExpUIData, ExpIcon) == 0x000000, "Member 'FM1ExpUIData::ExpIcon' has a wrong offset!");
static_assert(offsetof(FM1ExpUIData, ExpStringId) == 0x000030, "Member 'FM1ExpUIData::ExpStringId' has a wrong offset!");

// ScriptStruct M1.M1EQSConfigParam
// 0x0038 (0x0038 - 0x0000)
struct FM1EQSConfigParam final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBlackboardKey;                                 // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 EQSQueryBlackboardKey;                             // 0x0010(0x0028)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EQSConfigParam) == 0x000008, "Wrong alignment on FM1EQSConfigParam");
static_assert(sizeof(FM1EQSConfigParam) == 0x000038, "Wrong size on FM1EQSConfigParam");
static_assert(offsetof(FM1EQSConfigParam, Name) == 0x000000, "Member 'FM1EQSConfigParam::Name' has a wrong offset!");
static_assert(offsetof(FM1EQSConfigParam, bUseBlackboardKey) == 0x000008, "Member 'FM1EQSConfigParam::bUseBlackboardKey' has a wrong offset!");
static_assert(offsetof(FM1EQSConfigParam, Value) == 0x00000C, "Member 'FM1EQSConfigParam::Value' has a wrong offset!");
static_assert(offsetof(FM1EQSConfigParam, EQSQueryBlackboardKey) == 0x000010, "Member 'FM1EQSConfigParam::EQSQueryBlackboardKey' has a wrong offset!");

// ScriptStruct M1.M1MoveDurationParam
// 0x0038 (0x0038 - 0x0000)
struct FM1MoveDurationParam final
{
public:
	bool                                          bUseBlackboardKey;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 DurationBlackboardKey;                             // 0x0008(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         RandomDeviation;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MoveDurationParam) == 0x000008, "Wrong alignment on FM1MoveDurationParam");
static_assert(sizeof(FM1MoveDurationParam) == 0x000038, "Wrong size on FM1MoveDurationParam");
static_assert(offsetof(FM1MoveDurationParam, bUseBlackboardKey) == 0x000000, "Member 'FM1MoveDurationParam::bUseBlackboardKey' has a wrong offset!");
static_assert(offsetof(FM1MoveDurationParam, Duration) == 0x000004, "Member 'FM1MoveDurationParam::Duration' has a wrong offset!");
static_assert(offsetof(FM1MoveDurationParam, DurationBlackboardKey) == 0x000008, "Member 'FM1MoveDurationParam::DurationBlackboardKey' has a wrong offset!");
static_assert(offsetof(FM1MoveDurationParam, RandomDeviation) == 0x000030, "Member 'FM1MoveDurationParam::RandomDeviation' has a wrong offset!");

// ScriptStruct M1.M1OptionValueGamepadKeySetting
// 0x0048 (0x0048 - 0x0000)
struct FM1OptionValueGamepadKeySetting final
{
public:
	EM1BattleKey                                  BattleKey;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1BattleInputChord                    MainKey;                                           // 0x0008(0x0040)(Edit, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1OptionValueGamepadKeySetting) == 0x000008, "Wrong alignment on FM1OptionValueGamepadKeySetting");
static_assert(sizeof(FM1OptionValueGamepadKeySetting) == 0x000048, "Wrong size on FM1OptionValueGamepadKeySetting");
static_assert(offsetof(FM1OptionValueGamepadKeySetting, BattleKey) == 0x000000, "Member 'FM1OptionValueGamepadKeySetting::BattleKey' has a wrong offset!");
static_assert(offsetof(FM1OptionValueGamepadKeySetting, MainKey) == 0x000008, "Member 'FM1OptionValueGamepadKeySetting::MainKey' has a wrong offset!");

// ScriptStruct M1.M1AISpawnPlan
// 0x0020 (0x0020 - 0x0000)
struct FM1AISpawnPlan final
{
public:
	class AM1AISpawnPoint*                        SpawnPoint;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UM1AISpawnData*                         SpawnData;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelSequence*                         Sequence;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SequenceStartDelay;                                // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AISpawnPlan) == 0x000008, "Wrong alignment on FM1AISpawnPlan");
static_assert(sizeof(FM1AISpawnPlan) == 0x000020, "Wrong size on FM1AISpawnPlan");
static_assert(offsetof(FM1AISpawnPlan, SpawnPoint) == 0x000000, "Member 'FM1AISpawnPlan::SpawnPoint' has a wrong offset!");
static_assert(offsetof(FM1AISpawnPlan, SpawnData) == 0x000008, "Member 'FM1AISpawnPlan::SpawnData' has a wrong offset!");
static_assert(offsetof(FM1AISpawnPlan, Sequence) == 0x000010, "Member 'FM1AISpawnPlan::Sequence' has a wrong offset!");
static_assert(offsetof(FM1AISpawnPlan, SequenceStartDelay) == 0x000018, "Member 'FM1AISpawnPlan::SequenceStartDelay' has a wrong offset!");

// ScriptStruct M1.M1HitBoneGroupData
// 0x0030 (0x0030 - 0x0000)
struct FM1HitBoneGroupData final
{
public:
	TArray<class FName>                           CheckHitBoneNames;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCheckChildBone;                                   // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxHitCount;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          AttachSkeletalMesh;                                // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshWorldScale;                                    // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachBoneName;                                    // 0x0024(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1HitBoneGroupData) == 0x000008, "Wrong alignment on FM1HitBoneGroupData");
static_assert(sizeof(FM1HitBoneGroupData) == 0x000030, "Wrong size on FM1HitBoneGroupData");
static_assert(offsetof(FM1HitBoneGroupData, CheckHitBoneNames) == 0x000000, "Member 'FM1HitBoneGroupData::CheckHitBoneNames' has a wrong offset!");
static_assert(offsetof(FM1HitBoneGroupData, bCheckChildBone) == 0x000010, "Member 'FM1HitBoneGroupData::bCheckChildBone' has a wrong offset!");
static_assert(offsetof(FM1HitBoneGroupData, MaxHitCount) == 0x000014, "Member 'FM1HitBoneGroupData::MaxHitCount' has a wrong offset!");
static_assert(offsetof(FM1HitBoneGroupData, AttachSkeletalMesh) == 0x000018, "Member 'FM1HitBoneGroupData::AttachSkeletalMesh' has a wrong offset!");
static_assert(offsetof(FM1HitBoneGroupData, MeshWorldScale) == 0x000020, "Member 'FM1HitBoneGroupData::MeshWorldScale' has a wrong offset!");
static_assert(offsetof(FM1HitBoneGroupData, AttachBoneName) == 0x000024, "Member 'FM1HitBoneGroupData::AttachBoneName' has a wrong offset!");

// ScriptStruct M1.M1AISpawnPhaseInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1AISpawnPhaseInfo final
{
public:
	TArray<struct FM1AISpawnPlan>                 SpawnPlan;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PhaseGoal;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             BGM;                                               // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AISpawnPhaseInfo) == 0x000008, "Wrong alignment on FM1AISpawnPhaseInfo");
static_assert(sizeof(FM1AISpawnPhaseInfo) == 0x000020, "Wrong size on FM1AISpawnPhaseInfo");
static_assert(offsetof(FM1AISpawnPhaseInfo, SpawnPlan) == 0x000000, "Member 'FM1AISpawnPhaseInfo::SpawnPlan' has a wrong offset!");
static_assert(offsetof(FM1AISpawnPhaseInfo, PhaseGoal) == 0x000010, "Member 'FM1AISpawnPhaseInfo::PhaseGoal' has a wrong offset!");
static_assert(offsetof(FM1AISpawnPhaseInfo, BGM) == 0x000018, "Member 'FM1AISpawnPhaseInfo::BGM' has a wrong offset!");

// ScriptStruct M1.M1SpawnData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FM1SpawnData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SpawnData) == 0x000008, "Wrong alignment on FM1SpawnData");
static_assert(sizeof(FM1SpawnData) == 0x000018, "Wrong size on FM1SpawnData");

// ScriptStruct M1.M1TargetSearchRadius
// 0x0008 (0x0008 - 0x0000)
struct FM1TargetSearchRadius final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TargetSearchRadius) == 0x000004, "Wrong alignment on FM1TargetSearchRadius");
static_assert(sizeof(FM1TargetSearchRadius) == 0x000008, "Wrong size on FM1TargetSearchRadius");
static_assert(offsetof(FM1TargetSearchRadius, Min) == 0x000000, "Member 'FM1TargetSearchRadius::Min' has a wrong offset!");
static_assert(offsetof(FM1TargetSearchRadius, Max) == 0x000004, "Member 'FM1TargetSearchRadius::Max' has a wrong offset!");

// ScriptStruct M1.M1UIEvent_CustomFloaterReceived
// 0x0030 (0x0030 - 0x0000)
struct FM1UIEvent_CustomFloaterReceived final
{
public:
	EM1CustomFloaterType                          CustomType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringToDraw;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldLocation;                                     // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultRandomWorldOffset;                      // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_CustomFloaterReceived) == 0x000008, "Wrong alignment on FM1UIEvent_CustomFloaterReceived");
static_assert(sizeof(FM1UIEvent_CustomFloaterReceived) == 0x000030, "Wrong size on FM1UIEvent_CustomFloaterReceived");
static_assert(offsetof(FM1UIEvent_CustomFloaterReceived, CustomType) == 0x000000, "Member 'FM1UIEvent_CustomFloaterReceived::CustomType' has a wrong offset!");
static_assert(offsetof(FM1UIEvent_CustomFloaterReceived, StringToDraw) == 0x000008, "Member 'FM1UIEvent_CustomFloaterReceived::StringToDraw' has a wrong offset!");
static_assert(offsetof(FM1UIEvent_CustomFloaterReceived, TargetActor) == 0x000018, "Member 'FM1UIEvent_CustomFloaterReceived::TargetActor' has a wrong offset!");
static_assert(offsetof(FM1UIEvent_CustomFloaterReceived, WorldLocation) == 0x000020, "Member 'FM1UIEvent_CustomFloaterReceived::WorldLocation' has a wrong offset!");
static_assert(offsetof(FM1UIEvent_CustomFloaterReceived, bUseDefaultRandomWorldOffset) == 0x00002C, "Member 'FM1UIEvent_CustomFloaterReceived::bUseDefaultRandomWorldOffset' has a wrong offset!");

// ScriptStruct M1.M1MonsterAIEventParam
// 0x0018 (0x0018 - 0x0000)
struct FM1MonsterAIEventParam final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterAIEventParam) == 0x000008, "Wrong alignment on FM1MonsterAIEventParam");
static_assert(sizeof(FM1MonsterAIEventParam) == 0x000018, "Wrong size on FM1MonsterAIEventParam");
static_assert(offsetof(FM1MonsterAIEventParam, Name) == 0x000000, "Member 'FM1MonsterAIEventParam::Name' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIEventParam, Value) == 0x000008, "Member 'FM1MonsterAIEventParam::Value' has a wrong offset!");

// ScriptStruct M1.M1MonsterAIEventData
// 0x0028 (0x0028 - 0x0000)
struct FM1MonsterAIEventData final
{
public:
	EM1AIEventType                                Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         Actors;                                            // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1MonsterAIEventParam>         Params;                                            // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterAIEventData) == 0x000008, "Wrong alignment on FM1MonsterAIEventData");
static_assert(sizeof(FM1MonsterAIEventData) == 0x000028, "Wrong size on FM1MonsterAIEventData");
static_assert(offsetof(FM1MonsterAIEventData, Type) == 0x000000, "Member 'FM1MonsterAIEventData::Type' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIEventData, Actors) == 0x000008, "Member 'FM1MonsterAIEventData::Actors' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIEventData, Params) == 0x000018, "Member 'FM1MonsterAIEventData::Params' has a wrong offset!");

// ScriptStruct M1.M1PreloadScreenParam
// 0x0030 (0x0030 - 0x0000)
struct FM1PreloadScreenParam final
{
public:
	class FString                                 MapStringId;                                       // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UTexture2D>              LoadingImage;                                      // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ToolTipArray;                                      // 0x0018(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PreloadScreenParam) == 0x000008, "Wrong alignment on FM1PreloadScreenParam");
static_assert(sizeof(FM1PreloadScreenParam) == 0x000030, "Wrong size on FM1PreloadScreenParam");
static_assert(offsetof(FM1PreloadScreenParam, MapStringId) == 0x000000, "Member 'FM1PreloadScreenParam::MapStringId' has a wrong offset!");
static_assert(offsetof(FM1PreloadScreenParam, LoadingImage) == 0x000010, "Member 'FM1PreloadScreenParam::LoadingImage' has a wrong offset!");
static_assert(offsetof(FM1PreloadScreenParam, ToolTipArray) == 0x000018, "Member 'FM1PreloadScreenParam::ToolTipArray' has a wrong offset!");

// ScriptStruct M1.M1AnimClass
// 0x0028 (0x0028 - 0x0000)
struct FM1AnimClass final
{
public:
	EM1PlayerAnimType                             AnimType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         AnimClass;                                         // 0x0008(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AnimClass) == 0x000008, "Wrong alignment on FM1AnimClass");
static_assert(sizeof(FM1AnimClass) == 0x000028, "Wrong size on FM1AnimClass");
static_assert(offsetof(FM1AnimClass, AnimType) == 0x000000, "Member 'FM1AnimClass::AnimType' has a wrong offset!");
static_assert(offsetof(FM1AnimClass, AnimClass) == 0x000008, "Member 'FM1AnimClass::AnimClass' has a wrong offset!");

// ScriptStruct M1.M1AnimClassList
// 0x0010 (0x0010 - 0x0000)
struct FM1AnimClassList final
{
public:
	TArray<struct FM1AnimClass>                   ClassesByAnimType;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AnimClassList) == 0x000008, "Wrong alignment on FM1AnimClassList");
static_assert(sizeof(FM1AnimClassList) == 0x000010, "Wrong size on FM1AnimClassList");
static_assert(offsetof(FM1AnimClassList, ClassesByAnimType) == 0x000000, "Member 'FM1AnimClassList::ClassesByAnimType' has a wrong offset!");

// ScriptStruct M1.M1KeyDuplicateSetting
// 0x0018 (0x0018 - 0x0000)
struct FM1KeyDuplicateSetting final
{
public:
	int32                                         KeyKind;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EM1SystemKey>                          CustomBlockDuplicateSystemKey;                     // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1KeyDuplicateSetting) == 0x000008, "Wrong alignment on FM1KeyDuplicateSetting");
static_assert(sizeof(FM1KeyDuplicateSetting) == 0x000018, "Wrong size on FM1KeyDuplicateSetting");
static_assert(offsetof(FM1KeyDuplicateSetting, KeyKind) == 0x000000, "Member 'FM1KeyDuplicateSetting::KeyKind' has a wrong offset!");
static_assert(offsetof(FM1KeyDuplicateSetting, CustomBlockDuplicateSystemKey) == 0x000008, "Member 'FM1KeyDuplicateSetting::CustomBlockDuplicateSystemKey' has a wrong offset!");

// ScriptStruct M1.M1AnimSetsForPresetTypes
// 0x00A0 (0x00A0 - 0x0000)
struct FM1AnimSetsForPresetTypes final
{
public:
	TMap<EM1LayerAnimSetType, struct FM1AnimClassList> MalePreset;                                        // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EM1LayerAnimSetType, struct FM1AnimClassList> FemalePreset;                                      // 0x0050(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AnimSetsForPresetTypes) == 0x000008, "Wrong alignment on FM1AnimSetsForPresetTypes");
static_assert(sizeof(FM1AnimSetsForPresetTypes) == 0x0000A0, "Wrong size on FM1AnimSetsForPresetTypes");
static_assert(offsetof(FM1AnimSetsForPresetTypes, MalePreset) == 0x000000, "Member 'FM1AnimSetsForPresetTypes::MalePreset' has a wrong offset!");
static_assert(offsetof(FM1AnimSetsForPresetTypes, FemalePreset) == 0x000050, "Member 'FM1AnimSetsForPresetTypes::FemalePreset' has a wrong offset!");

// ScriptStruct M1.M1PartsIndicatorInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1PartsIndicatorInfo final
{
public:
	TArray<class UMaterialInterface*>             EffectMaterials;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PartsIndicatorInfo) == 0x000008, "Wrong alignment on FM1PartsIndicatorInfo");
static_assert(sizeof(FM1PartsIndicatorInfo) == 0x000010, "Wrong size on FM1PartsIndicatorInfo");
static_assert(offsetof(FM1PartsIndicatorInfo, EffectMaterials) == 0x000000, "Member 'FM1PartsIndicatorInfo::EffectMaterials' has a wrong offset!");

// ScriptStruct M1.M1AnimNode_ApplyFacialAdditive
// 0x0088 (0x0098 - 0x0010)
struct FM1AnimNode_ApplyFacialAdditive final : public FAnimNode_Base
{
public:
	struct FPoseLink                              Base;                                              // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         FacialRootBone;                                    // 0x0020(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RefPoseSequence;                                   // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODThreshold;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AlphaCurveName;                                    // 0x003C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  SkeletonGuid;                                      // 0x0044(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  VirtualBoneGuid;                                   // 0x0054(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x34];                                      // 0x0064(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AnimNode_ApplyFacialAdditive) == 0x000008, "Wrong alignment on FM1AnimNode_ApplyFacialAdditive");
static_assert(sizeof(FM1AnimNode_ApplyFacialAdditive) == 0x000098, "Wrong size on FM1AnimNode_ApplyFacialAdditive");
static_assert(offsetof(FM1AnimNode_ApplyFacialAdditive, Base) == 0x000010, "Member 'FM1AnimNode_ApplyFacialAdditive::Base' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ApplyFacialAdditive, FacialRootBone) == 0x000020, "Member 'FM1AnimNode_ApplyFacialAdditive::FacialRootBone' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ApplyFacialAdditive, RefPoseSequence) == 0x000030, "Member 'FM1AnimNode_ApplyFacialAdditive::RefPoseSequence' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ApplyFacialAdditive, LODThreshold) == 0x000038, "Member 'FM1AnimNode_ApplyFacialAdditive::LODThreshold' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ApplyFacialAdditive, AlphaCurveName) == 0x00003C, "Member 'FM1AnimNode_ApplyFacialAdditive::AlphaCurveName' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ApplyFacialAdditive, SkeletonGuid) == 0x000044, "Member 'FM1AnimNode_ApplyFacialAdditive::SkeletonGuid' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ApplyFacialAdditive, VirtualBoneGuid) == 0x000054, "Member 'FM1AnimNode_ApplyFacialAdditive::VirtualBoneGuid' has a wrong offset!");

// ScriptStruct M1.M1AnimNode_CrotchIK
// 0x0098 (0x00A8 - 0x0010)
struct FM1AnimNode_CrotchIK final : public FAnimNode_Base
{
public:
	struct FPoseLink                              Base;                                              // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Thigh_L;                                           // 0x0020(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Crotch_L1;                                         // 0x0030(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Crotch_L2;                                         // 0x0040(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         ThighTw_L1;                                        // 0x0050(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Thigh_R;                                           // 0x0060(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Crotch_R1;                                         // 0x0070(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Crotch_R2;                                         // 0x0080(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         ThighTw_R1;                                        // 0x0090(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AnimNode_CrotchIK) == 0x000008, "Wrong alignment on FM1AnimNode_CrotchIK");
static_assert(sizeof(FM1AnimNode_CrotchIK) == 0x0000A8, "Wrong size on FM1AnimNode_CrotchIK");
static_assert(offsetof(FM1AnimNode_CrotchIK, Base) == 0x000010, "Member 'FM1AnimNode_CrotchIK::Base' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_CrotchIK, Thigh_L) == 0x000020, "Member 'FM1AnimNode_CrotchIK::Thigh_L' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_CrotchIK, Crotch_L1) == 0x000030, "Member 'FM1AnimNode_CrotchIK::Crotch_L1' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_CrotchIK, Crotch_L2) == 0x000040, "Member 'FM1AnimNode_CrotchIK::Crotch_L2' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_CrotchIK, ThighTw_L1) == 0x000050, "Member 'FM1AnimNode_CrotchIK::ThighTw_L1' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_CrotchIK, Thigh_R) == 0x000060, "Member 'FM1AnimNode_CrotchIK::Thigh_R' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_CrotchIK, Crotch_R1) == 0x000070, "Member 'FM1AnimNode_CrotchIK::Crotch_R1' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_CrotchIK, Crotch_R2) == 0x000080, "Member 'FM1AnimNode_CrotchIK::Crotch_R2' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_CrotchIK, ThighTw_R1) == 0x000090, "Member 'FM1AnimNode_CrotchIK::ThighTw_R1' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_CrotchIK, bEnabled) == 0x0000A0, "Member 'FM1AnimNode_CrotchIK::bEnabled' has a wrong offset!");

// ScriptStruct M1.M1AnimNode_HeadIK
// 0x00F8 (0x01C0 - 0x00C8)
struct alignas(0x10) FM1AnimNode_HeadIK final : public FAnimNode_SkeletalControlBase
{
public:
	bool                                          bEnableEyesParallalAim;                            // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         EyeLeftBone;                                       // 0x00CC(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         EyeRightBone;                                      // 0x00DC(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EyeAimClamp;                                       // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAxis                                  EyeLookAtAxis;                                     // 0x00F0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableHeadAim;                                    // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         BustBone;                                          // 0x0104(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         HeadBone;                                          // 0x0114(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         HeadAimClamp;                                      // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAxis                                  HeadLookAtAxis;                                    // 0x0128(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                AimLocation;                                       // 0x0138(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x7C];                                     // 0x0144(0x007C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AnimNode_HeadIK) == 0x000010, "Wrong alignment on FM1AnimNode_HeadIK");
static_assert(sizeof(FM1AnimNode_HeadIK) == 0x0001C0, "Wrong size on FM1AnimNode_HeadIK");
static_assert(offsetof(FM1AnimNode_HeadIK, bEnableEyesParallalAim) == 0x0000C8, "Member 'FM1AnimNode_HeadIK::bEnableEyesParallalAim' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_HeadIK, EyeLeftBone) == 0x0000CC, "Member 'FM1AnimNode_HeadIK::EyeLeftBone' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_HeadIK, EyeRightBone) == 0x0000DC, "Member 'FM1AnimNode_HeadIK::EyeRightBone' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_HeadIK, EyeAimClamp) == 0x0000EC, "Member 'FM1AnimNode_HeadIK::EyeAimClamp' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_HeadIK, EyeLookAtAxis) == 0x0000F0, "Member 'FM1AnimNode_HeadIK::EyeLookAtAxis' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_HeadIK, bEnableHeadAim) == 0x000100, "Member 'FM1AnimNode_HeadIK::bEnableHeadAim' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_HeadIK, BustBone) == 0x000104, "Member 'FM1AnimNode_HeadIK::BustBone' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_HeadIK, HeadBone) == 0x000114, "Member 'FM1AnimNode_HeadIK::HeadBone' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_HeadIK, HeadAimClamp) == 0x000124, "Member 'FM1AnimNode_HeadIK::HeadAimClamp' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_HeadIK, HeadLookAtAxis) == 0x000128, "Member 'FM1AnimNode_HeadIK::HeadLookAtAxis' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_HeadIK, AimLocation) == 0x000138, "Member 'FM1AnimNode_HeadIK::AimLocation' has a wrong offset!");

// ScriptStruct M1.M1LegGroundDefinition
// 0x0070 (0x0070 - 0x0000)
struct FM1LegGroundDefinition final
{
public:
	int32                                         UppermostLegBoneIndex;                             // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefPoseFootZOffset;                                // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             IKFootOrigTransformWS;                             // 0x0010(0x0030)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FootGroundRotation;                                // 0x0040(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ComponentZToFootImpactZ;                           // 0x004C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLimbLength;                                     // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x1C];                                      // 0x0054(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1LegGroundDefinition) == 0x000010, "Wrong alignment on FM1LegGroundDefinition");
static_assert(sizeof(FM1LegGroundDefinition) == 0x000070, "Wrong size on FM1LegGroundDefinition");
static_assert(offsetof(FM1LegGroundDefinition, UppermostLegBoneIndex) == 0x000000, "Member 'FM1LegGroundDefinition::UppermostLegBoneIndex' has a wrong offset!");
static_assert(offsetof(FM1LegGroundDefinition, RefPoseFootZOffset) == 0x000004, "Member 'FM1LegGroundDefinition::RefPoseFootZOffset' has a wrong offset!");
static_assert(offsetof(FM1LegGroundDefinition, IKFootOrigTransformWS) == 0x000010, "Member 'FM1LegGroundDefinition::IKFootOrigTransformWS' has a wrong offset!");
static_assert(offsetof(FM1LegGroundDefinition, FootGroundRotation) == 0x000040, "Member 'FM1LegGroundDefinition::FootGroundRotation' has a wrong offset!");
static_assert(offsetof(FM1LegGroundDefinition, ComponentZToFootImpactZ) == 0x00004C, "Member 'FM1LegGroundDefinition::ComponentZToFootImpactZ' has a wrong offset!");
static_assert(offsetof(FM1LegGroundDefinition, MaxLimbLength) == 0x000050, "Member 'FM1LegGroundDefinition::MaxLimbLength' has a wrong offset!");

// ScriptStruct M1.M1AnimNode_LegGroundIK
// 0x0108 (0x0200 - 0x00F8)
struct FM1AnimNode_LegGroundIK final : public FAnimNode_LegIK
{
public:
	float                                         SweepRadius;                                       // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableFootRotation;                               // 0x00FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FootTraceExtentZ;                                  // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FootInterpRotationSpeed;                           // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               FootRotationLimit;                                 // 0x0108(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         FootInterpLocationSpeed;                           // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBoneReference                         PelvisBone;                                        // 0x0118(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         PelvisInterpLocationSpeed;                         // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PelvisOffsetMaxSize;                               // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PelvisOffsetAboveFoot;                             // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FM1LegGroundDefinition> LegsGroundDefinition;                              // 0x0138(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	float                                         PelvisOffset;                                      // 0x0188(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            OwnerMovementComp;                                 // 0x0190(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 OwnerActor;                                        // 0x0198(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMoveCompIsWalking;                                // 0x01A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A1[0xF];                                      // 0x01A1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ComponentTransform;                                // 0x01B0(0x0030)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ComponentTransformTraceDiffZ;                      // 0x01E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E4[0x1C];                                     // 0x01E4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AnimNode_LegGroundIK) == 0x000010, "Wrong alignment on FM1AnimNode_LegGroundIK");
static_assert(sizeof(FM1AnimNode_LegGroundIK) == 0x000200, "Wrong size on FM1AnimNode_LegGroundIK");
static_assert(offsetof(FM1AnimNode_LegGroundIK, SweepRadius) == 0x0000F8, "Member 'FM1AnimNode_LegGroundIK::SweepRadius' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_LegGroundIK, bEnableFootRotation) == 0x0000FC, "Member 'FM1AnimNode_LegGroundIK::bEnableFootRotation' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_LegGroundIK, FootTraceExtentZ) == 0x000100, "Member 'FM1AnimNode_LegGroundIK::FootTraceExtentZ' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_LegGroundIK, FootInterpRotationSpeed) == 0x000104, "Member 'FM1AnimNode_LegGroundIK::FootInterpRotationSpeed' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_LegGroundIK, FootRotationLimit) == 0x000108, "Member 'FM1AnimNode_LegGroundIK::FootRotationLimit' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_LegGroundIK, FootInterpLocationSpeed) == 0x000114, "Member 'FM1AnimNode_LegGroundIK::FootInterpLocationSpeed' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_LegGroundIK, PelvisBone) == 0x000118, "Member 'FM1AnimNode_LegGroundIK::PelvisBone' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_LegGroundIK, PelvisInterpLocationSpeed) == 0x000128, "Member 'FM1AnimNode_LegGroundIK::PelvisInterpLocationSpeed' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_LegGroundIK, PelvisOffsetMaxSize) == 0x00012C, "Member 'FM1AnimNode_LegGroundIK::PelvisOffsetMaxSize' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_LegGroundIK, PelvisOffsetAboveFoot) == 0x000130, "Member 'FM1AnimNode_LegGroundIK::PelvisOffsetAboveFoot' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_LegGroundIK, LegsGroundDefinition) == 0x000138, "Member 'FM1AnimNode_LegGroundIK::LegsGroundDefinition' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_LegGroundIK, PelvisOffset) == 0x000188, "Member 'FM1AnimNode_LegGroundIK::PelvisOffset' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_LegGroundIK, OwnerMovementComp) == 0x000190, "Member 'FM1AnimNode_LegGroundIK::OwnerMovementComp' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_LegGroundIK, OwnerActor) == 0x000198, "Member 'FM1AnimNode_LegGroundIK::OwnerActor' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_LegGroundIK, bMoveCompIsWalking) == 0x0001A0, "Member 'FM1AnimNode_LegGroundIK::bMoveCompIsWalking' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_LegGroundIK, ComponentTransform) == 0x0001B0, "Member 'FM1AnimNode_LegGroundIK::ComponentTransform' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_LegGroundIK, ComponentTransformTraceDiffZ) == 0x0001E0, "Member 'FM1AnimNode_LegGroundIK::ComponentTransformTraceDiffZ' has a wrong offset!");

// ScriptStruct M1.M1TaskWaypoint
// 0x0010 (0x0010 - 0x0000)
struct FM1TaskWaypoint final
{
public:
	bool                                          bVisited;                                          // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AM1MissionTaskMoveWayPoint*             Waypoint;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TaskWaypoint) == 0x000008, "Wrong alignment on FM1TaskWaypoint");
static_assert(sizeof(FM1TaskWaypoint) == 0x000010, "Wrong size on FM1TaskWaypoint");
static_assert(offsetof(FM1TaskWaypoint, bVisited) == 0x000000, "Member 'FM1TaskWaypoint::bVisited' has a wrong offset!");
static_assert(offsetof(FM1TaskWaypoint, Waypoint) == 0x000008, "Member 'FM1TaskWaypoint::Waypoint' has a wrong offset!");

// ScriptStruct M1.M1AnimNode_LinkConstraint
// 0x0058 (0x0120 - 0x00C8)
struct FM1AnimNode_LinkConstraint final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         LinkSource;                                        // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LinkTarget;                                        // 0x00D8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsRelevant;                                       // 0x00E8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SourceRelativeToTargetTM;                          // 0x00F0(0x0030)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AnimNode_LinkConstraint) == 0x000010, "Wrong alignment on FM1AnimNode_LinkConstraint");
static_assert(sizeof(FM1AnimNode_LinkConstraint) == 0x000120, "Wrong size on FM1AnimNode_LinkConstraint");
static_assert(offsetof(FM1AnimNode_LinkConstraint, LinkSource) == 0x0000C8, "Member 'FM1AnimNode_LinkConstraint::LinkSource' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_LinkConstraint, LinkTarget) == 0x0000D8, "Member 'FM1AnimNode_LinkConstraint::LinkTarget' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_LinkConstraint, bIsRelevant) == 0x0000E8, "Member 'FM1AnimNode_LinkConstraint::bIsRelevant' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_LinkConstraint, SourceRelativeToTargetTM) == 0x0000F0, "Member 'FM1AnimNode_LinkConstraint::SourceRelativeToTargetTM' has a wrong offset!");

// ScriptStruct M1.M1AnkleHighExpression
// 0x0044 (0x0044 - 0x0000)
struct FM1AnkleHighExpression final
{
public:
	struct FBoneReference                         Foot_L;                                            // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Ankle_Hi_L1;                                       // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Foot_R;                                            // 0x0020(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Ankle_Hi_R1;                                       // 0x0030(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bValid;                                            // 0x0040(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AnkleHighExpression) == 0x000004, "Wrong alignment on FM1AnkleHighExpression");
static_assert(sizeof(FM1AnkleHighExpression) == 0x000044, "Wrong size on FM1AnkleHighExpression");
static_assert(offsetof(FM1AnkleHighExpression, Foot_L) == 0x000000, "Member 'FM1AnkleHighExpression::Foot_L' has a wrong offset!");
static_assert(offsetof(FM1AnkleHighExpression, Ankle_Hi_L1) == 0x000010, "Member 'FM1AnkleHighExpression::Ankle_Hi_L1' has a wrong offset!");
static_assert(offsetof(FM1AnkleHighExpression, Foot_R) == 0x000020, "Member 'FM1AnkleHighExpression::Foot_R' has a wrong offset!");
static_assert(offsetof(FM1AnkleHighExpression, Ankle_Hi_R1) == 0x000030, "Member 'FM1AnkleHighExpression::Ankle_Hi_R1' has a wrong offset!");
static_assert(offsetof(FM1AnkleHighExpression, bValid) == 0x000040, "Member 'FM1AnkleHighExpression::bValid' has a wrong offset!");

// ScriptStruct M1.M1AnkleLowExpression
// 0x0064 (0x0064 - 0x0000)
struct FM1AnkleLowExpression final
{
public:
	struct FBoneReference                         Foot_L;                                            // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Ankle_Low_L1;                                      // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Ankle_Low_L11;                                     // 0x0020(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Foot_R;                                            // 0x0030(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Ankle_Low_R1;                                      // 0x0040(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Ankle_Low_R11;                                     // 0x0050(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bValid;                                            // 0x0060(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AnkleLowExpression) == 0x000004, "Wrong alignment on FM1AnkleLowExpression");
static_assert(sizeof(FM1AnkleLowExpression) == 0x000064, "Wrong size on FM1AnkleLowExpression");
static_assert(offsetof(FM1AnkleLowExpression, Foot_L) == 0x000000, "Member 'FM1AnkleLowExpression::Foot_L' has a wrong offset!");
static_assert(offsetof(FM1AnkleLowExpression, Ankle_Low_L1) == 0x000010, "Member 'FM1AnkleLowExpression::Ankle_Low_L1' has a wrong offset!");
static_assert(offsetof(FM1AnkleLowExpression, Ankle_Low_L11) == 0x000020, "Member 'FM1AnkleLowExpression::Ankle_Low_L11' has a wrong offset!");
static_assert(offsetof(FM1AnkleLowExpression, Foot_R) == 0x000030, "Member 'FM1AnkleLowExpression::Foot_R' has a wrong offset!");
static_assert(offsetof(FM1AnkleLowExpression, Ankle_Low_R1) == 0x000040, "Member 'FM1AnkleLowExpression::Ankle_Low_R1' has a wrong offset!");
static_assert(offsetof(FM1AnkleLowExpression, Ankle_Low_R11) == 0x000050, "Member 'FM1AnkleLowExpression::Ankle_Low_R11' has a wrong offset!");
static_assert(offsetof(FM1AnkleLowExpression, bValid) == 0x000060, "Member 'FM1AnkleLowExpression::bValid' has a wrong offset!");

// ScriptStruct M1.M1NxLogRecord
// 0x0040 (0x0040 - 0x0000)
struct FM1NxLogRecord final
{
public:
	class FString                                 Recordholdertype;                                  // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Recordholderid;                                    // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RecordType;                                        // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogDouble                         Recordvalue;                                       // 0x0030(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLogRecord) == 0x000008, "Wrong alignment on FM1NxLogRecord");
static_assert(sizeof(FM1NxLogRecord) == 0x000040, "Wrong size on FM1NxLogRecord");
static_assert(offsetof(FM1NxLogRecord, Recordholdertype) == 0x000000, "Member 'FM1NxLogRecord::Recordholdertype' has a wrong offset!");
static_assert(offsetof(FM1NxLogRecord, Recordholderid) == 0x000010, "Member 'FM1NxLogRecord::Recordholderid' has a wrong offset!");
static_assert(offsetof(FM1NxLogRecord, RecordType) == 0x000020, "Member 'FM1NxLogRecord::RecordType' has a wrong offset!");
static_assert(offsetof(FM1NxLogRecord, Recordvalue) == 0x000030, "Member 'FM1NxLogRecord::Recordvalue' has a wrong offset!");

// ScriptStruct M1.M1NxLogReward
// 0x0080 (0x0080 - 0x0000)
struct FM1NxLogReward final
{
public:
	class FString                                 Category;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Cnt;                                               // 0x0010(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 ID;                                                // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Idcategory;                                        // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MailId;                                            // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Rewardpositiontype;                                // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Type;                                              // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Uid;                                               // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLogReward) == 0x000008, "Wrong alignment on FM1NxLogReward");
static_assert(sizeof(FM1NxLogReward) == 0x000080, "Wrong size on FM1NxLogReward");
static_assert(offsetof(FM1NxLogReward, Category) == 0x000000, "Member 'FM1NxLogReward::Category' has a wrong offset!");
static_assert(offsetof(FM1NxLogReward, Cnt) == 0x000010, "Member 'FM1NxLogReward::Cnt' has a wrong offset!");
static_assert(offsetof(FM1NxLogReward, ID) == 0x000020, "Member 'FM1NxLogReward::ID' has a wrong offset!");
static_assert(offsetof(FM1NxLogReward, Idcategory) == 0x000030, "Member 'FM1NxLogReward::Idcategory' has a wrong offset!");
static_assert(offsetof(FM1NxLogReward, MailId) == 0x000040, "Member 'FM1NxLogReward::MailId' has a wrong offset!");
static_assert(offsetof(FM1NxLogReward, Rewardpositiontype) == 0x000050, "Member 'FM1NxLogReward::Rewardpositiontype' has a wrong offset!");
static_assert(offsetof(FM1NxLogReward, Type) == 0x000060, "Member 'FM1NxLogReward::Type' has a wrong offset!");
static_assert(offsetof(FM1NxLogReward, Uid) == 0x000070, "Member 'FM1NxLogReward::Uid' has a wrong offset!");

// ScriptStruct M1.M1NxLogFieldJoinPCInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1NxLogFieldJoinPCInfo final
{
public:
	class FString                                 Pcaccountno;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Pcnpsn;                                            // 0x0010(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLogFieldJoinPCInfo) == 0x000008, "Wrong alignment on FM1NxLogFieldJoinPCInfo");
static_assert(sizeof(FM1NxLogFieldJoinPCInfo) == 0x000020, "Wrong size on FM1NxLogFieldJoinPCInfo");
static_assert(offsetof(FM1NxLogFieldJoinPCInfo, Pcaccountno) == 0x000000, "Member 'FM1NxLogFieldJoinPCInfo::Pcaccountno' has a wrong offset!");
static_assert(offsetof(FM1NxLogFieldJoinPCInfo, Pcnpsn) == 0x000010, "Member 'FM1NxLogFieldJoinPCInfo::Pcnpsn' has a wrong offset!");

// ScriptStruct M1.M1NxLog_Play_PlayerResult
// 0x0180 (0x0180 - 0x0000)
struct FM1NxLog_Play_PlayerResult final
{
public:
	class FString                                 Actionid;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Contentsdifficulty;                                // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Contentsid;                                        // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Contentsmeta;                                      // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Contentsplayresultmeta;                            // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Contentsplayresulttype;                            // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ContentsType;                                      // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Contentsuid;                                       // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldId;                                           // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldUid;                                          // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Pcid;                                              // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Pclevel;                                           // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Pcname;                                            // 0x00C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Pctype;                                            // 0x00D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1NxLogRecord>                 Recordarray;                                       // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1NxLogReward>                 Rewardarray;                                       // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Tfdplayeritemid;                                   // 0x0100(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Tfdplayeritemlevel;                                // 0x0110(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 ControllerType;                                    // 0x0120(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1NxLogExtraInfo>              Extrainfoarray;                                    // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Privateflag;                                       // 0x0140(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Contentsseasontype;                                // 0x0150(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Contentsseasonid;                                  // 0x0160(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1NxLogFieldJoinPCInfo>        Tfdfieldjoinpcinfo;                                // 0x0170(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_Play_PlayerResult) == 0x000008, "Wrong alignment on FM1NxLog_Play_PlayerResult");
static_assert(sizeof(FM1NxLog_Play_PlayerResult) == 0x000180, "Wrong size on FM1NxLog_Play_PlayerResult");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, Actionid) == 0x000000, "Member 'FM1NxLog_Play_PlayerResult::Actionid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, Contentsdifficulty) == 0x000010, "Member 'FM1NxLog_Play_PlayerResult::Contentsdifficulty' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, Contentsid) == 0x000020, "Member 'FM1NxLog_Play_PlayerResult::Contentsid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, Contentsmeta) == 0x000030, "Member 'FM1NxLog_Play_PlayerResult::Contentsmeta' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, Contentsplayresultmeta) == 0x000040, "Member 'FM1NxLog_Play_PlayerResult::Contentsplayresultmeta' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, Contentsplayresulttype) == 0x000050, "Member 'FM1NxLog_Play_PlayerResult::Contentsplayresulttype' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, ContentsType) == 0x000060, "Member 'FM1NxLog_Play_PlayerResult::ContentsType' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, Contentsuid) == 0x000070, "Member 'FM1NxLog_Play_PlayerResult::Contentsuid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, FieldId) == 0x000080, "Member 'FM1NxLog_Play_PlayerResult::FieldId' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, FieldUid) == 0x000090, "Member 'FM1NxLog_Play_PlayerResult::FieldUid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, Pcid) == 0x0000A0, "Member 'FM1NxLog_Play_PlayerResult::Pcid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, Pclevel) == 0x0000B0, "Member 'FM1NxLog_Play_PlayerResult::Pclevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, Pcname) == 0x0000C0, "Member 'FM1NxLog_Play_PlayerResult::Pcname' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, Pctype) == 0x0000D0, "Member 'FM1NxLog_Play_PlayerResult::Pctype' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, Recordarray) == 0x0000E0, "Member 'FM1NxLog_Play_PlayerResult::Recordarray' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, Rewardarray) == 0x0000F0, "Member 'FM1NxLog_Play_PlayerResult::Rewardarray' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, Tfdplayeritemid) == 0x000100, "Member 'FM1NxLog_Play_PlayerResult::Tfdplayeritemid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, Tfdplayeritemlevel) == 0x000110, "Member 'FM1NxLog_Play_PlayerResult::Tfdplayeritemlevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, ControllerType) == 0x000120, "Member 'FM1NxLog_Play_PlayerResult::ControllerType' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, Extrainfoarray) == 0x000130, "Member 'FM1NxLog_Play_PlayerResult::Extrainfoarray' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, Privateflag) == 0x000140, "Member 'FM1NxLog_Play_PlayerResult::Privateflag' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, Contentsseasontype) == 0x000150, "Member 'FM1NxLog_Play_PlayerResult::Contentsseasontype' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, Contentsseasonid) == 0x000160, "Member 'FM1NxLog_Play_PlayerResult::Contentsseasonid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerResult, Tfdfieldjoinpcinfo) == 0x000170, "Member 'FM1NxLog_Play_PlayerResult::Tfdfieldjoinpcinfo' has a wrong offset!");

// ScriptStruct M1.M1NxLog_Play_PlayerResult_Base
// 0x0180 (0x0260 - 0x00E0)
struct FM1NxLog_Play_PlayerResult_Base final : public FM1NxLog_Base
{
public:
	struct FM1NxLog_Play_PlayerResult             Play_PlayerResult;                                 // 0x00E0(0x0180)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_Play_PlayerResult_Base) == 0x000008, "Wrong alignment on FM1NxLog_Play_PlayerResult_Base");
static_assert(sizeof(FM1NxLog_Play_PlayerResult_Base) == 0x000260, "Wrong size on FM1NxLog_Play_PlayerResult_Base");
static_assert(offsetof(FM1NxLog_Play_PlayerResult_Base, Play_PlayerResult) == 0x0000E0, "Member 'FM1NxLog_Play_PlayerResult_Base::Play_PlayerResult' has a wrong offset!");

// ScriptStruct M1.M1CrotchExpression
// 0x00A4 (0x00A4 - 0x0000)
struct FM1CrotchExpression final
{
public:
	struct FBoneReference                         Thigh_L;                                           // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Crotch_L1;                                         // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Crotch_L2;                                         // 0x0020(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         CrotchTw_L1;                                       // 0x0030(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         ThighTw_L1;                                        // 0x0040(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Thigh_R;                                           // 0x0050(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Crotch_R1;                                         // 0x0060(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Crotch_R2;                                         // 0x0070(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         CrotchTw_R1;                                       // 0x0080(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         ThighTw_R1;                                        // 0x0090(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bValid;                                            // 0x00A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CrotchExpression) == 0x000004, "Wrong alignment on FM1CrotchExpression");
static_assert(sizeof(FM1CrotchExpression) == 0x0000A4, "Wrong size on FM1CrotchExpression");
static_assert(offsetof(FM1CrotchExpression, Thigh_L) == 0x000000, "Member 'FM1CrotchExpression::Thigh_L' has a wrong offset!");
static_assert(offsetof(FM1CrotchExpression, Crotch_L1) == 0x000010, "Member 'FM1CrotchExpression::Crotch_L1' has a wrong offset!");
static_assert(offsetof(FM1CrotchExpression, Crotch_L2) == 0x000020, "Member 'FM1CrotchExpression::Crotch_L2' has a wrong offset!");
static_assert(offsetof(FM1CrotchExpression, CrotchTw_L1) == 0x000030, "Member 'FM1CrotchExpression::CrotchTw_L1' has a wrong offset!");
static_assert(offsetof(FM1CrotchExpression, ThighTw_L1) == 0x000040, "Member 'FM1CrotchExpression::ThighTw_L1' has a wrong offset!");
static_assert(offsetof(FM1CrotchExpression, Thigh_R) == 0x000050, "Member 'FM1CrotchExpression::Thigh_R' has a wrong offset!");
static_assert(offsetof(FM1CrotchExpression, Crotch_R1) == 0x000060, "Member 'FM1CrotchExpression::Crotch_R1' has a wrong offset!");
static_assert(offsetof(FM1CrotchExpression, Crotch_R2) == 0x000070, "Member 'FM1CrotchExpression::Crotch_R2' has a wrong offset!");
static_assert(offsetof(FM1CrotchExpression, CrotchTw_R1) == 0x000080, "Member 'FM1CrotchExpression::CrotchTw_R1' has a wrong offset!");
static_assert(offsetof(FM1CrotchExpression, ThighTw_R1) == 0x000090, "Member 'FM1CrotchExpression::ThighTw_R1' has a wrong offset!");
static_assert(offsetof(FM1CrotchExpression, bValid) == 0x0000A0, "Member 'FM1CrotchExpression::bValid' has a wrong offset!");

// ScriptStruct M1.M1AnimNode_ModifyBone_Expression
// 0x0160 (0x0170 - 0x0010)
struct FM1AnimNode_ModifyBone_Expression final : public FAnimNode_Base
{
public:
	struct FPoseLink                              Base;                                              // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1AnkleHighExpression                 AnkleHighExpression;                               // 0x0024(0x0044)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1AnkleLowExpression                  AnkleLowExpression;                                // 0x0068(0x0064)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1CrotchExpression                    CrotchExpression;                                  // 0x00CC(0x00A4)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AnimNode_ModifyBone_Expression) == 0x000008, "Wrong alignment on FM1AnimNode_ModifyBone_Expression");
static_assert(sizeof(FM1AnimNode_ModifyBone_Expression) == 0x000170, "Wrong size on FM1AnimNode_ModifyBone_Expression");
static_assert(offsetof(FM1AnimNode_ModifyBone_Expression, Base) == 0x000010, "Member 'FM1AnimNode_ModifyBone_Expression::Base' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ModifyBone_Expression, bEnabled) == 0x000020, "Member 'FM1AnimNode_ModifyBone_Expression::bEnabled' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ModifyBone_Expression, AnkleHighExpression) == 0x000024, "Member 'FM1AnimNode_ModifyBone_Expression::AnkleHighExpression' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ModifyBone_Expression, AnkleLowExpression) == 0x000068, "Member 'FM1AnimNode_ModifyBone_Expression::AnkleLowExpression' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ModifyBone_Expression, CrotchExpression) == 0x0000CC, "Member 'FM1AnimNode_ModifyBone_Expression::CrotchExpression' has a wrong offset!");

// ScriptStruct M1.M1SimpleBoneTransform
// 0x0020 (0x0020 - 0x0000)
struct FM1SimpleBoneTransform final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SimpleBoneTransform) == 0x000004, "Wrong alignment on FM1SimpleBoneTransform");
static_assert(sizeof(FM1SimpleBoneTransform) == 0x000020, "Wrong size on FM1SimpleBoneTransform");
static_assert(offsetof(FM1SimpleBoneTransform, BoneName) == 0x000000, "Member 'FM1SimpleBoneTransform::BoneName' has a wrong offset!");
static_assert(offsetof(FM1SimpleBoneTransform, Translation) == 0x000008, "Member 'FM1SimpleBoneTransform::Translation' has a wrong offset!");
static_assert(offsetof(FM1SimpleBoneTransform, Rotation) == 0x000014, "Member 'FM1SimpleBoneTransform::Rotation' has a wrong offset!");

// ScriptStruct M1.M1BoneTransformArray
// 0x0010 (0x0010 - 0x0000)
struct FM1BoneTransformArray final
{
public:
	TArray<struct FM1SimpleBoneTransform>         Values;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BoneTransformArray) == 0x000008, "Wrong alignment on FM1BoneTransformArray");
static_assert(sizeof(FM1BoneTransformArray) == 0x000010, "Wrong size on FM1BoneTransformArray");
static_assert(offsetof(FM1BoneTransformArray, Values) == 0x000000, "Member 'FM1BoneTransformArray::Values' has a wrong offset!");

// ScriptStruct M1.M1AnimNode_ModifyBone_Multi
// 0x0028 (0x00F0 - 0x00C8)
struct FM1AnimNode_ModifyBone_Multi final : public FAnimNode_SkeletalControlBase
{
public:
	TArray<struct FBoneReference>                 Bones;                                             // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1BoneTransformArray                  BoneTransforms;                                    // 0x00D8(0x0010)(Edit, NativeAccessSpecifierPublic)
	EBoneModificationMode                         TranslationMode;                                   // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneModificationMode                         RotationMode;                                      // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneControlSpace                             TranslationSpace;                                  // 0x00EA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneControlSpace                             RotationSpace;                                     // 0x00EB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AnimNode_ModifyBone_Multi) == 0x000008, "Wrong alignment on FM1AnimNode_ModifyBone_Multi");
static_assert(sizeof(FM1AnimNode_ModifyBone_Multi) == 0x0000F0, "Wrong size on FM1AnimNode_ModifyBone_Multi");
static_assert(offsetof(FM1AnimNode_ModifyBone_Multi, Bones) == 0x0000C8, "Member 'FM1AnimNode_ModifyBone_Multi::Bones' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ModifyBone_Multi, BoneTransforms) == 0x0000D8, "Member 'FM1AnimNode_ModifyBone_Multi::BoneTransforms' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ModifyBone_Multi, TranslationMode) == 0x0000E8, "Member 'FM1AnimNode_ModifyBone_Multi::TranslationMode' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ModifyBone_Multi, RotationMode) == 0x0000E9, "Member 'FM1AnimNode_ModifyBone_Multi::RotationMode' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ModifyBone_Multi, TranslationSpace) == 0x0000EA, "Member 'FM1AnimNode_ModifyBone_Multi::TranslationSpace' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ModifyBone_Multi, RotationSpace) == 0x0000EB, "Member 'FM1AnimNode_ModifyBone_Multi::RotationSpace' has a wrong offset!");

// ScriptStruct M1.M1AnimNode_OrientationWarping
// 0x0118 (0x0128 - 0x0010)
struct FM1AnimNode_OrientationWarping : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RootBone;                                          // 0x0020(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         PelvisBone;                                        // 0x0030(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FBoneReference>                 SpineBones;                                        // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBoneReference>                 IKFootBones;                                       // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     SpineRotateCurve;                                  // 0x0068(0x0088)(Edit, NativeAccessSpecifierPublic)
	float                                         MinAngle;                                          // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngle;                                          // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisRotateWeight;                                // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlignedSpine;                                     // 0x00FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x2B];                                      // 0x00FD(0x002B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AnimNode_OrientationWarping) == 0x000008, "Wrong alignment on FM1AnimNode_OrientationWarping");
static_assert(sizeof(FM1AnimNode_OrientationWarping) == 0x000128, "Wrong size on FM1AnimNode_OrientationWarping");
static_assert(offsetof(FM1AnimNode_OrientationWarping, BasePose) == 0x000010, "Member 'FM1AnimNode_OrientationWarping::BasePose' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_OrientationWarping, RootBone) == 0x000020, "Member 'FM1AnimNode_OrientationWarping::RootBone' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_OrientationWarping, PelvisBone) == 0x000030, "Member 'FM1AnimNode_OrientationWarping::PelvisBone' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_OrientationWarping, SpineBones) == 0x000040, "Member 'FM1AnimNode_OrientationWarping::SpineBones' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_OrientationWarping, IKFootBones) == 0x000050, "Member 'FM1AnimNode_OrientationWarping::IKFootBones' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_OrientationWarping, Angle) == 0x000060, "Member 'FM1AnimNode_OrientationWarping::Angle' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_OrientationWarping, SpineRotateCurve) == 0x000068, "Member 'FM1AnimNode_OrientationWarping::SpineRotateCurve' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_OrientationWarping, MinAngle) == 0x0000F0, "Member 'FM1AnimNode_OrientationWarping::MinAngle' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_OrientationWarping, MaxAngle) == 0x0000F4, "Member 'FM1AnimNode_OrientationWarping::MaxAngle' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_OrientationWarping, PelvisRotateWeight) == 0x0000F8, "Member 'FM1AnimNode_OrientationWarping::PelvisRotateWeight' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_OrientationWarping, bAlignedSpine) == 0x0000FC, "Member 'FM1AnimNode_OrientationWarping::bAlignedSpine' has a wrong offset!");

// ScriptStruct M1.ProceduralFootBonePair
// 0x0020 (0x0020 - 0x0000)
struct FProceduralFootBonePair final
{
public:
	struct FBoneReference                         IKFoot;                                            // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         FKFoot;                                            // 0x0010(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralFootBonePair) == 0x000004, "Wrong alignment on FProceduralFootBonePair");
static_assert(sizeof(FProceduralFootBonePair) == 0x000020, "Wrong size on FProceduralFootBonePair");
static_assert(offsetof(FProceduralFootBonePair, IKFoot) == 0x000000, "Member 'FProceduralFootBonePair::IKFoot' has a wrong offset!");
static_assert(offsetof(FProceduralFootBonePair, FKFoot) == 0x000010, "Member 'FProceduralFootBonePair::FKFoot' has a wrong offset!");

// ScriptStruct M1.ProceduralLegInfo
// 0x0064 (0x0064 - 0x0000)
struct FProceduralLegInfo final
{
public:
	class FName                                   FootBone;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PrevFootStancePos;                                 // 0x0008(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NextFootStancePos;                                 // 0x0014(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurFootPos;                                        // 0x0020(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StancePosCS;                                       // 0x002C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentVelocity;                                   // 0x0038(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootFlighting;                                    // 0x0044(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimPlayTime;                                      // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootCycleTime;                                     // 0x004C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrajectoryForward;                                 // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootLimitDistance;                                 // 0x0054(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangedAnimData;                                  // 0x0058(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UM1ProceduralAnimUserData> MovementPoseAnimData;                              // 0x005C(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralLegInfo) == 0x000004, "Wrong alignment on FProceduralLegInfo");
static_assert(sizeof(FProceduralLegInfo) == 0x000064, "Wrong size on FProceduralLegInfo");
static_assert(offsetof(FProceduralLegInfo, FootBone) == 0x000000, "Member 'FProceduralLegInfo::FootBone' has a wrong offset!");
static_assert(offsetof(FProceduralLegInfo, PrevFootStancePos) == 0x000008, "Member 'FProceduralLegInfo::PrevFootStancePos' has a wrong offset!");
static_assert(offsetof(FProceduralLegInfo, NextFootStancePos) == 0x000014, "Member 'FProceduralLegInfo::NextFootStancePos' has a wrong offset!");
static_assert(offsetof(FProceduralLegInfo, CurFootPos) == 0x000020, "Member 'FProceduralLegInfo::CurFootPos' has a wrong offset!");
static_assert(offsetof(FProceduralLegInfo, StancePosCS) == 0x00002C, "Member 'FProceduralLegInfo::StancePosCS' has a wrong offset!");
static_assert(offsetof(FProceduralLegInfo, CurrentVelocity) == 0x000038, "Member 'FProceduralLegInfo::CurrentVelocity' has a wrong offset!");
static_assert(offsetof(FProceduralLegInfo, bFootFlighting) == 0x000044, "Member 'FProceduralLegInfo::bFootFlighting' has a wrong offset!");
static_assert(offsetof(FProceduralLegInfo, AnimPlayTime) == 0x000048, "Member 'FProceduralLegInfo::AnimPlayTime' has a wrong offset!");
static_assert(offsetof(FProceduralLegInfo, FootCycleTime) == 0x00004C, "Member 'FProceduralLegInfo::FootCycleTime' has a wrong offset!");
static_assert(offsetof(FProceduralLegInfo, TrajectoryForward) == 0x000050, "Member 'FProceduralLegInfo::TrajectoryForward' has a wrong offset!");
static_assert(offsetof(FProceduralLegInfo, FootLimitDistance) == 0x000054, "Member 'FProceduralLegInfo::FootLimitDistance' has a wrong offset!");
static_assert(offsetof(FProceduralLegInfo, bChangedAnimData) == 0x000058, "Member 'FProceduralLegInfo::bChangedAnimData' has a wrong offset!");
static_assert(offsetof(FProceduralLegInfo, MovementPoseAnimData) == 0x00005C, "Member 'FProceduralLegInfo::MovementPoseAnimData' has a wrong offset!");

// ScriptStruct M1.M1AnimNode_ProceduralLocomotion
// 0x01C0 (0x01D0 - 0x0010)
struct FM1AnimNode_ProceduralLocomotion final : public FAnimNode_Base
{
public:
	struct FPoseLink                              MovementPose;                                      // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              IdlePose;                                          // 0x0020(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FProceduralFootBonePair>        FootBonePairs;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bMoveWhenRotating;                                 // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationToleranceYawSpeed;                         // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventLegIntersectInArc;                         // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StateBlendingTime;                                 // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopDelayInit;                                     // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFootStrideConstraint;                       // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNowIdle;                                          // 0x0055(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CurrentVelocity;                                   // 0x0058(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentAngularVelocityRate;                        // 0x0064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CurrentAcceleration;                               // 0x0068(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               CurrentRotator;                                    // 0x0074(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             MeshComponentTransform;                            // 0x0080(0x0030)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, struct FProceduralLegInfo>  LegInfos;                                          // 0x00B0(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         CapturedPoseBlendWeight;                           // 0x0100(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OwnerHalfHeight;                                   // 0x0104(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StopDelay;                                         // 0x0108(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C[0xC4];                                     // 0x010C(0x00C4)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AnimNode_ProceduralLocomotion) == 0x000010, "Wrong alignment on FM1AnimNode_ProceduralLocomotion");
static_assert(sizeof(FM1AnimNode_ProceduralLocomotion) == 0x0001D0, "Wrong size on FM1AnimNode_ProceduralLocomotion");
static_assert(offsetof(FM1AnimNode_ProceduralLocomotion, MovementPose) == 0x000010, "Member 'FM1AnimNode_ProceduralLocomotion::MovementPose' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ProceduralLocomotion, IdlePose) == 0x000020, "Member 'FM1AnimNode_ProceduralLocomotion::IdlePose' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ProceduralLocomotion, FootBonePairs) == 0x000030, "Member 'FM1AnimNode_ProceduralLocomotion::FootBonePairs' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ProceduralLocomotion, bMoveWhenRotating) == 0x000040, "Member 'FM1AnimNode_ProceduralLocomotion::bMoveWhenRotating' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ProceduralLocomotion, RotationToleranceYawSpeed) == 0x000044, "Member 'FM1AnimNode_ProceduralLocomotion::RotationToleranceYawSpeed' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ProceduralLocomotion, bPreventLegIntersectInArc) == 0x000048, "Member 'FM1AnimNode_ProceduralLocomotion::bPreventLegIntersectInArc' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ProceduralLocomotion, StateBlendingTime) == 0x00004C, "Member 'FM1AnimNode_ProceduralLocomotion::StateBlendingTime' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ProceduralLocomotion, StopDelayInit) == 0x000050, "Member 'FM1AnimNode_ProceduralLocomotion::StopDelayInit' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ProceduralLocomotion, bEnableFootStrideConstraint) == 0x000054, "Member 'FM1AnimNode_ProceduralLocomotion::bEnableFootStrideConstraint' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ProceduralLocomotion, bNowIdle) == 0x000055, "Member 'FM1AnimNode_ProceduralLocomotion::bNowIdle' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ProceduralLocomotion, CurrentVelocity) == 0x000058, "Member 'FM1AnimNode_ProceduralLocomotion::CurrentVelocity' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ProceduralLocomotion, CurrentAngularVelocityRate) == 0x000064, "Member 'FM1AnimNode_ProceduralLocomotion::CurrentAngularVelocityRate' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ProceduralLocomotion, CurrentAcceleration) == 0x000068, "Member 'FM1AnimNode_ProceduralLocomotion::CurrentAcceleration' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ProceduralLocomotion, CurrentRotator) == 0x000074, "Member 'FM1AnimNode_ProceduralLocomotion::CurrentRotator' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ProceduralLocomotion, MeshComponentTransform) == 0x000080, "Member 'FM1AnimNode_ProceduralLocomotion::MeshComponentTransform' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ProceduralLocomotion, LegInfos) == 0x0000B0, "Member 'FM1AnimNode_ProceduralLocomotion::LegInfos' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ProceduralLocomotion, CapturedPoseBlendWeight) == 0x000100, "Member 'FM1AnimNode_ProceduralLocomotion::CapturedPoseBlendWeight' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ProceduralLocomotion, OwnerHalfHeight) == 0x000104, "Member 'FM1AnimNode_ProceduralLocomotion::OwnerHalfHeight' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_ProceduralLocomotion, StopDelay) == 0x000108, "Member 'FM1AnimNode_ProceduralLocomotion::StopDelay' has a wrong offset!");

// ScriptStruct M1.M1CrowdCandidates
// 0x0028 (0x0028 - 0x0000)
struct FM1CrowdCandidates final
{
public:
	TArray<class AActor*>                         LeaderCandidates;                                  // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         FollowerCandidates;                                // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          bShouldTransferLeaderToOther;                      // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CrowdCandidates) == 0x000008, "Wrong alignment on FM1CrowdCandidates");
static_assert(sizeof(FM1CrowdCandidates) == 0x000028, "Wrong size on FM1CrowdCandidates");
static_assert(offsetof(FM1CrowdCandidates, LeaderCandidates) == 0x000000, "Member 'FM1CrowdCandidates::LeaderCandidates' has a wrong offset!");
static_assert(offsetof(FM1CrowdCandidates, FollowerCandidates) == 0x000010, "Member 'FM1CrowdCandidates::FollowerCandidates' has a wrong offset!");
static_assert(offsetof(FM1CrowdCandidates, bShouldTransferLeaderToOther) == 0x000020, "Member 'FM1CrowdCandidates::bShouldTransferLeaderToOther' has a wrong offset!");

// ScriptStruct M1.M1AnimNode_Reinitialize
// 0x0018 (0x0028 - 0x0010)
struct FM1AnimNode_Reinitialize final : public FAnimNode_Base
{
public:
	struct FPoseLink                              Pose;                                              // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         SavedResetConditionFlag;                           // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AnimNode_Reinitialize) == 0x000008, "Wrong alignment on FM1AnimNode_Reinitialize");
static_assert(sizeof(FM1AnimNode_Reinitialize) == 0x000028, "Wrong size on FM1AnimNode_Reinitialize");
static_assert(offsetof(FM1AnimNode_Reinitialize, Pose) == 0x000010, "Member 'FM1AnimNode_Reinitialize::Pose' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_Reinitialize, SavedResetConditionFlag) == 0x000020, "Member 'FM1AnimNode_Reinitialize::SavedResetConditionFlag' has a wrong offset!");

// ScriptStruct M1.M1AnimNode_SequenceEvaluatorByAnimCurve
// 0x0040 (0x0078 - 0x0038)
struct FM1AnimNode_SequenceEvaluatorByAnimCurve final : public FAnimNode_AssetPlayerBase
{
public:
	class UAnimSequence*                          Sequence;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConditionCurveName;                                // 0x0044(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurveName;                                         // 0x004C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputValue;                                        // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoopAnimation;                                    // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EvaluatedStartPosition;                            // 0x005C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EvaluatedEndPosition;                              // 0x0060(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x14];                                      // 0x0064(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AnimNode_SequenceEvaluatorByAnimCurve) == 0x000008, "Wrong alignment on FM1AnimNode_SequenceEvaluatorByAnimCurve");
static_assert(sizeof(FM1AnimNode_SequenceEvaluatorByAnimCurve) == 0x000078, "Wrong size on FM1AnimNode_SequenceEvaluatorByAnimCurve");
static_assert(offsetof(FM1AnimNode_SequenceEvaluatorByAnimCurve, Sequence) == 0x000038, "Member 'FM1AnimNode_SequenceEvaluatorByAnimCurve::Sequence' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_SequenceEvaluatorByAnimCurve, PlayRate) == 0x000040, "Member 'FM1AnimNode_SequenceEvaluatorByAnimCurve::PlayRate' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_SequenceEvaluatorByAnimCurve, ConditionCurveName) == 0x000044, "Member 'FM1AnimNode_SequenceEvaluatorByAnimCurve::ConditionCurveName' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_SequenceEvaluatorByAnimCurve, CurveName) == 0x00004C, "Member 'FM1AnimNode_SequenceEvaluatorByAnimCurve::CurveName' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_SequenceEvaluatorByAnimCurve, InputValue) == 0x000054, "Member 'FM1AnimNode_SequenceEvaluatorByAnimCurve::InputValue' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_SequenceEvaluatorByAnimCurve, bLoopAnimation) == 0x000058, "Member 'FM1AnimNode_SequenceEvaluatorByAnimCurve::bLoopAnimation' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_SequenceEvaluatorByAnimCurve, EvaluatedStartPosition) == 0x00005C, "Member 'FM1AnimNode_SequenceEvaluatorByAnimCurve::EvaluatedStartPosition' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_SequenceEvaluatorByAnimCurve, EvaluatedEndPosition) == 0x000060, "Member 'FM1AnimNode_SequenceEvaluatorByAnimCurve::EvaluatedEndPosition' has a wrong offset!");

// ScriptStruct M1.M1AnimNode_SpeedWarping
// 0x0090 (0x00A0 - 0x0010)
struct FM1AnimNode_SpeedWarping final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         SpineBone;                                         // 0x0020(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FBoneReference>                 IKFootBones;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAlignPitchForToes;                                // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlantFootBias;                                     // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideBaseSpeed;                                // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseSpeed;                                         // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideYaw;                                      // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Yaw;                                               // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lean;                                              // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CachedAnimAssetName;                               // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   PlantIKFootBoneName;                               // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTransform                             CachedComnentTransformForPlantIKFoot;              // 0x0070(0x0030)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1AnimNode_SpeedWarping) == 0x000010, "Wrong alignment on FM1AnimNode_SpeedWarping");
static_assert(sizeof(FM1AnimNode_SpeedWarping) == 0x0000A0, "Wrong size on FM1AnimNode_SpeedWarping");
static_assert(offsetof(FM1AnimNode_SpeedWarping, BasePose) == 0x000010, "Member 'FM1AnimNode_SpeedWarping::BasePose' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_SpeedWarping, SpineBone) == 0x000020, "Member 'FM1AnimNode_SpeedWarping::SpineBone' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_SpeedWarping, IKFootBones) == 0x000030, "Member 'FM1AnimNode_SpeedWarping::IKFootBones' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_SpeedWarping, bAlignPitchForToes) == 0x000040, "Member 'FM1AnimNode_SpeedWarping::bAlignPitchForToes' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_SpeedWarping, PlantFootBias) == 0x000044, "Member 'FM1AnimNode_SpeedWarping::PlantFootBias' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_SpeedWarping, bOverrideBaseSpeed) == 0x000048, "Member 'FM1AnimNode_SpeedWarping::bOverrideBaseSpeed' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_SpeedWarping, BaseSpeed) == 0x00004C, "Member 'FM1AnimNode_SpeedWarping::BaseSpeed' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_SpeedWarping, bOverrideYaw) == 0x000050, "Member 'FM1AnimNode_SpeedWarping::bOverrideYaw' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_SpeedWarping, Yaw) == 0x000054, "Member 'FM1AnimNode_SpeedWarping::Yaw' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_SpeedWarping, Speed) == 0x000058, "Member 'FM1AnimNode_SpeedWarping::Speed' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_SpeedWarping, Lean) == 0x00005C, "Member 'FM1AnimNode_SpeedWarping::Lean' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_SpeedWarping, CachedAnimAssetName) == 0x000060, "Member 'FM1AnimNode_SpeedWarping::CachedAnimAssetName' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_SpeedWarping, PlantIKFootBoneName) == 0x000068, "Member 'FM1AnimNode_SpeedWarping::PlantIKFootBoneName' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_SpeedWarping, CachedComnentTransformForPlantIKFoot) == 0x000070, "Member 'FM1AnimNode_SpeedWarping::CachedComnentTransformForPlantIKFoot' has a wrong offset!");

// ScriptStruct M1.M1AnimNode_TurnInPlace
// 0x0150 (0x0278 - 0x0128)
struct FM1AnimNode_TurnInPlace final : public FM1AnimNode_OrientationWarping
{
public:
	struct FPoseLink                              TurnLeft90;                                        // 0x0128(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              TurnRight90;                                       // 0x0138(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              TurnLeft45;                                        // 0x0148(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              TurnRight45;                                       // 0x0158(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              ExtraAdditivePose;                                 // 0x0168(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EM1AimOffset                                  AOMode;                                            // 0x0178(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x3];                                      // 0x0179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Turn90Threshold;                                   // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Turn45Threshold;                                   // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FeetToCharacterAngleLimit;                         // 0x0184(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveAnimsBlendInOutTime;                       // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraAdditiveYAxisInterpolateTime;                 // 0x018C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1TurnInPlaceType                            TurnInPlaceType;                                   // 0x0190(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_191[0x3];                                      // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FeetToCharacterYaw;                                // 0x0194(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FeetYaw;                                           // 0x0198(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PrevCharacterYaw;                                  // 0x019C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TurnInPlaceRemainYaw;                              // 0x01A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AdditiveAnimsBlendWeight;                          // 0x01A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExtraAdditiveYAxisInterpolateElapsedTime;          // 0x01A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AM1Character*                           OwnerCharacter;                                    // 0x01B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UM1CharacterMovementComponent*          OwnerCharacterMovementComp;                        // 0x01B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0xB8];                                     // 0x01C0(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AnimNode_TurnInPlace) == 0x000008, "Wrong alignment on FM1AnimNode_TurnInPlace");
static_assert(sizeof(FM1AnimNode_TurnInPlace) == 0x000278, "Wrong size on FM1AnimNode_TurnInPlace");
static_assert(offsetof(FM1AnimNode_TurnInPlace, TurnLeft90) == 0x000128, "Member 'FM1AnimNode_TurnInPlace::TurnLeft90' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_TurnInPlace, TurnRight90) == 0x000138, "Member 'FM1AnimNode_TurnInPlace::TurnRight90' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_TurnInPlace, TurnLeft45) == 0x000148, "Member 'FM1AnimNode_TurnInPlace::TurnLeft45' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_TurnInPlace, TurnRight45) == 0x000158, "Member 'FM1AnimNode_TurnInPlace::TurnRight45' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_TurnInPlace, ExtraAdditivePose) == 0x000168, "Member 'FM1AnimNode_TurnInPlace::ExtraAdditivePose' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_TurnInPlace, AOMode) == 0x000178, "Member 'FM1AnimNode_TurnInPlace::AOMode' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_TurnInPlace, Turn90Threshold) == 0x00017C, "Member 'FM1AnimNode_TurnInPlace::Turn90Threshold' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_TurnInPlace, Turn45Threshold) == 0x000180, "Member 'FM1AnimNode_TurnInPlace::Turn45Threshold' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_TurnInPlace, FeetToCharacterAngleLimit) == 0x000184, "Member 'FM1AnimNode_TurnInPlace::FeetToCharacterAngleLimit' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_TurnInPlace, AdditiveAnimsBlendInOutTime) == 0x000188, "Member 'FM1AnimNode_TurnInPlace::AdditiveAnimsBlendInOutTime' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_TurnInPlace, ExtraAdditiveYAxisInterpolateTime) == 0x00018C, "Member 'FM1AnimNode_TurnInPlace::ExtraAdditiveYAxisInterpolateTime' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_TurnInPlace, TurnInPlaceType) == 0x000190, "Member 'FM1AnimNode_TurnInPlace::TurnInPlaceType' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_TurnInPlace, FeetToCharacterYaw) == 0x000194, "Member 'FM1AnimNode_TurnInPlace::FeetToCharacterYaw' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_TurnInPlace, FeetYaw) == 0x000198, "Member 'FM1AnimNode_TurnInPlace::FeetYaw' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_TurnInPlace, PrevCharacterYaw) == 0x00019C, "Member 'FM1AnimNode_TurnInPlace::PrevCharacterYaw' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_TurnInPlace, TurnInPlaceRemainYaw) == 0x0001A0, "Member 'FM1AnimNode_TurnInPlace::TurnInPlaceRemainYaw' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_TurnInPlace, AdditiveAnimsBlendWeight) == 0x0001A4, "Member 'FM1AnimNode_TurnInPlace::AdditiveAnimsBlendWeight' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_TurnInPlace, ExtraAdditiveYAxisInterpolateElapsedTime) == 0x0001A8, "Member 'FM1AnimNode_TurnInPlace::ExtraAdditiveYAxisInterpolateElapsedTime' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_TurnInPlace, OwnerCharacter) == 0x0001B0, "Member 'FM1AnimNode_TurnInPlace::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(FM1AnimNode_TurnInPlace, OwnerCharacterMovementComp) == 0x0001B8, "Member 'FM1AnimNode_TurnInPlace::OwnerCharacterMovementComp' has a wrong offset!");

// ScriptStruct M1.M1MaterialParameterCollectionParam
// 0x0028 (0x0028 - 0x0000)
struct FM1MaterialParameterCollectionParam final
{
public:
	class UMaterialParameterCollection*           MaterialParameterCollection;                       // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitValue;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndValue;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentValue;                                      // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValidParameters;                                  // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MaterialParameterCollectionParam) == 0x000008, "Wrong alignment on FM1MaterialParameterCollectionParam");
static_assert(sizeof(FM1MaterialParameterCollectionParam) == 0x000028, "Wrong size on FM1MaterialParameterCollectionParam");
static_assert(offsetof(FM1MaterialParameterCollectionParam, MaterialParameterCollection) == 0x000000, "Member 'FM1MaterialParameterCollectionParam::MaterialParameterCollection' has a wrong offset!");
static_assert(offsetof(FM1MaterialParameterCollectionParam, ParameterName) == 0x000008, "Member 'FM1MaterialParameterCollectionParam::ParameterName' has a wrong offset!");
static_assert(offsetof(FM1MaterialParameterCollectionParam, InitValue) == 0x000010, "Member 'FM1MaterialParameterCollectionParam::InitValue' has a wrong offset!");
static_assert(offsetof(FM1MaterialParameterCollectionParam, InterpSpeed) == 0x000014, "Member 'FM1MaterialParameterCollectionParam::InterpSpeed' has a wrong offset!");
static_assert(offsetof(FM1MaterialParameterCollectionParam, EndValue) == 0x000018, "Member 'FM1MaterialParameterCollectionParam::EndValue' has a wrong offset!");
static_assert(offsetof(FM1MaterialParameterCollectionParam, CurrentValue) == 0x00001C, "Member 'FM1MaterialParameterCollectionParam::CurrentValue' has a wrong offset!");
static_assert(offsetof(FM1MaterialParameterCollectionParam, bValidParameters) == 0x000020, "Member 'FM1MaterialParameterCollectionParam::bValidParameters' has a wrong offset!");

// ScriptStruct M1.M1SpawnPoint
// 0x0030 (0x0030 - 0x0000)
struct FM1SpawnPoint final
{
public:
	class AM1SpawnLocationSelector*               SpawnLocationSelector;                             // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnGroupActorLocation;                           // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UM1ActorManagerSubsystem*               ActorManagerSubsystem;                             // 0x0018(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SpawnPoint) == 0x000008, "Wrong alignment on FM1SpawnPoint");
static_assert(sizeof(FM1SpawnPoint) == 0x000030, "Wrong size on FM1SpawnPoint");
static_assert(offsetof(FM1SpawnPoint, SpawnLocationSelector) == 0x000000, "Member 'FM1SpawnPoint::SpawnLocationSelector' has a wrong offset!");
static_assert(offsetof(FM1SpawnPoint, SpawnGroupActorLocation) == 0x000008, "Member 'FM1SpawnPoint::SpawnGroupActorLocation' has a wrong offset!");
static_assert(offsetof(FM1SpawnPoint, ActorManagerSubsystem) == 0x000018, "Member 'FM1SpawnPoint::ActorManagerSubsystem' has a wrong offset!");

// ScriptStruct M1.M1MonsterSpawner
// 0x00A0 (0x00A0 - 0x0000)
struct FM1MonsterSpawner final
{
public:
	struct FM1SpawnGroupIDSelector                SpawnGroupID;                                      // 0x0000(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bRandomRotation;                                   // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1SpawnPoint>                  SpawnPoints;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x80];                                      // 0x0020(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MonsterSpawner) == 0x000008, "Wrong alignment on FM1MonsterSpawner");
static_assert(sizeof(FM1MonsterSpawner) == 0x0000A0, "Wrong size on FM1MonsterSpawner");
static_assert(offsetof(FM1MonsterSpawner, SpawnGroupID) == 0x000000, "Member 'FM1MonsterSpawner::SpawnGroupID' has a wrong offset!");
static_assert(offsetof(FM1MonsterSpawner, bRandomRotation) == 0x000008, "Member 'FM1MonsterSpawner::bRandomRotation' has a wrong offset!");
static_assert(offsetof(FM1MonsterSpawner, SpawnPoints) == 0x000010, "Member 'FM1MonsterSpawner::SpawnPoints' has a wrong offset!");

// ScriptStruct M1.M1MeshMaterialParam
// 0x0020 (0x0020 - 0x0000)
struct FM1MeshMaterialParam final
{
public:
	int32                                         MaterialIndex;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitValue;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndValue;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentValue;                                      // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValidParameters;                                  // 0x001C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MeshMaterialParam) == 0x000004, "Wrong alignment on FM1MeshMaterialParam");
static_assert(sizeof(FM1MeshMaterialParam) == 0x000020, "Wrong size on FM1MeshMaterialParam");
static_assert(offsetof(FM1MeshMaterialParam, MaterialIndex) == 0x000000, "Member 'FM1MeshMaterialParam::MaterialIndex' has a wrong offset!");
static_assert(offsetof(FM1MeshMaterialParam, ParameterName) == 0x000004, "Member 'FM1MeshMaterialParam::ParameterName' has a wrong offset!");
static_assert(offsetof(FM1MeshMaterialParam, InitValue) == 0x00000C, "Member 'FM1MeshMaterialParam::InitValue' has a wrong offset!");
static_assert(offsetof(FM1MeshMaterialParam, InterpSpeed) == 0x000010, "Member 'FM1MeshMaterialParam::InterpSpeed' has a wrong offset!");
static_assert(offsetof(FM1MeshMaterialParam, EndValue) == 0x000014, "Member 'FM1MeshMaterialParam::EndValue' has a wrong offset!");
static_assert(offsetof(FM1MeshMaterialParam, CurrentValue) == 0x000018, "Member 'FM1MeshMaterialParam::CurrentValue' has a wrong offset!");
static_assert(offsetof(FM1MeshMaterialParam, bValidParameters) == 0x00001C, "Member 'FM1MeshMaterialParam::bValidParameters' has a wrong offset!");

// ScriptStruct M1.M1AnimNotifyState_VFXMaterials
// 0x0010 (0x0010 - 0x0000)
struct FM1AnimNotifyState_VFXMaterials final
{
public:
	TArray<struct FM1DataVisualFX_Material>       MaterialVFXs;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AnimNotifyState_VFXMaterials) == 0x000008, "Wrong alignment on FM1AnimNotifyState_VFXMaterials");
static_assert(sizeof(FM1AnimNotifyState_VFXMaterials) == 0x000010, "Wrong size on FM1AnimNotifyState_VFXMaterials");
static_assert(offsetof(FM1AnimNotifyState_VFXMaterials, MaterialVFXs) == 0x000000, "Member 'FM1AnimNotifyState_VFXMaterials::MaterialVFXs' has a wrong offset!");

// ScriptStruct M1.WeaponMaterialStateParam
// 0x0020 (0x0020 - 0x0000)
struct FWeaponMaterialStateParam final
{
public:
	int32                                         MaterialIndex;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitValue;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndValue;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentValue;                                      // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValidParameters;                                  // 0x001C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponMaterialStateParam) == 0x000004, "Wrong alignment on FWeaponMaterialStateParam");
static_assert(sizeof(FWeaponMaterialStateParam) == 0x000020, "Wrong size on FWeaponMaterialStateParam");
static_assert(offsetof(FWeaponMaterialStateParam, MaterialIndex) == 0x000000, "Member 'FWeaponMaterialStateParam::MaterialIndex' has a wrong offset!");
static_assert(offsetof(FWeaponMaterialStateParam, ParameterName) == 0x000004, "Member 'FWeaponMaterialStateParam::ParameterName' has a wrong offset!");
static_assert(offsetof(FWeaponMaterialStateParam, InitValue) == 0x00000C, "Member 'FWeaponMaterialStateParam::InitValue' has a wrong offset!");
static_assert(offsetof(FWeaponMaterialStateParam, InterpSpeed) == 0x000010, "Member 'FWeaponMaterialStateParam::InterpSpeed' has a wrong offset!");
static_assert(offsetof(FWeaponMaterialStateParam, EndValue) == 0x000014, "Member 'FWeaponMaterialStateParam::EndValue' has a wrong offset!");
static_assert(offsetof(FWeaponMaterialStateParam, CurrentValue) == 0x000018, "Member 'FWeaponMaterialStateParam::CurrentValue' has a wrong offset!");
static_assert(offsetof(FWeaponMaterialStateParam, bValidParameters) == 0x00001C, "Member 'FWeaponMaterialStateParam::bValidParameters' has a wrong offset!");

// ScriptStruct M1.M1PrimaryAssetTypeList
// 0x0050 (0x0050 - 0x0000)
struct FM1PrimaryAssetTypeList final
{
public:
	TSet<struct FPrimaryAssetType>                PrimaryAssets;                                     // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PrimaryAssetTypeList) == 0x000008, "Wrong alignment on FM1PrimaryAssetTypeList");
static_assert(sizeof(FM1PrimaryAssetTypeList) == 0x000050, "Wrong size on FM1PrimaryAssetTypeList");
static_assert(offsetof(FM1PrimaryAssetTypeList, PrimaryAssets) == 0x000000, "Member 'FM1PrimaryAssetTypeList::PrimaryAssets' has a wrong offset!");

// ScriptStruct M1.M1PreloadedContentForURL
// 0x0010 (0x0010 - 0x0000)
struct FM1PreloadedContentForURL final
{
public:
	class FName                                   MapPathName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LibraryPathName;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PreloadedContentForURL) == 0x000004, "Wrong alignment on FM1PreloadedContentForURL");
static_assert(sizeof(FM1PreloadedContentForURL) == 0x000010, "Wrong size on FM1PreloadedContentForURL");
static_assert(offsetof(FM1PreloadedContentForURL, MapPathName) == 0x000000, "Member 'FM1PreloadedContentForURL::MapPathName' has a wrong offset!");
static_assert(offsetof(FM1PreloadedContentForURL, LibraryPathName) == 0x000008, "Member 'FM1PreloadedContentForURL::LibraryPathName' has a wrong offset!");

// ScriptStruct M1.M1PreloadAssetsTags
// 0x0010 (0x0010 - 0x0000)
struct FM1PreloadAssetsTags final
{
public:
	TArray<struct FGameplayTag>                   Tags;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PreloadAssetsTags) == 0x000008, "Wrong alignment on FM1PreloadAssetsTags");
static_assert(sizeof(FM1PreloadAssetsTags) == 0x000010, "Wrong size on FM1PreloadAssetsTags");
static_assert(offsetof(FM1PreloadAssetsTags, Tags) == 0x000000, "Member 'FM1PreloadAssetsTags::Tags' has a wrong offset!");

// ScriptStruct M1.M1StreamableHandlesRowData
// 0x0008 (0x0010 - 0x0008)
struct FM1StreamableHandlesRowData final : public FTableRowBase
{
public:
	double                                        SizeInMB;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StreamableHandlesRowData) == 0x000008, "Wrong alignment on FM1StreamableHandlesRowData");
static_assert(sizeof(FM1StreamableHandlesRowData) == 0x000010, "Wrong size on FM1StreamableHandlesRowData");
static_assert(offsetof(FM1StreamableHandlesRowData, SizeInMB) == 0x000008, "Member 'FM1StreamableHandlesRowData::SizeInMB' has a wrong offset!");

// ScriptStruct M1.M1BaseAttachmentAnimInstanceProxy
// 0x0080 (0x0760 - 0x06E0)
struct FM1BaseAttachmentAnimInstanceProxy final : public FAnimInstanceProxy
{
public:
	uint8                                         Pad_6D8[0x88];                                     // 0x06D8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1BaseAttachmentAnimInstanceProxy) == 0x000010, "Wrong alignment on FM1BaseAttachmentAnimInstanceProxy");
static_assert(sizeof(FM1BaseAttachmentAnimInstanceProxy) == 0x000760, "Wrong size on FM1BaseAttachmentAnimInstanceProxy");

// ScriptStruct M1.M1PhaseInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1PhaseInfo final
{
public:
	int32                                         ArrIndex;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UM1ProgressBar*                         ProgressBar;                                       // 0x0008(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PhaseInfo) == 0x000008, "Wrong alignment on FM1PhaseInfo");
static_assert(sizeof(FM1PhaseInfo) == 0x000010, "Wrong size on FM1PhaseInfo");
static_assert(offsetof(FM1PhaseInfo, ArrIndex) == 0x000000, "Member 'FM1PhaseInfo::ArrIndex' has a wrong offset!");
static_assert(offsetof(FM1PhaseInfo, Ratio) == 0x000004, "Member 'FM1PhaseInfo::Ratio' has a wrong offset!");
static_assert(offsetof(FM1PhaseInfo, ProgressBar) == 0x000008, "Member 'FM1PhaseInfo::ProgressBar' has a wrong offset!");

// ScriptStruct M1.M1InputParam
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FM1InputParam final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1InputParam) == 0x000004, "Wrong alignment on FM1InputParam");
static_assert(sizeof(FM1InputParam) == 0x000008, "Wrong size on FM1InputParam");

// ScriptStruct M1.M1UIEvent_ChangedCurrentWeaponRounds
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FM1UIEvent_ChangedCurrentWeaponRounds final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_ChangedCurrentWeaponRounds) == 0x000004, "Wrong alignment on FM1UIEvent_ChangedCurrentWeaponRounds");
static_assert(sizeof(FM1UIEvent_ChangedCurrentWeaponRounds) == 0x000018, "Wrong size on FM1UIEvent_ChangedCurrentWeaponRounds");

// ScriptStruct M1.M1UIShopGoodsBG
// 0x0010 (0x0018 - 0x0008)
struct FM1UIShopGoodsBG final : public FTableRowBase
{
public:
	TArray<struct FSlateBrush>                    Brushes;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1UIShopGoodsBG) == 0x000008, "Wrong alignment on FM1UIShopGoodsBG");
static_assert(sizeof(FM1UIShopGoodsBG) == 0x000018, "Wrong size on FM1UIShopGoodsBG");
static_assert(offsetof(FM1UIShopGoodsBG, Brushes) == 0x000008, "Member 'FM1UIShopGoodsBG::Brushes' has a wrong offset!");

// ScriptStruct M1.M1GameplayClientSaveGameHelper
// 0x0018 (0x0018 - 0x0000)
struct FM1GameplayClientSaveGameHelper final
{
public:
	class UM1GameplayClientSaveGame*              SaveGameData;                                      // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1GameplayClientSaveGameHelper) == 0x000008, "Wrong alignment on FM1GameplayClientSaveGameHelper");
static_assert(sizeof(FM1GameplayClientSaveGameHelper) == 0x000018, "Wrong size on FM1GameplayClientSaveGameHelper");
static_assert(offsetof(FM1GameplayClientSaveGameHelper, SaveGameData) == 0x000000, "Member 'FM1GameplayClientSaveGameHelper::SaveGameData' has a wrong offset!");

// ScriptStruct M1.M1UIEvent_ChangedActiveWeaponOrWeaponSlot
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FM1UIEvent_ChangedActiveWeaponOrWeaponSlot final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_ChangedActiveWeaponOrWeaponSlot) == 0x000004, "Wrong alignment on FM1UIEvent_ChangedActiveWeaponOrWeaponSlot");
static_assert(sizeof(FM1UIEvent_ChangedActiveWeaponOrWeaponSlot) == 0x00000C, "Wrong size on FM1UIEvent_ChangedActiveWeaponOrWeaponSlot");

// ScriptStruct M1.M1UIEvent_SkillInput
// 0x0002 (0x0002 - 0x0000)
struct FM1UIEvent_SkillInput final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_SkillInput) == 0x000001, "Wrong alignment on FM1UIEvent_SkillInput");
static_assert(sizeof(FM1UIEvent_SkillInput) == 0x000002, "Wrong size on FM1UIEvent_SkillInput");

// ScriptStruct M1.M1ZoomPostProcessSetting
// 0x0008 (0x0008 - 0x0000)
struct FM1ZoomPostProcessSetting final
{
public:
	bool                                          bOverrideDOFFocalDistance;                         // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DOFFocalDistance;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ZoomPostProcessSetting) == 0x000004, "Wrong alignment on FM1ZoomPostProcessSetting");
static_assert(sizeof(FM1ZoomPostProcessSetting) == 0x000008, "Wrong size on FM1ZoomPostProcessSetting");
static_assert(offsetof(FM1ZoomPostProcessSetting, bOverrideDOFFocalDistance) == 0x000000, "Member 'FM1ZoomPostProcessSetting::bOverrideDOFFocalDistance' has a wrong offset!");
static_assert(offsetof(FM1ZoomPostProcessSetting, DOFFocalDistance) == 0x000004, "Member 'FM1ZoomPostProcessSetting::DOFFocalDistance' has a wrong offset!");

// ScriptStruct M1.M1ZoomCameraSetting
// 0x0050 (0x0050 - 0x0000)
struct FM1ZoomCameraSetting final
{
public:
	struct FM1CameraSetting                       CameraSetting;                                     // 0x0000(0x0048)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1ZoomPostProcessSetting              PostProcessSetting;                                // 0x0048(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ZoomCameraSetting) == 0x000004, "Wrong alignment on FM1ZoomCameraSetting");
static_assert(sizeof(FM1ZoomCameraSetting) == 0x000050, "Wrong size on FM1ZoomCameraSetting");
static_assert(offsetof(FM1ZoomCameraSetting, CameraSetting) == 0x000000, "Member 'FM1ZoomCameraSetting::CameraSetting' has a wrong offset!");
static_assert(offsetof(FM1ZoomCameraSetting, PostProcessSetting) == 0x000048, "Member 'FM1ZoomCameraSetting::PostProcessSetting' has a wrong offset!");

// ScriptStruct M1.M1CollisionDisableContext
// 0x0018 (0x0018 - 0x0000)
struct FM1CollisionDisableContext final
{
public:
	uint8                                         Disabled : 1;                                      // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Server : 1;                                        // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Context;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CollisionDisableContext) == 0x000008, "Wrong alignment on FM1CollisionDisableContext");
static_assert(sizeof(FM1CollisionDisableContext) == 0x000018, "Wrong size on FM1CollisionDisableContext");
static_assert(offsetof(FM1CollisionDisableContext, Context) == 0x000008, "Member 'FM1CollisionDisableContext::Context' has a wrong offset!");

// ScriptStruct M1.M1OptionValueIntPoint
// 0x0008 (0x0008 - 0x0000)
struct FM1OptionValueIntPoint final
{
public:
	uint32                                        X;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Y;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1OptionValueIntPoint) == 0x000004, "Wrong alignment on FM1OptionValueIntPoint");
static_assert(sizeof(FM1OptionValueIntPoint) == 0x000008, "Wrong size on FM1OptionValueIntPoint");
static_assert(offsetof(FM1OptionValueIntPoint, X) == 0x000000, "Member 'FM1OptionValueIntPoint::X' has a wrong offset!");
static_assert(offsetof(FM1OptionValueIntPoint, Y) == 0x000004, "Member 'FM1OptionValueIntPoint::Y' has a wrong offset!");

// ScriptStruct M1.M1KnockMoveInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1KnockMoveInfo final
{
public:
	float                                         ResistanceTime;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResistanceVelocityX;                               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResistanceVelocityZ;                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MoveFloatCurve;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           MoveVectorCurve;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1KnockMoveInfo) == 0x000008, "Wrong alignment on FM1KnockMoveInfo");
static_assert(sizeof(FM1KnockMoveInfo) == 0x000020, "Wrong size on FM1KnockMoveInfo");
static_assert(offsetof(FM1KnockMoveInfo, ResistanceTime) == 0x000000, "Member 'FM1KnockMoveInfo::ResistanceTime' has a wrong offset!");
static_assert(offsetof(FM1KnockMoveInfo, ResistanceVelocityX) == 0x000004, "Member 'FM1KnockMoveInfo::ResistanceVelocityX' has a wrong offset!");
static_assert(offsetof(FM1KnockMoveInfo, ResistanceVelocityZ) == 0x000008, "Member 'FM1KnockMoveInfo::ResistanceVelocityZ' has a wrong offset!");
static_assert(offsetof(FM1KnockMoveInfo, MoveFloatCurve) == 0x000010, "Member 'FM1KnockMoveInfo::MoveFloatCurve' has a wrong offset!");
static_assert(offsetof(FM1KnockMoveInfo, MoveVectorCurve) == 0x000018, "Member 'FM1KnockMoveInfo::MoveVectorCurve' has a wrong offset!");

// ScriptStruct M1.M1UIEvent_ExpRewarded
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FM1UIEvent_ExpRewarded final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_ExpRewarded) == 0x000008, "Wrong alignment on FM1UIEvent_ExpRewarded");
static_assert(sizeof(FM1UIEvent_ExpRewarded) == 0x000020, "Wrong size on FM1UIEvent_ExpRewarded");

// ScriptStruct M1.M1ImmunedTargetInfo
// 0x000C (0x000C - 0x0000)
struct FM1ImmunedTargetInfo final
{
public:
	struct FGameplayTag                           QueryTag;                                          // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTemporalTargetLost;                               // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ImmunedTargetInfo) == 0x000004, "Wrong alignment on FM1ImmunedTargetInfo");
static_assert(sizeof(FM1ImmunedTargetInfo) == 0x00000C, "Wrong size on FM1ImmunedTargetInfo");
static_assert(offsetof(FM1ImmunedTargetInfo, QueryTag) == 0x000000, "Member 'FM1ImmunedTargetInfo::QueryTag' has a wrong offset!");
static_assert(offsetof(FM1ImmunedTargetInfo, bTemporalTargetLost) == 0x000008, "Member 'FM1ImmunedTargetInfo::bTemporalTargetLost' has a wrong offset!");

// ScriptStruct M1.M1CheatIntVar
// 0x000C (0x000C - 0x0000)
struct FM1CheatIntVar final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CheatIntVar) == 0x000004, "Wrong alignment on FM1CheatIntVar");
static_assert(sizeof(FM1CheatIntVar) == 0x00000C, "Wrong size on FM1CheatIntVar");
static_assert(offsetof(FM1CheatIntVar, Name) == 0x000000, "Member 'FM1CheatIntVar::Name' has a wrong offset!");
static_assert(offsetof(FM1CheatIntVar, Value) == 0x000008, "Member 'FM1CheatIntVar::Value' has a wrong offset!");

// ScriptStruct M1.M1WeaponSlot
// 0x0018 (0x0018 - 0x0000)
struct FM1WeaponSlot final
{
public:
	int64                                         ItemUid;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1EquipmentSlotType                          SlotType;                                          // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AM1Weapon*                              Weapon;                                            // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponSlot) == 0x000008, "Wrong alignment on FM1WeaponSlot");
static_assert(sizeof(FM1WeaponSlot) == 0x000018, "Wrong size on FM1WeaponSlot");
static_assert(offsetof(FM1WeaponSlot, ItemUid) == 0x000000, "Member 'FM1WeaponSlot::ItemUid' has a wrong offset!");
static_assert(offsetof(FM1WeaponSlot, TemplateId) == 0x000008, "Member 'FM1WeaponSlot::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1WeaponSlot, SlotType) == 0x00000C, "Member 'FM1WeaponSlot::SlotType' has a wrong offset!");
static_assert(offsetof(FM1WeaponSlot, Weapon) == 0x000010, "Member 'FM1WeaponSlot::Weapon' has a wrong offset!");

// ScriptStruct M1.M1WeaponSlotState
// 0x0020 (0x0020 - 0x0000)
struct FM1WeaponSlotState final
{
public:
	EM1EquipmentSlotType                          CurWeaponSlotType;                                 // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1WeaponSlot>                  WeaponSlots;                                       // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1WeaponChangingState                 WeaponChangingState;                               // 0x0018(0x0003)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1WeaponSlotState) == 0x000008, "Wrong alignment on FM1WeaponSlotState");
static_assert(sizeof(FM1WeaponSlotState) == 0x000020, "Wrong size on FM1WeaponSlotState");
static_assert(offsetof(FM1WeaponSlotState, CurWeaponSlotType) == 0x000000, "Member 'FM1WeaponSlotState::CurWeaponSlotType' has a wrong offset!");
static_assert(offsetof(FM1WeaponSlotState, WeaponSlots) == 0x000008, "Member 'FM1WeaponSlotState::WeaponSlots' has a wrong offset!");
static_assert(offsetof(FM1WeaponSlotState, WeaponChangingState) == 0x000018, "Member 'FM1WeaponSlotState::WeaponChangingState' has a wrong offset!");

// ScriptStruct M1.M1CheatIntVarData
// 0x0010 (0x0010 - 0x0000)
struct FM1CheatIntVarData final
{
public:
	TArray<struct FM1CheatIntVar>                 IntVars;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CheatIntVarData) == 0x000008, "Wrong alignment on FM1CheatIntVarData");
static_assert(sizeof(FM1CheatIntVarData) == 0x000010, "Wrong size on FM1CheatIntVarData");
static_assert(offsetof(FM1CheatIntVarData, IntVars) == 0x000000, "Member 'FM1CheatIntVarData::IntVars' has a wrong offset!");

// ScriptStruct M1.M1NavMeshDebugData
// 0x001C (0x001C - 0x0000)
struct FM1NavMeshDebugData final
{
public:
	class FName                                   NavMeshName;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOnNav;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        AreaID;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NavLocation;                                       // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NavMeshDebugData) == 0x000004, "Wrong alignment on FM1NavMeshDebugData");
static_assert(sizeof(FM1NavMeshDebugData) == 0x00001C, "Wrong size on FM1NavMeshDebugData");
static_assert(offsetof(FM1NavMeshDebugData, NavMeshName) == 0x000000, "Member 'FM1NavMeshDebugData::NavMeshName' has a wrong offset!");
static_assert(offsetof(FM1NavMeshDebugData, bIsOnNav) == 0x000008, "Member 'FM1NavMeshDebugData::bIsOnNav' has a wrong offset!");
static_assert(offsetof(FM1NavMeshDebugData, AreaID) == 0x00000C, "Member 'FM1NavMeshDebugData::AreaID' has a wrong offset!");
static_assert(offsetof(FM1NavMeshDebugData, NavLocation) == 0x000010, "Member 'FM1NavMeshDebugData::NavLocation' has a wrong offset!");

// ScriptStruct M1.M1LastPlayedMissionInfo
// 0x0008 (0x0008 - 0x0000)
struct FM1LastPlayedMissionInfo final
{
public:
	EM1MissionEndReason                           MissionEndReason;                                  // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1TemplateId                          MissionTid;                                        // 0x0004(0x0004)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1LastPlayedMissionInfo) == 0x000004, "Wrong alignment on FM1LastPlayedMissionInfo");
static_assert(sizeof(FM1LastPlayedMissionInfo) == 0x000008, "Wrong size on FM1LastPlayedMissionInfo");
static_assert(offsetof(FM1LastPlayedMissionInfo, MissionEndReason) == 0x000000, "Member 'FM1LastPlayedMissionInfo::MissionEndReason' has a wrong offset!");
static_assert(offsetof(FM1LastPlayedMissionInfo, MissionTid) == 0x000004, "Member 'FM1LastPlayedMissionInfo::MissionTid' has a wrong offset!");

// ScriptStruct M1.M1PlayerNavDebugData
// 0x0038 (0x0038 - 0x0000)
struct FM1PlayerNavDebugData final
{
public:
	struct FM1NavMeshDebugData                    EpicBossNav;                                       // 0x0000(0x001C)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1NavMeshDebugData                    DefaultNav;                                        // 0x001C(0x001C)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PlayerNavDebugData) == 0x000004, "Wrong alignment on FM1PlayerNavDebugData");
static_assert(sizeof(FM1PlayerNavDebugData) == 0x000038, "Wrong size on FM1PlayerNavDebugData");
static_assert(offsetof(FM1PlayerNavDebugData, EpicBossNav) == 0x000000, "Member 'FM1PlayerNavDebugData::EpicBossNav' has a wrong offset!");
static_assert(offsetof(FM1PlayerNavDebugData, DefaultNav) == 0x00001C, "Member 'FM1PlayerNavDebugData::DefaultNav' has a wrong offset!");

// ScriptStruct M1.ArrayPropertyAnimLengths
// 0x0010 (0x0010 - 0x0000)
struct FArrayPropertyAnimLengths final
{
public:
	TArray<float>                                 AnimLengths;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArrayPropertyAnimLengths) == 0x000008, "Wrong alignment on FArrayPropertyAnimLengths");
static_assert(sizeof(FArrayPropertyAnimLengths) == 0x000010, "Wrong size on FArrayPropertyAnimLengths");
static_assert(offsetof(FArrayPropertyAnimLengths, AnimLengths) == 0x000000, "Member 'FArrayPropertyAnimLengths::AnimLengths' has a wrong offset!");

// ScriptStruct M1.MapPropertyAnimLengths
// 0x0050 (0x0050 - 0x0000)
struct FMapPropertyAnimLengths final
{
public:
	TMap<class FName, float>                      AnimLengths;                                       // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapPropertyAnimLengths) == 0x000008, "Wrong alignment on FMapPropertyAnimLengths");
static_assert(sizeof(FMapPropertyAnimLengths) == 0x000050, "Wrong size on FMapPropertyAnimLengths");
static_assert(offsetof(FMapPropertyAnimLengths, AnimLengths) == 0x000000, "Member 'FMapPropertyAnimLengths::AnimLengths' has a wrong offset!");

// ScriptStruct M1.M1InteractionEntities
// 0x0018 (0x0018 - 0x0000)
struct FM1InteractionEntities final
{
public:
	TArray<class UM1InteractableEntity*>          WaitingEntities;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UM1InteractableEntity*                  BestEntity;                                        // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InteractionEntities) == 0x000008, "Wrong alignment on FM1InteractionEntities");
static_assert(sizeof(FM1InteractionEntities) == 0x000018, "Wrong size on FM1InteractionEntities");
static_assert(offsetof(FM1InteractionEntities, WaitingEntities) == 0x000000, "Member 'FM1InteractionEntities::WaitingEntities' has a wrong offset!");
static_assert(offsetof(FM1InteractionEntities, BestEntity) == 0x000010, "Member 'FM1InteractionEntities::BestEntity' has a wrong offset!");

// ScriptStruct M1.M1DirectMessageCandidate
// 0x0020 (0x0020 - 0x0000)
struct FM1DirectMessageCandidate final
{
public:
	class FString                                 AccountName;                                       // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DirectMessageCandidate) == 0x000008, "Wrong alignment on FM1DirectMessageCandidate");
static_assert(sizeof(FM1DirectMessageCandidate) == 0x000020, "Wrong size on FM1DirectMessageCandidate");
static_assert(offsetof(FM1DirectMessageCandidate, AccountName) == 0x000000, "Member 'FM1DirectMessageCandidate::AccountName' has a wrong offset!");
static_assert(offsetof(FM1DirectMessageCandidate, DisplayName) == 0x000010, "Member 'FM1DirectMessageCandidate::DisplayName' has a wrong offset!");

// ScriptStruct M1.M1ChattingTypeHistory
// 0x0028 (0x0028 - 0x0000)
struct FM1ChattingTypeHistory final
{
public:
	EM1ChattingTab                                Tab;                                               // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ChattingType                               TypeInWorldTab;                                    // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ChattingType                               TypeInNormalTab;                                   // 0x0002(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1DirectMessageCandidate              Receiver;                                          // 0x0008(0x0020)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ChattingTypeHistory) == 0x000008, "Wrong alignment on FM1ChattingTypeHistory");
static_assert(sizeof(FM1ChattingTypeHistory) == 0x000028, "Wrong size on FM1ChattingTypeHistory");
static_assert(offsetof(FM1ChattingTypeHistory, Tab) == 0x000000, "Member 'FM1ChattingTypeHistory::Tab' has a wrong offset!");
static_assert(offsetof(FM1ChattingTypeHistory, TypeInWorldTab) == 0x000001, "Member 'FM1ChattingTypeHistory::TypeInWorldTab' has a wrong offset!");
static_assert(offsetof(FM1ChattingTypeHistory, TypeInNormalTab) == 0x000002, "Member 'FM1ChattingTypeHistory::TypeInNormalTab' has a wrong offset!");
static_assert(offsetof(FM1ChattingTypeHistory, Receiver) == 0x000008, "Member 'FM1ChattingTypeHistory::Receiver' has a wrong offset!");

// ScriptStruct M1.M1WorldTabLocalHistory
// 0x0010 (0x0010 - 0x0000)
struct FM1WorldTabLocalHistory final
{
public:
	TArray<class UM1ChattingHistoryData*>         History;                                           // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WorldTabLocalHistory) == 0x000008, "Wrong alignment on FM1WorldTabLocalHistory");
static_assert(sizeof(FM1WorldTabLocalHistory) == 0x000010, "Wrong size on FM1WorldTabLocalHistory");
static_assert(offsetof(FM1WorldTabLocalHistory, History) == 0x000000, "Member 'FM1WorldTabLocalHistory::History' has a wrong offset!");

// ScriptStruct M1.M1WeaponRoundsConsumeRecord
// 0x0010 (0x0010 - 0x0000)
struct FM1WeaponRoundsConsumeRecord final
{
public:
	double                                        Timestamp;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StatValue;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1WeaponRoundsConsumeRecord) == 0x000008, "Wrong alignment on FM1WeaponRoundsConsumeRecord");
static_assert(sizeof(FM1WeaponRoundsConsumeRecord) == 0x000010, "Wrong size on FM1WeaponRoundsConsumeRecord");
static_assert(offsetof(FM1WeaponRoundsConsumeRecord, Timestamp) == 0x000000, "Member 'FM1WeaponRoundsConsumeRecord::Timestamp' has a wrong offset!");
static_assert(offsetof(FM1WeaponRoundsConsumeRecord, StatValue) == 0x000008, "Member 'FM1WeaponRoundsConsumeRecord::StatValue' has a wrong offset!");

// ScriptStruct M1.M1MessageSendInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1MessageSendInfo final
{
public:
	int64                                         LastSendTime;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         NextAvailableSendTime;                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SendStackCount;                                    // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MessageSendInfo) == 0x000008, "Wrong alignment on FM1MessageSendInfo");
static_assert(sizeof(FM1MessageSendInfo) == 0x000018, "Wrong size on FM1MessageSendInfo");
static_assert(offsetof(FM1MessageSendInfo, LastSendTime) == 0x000000, "Member 'FM1MessageSendInfo::LastSendTime' has a wrong offset!");
static_assert(offsetof(FM1MessageSendInfo, NextAvailableSendTime) == 0x000008, "Member 'FM1MessageSendInfo::NextAvailableSendTime' has a wrong offset!");
static_assert(offsetof(FM1MessageSendInfo, SendStackCount) == 0x000010, "Member 'FM1MessageSendInfo::SendStackCount' has a wrong offset!");

// ScriptStruct M1.M1MessageSendInfoByRule
// 0x0050 (0x0050 - 0x0000)
struct FM1MessageSendInfoByRule final
{
public:
	TMap<EM1ChattingBlockRule, struct FM1MessageSendInfo> MessageInfos;                                      // 0x0000(0x0050)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MessageSendInfoByRule) == 0x000008, "Wrong alignment on FM1MessageSendInfoByRule");
static_assert(sizeof(FM1MessageSendInfoByRule) == 0x000050, "Wrong size on FM1MessageSendInfoByRule");
static_assert(offsetof(FM1MessageSendInfoByRule, MessageInfos) == 0x000000, "Member 'FM1MessageSendInfoByRule::MessageInfos' has a wrong offset!");

// ScriptStruct M1.M1MissionEventParam
// 0x0010 (0x0010 - 0x0000)
struct FM1MissionEventParam final
{
public:
	class UM1MissionControlComponent*             MissionControlComponent;                           // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AM1MissionActor*                        MissionActor;                                      // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionEventParam) == 0x000008, "Wrong alignment on FM1MissionEventParam");
static_assert(sizeof(FM1MissionEventParam) == 0x000010, "Wrong size on FM1MissionEventParam");
static_assert(offsetof(FM1MissionEventParam, MissionControlComponent) == 0x000000, "Member 'FM1MissionEventParam::MissionControlComponent' has a wrong offset!");
static_assert(offsetof(FM1MissionEventParam, MissionActor) == 0x000008, "Member 'FM1MissionEventParam::MissionActor' has a wrong offset!");

// ScriptStruct M1.M1CheatVarsAuthority
// 0x0050 (0x0050 - 0x0000)
struct FM1CheatVarsAuthority final
{
public:
	bool                                          bTestNoDieAllPlayer;                               // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMonsterAIDisable;                                 // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSummonAIDisable;                                  // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AIDisableUsingName;                                // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAISkillDisable;                                   // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAITargetDisable;                                  // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoAlly;                                           // 0x001A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x1];                                       // 0x001B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DestructivePower;                                  // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeboneableAllParts;                               // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowMonsterAIDebug;                               // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowSkillRangeCheck;                              // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGoToClosestNavmesh;                         // 0x0023(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MonsterDeadbodyLifeTime;                           // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDoorDebug;                                    // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowMovingActorDebug;                             // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisabledCharacterControlUnapplyDelay;             // 0x002A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MonsterSpawnOverrideSuffix;                        // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNativeConvertMode;                                // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProjectNavMeshWalking;                            // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MonsterPathFailedTeleportTime;                     // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMissionBalanceDump;                               // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CheatVarsAuthority) == 0x000008, "Wrong alignment on FM1CheatVarsAuthority");
static_assert(sizeof(FM1CheatVarsAuthority) == 0x000050, "Wrong size on FM1CheatVarsAuthority");
static_assert(offsetof(FM1CheatVarsAuthority, bTestNoDieAllPlayer) == 0x000000, "Member 'FM1CheatVarsAuthority::bTestNoDieAllPlayer' has a wrong offset!");
static_assert(offsetof(FM1CheatVarsAuthority, bMonsterAIDisable) == 0x000001, "Member 'FM1CheatVarsAuthority::bMonsterAIDisable' has a wrong offset!");
static_assert(offsetof(FM1CheatVarsAuthority, bSummonAIDisable) == 0x000002, "Member 'FM1CheatVarsAuthority::bSummonAIDisable' has a wrong offset!");
static_assert(offsetof(FM1CheatVarsAuthority, AIDisableUsingName) == 0x000008, "Member 'FM1CheatVarsAuthority::AIDisableUsingName' has a wrong offset!");
static_assert(offsetof(FM1CheatVarsAuthority, bAISkillDisable) == 0x000018, "Member 'FM1CheatVarsAuthority::bAISkillDisable' has a wrong offset!");
static_assert(offsetof(FM1CheatVarsAuthority, bAITargetDisable) == 0x000019, "Member 'FM1CheatVarsAuthority::bAITargetDisable' has a wrong offset!");
static_assert(offsetof(FM1CheatVarsAuthority, bNoAlly) == 0x00001A, "Member 'FM1CheatVarsAuthority::bNoAlly' has a wrong offset!");
static_assert(offsetof(FM1CheatVarsAuthority, DestructivePower) == 0x00001C, "Member 'FM1CheatVarsAuthority::DestructivePower' has a wrong offset!");
static_assert(offsetof(FM1CheatVarsAuthority, bDeboneableAllParts) == 0x000020, "Member 'FM1CheatVarsAuthority::bDeboneableAllParts' has a wrong offset!");
static_assert(offsetof(FM1CheatVarsAuthority, bShowMonsterAIDebug) == 0x000021, "Member 'FM1CheatVarsAuthority::bShowMonsterAIDebug' has a wrong offset!");
static_assert(offsetof(FM1CheatVarsAuthority, bShowSkillRangeCheck) == 0x000022, "Member 'FM1CheatVarsAuthority::bShowSkillRangeCheck' has a wrong offset!");
static_assert(offsetof(FM1CheatVarsAuthority, bEnableGoToClosestNavmesh) == 0x000023, "Member 'FM1CheatVarsAuthority::bEnableGoToClosestNavmesh' has a wrong offset!");
static_assert(offsetof(FM1CheatVarsAuthority, MonsterDeadbodyLifeTime) == 0x000024, "Member 'FM1CheatVarsAuthority::MonsterDeadbodyLifeTime' has a wrong offset!");
static_assert(offsetof(FM1CheatVarsAuthority, bShowDoorDebug) == 0x000028, "Member 'FM1CheatVarsAuthority::bShowDoorDebug' has a wrong offset!");
static_assert(offsetof(FM1CheatVarsAuthority, bShowMovingActorDebug) == 0x000029, "Member 'FM1CheatVarsAuthority::bShowMovingActorDebug' has a wrong offset!");
static_assert(offsetof(FM1CheatVarsAuthority, bDisabledCharacterControlUnapplyDelay) == 0x00002A, "Member 'FM1CheatVarsAuthority::bDisabledCharacterControlUnapplyDelay' has a wrong offset!");
static_assert(offsetof(FM1CheatVarsAuthority, MonsterSpawnOverrideSuffix) == 0x000030, "Member 'FM1CheatVarsAuthority::MonsterSpawnOverrideSuffix' has a wrong offset!");
static_assert(offsetof(FM1CheatVarsAuthority, bNativeConvertMode) == 0x000040, "Member 'FM1CheatVarsAuthority::bNativeConvertMode' has a wrong offset!");
static_assert(offsetof(FM1CheatVarsAuthority, bProjectNavMeshWalking) == 0x000041, "Member 'FM1CheatVarsAuthority::bProjectNavMeshWalking' has a wrong offset!");
static_assert(offsetof(FM1CheatVarsAuthority, MonsterPathFailedTeleportTime) == 0x000044, "Member 'FM1CheatVarsAuthority::MonsterPathFailedTeleportTime' has a wrong offset!");
static_assert(offsetof(FM1CheatVarsAuthority, bMissionBalanceDump) == 0x000048, "Member 'FM1CheatVarsAuthority::bMissionBalanceDump' has a wrong offset!");

// ScriptStruct M1.M1TestParam
// 0x0040 (0x0040 - 0x0000)
struct FM1TestParam final
{
public:
	TArray<int64>                                 Value1;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x30];                                      // 0x0010(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1TestParam) == 0x000008, "Wrong alignment on FM1TestParam");
static_assert(sizeof(FM1TestParam) == 0x000040, "Wrong size on FM1TestParam");
static_assert(offsetof(FM1TestParam, Value1) == 0x000000, "Member 'FM1TestParam::Value1' has a wrong offset!");

// ScriptStruct M1.M1LobbyAnimArray
// 0x0010 (0x0010 - 0x0000)
struct FM1LobbyAnimArray final
{
public:
	TArray<TSoftObjectPtr<class UAnimSequence>>   LobbyAnimArray;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1LobbyAnimArray) == 0x000008, "Wrong alignment on FM1LobbyAnimArray");
static_assert(sizeof(FM1LobbyAnimArray) == 0x000010, "Wrong size on FM1LobbyAnimArray");
static_assert(offsetof(FM1LobbyAnimArray, LobbyAnimArray) == 0x000000, "Member 'FM1LobbyAnimArray::LobbyAnimArray' has a wrong offset!");

// ScriptStruct M1.M1CharacterLobbyAnim
// 0x0068 (0x0070 - 0x0008)
struct FM1CharacterLobbyAnim final : public FTableRowBase
{
public:
	int64                                         CharacterId;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UAnimSequence>>   AnimSequences;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class USkeletalMesh>, struct FM1LobbyAnimArray> BodyMeshMap;                                       // 0x0020(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CharacterLobbyAnim) == 0x000008, "Wrong alignment on FM1CharacterLobbyAnim");
static_assert(sizeof(FM1CharacterLobbyAnim) == 0x000070, "Wrong size on FM1CharacterLobbyAnim");
static_assert(offsetof(FM1CharacterLobbyAnim, CharacterId) == 0x000008, "Member 'FM1CharacterLobbyAnim::CharacterId' has a wrong offset!");
static_assert(offsetof(FM1CharacterLobbyAnim, AnimSequences) == 0x000010, "Member 'FM1CharacterLobbyAnim::AnimSequences' has a wrong offset!");
static_assert(offsetof(FM1CharacterLobbyAnim, BodyMeshMap) == 0x000020, "Member 'FM1CharacterLobbyAnim::BodyMeshMap' has a wrong offset!");

// ScriptStruct M1.M1MeleeAOE
// 0x0010 (0x0010 - 0x0000)
struct FM1MeleeAOE final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UM1AnimNotify_MeleeAOE*                 Notify;                                            // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MeleeAOE) == 0x000008, "Wrong alignment on FM1MeleeAOE");
static_assert(sizeof(FM1MeleeAOE) == 0x000010, "Wrong size on FM1MeleeAOE");
static_assert(offsetof(FM1MeleeAOE, Notify) == 0x000008, "Member 'FM1MeleeAOE::Notify' has a wrong offset!");

// ScriptStruct M1.M1ClientSavedDataMap
// 0x0050 (0x0050 - 0x0000)
struct FM1ClientSavedDataMap final
{
public:
	TMap<struct FM1TemplateId, struct FM1TemplateId> DataMap;                                           // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ClientSavedDataMap) == 0x000008, "Wrong alignment on FM1ClientSavedDataMap");
static_assert(sizeof(FM1ClientSavedDataMap) == 0x000050, "Wrong size on FM1ClientSavedDataMap");
static_assert(offsetof(FM1ClientSavedDataMap, DataMap) == 0x000000, "Member 'FM1ClientSavedDataMap::DataMap' has a wrong offset!");

// ScriptStruct M1.M1WidgetUserValue
// 0x0018 (0x0018 - 0x0000)
struct FM1WidgetUserValue final
{
public:
	int32                                         IntValue;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringValue;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WidgetUserValue) == 0x000008, "Wrong alignment on FM1WidgetUserValue");
static_assert(sizeof(FM1WidgetUserValue) == 0x000018, "Wrong size on FM1WidgetUserValue");
static_assert(offsetof(FM1WidgetUserValue, IntValue) == 0x000000, "Member 'FM1WidgetUserValue::IntValue' has a wrong offset!");
static_assert(offsetof(FM1WidgetUserValue, StringValue) == 0x000008, "Member 'FM1WidgetUserValue::StringValue' has a wrong offset!");

// ScriptStruct M1.M1MultiConditionDropDownInfo
// 0x0050 (0x0050 - 0x0000)
struct FM1MultiConditionDropDownInfo final
{
public:
	TSoftObjectPtr<class UTexture2D>              IconImage;                                         // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StringId;                                          // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Payload;                                           // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MultiConditionDropDownInfo) == 0x000008, "Wrong alignment on FM1MultiConditionDropDownInfo");
static_assert(sizeof(FM1MultiConditionDropDownInfo) == 0x000050, "Wrong size on FM1MultiConditionDropDownInfo");
static_assert(offsetof(FM1MultiConditionDropDownInfo, IconImage) == 0x000000, "Member 'FM1MultiConditionDropDownInfo::IconImage' has a wrong offset!");
static_assert(offsetof(FM1MultiConditionDropDownInfo, StringId) == 0x000030, "Member 'FM1MultiConditionDropDownInfo::StringId' has a wrong offset!");
static_assert(offsetof(FM1MultiConditionDropDownInfo, Payload) == 0x000040, "Member 'FM1MultiConditionDropDownInfo::Payload' has a wrong offset!");

// ScriptStruct M1.M1MultiConditionSorterCreateParam
// 0x0058 (0x0058 - 0x0000)
struct FM1MultiConditionSorterCreateParam final
{
public:
	EM1SortOption                                 SortOption;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1MultiConditionDropDownInfo          Info;                                              // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MultiConditionSorterCreateParam) == 0x000008, "Wrong alignment on FM1MultiConditionSorterCreateParam");
static_assert(sizeof(FM1MultiConditionSorterCreateParam) == 0x000058, "Wrong size on FM1MultiConditionSorterCreateParam");
static_assert(offsetof(FM1MultiConditionSorterCreateParam, SortOption) == 0x000000, "Member 'FM1MultiConditionSorterCreateParam::SortOption' has a wrong offset!");
static_assert(offsetof(FM1MultiConditionSorterCreateParam, Info) == 0x000008, "Member 'FM1MultiConditionSorterCreateParam::Info' has a wrong offset!");

// ScriptStruct M1.M1StringId
// 0x0008 (0x0008 - 0x0000)
struct FM1StringId final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1StringId) == 0x000004, "Wrong alignment on FM1StringId");
static_assert(sizeof(FM1StringId) == 0x000008, "Wrong size on FM1StringId");
static_assert(offsetof(FM1StringId, ID) == 0x000000, "Member 'FM1StringId::ID' has a wrong offset!");

// ScriptStruct M1.M1FlagCounter
// 0x0001 (0x0001 - 0x0000)
struct FM1FlagCounter final
{
public:
	uint8                                         Counter;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1FlagCounter) == 0x000001, "Wrong alignment on FM1FlagCounter");
static_assert(sizeof(FM1FlagCounter) == 0x000001, "Wrong size on FM1FlagCounter");
static_assert(offsetof(FM1FlagCounter, Counter) == 0x000000, "Member 'FM1FlagCounter::Counter' has a wrong offset!");

// ScriptStruct M1.M1GameServerInfo
// 0x00A0 (0x00A0 - 0x0000)
struct FM1GameServerInfo final
{
public:
	struct FURL                                   URL;                                               // 0x0000(0x0068)(NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MapTemplateId;                                     // 0x0068(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        NetworkVersion;                                    // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        NoonBiasHour;                                      // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        CreationTimeTicksUtc;                              // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MapSubType                                 MapSubType;                                        // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FieldDifficulty;                                   // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LogFileName;                                       // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ZoneId;                                            // 0x0098(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1GameServerInfo) == 0x000008, "Wrong alignment on FM1GameServerInfo");
static_assert(sizeof(FM1GameServerInfo) == 0x0000A0, "Wrong size on FM1GameServerInfo");
static_assert(offsetof(FM1GameServerInfo, URL) == 0x000000, "Member 'FM1GameServerInfo::URL' has a wrong offset!");
static_assert(offsetof(FM1GameServerInfo, MapTemplateId) == 0x000068, "Member 'FM1GameServerInfo::MapTemplateId' has a wrong offset!");
static_assert(offsetof(FM1GameServerInfo, NetworkVersion) == 0x00006C, "Member 'FM1GameServerInfo::NetworkVersion' has a wrong offset!");
static_assert(offsetof(FM1GameServerInfo, NoonBiasHour) == 0x000070, "Member 'FM1GameServerInfo::NoonBiasHour' has a wrong offset!");
static_assert(offsetof(FM1GameServerInfo, CreationTimeTicksUtc) == 0x000078, "Member 'FM1GameServerInfo::CreationTimeTicksUtc' has a wrong offset!");
static_assert(offsetof(FM1GameServerInfo, MapSubType) == 0x000080, "Member 'FM1GameServerInfo::MapSubType' has a wrong offset!");
static_assert(offsetof(FM1GameServerInfo, FieldDifficulty) == 0x000084, "Member 'FM1GameServerInfo::FieldDifficulty' has a wrong offset!");
static_assert(offsetof(FM1GameServerInfo, LogFileName) == 0x000088, "Member 'FM1GameServerInfo::LogFileName' has a wrong offset!");
static_assert(offsetof(FM1GameServerInfo, ZoneId) == 0x000098, "Member 'FM1GameServerInfo::ZoneId' has a wrong offset!");

// ScriptStruct M1.M1ItemListSource
// 0x0048 (0x0048 - 0x0000)
struct FM1ItemListSource final
{
public:
	EM1ItemListSourceType                         ListSourceType;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ListSourceStringIds;                               // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          SourceTid;                                         // 0x0018(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          BelongedMapTemplateId;                             // 0x001C(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          BelongedMapBattleZoneId;                           // 0x0020(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          FieldDifficultyLevel;                              // 0x0024(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1WidgetUserValue                     CustomValue;                                       // 0x0028(0x0018)(NativeAccessSpecifierPublic)
	bool                                          bOnce;                                             // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ItemListSource) == 0x000008, "Wrong alignment on FM1ItemListSource");
static_assert(sizeof(FM1ItemListSource) == 0x000048, "Wrong size on FM1ItemListSource");
static_assert(offsetof(FM1ItemListSource, ListSourceType) == 0x000000, "Member 'FM1ItemListSource::ListSourceType' has a wrong offset!");
static_assert(offsetof(FM1ItemListSource, ListSourceStringIds) == 0x000008, "Member 'FM1ItemListSource::ListSourceStringIds' has a wrong offset!");
static_assert(offsetof(FM1ItemListSource, SourceTid) == 0x000018, "Member 'FM1ItemListSource::SourceTid' has a wrong offset!");
static_assert(offsetof(FM1ItemListSource, BelongedMapTemplateId) == 0x00001C, "Member 'FM1ItemListSource::BelongedMapTemplateId' has a wrong offset!");
static_assert(offsetof(FM1ItemListSource, BelongedMapBattleZoneId) == 0x000020, "Member 'FM1ItemListSource::BelongedMapBattleZoneId' has a wrong offset!");
static_assert(offsetof(FM1ItemListSource, FieldDifficultyLevel) == 0x000024, "Member 'FM1ItemListSource::FieldDifficultyLevel' has a wrong offset!");
static_assert(offsetof(FM1ItemListSource, CustomValue) == 0x000028, "Member 'FM1ItemListSource::CustomValue' has a wrong offset!");
static_assert(offsetof(FM1ItemListSource, bOnce) == 0x000040, "Member 'FM1ItemListSource::bOnce' has a wrong offset!");

// ScriptStruct M1.M1MovingActorInteractionActor
// 0x0010 (0x0010 - 0x0000)
struct FM1MovingActorInteractionActor final
{
public:
	class AM1MovingActorInteractableActor*        InteractableActor;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionTime;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MovingActorInteractionActor) == 0x000008, "Wrong alignment on FM1MovingActorInteractionActor");
static_assert(sizeof(FM1MovingActorInteractionActor) == 0x000010, "Wrong size on FM1MovingActorInteractionActor");
static_assert(offsetof(FM1MovingActorInteractionActor, InteractableActor) == 0x000000, "Member 'FM1MovingActorInteractionActor::InteractableActor' has a wrong offset!");
static_assert(offsetof(FM1MovingActorInteractionActor, InteractionTime) == 0x000008, "Member 'FM1MovingActorInteractionActor::InteractionTime' has a wrong offset!");

// ScriptStruct M1.M1StringKeyType
// 0x0008 (0x0008 - 0x0000)
struct FM1StringKeyType final
{
public:
	class FName                                   KeyName;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StringKeyType) == 0x000004, "Wrong alignment on FM1StringKeyType");
static_assert(sizeof(FM1StringKeyType) == 0x000008, "Wrong size on FM1StringKeyType");
static_assert(offsetof(FM1StringKeyType, KeyName) == 0x000000, "Member 'FM1StringKeyType::KeyName' has a wrong offset!");

// ScriptStruct M1.M1CameraLimit
// 0x0018 (0x0018 - 0x0000)
struct FM1CameraLimit final
{
public:
	float                                         LimitCameraZoomOut;                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitCameraZoomIn;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighestMoveY_ZoomedOut;                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowestMoveY_ZoomedOut;                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighestMoveY_ZoomedIn;                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowestMoveY_ZoomedIn;                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CameraLimit) == 0x000004, "Wrong alignment on FM1CameraLimit");
static_assert(sizeof(FM1CameraLimit) == 0x000018, "Wrong size on FM1CameraLimit");
static_assert(offsetof(FM1CameraLimit, LimitCameraZoomOut) == 0x000000, "Member 'FM1CameraLimit::LimitCameraZoomOut' has a wrong offset!");
static_assert(offsetof(FM1CameraLimit, LimitCameraZoomIn) == 0x000004, "Member 'FM1CameraLimit::LimitCameraZoomIn' has a wrong offset!");
static_assert(offsetof(FM1CameraLimit, HighestMoveY_ZoomedOut) == 0x000008, "Member 'FM1CameraLimit::HighestMoveY_ZoomedOut' has a wrong offset!");
static_assert(offsetof(FM1CameraLimit, LowestMoveY_ZoomedOut) == 0x00000C, "Member 'FM1CameraLimit::LowestMoveY_ZoomedOut' has a wrong offset!");
static_assert(offsetof(FM1CameraLimit, HighestMoveY_ZoomedIn) == 0x000010, "Member 'FM1CameraLimit::HighestMoveY_ZoomedIn' has a wrong offset!");
static_assert(offsetof(FM1CameraLimit, LowestMoveY_ZoomedIn) == 0x000014, "Member 'FM1CameraLimit::LowestMoveY_ZoomedIn' has a wrong offset!");

// ScriptStruct M1.M1NavigationWidgetHandler
// 0x0010 (0x0010 - 0x0000)
struct FM1NavigationWidgetHandler final
{
public:
	class UWidget*                                HandlerWidget;                                     // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDescendant;                                    // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DescendantIndex;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NavigationWidgetHandler) == 0x000008, "Wrong alignment on FM1NavigationWidgetHandler");
static_assert(sizeof(FM1NavigationWidgetHandler) == 0x000010, "Wrong size on FM1NavigationWidgetHandler");
static_assert(offsetof(FM1NavigationWidgetHandler, HandlerWidget) == 0x000000, "Member 'FM1NavigationWidgetHandler::HandlerWidget' has a wrong offset!");
static_assert(offsetof(FM1NavigationWidgetHandler, bUseDescendant) == 0x000008, "Member 'FM1NavigationWidgetHandler::bUseDescendant' has a wrong offset!");
static_assert(offsetof(FM1NavigationWidgetHandler, DescendantIndex) == 0x00000C, "Member 'FM1NavigationWidgetHandler::DescendantIndex' has a wrong offset!");

// ScriptStruct M1.M1ToastData
// 0x0020 (0x0028 - 0x0008)
struct FM1ToastData final : public FTableRowBase
{
public:
	class FString                                 StringId;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ToastType                                  ToastType;                                         // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseChatMsg;                                        // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ToastData) == 0x000008, "Wrong alignment on FM1ToastData");
static_assert(sizeof(FM1ToastData) == 0x000028, "Wrong size on FM1ToastData");
static_assert(offsetof(FM1ToastData, StringId) == 0x000008, "Member 'FM1ToastData::StringId' has a wrong offset!");
static_assert(offsetof(FM1ToastData, ToastType) == 0x000018, "Member 'FM1ToastData::ToastType' has a wrong offset!");
static_assert(offsetof(FM1ToastData, Priority) == 0x00001C, "Member 'FM1ToastData::Priority' has a wrong offset!");
static_assert(offsetof(FM1ToastData, UseChatMsg) == 0x000020, "Member 'FM1ToastData::UseChatMsg' has a wrong offset!");

// ScriptStruct M1.M1NavigationTagMapping
// 0x0018 (0x0018 - 0x0000)
struct FM1NavigationTagMapping final
{
public:
	class FName                                   NavigationTagFrom;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NavigationTagTo;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            HandlerWidgetTo;                                   // 0x0010(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NavigationTagMapping) == 0x000008, "Wrong alignment on FM1NavigationTagMapping");
static_assert(sizeof(FM1NavigationTagMapping) == 0x000018, "Wrong size on FM1NavigationTagMapping");
static_assert(offsetof(FM1NavigationTagMapping, NavigationTagFrom) == 0x000000, "Member 'FM1NavigationTagMapping::NavigationTagFrom' has a wrong offset!");
static_assert(offsetof(FM1NavigationTagMapping, NavigationTagTo) == 0x000008, "Member 'FM1NavigationTagMapping::NavigationTagTo' has a wrong offset!");
static_assert(offsetof(FM1NavigationTagMapping, HandlerWidgetTo) == 0x000010, "Member 'FM1NavigationTagMapping::HandlerWidgetTo' has a wrong offset!");

// ScriptStruct M1.M1MatchingContentData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FM1MatchingContentData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MatchingContentData) == 0x000004, "Wrong alignment on FM1MatchingContentData");
static_assert(sizeof(FM1MatchingContentData) == 0x000010, "Wrong size on FM1MatchingContentData");

// ScriptStruct M1.M1NXAPIRequest
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FM1NXAPIRequest final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1NXAPIRequest) == 0x000008, "Wrong alignment on FM1NXAPIRequest");
static_assert(sizeof(FM1NXAPIRequest) == 0x000040, "Wrong size on FM1NXAPIRequest");

// ScriptStruct M1.M1ContentsUnlockCondition
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FM1ContentsUnlockCondition final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ContentsUnlockCondition) == 0x000008, "Wrong alignment on FM1ContentsUnlockCondition");
static_assert(sizeof(FM1ContentsUnlockCondition) == 0x000020, "Wrong size on FM1ContentsUnlockCondition");

// ScriptStruct M1.M1NavDirtyArea
// 0x0060 (0x0060 - 0x0000)
struct FM1NavDirtyArea final
{
public:
	bool                                          bRevert;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FVector, struct FM1NavConvex>     DirtyAreaConvexData;                               // 0x0008(0x0050)(NativeAccessSpecifierPublic)
	bool                                          bSetViewTarget;                                    // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NavTileIndex;                                      // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NavDirtyArea) == 0x000008, "Wrong alignment on FM1NavDirtyArea");
static_assert(sizeof(FM1NavDirtyArea) == 0x000060, "Wrong size on FM1NavDirtyArea");
static_assert(offsetof(FM1NavDirtyArea, bRevert) == 0x000000, "Member 'FM1NavDirtyArea::bRevert' has a wrong offset!");
static_assert(offsetof(FM1NavDirtyArea, DirtyAreaConvexData) == 0x000008, "Member 'FM1NavDirtyArea::DirtyAreaConvexData' has a wrong offset!");
static_assert(offsetof(FM1NavDirtyArea, bSetViewTarget) == 0x000058, "Member 'FM1NavDirtyArea::bSetViewTarget' has a wrong offset!");
static_assert(offsetof(FM1NavDirtyArea, NavTileIndex) == 0x00005C, "Member 'FM1NavDirtyArea::NavTileIndex' has a wrong offset!");

// ScriptStruct M1.M1ContentsUnlockInfo
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FM1ContentsUnlockInfo final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ContentsUnlockInfo) == 0x000008, "Wrong alignment on FM1ContentsUnlockInfo");
static_assert(sizeof(FM1ContentsUnlockInfo) == 0x000060, "Wrong size on FM1ContentsUnlockInfo");

// ScriptStruct M1.M1CoolTimer
// 0x0014 (0x0014 - 0x0000)
struct FM1CoolTimer final
{
public:
	class FName                                   CoolTimeContext;                                   // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bActivated;                                        // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CoolTimeDuration;                                  // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RemainingCoolTime;                                 // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1CoolTimer) == 0x000004, "Wrong alignment on FM1CoolTimer");
static_assert(sizeof(FM1CoolTimer) == 0x000014, "Wrong size on FM1CoolTimer");
static_assert(offsetof(FM1CoolTimer, CoolTimeContext) == 0x000000, "Member 'FM1CoolTimer::CoolTimeContext' has a wrong offset!");
static_assert(offsetof(FM1CoolTimer, bActivated) == 0x000008, "Member 'FM1CoolTimer::bActivated' has a wrong offset!");
static_assert(offsetof(FM1CoolTimer, CoolTimeDuration) == 0x00000C, "Member 'FM1CoolTimer::CoolTimeDuration' has a wrong offset!");
static_assert(offsetof(FM1CoolTimer, RemainingCoolTime) == 0x000010, "Member 'FM1CoolTimer::RemainingCoolTime' has a wrong offset!");

// ScriptStruct M1.M1CustomizablePlayerEvolutionInfo
// 0x000C (0x000C - 0x0000)
struct FM1CustomizablePlayerEvolutionInfo final
{
public:
	int32                                         HeadSkinEvolutionIndex;                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BodySkinEvolutionIndex;                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponSkinEvolutionIndex;                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizablePlayerEvolutionInfo) == 0x000004, "Wrong alignment on FM1CustomizablePlayerEvolutionInfo");
static_assert(sizeof(FM1CustomizablePlayerEvolutionInfo) == 0x00000C, "Wrong size on FM1CustomizablePlayerEvolutionInfo");
static_assert(offsetof(FM1CustomizablePlayerEvolutionInfo, HeadSkinEvolutionIndex) == 0x000000, "Member 'FM1CustomizablePlayerEvolutionInfo::HeadSkinEvolutionIndex' has a wrong offset!");
static_assert(offsetof(FM1CustomizablePlayerEvolutionInfo, BodySkinEvolutionIndex) == 0x000004, "Member 'FM1CustomizablePlayerEvolutionInfo::BodySkinEvolutionIndex' has a wrong offset!");
static_assert(offsetof(FM1CustomizablePlayerEvolutionInfo, WeaponSkinEvolutionIndex) == 0x000008, "Member 'FM1CustomizablePlayerEvolutionInfo::WeaponSkinEvolutionIndex' has a wrong offset!");

// ScriptStruct M1.M1BattleZoneRotationDropItemInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FM1BattleZoneRotationDropItemInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1BattleZoneRotationDropItemInfo) == 0x000008, "Wrong alignment on FM1BattleZoneRotationDropItemInfo");
static_assert(sizeof(FM1BattleZoneRotationDropItemInfo) == 0x000010, "Wrong size on FM1BattleZoneRotationDropItemInfo");

// ScriptStruct M1.M1CustomizablePlayerCustomizingInfo
// 0x003C (0x003C - 0x0000)
struct FM1CustomizablePlayerCustomizingInfo final
{
public:
	class FName                                   HeadSkinId;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FaceSkinId;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodySkinId;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChestAttachmentId;                                 // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BackAttachmentId;                                  // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponSkinId;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1CustomizablePlayerEvolutionInfo     EvolutionInfo;                                     // 0x0030(0x000C)(Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizablePlayerCustomizingInfo) == 0x000004, "Wrong alignment on FM1CustomizablePlayerCustomizingInfo");
static_assert(sizeof(FM1CustomizablePlayerCustomizingInfo) == 0x00003C, "Wrong size on FM1CustomizablePlayerCustomizingInfo");
static_assert(offsetof(FM1CustomizablePlayerCustomizingInfo, HeadSkinId) == 0x000000, "Member 'FM1CustomizablePlayerCustomizingInfo::HeadSkinId' has a wrong offset!");
static_assert(offsetof(FM1CustomizablePlayerCustomizingInfo, FaceSkinId) == 0x000008, "Member 'FM1CustomizablePlayerCustomizingInfo::FaceSkinId' has a wrong offset!");
static_assert(offsetof(FM1CustomizablePlayerCustomizingInfo, BodySkinId) == 0x000010, "Member 'FM1CustomizablePlayerCustomizingInfo::BodySkinId' has a wrong offset!");
static_assert(offsetof(FM1CustomizablePlayerCustomizingInfo, ChestAttachmentId) == 0x000018, "Member 'FM1CustomizablePlayerCustomizingInfo::ChestAttachmentId' has a wrong offset!");
static_assert(offsetof(FM1CustomizablePlayerCustomizingInfo, BackAttachmentId) == 0x000020, "Member 'FM1CustomizablePlayerCustomizingInfo::BackAttachmentId' has a wrong offset!");
static_assert(offsetof(FM1CustomizablePlayerCustomizingInfo, WeaponSkinId) == 0x000028, "Member 'FM1CustomizablePlayerCustomizingInfo::WeaponSkinId' has a wrong offset!");
static_assert(offsetof(FM1CustomizablePlayerCustomizingInfo, EvolutionInfo) == 0x000030, "Member 'FM1CustomizablePlayerCustomizingInfo::EvolutionInfo' has a wrong offset!");

// ScriptStruct M1.M1CustomizeItemWidgetSize
// 0x0018 (0x0018 - 0x0000)
struct FM1CustomizeItemWidgetSize final
{
public:
	struct FVector2D                              EntryWidgetSize;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemIconType                               EntryIconType;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SlotSize;                                          // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemIconType                               SlotIconType;                                      // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CustomizeItemWidgetSize) == 0x000004, "Wrong alignment on FM1CustomizeItemWidgetSize");
static_assert(sizeof(FM1CustomizeItemWidgetSize) == 0x000018, "Wrong size on FM1CustomizeItemWidgetSize");
static_assert(offsetof(FM1CustomizeItemWidgetSize, EntryWidgetSize) == 0x000000, "Member 'FM1CustomizeItemWidgetSize::EntryWidgetSize' has a wrong offset!");
static_assert(offsetof(FM1CustomizeItemWidgetSize, EntryIconType) == 0x000008, "Member 'FM1CustomizeItemWidgetSize::EntryIconType' has a wrong offset!");
static_assert(offsetof(FM1CustomizeItemWidgetSize, SlotSize) == 0x00000C, "Member 'FM1CustomizeItemWidgetSize::SlotSize' has a wrong offset!");
static_assert(offsetof(FM1CustomizeItemWidgetSize, SlotIconType) == 0x000014, "Member 'FM1CustomizeItemWidgetSize::SlotIconType' has a wrong offset!");

// ScriptStruct M1.M1RecordCategoryData
// 0x0048 (0x0050 - 0x0008)
struct FM1RecordCategoryData final : public FTableRowBase
{
public:
	int32                                         CategoryId;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringId;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0020(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         RecordList;                                        // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RecordCategoryData) == 0x000008, "Wrong alignment on FM1RecordCategoryData");
static_assert(sizeof(FM1RecordCategoryData) == 0x000050, "Wrong size on FM1RecordCategoryData");
static_assert(offsetof(FM1RecordCategoryData, CategoryId) == 0x000008, "Member 'FM1RecordCategoryData::CategoryId' has a wrong offset!");
static_assert(offsetof(FM1RecordCategoryData, StringId) == 0x000010, "Member 'FM1RecordCategoryData::StringId' has a wrong offset!");
static_assert(offsetof(FM1RecordCategoryData, IconPath) == 0x000020, "Member 'FM1RecordCategoryData::IconPath' has a wrong offset!");
static_assert(offsetof(FM1RecordCategoryData, RecordList) == 0x000040, "Member 'FM1RecordCategoryData::RecordList' has a wrong offset!");

// ScriptStruct M1.M1CustomizeSkinPaintsInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1CustomizeSkinPaintsInfo final
{
public:
	struct FM1TemplateId                          SkinTid;                                           // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1PaintData>                   Paints;                                            // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizeSkinPaintsInfo) == 0x000008, "Wrong alignment on FM1CustomizeSkinPaintsInfo");
static_assert(sizeof(FM1CustomizeSkinPaintsInfo) == 0x000018, "Wrong size on FM1CustomizeSkinPaintsInfo");
static_assert(offsetof(FM1CustomizeSkinPaintsInfo, SkinTid) == 0x000000, "Member 'FM1CustomizeSkinPaintsInfo::SkinTid' has a wrong offset!");
static_assert(offsetof(FM1CustomizeSkinPaintsInfo, Paints) == 0x000008, "Member 'FM1CustomizeSkinPaintsInfo::Paints' has a wrong offset!");

// ScriptStruct M1.M1CustomizingAttachmentOffset
// 0x0020 (0x0020 - 0x0000)
struct FM1CustomizingAttachmentOffset final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0010(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizingAttachmentOffset) == 0x000010, "Wrong alignment on FM1CustomizingAttachmentOffset");
static_assert(sizeof(FM1CustomizingAttachmentOffset) == 0x000020, "Wrong size on FM1CustomizingAttachmentOffset");
static_assert(offsetof(FM1CustomizingAttachmentOffset, Location) == 0x000000, "Member 'FM1CustomizingAttachmentOffset::Location' has a wrong offset!");
static_assert(offsetof(FM1CustomizingAttachmentOffset, Rotation) == 0x000010, "Member 'FM1CustomizingAttachmentOffset::Rotation' has a wrong offset!");

// ScriptStruct M1.M1SocialMotionSetting
// 0x0004 (0x0004 - 0x0000)
struct FM1SocialMotionSetting final
{
public:
	float                                         GroupSocialMotionCancelDistance;                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SocialMotionSetting) == 0x000004, "Wrong alignment on FM1SocialMotionSetting");
static_assert(sizeof(FM1SocialMotionSetting) == 0x000004, "Wrong size on FM1SocialMotionSetting");
static_assert(offsetof(FM1SocialMotionSetting, GroupSocialMotionCancelDistance) == 0x000000, "Member 'FM1SocialMotionSetting::GroupSocialMotionCancelDistance' has a wrong offset!");

// ScriptStruct M1.M1CustomizingSkinMaterialSlotInfo
// 0x0040 (0x0040 - 0x0000)
struct FM1CustomizingSkinMaterialSlotInfo final
{
public:
	TSoftObjectPtr<class UMaterialInterface>      MaterialAsset;                                     // 0x0000(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 MaterialSlotIdxList;                               // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizingSkinMaterialSlotInfo) == 0x000008, "Wrong alignment on FM1CustomizingSkinMaterialSlotInfo");
static_assert(sizeof(FM1CustomizingSkinMaterialSlotInfo) == 0x000040, "Wrong size on FM1CustomizingSkinMaterialSlotInfo");
static_assert(offsetof(FM1CustomizingSkinMaterialSlotInfo, MaterialAsset) == 0x000000, "Member 'FM1CustomizingSkinMaterialSlotInfo::MaterialAsset' has a wrong offset!");
static_assert(offsetof(FM1CustomizingSkinMaterialSlotInfo, MaterialSlotIdxList) == 0x000030, "Member 'FM1CustomizingSkinMaterialSlotInfo::MaterialSlotIdxList' has a wrong offset!");

// ScriptStruct M1.M1EciveSkinEffectSlotInfo
// 0x0060 (0x0060 - 0x0000)
struct FM1EciveSkinEffectSlotInfo final
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          FX;                                                // 0x0000(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0030(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EciveSkinEffectSlotInfo) == 0x000010, "Wrong alignment on FM1EciveSkinEffectSlotInfo");
static_assert(sizeof(FM1EciveSkinEffectSlotInfo) == 0x000060, "Wrong size on FM1EciveSkinEffectSlotInfo");
static_assert(offsetof(FM1EciveSkinEffectSlotInfo, FX) == 0x000000, "Member 'FM1EciveSkinEffectSlotInfo::FX' has a wrong offset!");
static_assert(offsetof(FM1EciveSkinEffectSlotInfo, Transform) == 0x000030, "Member 'FM1EciveSkinEffectSlotInfo::Transform' has a wrong offset!");

// ScriptStruct M1.M1EciveEffectInfo
// 0x01B0 (0x01B0 - 0x0000)
struct FM1EciveEffectInfo final
{
public:
	struct FM1EciveSkinEffectSlotInfo             EciveActiveFX;                                     // 0x0000(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FM1EciveSkinEffectSlotInfo             EciveLoopFX;                                       // 0x0060(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FM1EciveSkinEffectSlotInfo             EciveLineFX;                                       // 0x00C0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UM1DataPostProcessMaterialEffect> EciveScanLinePPM;                                  // 0x0120(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UM1DataPostProcessMaterialEffect> EciveScanEffectPPM;                                // 0x0150(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ActivatedAkEvent;                                  // 0x0180(0x0020)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EciveEffectDuration;                               // 0x01A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEciveActiveFXAttachAbsoluteRotation;              // 0x01A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A5[0x3];                                      // 0x01A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EciveAttachBoneName;                               // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EciveEffectInfo) == 0x000010, "Wrong alignment on FM1EciveEffectInfo");
static_assert(sizeof(FM1EciveEffectInfo) == 0x0001B0, "Wrong size on FM1EciveEffectInfo");
static_assert(offsetof(FM1EciveEffectInfo, EciveActiveFX) == 0x000000, "Member 'FM1EciveEffectInfo::EciveActiveFX' has a wrong offset!");
static_assert(offsetof(FM1EciveEffectInfo, EciveLoopFX) == 0x000060, "Member 'FM1EciveEffectInfo::EciveLoopFX' has a wrong offset!");
static_assert(offsetof(FM1EciveEffectInfo, EciveLineFX) == 0x0000C0, "Member 'FM1EciveEffectInfo::EciveLineFX' has a wrong offset!");
static_assert(offsetof(FM1EciveEffectInfo, EciveScanLinePPM) == 0x000120, "Member 'FM1EciveEffectInfo::EciveScanLinePPM' has a wrong offset!");
static_assert(offsetof(FM1EciveEffectInfo, EciveScanEffectPPM) == 0x000150, "Member 'FM1EciveEffectInfo::EciveScanEffectPPM' has a wrong offset!");
static_assert(offsetof(FM1EciveEffectInfo, ActivatedAkEvent) == 0x000180, "Member 'FM1EciveEffectInfo::ActivatedAkEvent' has a wrong offset!");
static_assert(offsetof(FM1EciveEffectInfo, EciveEffectDuration) == 0x0001A0, "Member 'FM1EciveEffectInfo::EciveEffectDuration' has a wrong offset!");
static_assert(offsetof(FM1EciveEffectInfo, bEciveActiveFXAttachAbsoluteRotation) == 0x0001A4, "Member 'FM1EciveEffectInfo::bEciveActiveFXAttachAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(FM1EciveEffectInfo, EciveAttachBoneName) == 0x0001A8, "Member 'FM1EciveEffectInfo::EciveAttachBoneName' has a wrong offset!");

// ScriptStruct M1.M1TeleportCameraDelaySetting
// 0x0014 (0x0014 - 0x0000)
struct FM1TeleportCameraDelaySetting final
{
public:
	struct FVector                                CameraOffset;                                      // 0x0000(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowDelay;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowSpeed;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TeleportCameraDelaySetting) == 0x000004, "Wrong alignment on FM1TeleportCameraDelaySetting");
static_assert(sizeof(FM1TeleportCameraDelaySetting) == 0x000014, "Wrong size on FM1TeleportCameraDelaySetting");
static_assert(offsetof(FM1TeleportCameraDelaySetting, CameraOffset) == 0x000000, "Member 'FM1TeleportCameraDelaySetting::CameraOffset' has a wrong offset!");
static_assert(offsetof(FM1TeleportCameraDelaySetting, FollowDelay) == 0x00000C, "Member 'FM1TeleportCameraDelaySetting::FollowDelay' has a wrong offset!");
static_assert(offsetof(FM1TeleportCameraDelaySetting, FollowSpeed) == 0x000010, "Member 'FM1TeleportCameraDelaySetting::FollowSpeed' has a wrong offset!");

// ScriptStruct M1.M1BaseMissionTargetInfoUI
// 0x0038 (0x0038 - 0x0000)
struct FM1BaseMissionTargetInfoUI final
{
public:
	class FString                                 TargetStringId;                                    // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MarkerString;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1BaseMissionProgressState                   State;                                             // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProgressRatio;                                     // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetProgressStateStringId;                       // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BaseMissionTargetInfoUI) == 0x000008, "Wrong alignment on FM1BaseMissionTargetInfoUI");
static_assert(sizeof(FM1BaseMissionTargetInfoUI) == 0x000038, "Wrong size on FM1BaseMissionTargetInfoUI");
static_assert(offsetof(FM1BaseMissionTargetInfoUI, TargetStringId) == 0x000000, "Member 'FM1BaseMissionTargetInfoUI::TargetStringId' has a wrong offset!");
static_assert(offsetof(FM1BaseMissionTargetInfoUI, MarkerString) == 0x000010, "Member 'FM1BaseMissionTargetInfoUI::MarkerString' has a wrong offset!");
static_assert(offsetof(FM1BaseMissionTargetInfoUI, State) == 0x000020, "Member 'FM1BaseMissionTargetInfoUI::State' has a wrong offset!");
static_assert(offsetof(FM1BaseMissionTargetInfoUI, ProgressRatio) == 0x000024, "Member 'FM1BaseMissionTargetInfoUI::ProgressRatio' has a wrong offset!");
static_assert(offsetof(FM1BaseMissionTargetInfoUI, TargetProgressStateStringId) == 0x000028, "Member 'FM1BaseMissionTargetInfoUI::TargetProgressStateStringId' has a wrong offset!");

// ScriptStruct M1.M1TeleportCameraDelaySettingSet
// 0x0028 (0x0028 - 0x0000)
struct FM1TeleportCameraDelaySettingSet final
{
public:
	struct FM1TeleportCameraDelaySetting          StartCameraSetting;                                // 0x0000(0x0014)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1TeleportCameraDelaySetting          EndCameraSetting;                                  // 0x0014(0x0014)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TeleportCameraDelaySettingSet) == 0x000004, "Wrong alignment on FM1TeleportCameraDelaySettingSet");
static_assert(sizeof(FM1TeleportCameraDelaySettingSet) == 0x000028, "Wrong size on FM1TeleportCameraDelaySettingSet");
static_assert(offsetof(FM1TeleportCameraDelaySettingSet, StartCameraSetting) == 0x000000, "Member 'FM1TeleportCameraDelaySettingSet::StartCameraSetting' has a wrong offset!");
static_assert(offsetof(FM1TeleportCameraDelaySettingSet, EndCameraSetting) == 0x000014, "Member 'FM1TeleportCameraDelaySettingSet::EndCameraSetting' has a wrong offset!");

// ScriptStruct M1.M1DamagedEffectSet
// 0x0010 (0x0010 - 0x0000)
struct FM1DamagedEffectSet final
{
public:
	TArray<class UM1DataPostProcessMaterialEffect*> DamagedEffectPPMs;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DamagedEffectSet) == 0x000008, "Wrong alignment on FM1DamagedEffectSet");
static_assert(sizeof(FM1DamagedEffectSet) == 0x000010, "Wrong size on FM1DamagedEffectSet");
static_assert(offsetof(FM1DamagedEffectSet, DamagedEffectPPMs) == 0x000000, "Member 'FM1DamagedEffectSet::DamagedEffectPPMs' has a wrong offset!");

// ScriptStruct M1.M1FixedDamageEvent
// 0x0008 (0x0018 - 0x0010)
struct FM1FixedDamageEvent final : public FDamageEvent
{
public:
	float                                         FixedDamage;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1FixedDamageEvent) == 0x000008, "Wrong alignment on FM1FixedDamageEvent");
static_assert(sizeof(FM1FixedDamageEvent) == 0x000018, "Wrong size on FM1FixedDamageEvent");
static_assert(offsetof(FM1FixedDamageEvent, FixedDamage) == 0x000010, "Member 'FM1FixedDamageEvent::FixedDamage' has a wrong offset!");

// ScriptStruct M1.M1ExplosionDamageEvent
// 0x0008 (0x0048 - 0x0040)
struct FM1ExplosionDamageEvent final : public FRadialDamageEvent
{
public:
	float                                         ImpulseMagnitude;                                  // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ExplosionDamageEvent) == 0x000008, "Wrong alignment on FM1ExplosionDamageEvent");
static_assert(sizeof(FM1ExplosionDamageEvent) == 0x000048, "Wrong size on FM1ExplosionDamageEvent");
static_assert(offsetof(FM1ExplosionDamageEvent, ImpulseMagnitude) == 0x000040, "Member 'FM1ExplosionDamageEvent::ImpulseMagnitude' has a wrong offset!");

// ScriptStruct M1.M1SystemKeySet
// 0x0028 (0x0028 - 0x0000)
struct FM1SystemKeySet final
{
public:
	EM1SystemKey                                  GameKey;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInputChord                            Chord;                                             // 0x0008(0x0020)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SystemKeySet) == 0x000008, "Wrong alignment on FM1SystemKeySet");
static_assert(sizeof(FM1SystemKeySet) == 0x000028, "Wrong size on FM1SystemKeySet");
static_assert(offsetof(FM1SystemKeySet, GameKey) == 0x000000, "Member 'FM1SystemKeySet::GameKey' has a wrong offset!");
static_assert(offsetof(FM1SystemKeySet, Chord) == 0x000008, "Member 'FM1SystemKeySet::Chord' has a wrong offset!");

// ScriptStruct M1.M1MeleeDamageEvent
// 0x0008 (0x0018 - 0x0010)
struct FM1MeleeDamageEvent final : public FDamageEvent
{
public:
	class FName                                   BoneName;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MeleeDamageEvent) == 0x000008, "Wrong alignment on FM1MeleeDamageEvent");
static_assert(sizeof(FM1MeleeDamageEvent) == 0x000018, "Wrong size on FM1MeleeDamageEvent");
static_assert(offsetof(FM1MeleeDamageEvent, BoneName) == 0x000010, "Member 'FM1MeleeDamageEvent::BoneName' has a wrong offset!");

// ScriptStruct M1.M1UIEvent_StartedReload
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FM1UIEvent_StartedReload final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_StartedReload) == 0x000004, "Wrong alignment on FM1UIEvent_StartedReload");
static_assert(sizeof(FM1UIEvent_StartedReload) == 0x000010, "Wrong size on FM1UIEvent_StartedReload");

// ScriptStruct M1.M1MonsterSelector
// 0x0008 (0x0008 - 0x0000)
struct FM1MonsterSelector final
{
public:
	int64                                         MonsterId;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterSelector) == 0x000008, "Wrong alignment on FM1MonsterSelector");
static_assert(sizeof(FM1MonsterSelector) == 0x000008, "Wrong size on FM1MonsterSelector");
static_assert(offsetof(FM1MonsterSelector, MonsterId) == 0x000000, "Member 'FM1MonsterSelector::MonsterId' has a wrong offset!");

// ScriptStruct M1.M1VoidBattleCompleteResultInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1VoidBattleCompleteResultInfo final
{
public:
	struct FM1TemplateId                          VoidBattleTemplateId;                              // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Success;                                           // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1VoidBattleCompleteResult            Result;                                            // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1VoidBattleCompleteResultInfo) == 0x000004, "Wrong alignment on FM1VoidBattleCompleteResultInfo");
static_assert(sizeof(FM1VoidBattleCompleteResultInfo) == 0x000010, "Wrong size on FM1VoidBattleCompleteResultInfo");
static_assert(offsetof(FM1VoidBattleCompleteResultInfo, VoidBattleTemplateId) == 0x000000, "Member 'FM1VoidBattleCompleteResultInfo::VoidBattleTemplateId' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleCompleteResultInfo, Success) == 0x000004, "Member 'FM1VoidBattleCompleteResultInfo::Success' has a wrong offset!");
static_assert(offsetof(FM1VoidBattleCompleteResultInfo, Result) == 0x000008, "Member 'FM1VoidBattleCompleteResultInfo::Result' has a wrong offset!");

// ScriptStruct M1.M1MonsterSpawnData
// 0x0020 (0x0020 - 0x0000)
struct FM1MonsterSpawnData final
{
public:
	float                                         SpawnInterval;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSpawnNum;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBoss;                                            // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1MonsterSelector                     SpawnMonster;                                      // 0x0010(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         SpawnMonsterLevel;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsActivityOn;                                      // 0x001C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MonsterSpawnData) == 0x000008, "Wrong alignment on FM1MonsterSpawnData");
static_assert(sizeof(FM1MonsterSpawnData) == 0x000020, "Wrong size on FM1MonsterSpawnData");
static_assert(offsetof(FM1MonsterSpawnData, SpawnInterval) == 0x000000, "Member 'FM1MonsterSpawnData::SpawnInterval' has a wrong offset!");
static_assert(offsetof(FM1MonsterSpawnData, MaxSpawnNum) == 0x000004, "Member 'FM1MonsterSpawnData::MaxSpawnNum' has a wrong offset!");
static_assert(offsetof(FM1MonsterSpawnData, IsBoss) == 0x000008, "Member 'FM1MonsterSpawnData::IsBoss' has a wrong offset!");
static_assert(offsetof(FM1MonsterSpawnData, SpawnMonster) == 0x000010, "Member 'FM1MonsterSpawnData::SpawnMonster' has a wrong offset!");
static_assert(offsetof(FM1MonsterSpawnData, SpawnMonsterLevel) == 0x000018, "Member 'FM1MonsterSpawnData::SpawnMonsterLevel' has a wrong offset!");
static_assert(offsetof(FM1MonsterSpawnData, IsActivityOn) == 0x00001C, "Member 'FM1MonsterSpawnData::IsActivityOn' has a wrong offset!");

// ScriptStruct M1.M1GenderBasedPrivatePreviewAnim
// 0x0010 (0x0010 - 0x0000)
struct FM1GenderBasedPrivatePreviewAnim final
{
public:
	class UAnimSequence*                          Male;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Female;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GenderBasedPrivatePreviewAnim) == 0x000008, "Wrong alignment on FM1GenderBasedPrivatePreviewAnim");
static_assert(sizeof(FM1GenderBasedPrivatePreviewAnim) == 0x000010, "Wrong size on FM1GenderBasedPrivatePreviewAnim");
static_assert(offsetof(FM1GenderBasedPrivatePreviewAnim, Male) == 0x000000, "Member 'FM1GenderBasedPrivatePreviewAnim::Male' has a wrong offset!");
static_assert(offsetof(FM1GenderBasedPrivatePreviewAnim, Female) == 0x000008, "Member 'FM1GenderBasedPrivatePreviewAnim::Female' has a wrong offset!");

// ScriptStruct M1.M1HitEffects
// 0x0010 (0x0010 - 0x0000)
struct FM1HitEffects final
{
public:
	TArray<TSoftObjectPtr<class UNiagaraSystem>>  Effects;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1HitEffects) == 0x000008, "Wrong alignment on FM1HitEffects");
static_assert(sizeof(FM1HitEffects) == 0x000010, "Wrong size on FM1HitEffects");
static_assert(offsetof(FM1HitEffects, Effects) == 0x000000, "Member 'FM1HitEffects::Effects' has a wrong offset!");

// ScriptStruct M1.M1InventoryCharacterAnimSequences
// 0x0040 (0x0040 - 0x0000)
struct FM1InventoryCharacterAnimSequences final
{
public:
	TSoftObjectPtr<class UAnimSequence>           IdleAnimSequence;                                  // 0x0000(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UAnimSequence>>   RandomAnimSequences;                               // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InventoryCharacterAnimSequences) == 0x000008, "Wrong alignment on FM1InventoryCharacterAnimSequences");
static_assert(sizeof(FM1InventoryCharacterAnimSequences) == 0x000040, "Wrong size on FM1InventoryCharacterAnimSequences");
static_assert(offsetof(FM1InventoryCharacterAnimSequences, IdleAnimSequence) == 0x000000, "Member 'FM1InventoryCharacterAnimSequences::IdleAnimSequence' has a wrong offset!");
static_assert(offsetof(FM1InventoryCharacterAnimSequences, RandomAnimSequences) == 0x000030, "Member 'FM1InventoryCharacterAnimSequences::RandomAnimSequences' has a wrong offset!");

// ScriptStruct M1.M1AnimSequencesPerPlayerAnimType
// 0x0050 (0x0050 - 0x0000)
struct FM1AnimSequencesPerPlayerAnimType final
{
public:
	TMap<EM1PlayerAnimType, struct FM1InventoryCharacterAnimSequences> AnimSequencesPerPlayerAnimType;                    // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AnimSequencesPerPlayerAnimType) == 0x000008, "Wrong alignment on FM1AnimSequencesPerPlayerAnimType");
static_assert(sizeof(FM1AnimSequencesPerPlayerAnimType) == 0x000050, "Wrong size on FM1AnimSequencesPerPlayerAnimType");
static_assert(offsetof(FM1AnimSequencesPerPlayerAnimType, AnimSequencesPerPlayerAnimType) == 0x000000, "Member 'FM1AnimSequencesPerPlayerAnimType::AnimSequencesPerPlayerAnimType' has a wrong offset!");

// ScriptStruct M1.M1MapObjectDetail
// 0x0018 (0x0018 - 0x0000)
struct FM1MapObjectDetail final
{
public:
	class FString                                 DebugName;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UM1MapObjectInfo*                       MapObject;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MapObjectDetail) == 0x000008, "Wrong alignment on FM1MapObjectDetail");
static_assert(sizeof(FM1MapObjectDetail) == 0x000018, "Wrong size on FM1MapObjectDetail");
static_assert(offsetof(FM1MapObjectDetail, DebugName) == 0x000000, "Member 'FM1MapObjectDetail::DebugName' has a wrong offset!");
static_assert(offsetof(FM1MapObjectDetail, MapObject) == 0x000010, "Member 'FM1MapObjectDetail::MapObject' has a wrong offset!");

// ScriptStruct M1.M1MapObjectList
// 0x0010 (0x0010 - 0x0000)
struct FM1MapObjectList final
{
public:
	TArray<struct FM1MapObjectDetail>             ObjectList;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MapObjectList) == 0x000008, "Wrong alignment on FM1MapObjectList");
static_assert(sizeof(FM1MapObjectList) == 0x000010, "Wrong size on FM1MapObjectList");
static_assert(offsetof(FM1MapObjectList, ObjectList) == 0x000000, "Member 'FM1MapObjectList::ObjectList' has a wrong offset!");

// ScriptStruct M1.M1MissionTaskLink
// 0x0020 (0x0020 - 0x0000)
struct FM1MissionTaskLink final
{
public:
	class FName                                   TaskName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LinkIndex;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AM1MissionTaskActor*                    InstancedTaskActor;                                // 0x0010(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AM1MissionTaskActor>        TaskActorClass;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionTaskLink) == 0x000008, "Wrong alignment on FM1MissionTaskLink");
static_assert(sizeof(FM1MissionTaskLink) == 0x000020, "Wrong size on FM1MissionTaskLink");
static_assert(offsetof(FM1MissionTaskLink, TaskName) == 0x000000, "Member 'FM1MissionTaskLink::TaskName' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskLink, LinkIndex) == 0x000008, "Member 'FM1MissionTaskLink::LinkIndex' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskLink, InstancedTaskActor) == 0x000010, "Member 'FM1MissionTaskLink::InstancedTaskActor' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskLink, TaskActorClass) == 0x000018, "Member 'FM1MissionTaskLink::TaskActorClass' has a wrong offset!");

// ScriptStruct M1.M1MissionRelatedObjectInfo
// 0x0028 (0x0028 - 0x0000)
struct FM1MissionRelatedObjectInfo final
{
public:
	struct FSoftObjectPath                        SoftObjectPath;                                    // 0x0000(0x0020)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ApperanceCount;                                    // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MissionRelatedObjectInfo) == 0x000008, "Wrong alignment on FM1MissionRelatedObjectInfo");
static_assert(sizeof(FM1MissionRelatedObjectInfo) == 0x000028, "Wrong size on FM1MissionRelatedObjectInfo");
static_assert(offsetof(FM1MissionRelatedObjectInfo, SoftObjectPath) == 0x000000, "Member 'FM1MissionRelatedObjectInfo::SoftObjectPath' has a wrong offset!");
static_assert(offsetof(FM1MissionRelatedObjectInfo, ApperanceCount) == 0x000020, "Member 'FM1MissionRelatedObjectInfo::ApperanceCount' has a wrong offset!");

// ScriptStruct M1.M1GenderBasedReloadMontage
// 0x0010 (0x0010 - 0x0000)
struct FM1GenderBasedReloadMontage final
{
public:
	class UAnimMontage*                           MaleReloadAnim;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FemaleReloadAnim;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GenderBasedReloadMontage) == 0x000008, "Wrong alignment on FM1GenderBasedReloadMontage");
static_assert(sizeof(FM1GenderBasedReloadMontage) == 0x000010, "Wrong size on FM1GenderBasedReloadMontage");
static_assert(offsetof(FM1GenderBasedReloadMontage, MaleReloadAnim) == 0x000000, "Member 'FM1GenderBasedReloadMontage::MaleReloadAnim' has a wrong offset!");
static_assert(offsetof(FM1GenderBasedReloadMontage, FemaleReloadAnim) == 0x000008, "Member 'FM1GenderBasedReloadMontage::FemaleReloadAnim' has a wrong offset!");

// ScriptStruct M1.M1RequestVoidBattleComplete
// 0x000C (0x000C - 0x0000)
struct FM1RequestVoidBattleComplete final
{
public:
	struct FM1TemplateId                          MapId;                                             // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MapTypeDataId;                                     // 0x0004(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Success;                                           // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RequestVoidBattleComplete) == 0x000004, "Wrong alignment on FM1RequestVoidBattleComplete");
static_assert(sizeof(FM1RequestVoidBattleComplete) == 0x00000C, "Wrong size on FM1RequestVoidBattleComplete");
static_assert(offsetof(FM1RequestVoidBattleComplete, MapId) == 0x000000, "Member 'FM1RequestVoidBattleComplete::MapId' has a wrong offset!");
static_assert(offsetof(FM1RequestVoidBattleComplete, MapTypeDataId) == 0x000004, "Member 'FM1RequestVoidBattleComplete::MapTypeDataId' has a wrong offset!");
static_assert(offsetof(FM1RequestVoidBattleComplete, Success) == 0x000008, "Member 'FM1RequestVoidBattleComplete::Success' has a wrong offset!");

// ScriptStruct M1.M1MissionRetriableBoundary
// 0x0010 (0x0010 - 0x0000)
struct FM1MissionRetriableBoundary final
{
public:
	int32                                         From;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         To;                                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RetriableCount;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionRetriableBoundary) == 0x000004, "Wrong alignment on FM1MissionRetriableBoundary");
static_assert(sizeof(FM1MissionRetriableBoundary) == 0x000010, "Wrong size on FM1MissionRetriableBoundary");
static_assert(offsetof(FM1MissionRetriableBoundary, From) == 0x000000, "Member 'FM1MissionRetriableBoundary::From' has a wrong offset!");
static_assert(offsetof(FM1MissionRetriableBoundary, To) == 0x000004, "Member 'FM1MissionRetriableBoundary::To' has a wrong offset!");
static_assert(offsetof(FM1MissionRetriableBoundary, RetriableCount) == 0x000008, "Member 'FM1MissionRetriableBoundary::RetriableCount' has a wrong offset!");
static_assert(offsetof(FM1MissionRetriableBoundary, Index) == 0x00000C, "Member 'FM1MissionRetriableBoundary::Index' has a wrong offset!");

// ScriptStruct M1.M1RequestFieldObjectDropItemInfo
// 0x0050 (0x0050 - 0x0000)
struct FM1RequestFieldObjectDropItemInfo final
{
public:
	TArray<int64>                                 AccountIDs;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FVector                                DropLocation;                                      // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBox                                   FieldObjectBounds;                                 // 0x001C(0x001C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FM1TemplateId                          FieldObjectTid;                                    // 0x0038(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         FieldObjectUid;                                    // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 FieldObjectDropped;                                // 0x0048(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1RequestFieldObjectDropItemInfo) == 0x000008, "Wrong alignment on FM1RequestFieldObjectDropItemInfo");
static_assert(sizeof(FM1RequestFieldObjectDropItemInfo) == 0x000050, "Wrong size on FM1RequestFieldObjectDropItemInfo");
static_assert(offsetof(FM1RequestFieldObjectDropItemInfo, AccountIDs) == 0x000000, "Member 'FM1RequestFieldObjectDropItemInfo::AccountIDs' has a wrong offset!");
static_assert(offsetof(FM1RequestFieldObjectDropItemInfo, DropLocation) == 0x000010, "Member 'FM1RequestFieldObjectDropItemInfo::DropLocation' has a wrong offset!");
static_assert(offsetof(FM1RequestFieldObjectDropItemInfo, FieldObjectBounds) == 0x00001C, "Member 'FM1RequestFieldObjectDropItemInfo::FieldObjectBounds' has a wrong offset!");
static_assert(offsetof(FM1RequestFieldObjectDropItemInfo, FieldObjectTid) == 0x000038, "Member 'FM1RequestFieldObjectDropItemInfo::FieldObjectTid' has a wrong offset!");
static_assert(offsetof(FM1RequestFieldObjectDropItemInfo, FieldObjectUid) == 0x000040, "Member 'FM1RequestFieldObjectDropItemInfo::FieldObjectUid' has a wrong offset!");
static_assert(offsetof(FM1RequestFieldObjectDropItemInfo, FieldObjectDropped) == 0x000048, "Member 'FM1RequestFieldObjectDropItemInfo::FieldObjectDropped' has a wrong offset!");

// ScriptStruct M1.M1ExtractedMissionInfoTableRow
// 0x0020 (0x0028 - 0x0008)
struct FM1ExtractedMissionInfoTableRow final : public FTableRowBase
{
public:
	class FName                                   TaskName;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventName;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MonsterOrGroupName;                                // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpectedSpawnCount;                                // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ExtractedMissionInfoTableRow) == 0x000008, "Wrong alignment on FM1ExtractedMissionInfoTableRow");
static_assert(sizeof(FM1ExtractedMissionInfoTableRow) == 0x000028, "Wrong size on FM1ExtractedMissionInfoTableRow");
static_assert(offsetof(FM1ExtractedMissionInfoTableRow, TaskName) == 0x000008, "Member 'FM1ExtractedMissionInfoTableRow::TaskName' has a wrong offset!");
static_assert(offsetof(FM1ExtractedMissionInfoTableRow, EventName) == 0x000010, "Member 'FM1ExtractedMissionInfoTableRow::EventName' has a wrong offset!");
static_assert(offsetof(FM1ExtractedMissionInfoTableRow, MonsterOrGroupName) == 0x000018, "Member 'FM1ExtractedMissionInfoTableRow::MonsterOrGroupName' has a wrong offset!");
static_assert(offsetof(FM1ExtractedMissionInfoTableRow, ExpectedSpawnCount) == 0x000020, "Member 'FM1ExtractedMissionInfoTableRow::ExpectedSpawnCount' has a wrong offset!");

// ScriptStruct M1.M1DialogueFacialAnim
// 0x0058 (0x0058 - 0x0000)
struct FM1DialogueFacialAnim final
{
public:
	class FName                                   DialogDataRowName;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EM1Locale, TSoftObjectPtr<class UAnimSequence>> FacialAnimSequencePerLocale;                       // 0x0008(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DialogueFacialAnim) == 0x000008, "Wrong alignment on FM1DialogueFacialAnim");
static_assert(sizeof(FM1DialogueFacialAnim) == 0x000058, "Wrong size on FM1DialogueFacialAnim");
static_assert(offsetof(FM1DialogueFacialAnim, DialogDataRowName) == 0x000000, "Member 'FM1DialogueFacialAnim::DialogDataRowName' has a wrong offset!");
static_assert(offsetof(FM1DialogueFacialAnim, FacialAnimSequencePerLocale) == 0x000008, "Member 'FM1DialogueFacialAnim::FacialAnimSequencePerLocale' has a wrong offset!");

// ScriptStruct M1.M1InteractionFacialAnim
// 0x0058 (0x0058 - 0x0000)
struct FM1InteractionFacialAnim final
{
public:
	class FName                                   StringStoryRowName;                                // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EM1Locale, TSoftObjectPtr<class UAnimSequence>> FacialAnimSequencePerLocale;                       // 0x0008(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InteractionFacialAnim) == 0x000008, "Wrong alignment on FM1InteractionFacialAnim");
static_assert(sizeof(FM1InteractionFacialAnim) == 0x000058, "Wrong size on FM1InteractionFacialAnim");
static_assert(offsetof(FM1InteractionFacialAnim, StringStoryRowName) == 0x000000, "Member 'FM1InteractionFacialAnim::StringStoryRowName' has a wrong offset!");
static_assert(offsetof(FM1InteractionFacialAnim, FacialAnimSequencePerLocale) == 0x000008, "Member 'FM1InteractionFacialAnim::FacialAnimSequencePerLocale' has a wrong offset!");

// ScriptStruct M1.M1MiniGameStatistics
// 0x0020 (0x0020 - 0x0000)
struct FM1MiniGameStatistics final
{
public:
	struct FM1TemplateId                          MiniGameTemplateId;                                // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          FieldDifficultyTemplateId;                         // 0x0004(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MiniGameResult                             Result;                                            // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1MiniGameItemChangeInfo>      ItemChangeInfoArray;                               // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MiniGameStatistics) == 0x000008, "Wrong alignment on FM1MiniGameStatistics");
static_assert(sizeof(FM1MiniGameStatistics) == 0x000020, "Wrong size on FM1MiniGameStatistics");
static_assert(offsetof(FM1MiniGameStatistics, MiniGameTemplateId) == 0x000000, "Member 'FM1MiniGameStatistics::MiniGameTemplateId' has a wrong offset!");
static_assert(offsetof(FM1MiniGameStatistics, FieldDifficultyTemplateId) == 0x000004, "Member 'FM1MiniGameStatistics::FieldDifficultyTemplateId' has a wrong offset!");
static_assert(offsetof(FM1MiniGameStatistics, Result) == 0x000008, "Member 'FM1MiniGameStatistics::Result' has a wrong offset!");
static_assert(offsetof(FM1MiniGameStatistics, ItemChangeInfoArray) == 0x000010, "Member 'FM1MiniGameStatistics::ItemChangeInfoArray' has a wrong offset!");

// ScriptStruct M1.M1InteractionAnimSet
// 0x0090 (0x0090 - 0x0000)
struct FM1InteractionAnimSet final
{
public:
	TSoftObjectPtr<class UAnimSequence>           StartAnim;                                         // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           LoopAnim;                                          // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           EndAnim;                                           // 0x0060(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InteractionAnimSet) == 0x000008, "Wrong alignment on FM1InteractionAnimSet");
static_assert(sizeof(FM1InteractionAnimSet) == 0x000090, "Wrong size on FM1InteractionAnimSet");
static_assert(offsetof(FM1InteractionAnimSet, StartAnim) == 0x000000, "Member 'FM1InteractionAnimSet::StartAnim' has a wrong offset!");
static_assert(offsetof(FM1InteractionAnimSet, LoopAnim) == 0x000030, "Member 'FM1InteractionAnimSet::LoopAnim' has a wrong offset!");
static_assert(offsetof(FM1InteractionAnimSet, EndAnim) == 0x000060, "Member 'FM1InteractionAnimSet::EndAnim' has a wrong offset!");

// ScriptStruct M1.M1DialogueAnimInfo
// 0x0038 (0x0038 - 0x0000)
struct FM1DialogueAnimInfo final
{
public:
	class FName                                   DialogDataID;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            AnimMontage;                                       // 0x0008(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DialogueAnimInfo) == 0x000008, "Wrong alignment on FM1DialogueAnimInfo");
static_assert(sizeof(FM1DialogueAnimInfo) == 0x000038, "Wrong size on FM1DialogueAnimInfo");
static_assert(offsetof(FM1DialogueAnimInfo, DialogDataID) == 0x000000, "Member 'FM1DialogueAnimInfo::DialogDataID' has a wrong offset!");
static_assert(offsetof(FM1DialogueAnimInfo, AnimMontage) == 0x000008, "Member 'FM1DialogueAnimInfo::AnimMontage' has a wrong offset!");

// ScriptStruct M1.M1QuestDialogueAnimData
// 0x00A8 (0x00A8 - 0x0000)
struct FM1QuestDialogueAnimData final
{
public:
	class FName                                   QuestDataID;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           StartAnim;                                         // 0x0008(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           LoopAnim;                                          // 0x0038(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           EndAnim;                                           // 0x0068(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1DialogueAnimInfo>            DialogueAnimList;                                  // 0x0098(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1QuestDialogueAnimData) == 0x000008, "Wrong alignment on FM1QuestDialogueAnimData");
static_assert(sizeof(FM1QuestDialogueAnimData) == 0x0000A8, "Wrong size on FM1QuestDialogueAnimData");
static_assert(offsetof(FM1QuestDialogueAnimData, QuestDataID) == 0x000000, "Member 'FM1QuestDialogueAnimData::QuestDataID' has a wrong offset!");
static_assert(offsetof(FM1QuestDialogueAnimData, StartAnim) == 0x000008, "Member 'FM1QuestDialogueAnimData::StartAnim' has a wrong offset!");
static_assert(offsetof(FM1QuestDialogueAnimData, LoopAnim) == 0x000038, "Member 'FM1QuestDialogueAnimData::LoopAnim' has a wrong offset!");
static_assert(offsetof(FM1QuestDialogueAnimData, EndAnim) == 0x000068, "Member 'FM1QuestDialogueAnimData::EndAnim' has a wrong offset!");
static_assert(offsetof(FM1QuestDialogueAnimData, DialogueAnimList) == 0x000098, "Member 'FM1QuestDialogueAnimData::DialogueAnimList' has a wrong offset!");

// ScriptStruct M1.M1PatchInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1PatchInfo final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Version;                                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         UncompressedSize;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         CompressedSize;                                    // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PatchInfo) == 0x000008, "Wrong alignment on FM1PatchInfo");
static_assert(sizeof(FM1PatchInfo) == 0x000018, "Wrong size on FM1PatchInfo");
static_assert(offsetof(FM1PatchInfo, Index) == 0x000000, "Member 'FM1PatchInfo::Index' has a wrong offset!");
static_assert(offsetof(FM1PatchInfo, Version) == 0x000004, "Member 'FM1PatchInfo::Version' has a wrong offset!");
static_assert(offsetof(FM1PatchInfo, UncompressedSize) == 0x000008, "Member 'FM1PatchInfo::UncompressedSize' has a wrong offset!");
static_assert(offsetof(FM1PatchInfo, CompressedSize) == 0x000010, "Member 'FM1PatchInfo::CompressedSize' has a wrong offset!");

// ScriptStruct M1.M1WeaponCrosshairClass
// 0x0028 (0x0028 - 0x0000)
struct FM1WeaponCrosshairClass final
{
public:
	TSubclassOf<class UUserWidget>                Crosshair;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                ZoomCrosshair;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                HitPositionHUD;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                ZoomHitPositionHUD;                                // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeaponCrosshairAimingNotice;                      // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 AimingNoticeCrosshairColor;                        // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponCrosshairClass) == 0x000008, "Wrong alignment on FM1WeaponCrosshairClass");
static_assert(sizeof(FM1WeaponCrosshairClass) == 0x000028, "Wrong size on FM1WeaponCrosshairClass");
static_assert(offsetof(FM1WeaponCrosshairClass, Crosshair) == 0x000000, "Member 'FM1WeaponCrosshairClass::Crosshair' has a wrong offset!");
static_assert(offsetof(FM1WeaponCrosshairClass, ZoomCrosshair) == 0x000008, "Member 'FM1WeaponCrosshairClass::ZoomCrosshair' has a wrong offset!");
static_assert(offsetof(FM1WeaponCrosshairClass, HitPositionHUD) == 0x000010, "Member 'FM1WeaponCrosshairClass::HitPositionHUD' has a wrong offset!");
static_assert(offsetof(FM1WeaponCrosshairClass, ZoomHitPositionHUD) == 0x000018, "Member 'FM1WeaponCrosshairClass::ZoomHitPositionHUD' has a wrong offset!");
static_assert(offsetof(FM1WeaponCrosshairClass, bWeaponCrosshairAimingNotice) == 0x000020, "Member 'FM1WeaponCrosshairClass::bWeaponCrosshairAimingNotice' has a wrong offset!");
static_assert(offsetof(FM1WeaponCrosshairClass, AimingNoticeCrosshairColor) == 0x000024, "Member 'FM1WeaponCrosshairClass::AimingNoticeCrosshairColor' has a wrong offset!");

// ScriptStruct M1.M1RequestDropItemInfo
// 0x0078 (0x0078 - 0x0000)
struct FM1RequestDropItemInfo final
{
public:
	TSubclassOf<class AM1Monster>                 MonsterClass;                                      // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AM1Monster*                             MonsterCanBeNull;                                  // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int64>                                 AccountIDs;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bIsParts;                                          // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1TemplateId                          MonsterTid;                                        // 0x0024(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int64                                         MonsterUid;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                DropLocation;                                      // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBox                                   MonsterBounds;                                     // 0x003C(0x001C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         MonsterCapsuleHalfHeight;                          // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MonsterLevel;                                      // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEliteMonster;                                     // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEpicMonster;                                      // 0x0061(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EM1MonsterCategory                            MonsterCategory;                                   // 0x0062(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_63[0x1];                                       // 0x0063(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1TemplateId                          MonsterSpawnGroupTemplateId;                       // 0x0064(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<EM1MonsterSubType>                     MonsterSubTypes;                                   // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1RequestDropItemInfo) == 0x000008, "Wrong alignment on FM1RequestDropItemInfo");
static_assert(sizeof(FM1RequestDropItemInfo) == 0x000078, "Wrong size on FM1RequestDropItemInfo");
static_assert(offsetof(FM1RequestDropItemInfo, MonsterClass) == 0x000000, "Member 'FM1RequestDropItemInfo::MonsterClass' has a wrong offset!");
static_assert(offsetof(FM1RequestDropItemInfo, MonsterCanBeNull) == 0x000008, "Member 'FM1RequestDropItemInfo::MonsterCanBeNull' has a wrong offset!");
static_assert(offsetof(FM1RequestDropItemInfo, AccountIDs) == 0x000010, "Member 'FM1RequestDropItemInfo::AccountIDs' has a wrong offset!");
static_assert(offsetof(FM1RequestDropItemInfo, bIsParts) == 0x000020, "Member 'FM1RequestDropItemInfo::bIsParts' has a wrong offset!");
static_assert(offsetof(FM1RequestDropItemInfo, MonsterTid) == 0x000024, "Member 'FM1RequestDropItemInfo::MonsterTid' has a wrong offset!");
static_assert(offsetof(FM1RequestDropItemInfo, MonsterUid) == 0x000028, "Member 'FM1RequestDropItemInfo::MonsterUid' has a wrong offset!");
static_assert(offsetof(FM1RequestDropItemInfo, DropLocation) == 0x000030, "Member 'FM1RequestDropItemInfo::DropLocation' has a wrong offset!");
static_assert(offsetof(FM1RequestDropItemInfo, MonsterBounds) == 0x00003C, "Member 'FM1RequestDropItemInfo::MonsterBounds' has a wrong offset!");
static_assert(offsetof(FM1RequestDropItemInfo, MonsterCapsuleHalfHeight) == 0x000058, "Member 'FM1RequestDropItemInfo::MonsterCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(FM1RequestDropItemInfo, MonsterLevel) == 0x00005C, "Member 'FM1RequestDropItemInfo::MonsterLevel' has a wrong offset!");
static_assert(offsetof(FM1RequestDropItemInfo, bEliteMonster) == 0x000060, "Member 'FM1RequestDropItemInfo::bEliteMonster' has a wrong offset!");
static_assert(offsetof(FM1RequestDropItemInfo, bEpicMonster) == 0x000061, "Member 'FM1RequestDropItemInfo::bEpicMonster' has a wrong offset!");
static_assert(offsetof(FM1RequestDropItemInfo, MonsterCategory) == 0x000062, "Member 'FM1RequestDropItemInfo::MonsterCategory' has a wrong offset!");
static_assert(offsetof(FM1RequestDropItemInfo, MonsterSpawnGroupTemplateId) == 0x000064, "Member 'FM1RequestDropItemInfo::MonsterSpawnGroupTemplateId' has a wrong offset!");
static_assert(offsetof(FM1RequestDropItemInfo, MonsterSubTypes) == 0x000068, "Member 'FM1RequestDropItemInfo::MonsterSubTypes' has a wrong offset!");

// ScriptStruct M1.M1DataTableRowMap
// 0x0050 (0x0050 - 0x0000)
struct FM1DataTableRowMap final
{
public:
	TMap<class FName, class FString>              Map;                                               // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DataTableRowMap) == 0x000008, "Wrong alignment on FM1DataTableRowMap");
static_assert(sizeof(FM1DataTableRowMap) == 0x000050, "Wrong size on FM1DataTableRowMap");
static_assert(offsetof(FM1DataTableRowMap, Map) == 0x000000, "Member 'FM1DataTableRowMap::Map' has a wrong offset!");

// ScriptStruct M1.M1AccountServiceLoginResult
// 0x0068 (0x0068 - 0x0000)
struct FM1AccountServiceLoginResult final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LoginId;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Token;                                             // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameServerIp;                                      // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GameServerPort;                                    // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LoginResultType                            LoginResultType;                                   // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GameServerIndex;                                   // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GameServerVersion;                                 // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForcedCrossPlayOff;                                // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreator;                                          // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         QueueNumber;                                       // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AccountServiceLoginResult) == 0x000008, "Wrong alignment on FM1AccountServiceLoginResult");
static_assert(sizeof(FM1AccountServiceLoginResult) == 0x000068, "Wrong size on FM1AccountServiceLoginResult");
static_assert(offsetof(FM1AccountServiceLoginResult, AccountUid) == 0x000000, "Member 'FM1AccountServiceLoginResult::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1AccountServiceLoginResult, LoginId) == 0x000008, "Member 'FM1AccountServiceLoginResult::LoginId' has a wrong offset!");
static_assert(offsetof(FM1AccountServiceLoginResult, Token) == 0x000018, "Member 'FM1AccountServiceLoginResult::Token' has a wrong offset!");
static_assert(offsetof(FM1AccountServiceLoginResult, GameServerIp) == 0x000028, "Member 'FM1AccountServiceLoginResult::GameServerIp' has a wrong offset!");
static_assert(offsetof(FM1AccountServiceLoginResult, GameServerPort) == 0x000038, "Member 'FM1AccountServiceLoginResult::GameServerPort' has a wrong offset!");
static_assert(offsetof(FM1AccountServiceLoginResult, LoginResultType) == 0x00003C, "Member 'FM1AccountServiceLoginResult::LoginResultType' has a wrong offset!");
static_assert(offsetof(FM1AccountServiceLoginResult, GameServerIndex) == 0x000040, "Member 'FM1AccountServiceLoginResult::GameServerIndex' has a wrong offset!");
static_assert(offsetof(FM1AccountServiceLoginResult, GameServerVersion) == 0x000048, "Member 'FM1AccountServiceLoginResult::GameServerVersion' has a wrong offset!");
static_assert(offsetof(FM1AccountServiceLoginResult, ForcedCrossPlayOff) == 0x000058, "Member 'FM1AccountServiceLoginResult::ForcedCrossPlayOff' has a wrong offset!");
static_assert(offsetof(FM1AccountServiceLoginResult, bCreator) == 0x000059, "Member 'FM1AccountServiceLoginResult::bCreator' has a wrong offset!");
static_assert(offsetof(FM1AccountServiceLoginResult, QueueNumber) == 0x000060, "Member 'FM1AccountServiceLoginResult::QueueNumber' has a wrong offset!");

// ScriptStruct M1.M1CompressedData
// 0x0020 (0x0020 - 0x0000)
struct FM1CompressedData final
{
public:
	bool                                          bSavedAsDataTable;                                 // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         UncompressedSize;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 CompressedData;                                    // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CompressedData) == 0x000008, "Wrong alignment on FM1CompressedData");
static_assert(sizeof(FM1CompressedData) == 0x000020, "Wrong size on FM1CompressedData");
static_assert(offsetof(FM1CompressedData, bSavedAsDataTable) == 0x000000, "Member 'FM1CompressedData::bSavedAsDataTable' has a wrong offset!");
static_assert(offsetof(FM1CompressedData, UncompressedSize) == 0x000008, "Member 'FM1CompressedData::UncompressedSize' has a wrong offset!");
static_assert(offsetof(FM1CompressedData, CompressedData) == 0x000010, "Member 'FM1CompressedData::CompressedData' has a wrong offset!");

// ScriptStruct M1.M1ExcelBasedDataRow_Monster
// 0x0008 (0x0008 - 0x0000)
struct FM1ExcelBasedDataRow_Monster final
{
public:
	class FName                                   MonsterRowName;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ExcelBasedDataRow_Monster) == 0x000004, "Wrong alignment on FM1ExcelBasedDataRow_Monster");
static_assert(sizeof(FM1ExcelBasedDataRow_Monster) == 0x000008, "Wrong size on FM1ExcelBasedDataRow_Monster");
static_assert(offsetof(FM1ExcelBasedDataRow_Monster, MonsterRowName) == 0x000000, "Member 'FM1ExcelBasedDataRow_Monster::MonsterRowName' has a wrong offset!");

// ScriptStruct M1.M1MissionDestructionVulgusPostCompleteInfo
// 0x0028 (0x0028 - 0x0000)
struct FM1MissionDestructionVulgusPostCompleteInfo final
{
public:
	int32                                         DeactivatedTargetCount;                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetCount;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1DestructionVulgusPostTargetInfo> TargetInfos;                                       // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bNamedMonsterSpawned;                              // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              NextCoolTimeForNonBattleState;                     // 0x0020(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionDestructionVulgusPostCompleteInfo) == 0x000008, "Wrong alignment on FM1MissionDestructionVulgusPostCompleteInfo");
static_assert(sizeof(FM1MissionDestructionVulgusPostCompleteInfo) == 0x000028, "Wrong size on FM1MissionDestructionVulgusPostCompleteInfo");
static_assert(offsetof(FM1MissionDestructionVulgusPostCompleteInfo, DeactivatedTargetCount) == 0x000000, "Member 'FM1MissionDestructionVulgusPostCompleteInfo::DeactivatedTargetCount' has a wrong offset!");
static_assert(offsetof(FM1MissionDestructionVulgusPostCompleteInfo, TargetCount) == 0x000004, "Member 'FM1MissionDestructionVulgusPostCompleteInfo::TargetCount' has a wrong offset!");
static_assert(offsetof(FM1MissionDestructionVulgusPostCompleteInfo, TargetInfos) == 0x000008, "Member 'FM1MissionDestructionVulgusPostCompleteInfo::TargetInfos' has a wrong offset!");
static_assert(offsetof(FM1MissionDestructionVulgusPostCompleteInfo, bNamedMonsterSpawned) == 0x000018, "Member 'FM1MissionDestructionVulgusPostCompleteInfo::bNamedMonsterSpawned' has a wrong offset!");
static_assert(offsetof(FM1MissionDestructionVulgusPostCompleteInfo, NextCoolTimeForNonBattleState) == 0x000020, "Member 'FM1MissionDestructionVulgusPostCompleteInfo::NextCoolTimeForNonBattleState' has a wrong offset!");

// ScriptStruct M1.M1ExcelBasedDataRow_Ability
// 0x0008 (0x0008 - 0x0000)
struct FM1ExcelBasedDataRow_Ability final
{
public:
	class FName                                   AbiltyRowName;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ExcelBasedDataRow_Ability) == 0x000004, "Wrong alignment on FM1ExcelBasedDataRow_Ability");
static_assert(sizeof(FM1ExcelBasedDataRow_Ability) == 0x000008, "Wrong size on FM1ExcelBasedDataRow_Ability");
static_assert(offsetof(FM1ExcelBasedDataRow_Ability, AbiltyRowName) == 0x000000, "Member 'FM1ExcelBasedDataRow_Ability::AbiltyRowName' has a wrong offset!");

// ScriptStruct M1.M1PackageWidgetInfo
// 0x0038 (0x0038 - 0x0000)
struct FM1PackageWidgetInfo final
{
public:
	TSoftClassPtr<class UClass>                   WidgetClass;                                       // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequirePreload;                                   // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PackageWidgetInfo) == 0x000008, "Wrong alignment on FM1PackageWidgetInfo");
static_assert(sizeof(FM1PackageWidgetInfo) == 0x000038, "Wrong size on FM1PackageWidgetInfo");
static_assert(offsetof(FM1PackageWidgetInfo, WidgetClass) == 0x000000, "Member 'FM1PackageWidgetInfo::WidgetClass' has a wrong offset!");
static_assert(offsetof(FM1PackageWidgetInfo, bRequirePreload) == 0x000030, "Member 'FM1PackageWidgetInfo::bRequirePreload' has a wrong offset!");

// ScriptStruct M1.M1DestructibleActorDebugData
// 0x0050 (0x0050 - 0x0000)
struct FM1DestructibleActorDebugData final
{
public:
	class FString                                 ActorName;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 State;                                             // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExistStaticMesh;                                  // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasLoadedDestructibleMesh;                        // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasTouchedDestructibleMesh;                       // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DMLoadState;                                       // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENetDormancy                                  NetDormancy;                                       // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DamageOrigin;                                      // 0x003C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRadius;                                      // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadialImpulseStrength;                             // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DestructibleActorDebugData) == 0x000008, "Wrong alignment on FM1DestructibleActorDebugData");
static_assert(sizeof(FM1DestructibleActorDebugData) == 0x000050, "Wrong size on FM1DestructibleActorDebugData");
static_assert(offsetof(FM1DestructibleActorDebugData, ActorName) == 0x000000, "Member 'FM1DestructibleActorDebugData::ActorName' has a wrong offset!");
static_assert(offsetof(FM1DestructibleActorDebugData, State) == 0x000010, "Member 'FM1DestructibleActorDebugData::State' has a wrong offset!");
static_assert(offsetof(FM1DestructibleActorDebugData, bExistStaticMesh) == 0x000020, "Member 'FM1DestructibleActorDebugData::bExistStaticMesh' has a wrong offset!");
static_assert(offsetof(FM1DestructibleActorDebugData, bHasLoadedDestructibleMesh) == 0x000021, "Member 'FM1DestructibleActorDebugData::bHasLoadedDestructibleMesh' has a wrong offset!");
static_assert(offsetof(FM1DestructibleActorDebugData, bHasTouchedDestructibleMesh) == 0x000022, "Member 'FM1DestructibleActorDebugData::bHasTouchedDestructibleMesh' has a wrong offset!");
static_assert(offsetof(FM1DestructibleActorDebugData, DMLoadState) == 0x000028, "Member 'FM1DestructibleActorDebugData::DMLoadState' has a wrong offset!");
static_assert(offsetof(FM1DestructibleActorDebugData, NetDormancy) == 0x000038, "Member 'FM1DestructibleActorDebugData::NetDormancy' has a wrong offset!");
static_assert(offsetof(FM1DestructibleActorDebugData, DamageOrigin) == 0x00003C, "Member 'FM1DestructibleActorDebugData::DamageOrigin' has a wrong offset!");
static_assert(offsetof(FM1DestructibleActorDebugData, DamageRadius) == 0x000048, "Member 'FM1DestructibleActorDebugData::DamageRadius' has a wrong offset!");
static_assert(offsetof(FM1DestructibleActorDebugData, RadialImpulseStrength) == 0x00004C, "Member 'FM1DestructibleActorDebugData::RadialImpulseStrength' has a wrong offset!");

// ScriptStruct M1.M1MissionRewardExp
// 0x0008 (0x0030 - 0x0028)
struct FM1MissionRewardExp : public FM1MissionRewardBase
{
public:
	int32                                         PrevLevel;                                         // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrevExp;                                           // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionRewardExp) == 0x000008, "Wrong alignment on FM1MissionRewardExp");
static_assert(sizeof(FM1MissionRewardExp) == 0x000030, "Wrong size on FM1MissionRewardExp");
static_assert(offsetof(FM1MissionRewardExp, PrevLevel) == 0x000028, "Member 'FM1MissionRewardExp::PrevLevel' has a wrong offset!");
static_assert(offsetof(FM1MissionRewardExp, PrevExp) == 0x00002C, "Member 'FM1MissionRewardExp::PrevExp' has a wrong offset!");

// ScriptStruct M1.M1DestructionEvent
// 0x0020 (0x0020 - 0x0000)
struct FM1DestructionEvent final
{
public:
	TWeakObjectPtr<class UActorComponent>         Component;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    DamageOrigin;                                      // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRadius;                                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadialImpulseStrength;                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJustDestroyed;                                    // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1DestructionEvent) == 0x000004, "Wrong alignment on FM1DestructionEvent");
static_assert(sizeof(FM1DestructionEvent) == 0x000020, "Wrong size on FM1DestructionEvent");
static_assert(offsetof(FM1DestructionEvent, Component) == 0x000000, "Member 'FM1DestructionEvent::Component' has a wrong offset!");
static_assert(offsetof(FM1DestructionEvent, DamageOrigin) == 0x000008, "Member 'FM1DestructionEvent::DamageOrigin' has a wrong offset!");
static_assert(offsetof(FM1DestructionEvent, DamageRadius) == 0x000014, "Member 'FM1DestructionEvent::DamageRadius' has a wrong offset!");
static_assert(offsetof(FM1DestructionEvent, RadialImpulseStrength) == 0x000018, "Member 'FM1DestructionEvent::RadialImpulseStrength' has a wrong offset!");
static_assert(offsetof(FM1DestructionEvent, bJustDestroyed) == 0x00001C, "Member 'FM1DestructionEvent::bJustDestroyed' has a wrong offset!");

// ScriptStruct M1.M1Request_LoadSetting
// 0x0008 (0x0008 - 0x0000)
struct FM1Request_LoadSetting final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_LoadSetting) == 0x000008, "Wrong alignment on FM1Request_LoadSetting");
static_assert(sizeof(FM1Request_LoadSetting) == 0x000008, "Wrong size on FM1Request_LoadSetting");
static_assert(offsetof(FM1Request_LoadSetting, AccountUid) == 0x000000, "Member 'FM1Request_LoadSetting::AccountUid' has a wrong offset!");

// ScriptStruct M1.M1FractureEffect
// 0x0050 (0x0050 - 0x0000)
struct FM1FractureEffect final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         FXSystem;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          WwiseSound;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1FractureEffect) == 0x000010, "Wrong alignment on FM1FractureEffect");
static_assert(sizeof(FM1FractureEffect) == 0x000050, "Wrong size on FM1FractureEffect");
static_assert(offsetof(FM1FractureEffect, Transform) == 0x000000, "Member 'FM1FractureEffect::Transform' has a wrong offset!");
static_assert(offsetof(FM1FractureEffect, Delay) == 0x000030, "Member 'FM1FractureEffect::Delay' has a wrong offset!");
static_assert(offsetof(FM1FractureEffect, FXSystem) == 0x000038, "Member 'FM1FractureEffect::FXSystem' has a wrong offset!");
static_assert(offsetof(FM1FractureEffect, WwiseSound) == 0x000040, "Member 'FM1FractureEffect::WwiseSound' has a wrong offset!");

// ScriptStruct M1.M1AccountServiceLoadSettingResult
// 0x0002 (0x0002 - 0x0000)
struct FM1AccountServiceLoadSettingResult final
{
public:
	struct FM1SettingInfo                         SettingInfo;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSuccess;                                          // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AccountServiceLoadSettingResult) == 0x000001, "Wrong alignment on FM1AccountServiceLoadSettingResult");
static_assert(sizeof(FM1AccountServiceLoadSettingResult) == 0x000002, "Wrong size on FM1AccountServiceLoadSettingResult");
static_assert(offsetof(FM1AccountServiceLoadSettingResult, SettingInfo) == 0x000000, "Member 'FM1AccountServiceLoadSettingResult::SettingInfo' has a wrong offset!");
static_assert(offsetof(FM1AccountServiceLoadSettingResult, bSuccess) == 0x000001, "Member 'FM1AccountServiceLoadSettingResult::bSuccess' has a wrong offset!");

// ScriptStruct M1.M1LargeChunkSettings
// 0x0070 (0x0070 - 0x0000)
struct FM1LargeChunkSettings final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECollisionChannel, ECollisionResponse>   CollisionResponseOverride;                         // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FFloatRange                            DisableCollisionDelay;                             // 0x0058(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1LargeChunkSettings) == 0x000008, "Wrong alignment on FM1LargeChunkSettings");
static_assert(sizeof(FM1LargeChunkSettings) == 0x000070, "Wrong size on FM1LargeChunkSettings");
static_assert(offsetof(FM1LargeChunkSettings, bEnable) == 0x000000, "Member 'FM1LargeChunkSettings::bEnable' has a wrong offset!");
static_assert(offsetof(FM1LargeChunkSettings, CollisionResponseOverride) == 0x000008, "Member 'FM1LargeChunkSettings::CollisionResponseOverride' has a wrong offset!");
static_assert(offsetof(FM1LargeChunkSettings, DisableCollisionDelay) == 0x000058, "Member 'FM1LargeChunkSettings::DisableCollisionDelay' has a wrong offset!");
static_assert(offsetof(FM1LargeChunkSettings, Timeout) == 0x000068, "Member 'FM1LargeChunkSettings::Timeout' has a wrong offset!");

// ScriptStruct M1.M1SmallChunkSettings
// 0x0058 (0x0058 - 0x0000)
struct FM1SmallChunkSettings final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECollisionChannel, ECollisionResponse>   CollisionResponseOverride;                         // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SmallChunkSettings) == 0x000008, "Wrong alignment on FM1SmallChunkSettings");
static_assert(sizeof(FM1SmallChunkSettings) == 0x000058, "Wrong size on FM1SmallChunkSettings");
static_assert(offsetof(FM1SmallChunkSettings, bEnable) == 0x000000, "Member 'FM1SmallChunkSettings::bEnable' has a wrong offset!");
static_assert(offsetof(FM1SmallChunkSettings, CollisionResponseOverride) == 0x000008, "Member 'FM1SmallChunkSettings::CollisionResponseOverride' has a wrong offset!");

// ScriptStruct M1.M1StructEventInfo
// 0x0024 (0x0024 - 0x0000)
struct FM1StructEventInfo final
{
public:
	bool                                          bDestructed;                                       // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1DestructionEvent                    DestructionEvent;                                  // 0x0004(0x0020)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StructEventInfo) == 0x000004, "Wrong alignment on FM1StructEventInfo");
static_assert(sizeof(FM1StructEventInfo) == 0x000024, "Wrong size on FM1StructEventInfo");
static_assert(offsetof(FM1StructEventInfo, bDestructed) == 0x000000, "Member 'FM1StructEventInfo::bDestructed' has a wrong offset!");
static_assert(offsetof(FM1StructEventInfo, DestructionEvent) == 0x000004, "Member 'FM1StructEventInfo::DestructionEvent' has a wrong offset!");

// ScriptStruct M1.M1WaveDefenseTargetInfo
// 0x000C (0x000C - 0x0000)
struct FM1WaveDefenseTargetInfo final
{
public:
	struct FM1TemplateId                          MissionTargetTemplateId;                           // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HpRatio;                                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldRatio;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WaveDefenseTargetInfo) == 0x000004, "Wrong alignment on FM1WaveDefenseTargetInfo");
static_assert(sizeof(FM1WaveDefenseTargetInfo) == 0x00000C, "Wrong size on FM1WaveDefenseTargetInfo");
static_assert(offsetof(FM1WaveDefenseTargetInfo, MissionTargetTemplateId) == 0x000000, "Member 'FM1WaveDefenseTargetInfo::MissionTargetTemplateId' has a wrong offset!");
static_assert(offsetof(FM1WaveDefenseTargetInfo, HpRatio) == 0x000004, "Member 'FM1WaveDefenseTargetInfo::HpRatio' has a wrong offset!");
static_assert(offsetof(FM1WaveDefenseTargetInfo, ShieldRatio) == 0x000008, "Member 'FM1WaveDefenseTargetInfo::ShieldRatio' has a wrong offset!");

// ScriptStruct M1.M1PlayDialogContext
// 0x0010 (0x0010 - 0x0000)
struct FM1PlayDialogContext final
{
public:
	class AActor*                                 OptionalContextActor;                              // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1AudioPlayContext                           Context;                                           // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PlayDialogContext) == 0x000008, "Wrong alignment on FM1PlayDialogContext");
static_assert(sizeof(FM1PlayDialogContext) == 0x000010, "Wrong size on FM1PlayDialogContext");
static_assert(offsetof(FM1PlayDialogContext, OptionalContextActor) == 0x000000, "Member 'FM1PlayDialogContext::OptionalContextActor' has a wrong offset!");
static_assert(offsetof(FM1PlayDialogContext, Context) == 0x000008, "Member 'FM1PlayDialogContext::Context' has a wrong offset!");

// ScriptStruct M1.M1DoorScalarParam
// 0x0010 (0x0010 - 0x0000)
struct FM1DoorScalarParam final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartParamValue;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndParamValue;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DoorScalarParam) == 0x000004, "Wrong alignment on FM1DoorScalarParam");
static_assert(sizeof(FM1DoorScalarParam) == 0x000010, "Wrong size on FM1DoorScalarParam");
static_assert(offsetof(FM1DoorScalarParam, ParamName) == 0x000000, "Member 'FM1DoorScalarParam::ParamName' has a wrong offset!");
static_assert(offsetof(FM1DoorScalarParam, StartParamValue) == 0x000008, "Member 'FM1DoorScalarParam::StartParamValue' has a wrong offset!");
static_assert(offsetof(FM1DoorScalarParam, EndParamValue) == 0x00000C, "Member 'FM1DoorScalarParam::EndParamValue' has a wrong offset!");

// ScriptStruct M1.M1DoorVectorParam
// 0x0020 (0x0020 - 0x0000)
struct FM1DoorVectorParam final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartParamValue;                                   // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndParamValue;                                     // 0x0014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DoorVectorParam) == 0x000004, "Wrong alignment on FM1DoorVectorParam");
static_assert(sizeof(FM1DoorVectorParam) == 0x000020, "Wrong size on FM1DoorVectorParam");
static_assert(offsetof(FM1DoorVectorParam, ParamName) == 0x000000, "Member 'FM1DoorVectorParam::ParamName' has a wrong offset!");
static_assert(offsetof(FM1DoorVectorParam, StartParamValue) == 0x000008, "Member 'FM1DoorVectorParam::StartParamValue' has a wrong offset!");
static_assert(offsetof(FM1DoorVectorParam, EndParamValue) == 0x000014, "Member 'FM1DoorVectorParam::EndParamValue' has a wrong offset!");

// ScriptStruct M1.M1BunchSubItemInfo
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FM1BunchSubItemInfo final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1BunchSubItemInfo) == 0x000004, "Wrong alignment on FM1BunchSubItemInfo");
static_assert(sizeof(FM1BunchSubItemInfo) == 0x00000C, "Wrong size on FM1BunchSubItemInfo");

// ScriptStruct M1.M1StaticDoorInfo
// 0x0090 (0x0090 - 0x0000)
struct FM1StaticDoorInfo final
{
public:
	class FName                                   MeshName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             StartTransform;                                    // 0x0010(0x0030)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             EndTransform;                                      // 0x0040(0x0030)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1DoorScalarParam>             ScalarParams;                                      // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1DoorVectorParam>             VectorParams;                                      // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StaticDoorInfo) == 0x000010, "Wrong alignment on FM1StaticDoorInfo");
static_assert(sizeof(FM1StaticDoorInfo) == 0x000090, "Wrong size on FM1StaticDoorInfo");
static_assert(offsetof(FM1StaticDoorInfo, MeshName) == 0x000000, "Member 'FM1StaticDoorInfo::MeshName' has a wrong offset!");
static_assert(offsetof(FM1StaticDoorInfo, StaticMeshComponent) == 0x000008, "Member 'FM1StaticDoorInfo::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(FM1StaticDoorInfo, StartTransform) == 0x000010, "Member 'FM1StaticDoorInfo::StartTransform' has a wrong offset!");
static_assert(offsetof(FM1StaticDoorInfo, EndTransform) == 0x000040, "Member 'FM1StaticDoorInfo::EndTransform' has a wrong offset!");
static_assert(offsetof(FM1StaticDoorInfo, ScalarParams) == 0x000070, "Member 'FM1StaticDoorInfo::ScalarParams' has a wrong offset!");
static_assert(offsetof(FM1StaticDoorInfo, VectorParams) == 0x000080, "Member 'FM1StaticDoorInfo::VectorParams' has a wrong offset!");

// ScriptStruct M1.M1GameServiceJoinGameByLowDensity
// 0x00F0 (0x00F0 - 0x0000)
struct FM1GameServiceJoinGameByLowDensity final
{
public:
	struct FM1JoinDedicatedServerRes              JoinGameResult;                                    // 0x0000(0x00B0)(NativeAccessSpecifierPublic)
	class FString                                 StartLocationId;                                   // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             PlayerLastTransform;                               // 0x00C0(0x0030)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GameServiceJoinGameByLowDensity) == 0x000010, "Wrong alignment on FM1GameServiceJoinGameByLowDensity");
static_assert(sizeof(FM1GameServiceJoinGameByLowDensity) == 0x0000F0, "Wrong size on FM1GameServiceJoinGameByLowDensity");
static_assert(offsetof(FM1GameServiceJoinGameByLowDensity, JoinGameResult) == 0x000000, "Member 'FM1GameServiceJoinGameByLowDensity::JoinGameResult' has a wrong offset!");
static_assert(offsetof(FM1GameServiceJoinGameByLowDensity, StartLocationId) == 0x0000B0, "Member 'FM1GameServiceJoinGameByLowDensity::StartLocationId' has a wrong offset!");
static_assert(offsetof(FM1GameServiceJoinGameByLowDensity, PlayerLastTransform) == 0x0000C0, "Member 'FM1GameServiceJoinGameByLowDensity::PlayerLastTransform' has a wrong offset!");

// ScriptStruct M1.M1StaticDoorController
// 0x0098 (0x0098 - 0x0000)
struct FM1StaticDoorController final
{
public:
	TArray<struct FM1StaticDoorInfo>              MeshInfo;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     AlphaCurve;                                        // 0x0010(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StaticDoorController) == 0x000008, "Wrong alignment on FM1StaticDoorController");
static_assert(sizeof(FM1StaticDoorController) == 0x000098, "Wrong size on FM1StaticDoorController");
static_assert(offsetof(FM1StaticDoorController, MeshInfo) == 0x000000, "Member 'FM1StaticDoorController::MeshInfo' has a wrong offset!");
static_assert(offsetof(FM1StaticDoorController, AlphaCurve) == 0x000010, "Member 'FM1StaticDoorController::AlphaCurve' has a wrong offset!");

// ScriptStruct M1.M1StaticDoorTimeController
// 0x00A8 (0x00A8 - 0x0000)
struct alignas(0x08) FM1StaticDoorTimeController final
{
public:
	bool                                          bAutoOpeningEndTime;                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OpeningEndTime;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoClosingEndTime;                               // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClosingEndTime;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x98];                                      // 0x0010(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1StaticDoorTimeController) == 0x000008, "Wrong alignment on FM1StaticDoorTimeController");
static_assert(sizeof(FM1StaticDoorTimeController) == 0x0000A8, "Wrong size on FM1StaticDoorTimeController");
static_assert(offsetof(FM1StaticDoorTimeController, bAutoOpeningEndTime) == 0x000000, "Member 'FM1StaticDoorTimeController::bAutoOpeningEndTime' has a wrong offset!");
static_assert(offsetof(FM1StaticDoorTimeController, OpeningEndTime) == 0x000004, "Member 'FM1StaticDoorTimeController::OpeningEndTime' has a wrong offset!");
static_assert(offsetof(FM1StaticDoorTimeController, bAutoClosingEndTime) == 0x000008, "Member 'FM1StaticDoorTimeController::bAutoClosingEndTime' has a wrong offset!");
static_assert(offsetof(FM1StaticDoorTimeController, ClosingEndTime) == 0x00000C, "Member 'FM1StaticDoorTimeController::ClosingEndTime' has a wrong offset!");

// ScriptStruct M1.M1TickablesTickFunction
// 0x0008 (0x0038 - 0x0030)
struct FM1TickablesTickFunction final : public FTickFunction
{
public:
	class UM1AggregateTickablesSubsystem*         Target;                                            // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TickablesTickFunction) == 0x000008, "Wrong alignment on FM1TickablesTickFunction");
static_assert(sizeof(FM1TickablesTickFunction) == 0x000038, "Wrong size on FM1TickablesTickFunction");
static_assert(offsetof(FM1TickablesTickFunction, Target) == 0x000030, "Member 'FM1TickablesTickFunction::Target' has a wrong offset!");

// ScriptStruct M1.M1DoorFxInfo
// 0x0080 (0x0080 - 0x0000)
struct FM1DoorFxInfo final
{
public:
	class UNiagaraSystem*                         FX;                                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1FXParam                             FXParam;                                           // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1DoorTiming                                 Timing;                                            // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeactivateWhenEndTiming;                          // 0x003A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachComponentName;                               // 0x003C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x0050(0x0030)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DoorFxInfo) == 0x000010, "Wrong alignment on FM1DoorFxInfo");
static_assert(sizeof(FM1DoorFxInfo) == 0x000080, "Wrong size on FM1DoorFxInfo");
static_assert(offsetof(FM1DoorFxInfo, FX) == 0x000000, "Member 'FM1DoorFxInfo::FX' has a wrong offset!");
static_assert(offsetof(FM1DoorFxInfo, FXParam) == 0x000008, "Member 'FM1DoorFxInfo::FXParam' has a wrong offset!");
static_assert(offsetof(FM1DoorFxInfo, bLoop) == 0x000038, "Member 'FM1DoorFxInfo::bLoop' has a wrong offset!");
static_assert(offsetof(FM1DoorFxInfo, Timing) == 0x000039, "Member 'FM1DoorFxInfo::Timing' has a wrong offset!");
static_assert(offsetof(FM1DoorFxInfo, bDeactivateWhenEndTiming) == 0x00003A, "Member 'FM1DoorFxInfo::bDeactivateWhenEndTiming' has a wrong offset!");
static_assert(offsetof(FM1DoorFxInfo, AttachComponentName) == 0x00003C, "Member 'FM1DoorFxInfo::AttachComponentName' has a wrong offset!");
static_assert(offsetof(FM1DoorFxInfo, Offset) == 0x000050, "Member 'FM1DoorFxInfo::Offset' has a wrong offset!");

// ScriptStruct M1.M1DoorFxInfoArray
// 0x0010 (0x0010 - 0x0000)
struct FM1DoorFxInfoArray final
{
public:
	TArray<struct FM1DoorFxInfo>                  DoorFxInfos;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DoorFxInfoArray) == 0x000008, "Wrong alignment on FM1DoorFxInfoArray");
static_assert(sizeof(FM1DoorFxInfoArray) == 0x000010, "Wrong size on FM1DoorFxInfoArray");
static_assert(offsetof(FM1DoorFxInfoArray, DoorFxInfos) == 0x000000, "Member 'FM1DoorFxInfoArray::DoorFxInfos' has a wrong offset!");

// ScriptStruct M1.M1TargetMonsterSpawnInfo
// 0x0060 (0x0060 - 0x0000)
struct FM1TargetMonsterSpawnInfo final
{
public:
	class FName                                   MonsterName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class UM1SpawnedActorTrait*>             Traits;                                            // 0x0008(0x0050)(Edit, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         SpawnRatio;                                        // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1TargetMonsterSpawnInfo) == 0x000008, "Wrong alignment on FM1TargetMonsterSpawnInfo");
static_assert(sizeof(FM1TargetMonsterSpawnInfo) == 0x000060, "Wrong size on FM1TargetMonsterSpawnInfo");
static_assert(offsetof(FM1TargetMonsterSpawnInfo, MonsterName) == 0x000000, "Member 'FM1TargetMonsterSpawnInfo::MonsterName' has a wrong offset!");
static_assert(offsetof(FM1TargetMonsterSpawnInfo, Traits) == 0x000008, "Member 'FM1TargetMonsterSpawnInfo::Traits' has a wrong offset!");
static_assert(offsetof(FM1TargetMonsterSpawnInfo, SpawnRatio) == 0x000058, "Member 'FM1TargetMonsterSpawnInfo::SpawnRatio' has a wrong offset!");

// ScriptStruct M1.M1DoorDebugData
// 0x000C (0x000C - 0x0000)
struct FM1DoorDebugData final
{
public:
	class FName                                   DoorName;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTickEnabled;                                      // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1DoorState                                  DoorState;                                         // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1DoorDebugData) == 0x000004, "Wrong alignment on FM1DoorDebugData");
static_assert(sizeof(FM1DoorDebugData) == 0x00000C, "Wrong size on FM1DoorDebugData");
static_assert(offsetof(FM1DoorDebugData, DoorName) == 0x000000, "Member 'FM1DoorDebugData::DoorName' has a wrong offset!");
static_assert(offsetof(FM1DoorDebugData, bTickEnabled) == 0x000008, "Member 'FM1DoorDebugData::bTickEnabled' has a wrong offset!");
static_assert(offsetof(FM1DoorDebugData, DoorState) == 0x000009, "Member 'FM1DoorDebugData::DoorState' has a wrong offset!");

// ScriptStruct M1.M1DropContainerLaunchParam
// 0x003C (0x003C - 0x0000)
struct FM1DropContainerLaunchParam final
{
public:
	float                                         DistanceLimit;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Boundary;                                          // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Force;                                             // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocation;                                     // 0x001C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         LaunchIndex;                                       // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreventInteractionOrObtainInSecs;                  // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DropContainerLaunchParam) == 0x000004, "Wrong alignment on FM1DropContainerLaunchParam");
static_assert(sizeof(FM1DropContainerLaunchParam) == 0x00003C, "Wrong size on FM1DropContainerLaunchParam");
static_assert(offsetof(FM1DropContainerLaunchParam, DistanceLimit) == 0x000000, "Member 'FM1DropContainerLaunchParam::DistanceLimit' has a wrong offset!");
static_assert(offsetof(FM1DropContainerLaunchParam, Boundary) == 0x000004, "Member 'FM1DropContainerLaunchParam::Boundary' has a wrong offset!");
static_assert(offsetof(FM1DropContainerLaunchParam, Force) == 0x000010, "Member 'FM1DropContainerLaunchParam::Force' has a wrong offset!");
static_assert(offsetof(FM1DropContainerLaunchParam, SpawnLocation) == 0x00001C, "Member 'FM1DropContainerLaunchParam::SpawnLocation' has a wrong offset!");
static_assert(offsetof(FM1DropContainerLaunchParam, Rotation) == 0x000028, "Member 'FM1DropContainerLaunchParam::Rotation' has a wrong offset!");
static_assert(offsetof(FM1DropContainerLaunchParam, LaunchIndex) == 0x000034, "Member 'FM1DropContainerLaunchParam::LaunchIndex' has a wrong offset!");
static_assert(offsetof(FM1DropContainerLaunchParam, PreventInteractionOrObtainInSecs) == 0x000038, "Member 'FM1DropContainerLaunchParam::PreventInteractionOrObtainInSecs' has a wrong offset!");

// ScriptStruct M1.M1DropContainerRepInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1DropContainerRepInfo final
{
public:
	EM1DropContainerState                         State;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RefreshVisibilityAndTickability;                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1DropContainerLocalVisibility               Visibility;                                        // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Instigator;                                        // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 WhoDroppedThis;                                    // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DropContainerRepInfo) == 0x000008, "Wrong alignment on FM1DropContainerRepInfo");
static_assert(sizeof(FM1DropContainerRepInfo) == 0x000020, "Wrong size on FM1DropContainerRepInfo");
static_assert(offsetof(FM1DropContainerRepInfo, State) == 0x000000, "Member 'FM1DropContainerRepInfo::State' has a wrong offset!");
static_assert(offsetof(FM1DropContainerRepInfo, RefreshVisibilityAndTickability) == 0x000004, "Member 'FM1DropContainerRepInfo::RefreshVisibilityAndTickability' has a wrong offset!");
static_assert(offsetof(FM1DropContainerRepInfo, Visibility) == 0x000008, "Member 'FM1DropContainerRepInfo::Visibility' has a wrong offset!");
static_assert(offsetof(FM1DropContainerRepInfo, Instigator) == 0x000010, "Member 'FM1DropContainerRepInfo::Instigator' has a wrong offset!");
static_assert(offsetof(FM1DropContainerRepInfo, WhoDroppedThis) == 0x000018, "Member 'FM1DropContainerRepInfo::WhoDroppedThis' has a wrong offset!");

// ScriptStruct M1.M1TypedUITheme_Brush
// 0x00C8 (0x00F0 - 0x0028)
struct FM1TypedUITheme_Brush final : public FM1TypedUICustomizing
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x0030(0x00C0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TypedUITheme_Brush) == 0x000010, "Wrong alignment on FM1TypedUITheme_Brush");
static_assert(sizeof(FM1TypedUITheme_Brush) == 0x0000F0, "Wrong size on FM1TypedUITheme_Brush");
static_assert(offsetof(FM1TypedUITheme_Brush, Brush) == 0x000030, "Member 'FM1TypedUITheme_Brush::Brush' has a wrong offset!");

// ScriptStruct M1.M1DropItemFxData
// 0x0060 (0x0060 - 0x0000)
struct FM1DropItemFxData final
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          Indicator;                                         // 0x0000(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          Gain;                                              // 0x0030(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DropItemFxData) == 0x000008, "Wrong alignment on FM1DropItemFxData");
static_assert(sizeof(FM1DropItemFxData) == 0x000060, "Wrong size on FM1DropItemFxData");
static_assert(offsetof(FM1DropItemFxData, Indicator) == 0x000000, "Member 'FM1DropItemFxData::Indicator' has a wrong offset!");
static_assert(offsetof(FM1DropItemFxData, Gain) == 0x000030, "Member 'FM1DropItemFxData::Gain' has a wrong offset!");

// ScriptStruct M1.M1FieldGoalInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1FieldGoalInfo final
{
public:
	class FString                                 GoalId;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MapGoalType                                GoalType;                                          // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TotalScore;                                        // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentScore;                                      // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1FieldGoalInfo) == 0x000008, "Wrong alignment on FM1FieldGoalInfo");
static_assert(sizeof(FM1FieldGoalInfo) == 0x000020, "Wrong size on FM1FieldGoalInfo");
static_assert(offsetof(FM1FieldGoalInfo, GoalId) == 0x000000, "Member 'FM1FieldGoalInfo::GoalId' has a wrong offset!");
static_assert(offsetof(FM1FieldGoalInfo, GoalType) == 0x000010, "Member 'FM1FieldGoalInfo::GoalType' has a wrong offset!");
static_assert(offsetof(FM1FieldGoalInfo, TotalScore) == 0x000014, "Member 'FM1FieldGoalInfo::TotalScore' has a wrong offset!");
static_assert(offsetof(FM1FieldGoalInfo, CurrentScore) == 0x000018, "Member 'FM1FieldGoalInfo::CurrentScore' has a wrong offset!");

// ScriptStruct M1.M1DropContainerFxData
// 0x0060 (0x0060 - 0x0000)
struct FM1DropContainerFxData final
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          Default;                                           // 0x0000(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          Symbol;                                            // 0x0030(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DropContainerFxData) == 0x000008, "Wrong alignment on FM1DropContainerFxData");
static_assert(sizeof(FM1DropContainerFxData) == 0x000060, "Wrong size on FM1DropContainerFxData");
static_assert(offsetof(FM1DropContainerFxData, Default) == 0x000000, "Member 'FM1DropContainerFxData::Default' has a wrong offset!");
static_assert(offsetof(FM1DropContainerFxData, Symbol) == 0x000030, "Member 'FM1DropContainerFxData::Symbol' has a wrong offset!");

// ScriptStruct M1.M1PickupWeaponInitParams
// 0x0008 (0x0008 - 0x0000)
struct FM1PickupWeaponInitParams final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rounds;                                            // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PickupWeaponInitParams) == 0x000004, "Wrong alignment on FM1PickupWeaponInitParams");
static_assert(sizeof(FM1PickupWeaponInitParams) == 0x000008, "Wrong size on FM1PickupWeaponInitParams");
static_assert(offsetof(FM1PickupWeaponInitParams, Level) == 0x000000, "Member 'FM1PickupWeaponInitParams::Level' has a wrong offset!");
static_assert(offsetof(FM1PickupWeaponInitParams, Rounds) == 0x000004, "Member 'FM1PickupWeaponInitParams::Rounds' has a wrong offset!");

// ScriptStruct M1.M1DropMissionCollectiblesInfo
// 0x000C (0x000C - 0x0000)
struct FM1DropMissionCollectiblesInfo final
{
public:
	class FName                                   DropContainerRow;                                  // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DropMissionCollectiblesInfo) == 0x000004, "Wrong alignment on FM1DropMissionCollectiblesInfo");
static_assert(sizeof(FM1DropMissionCollectiblesInfo) == 0x00000C, "Wrong size on FM1DropMissionCollectiblesInfo");
static_assert(offsetof(FM1DropMissionCollectiblesInfo, DropContainerRow) == 0x000000, "Member 'FM1DropMissionCollectiblesInfo::DropContainerRow' has a wrong offset!");
static_assert(offsetof(FM1DropMissionCollectiblesInfo, Count) == 0x000008, "Member 'FM1DropMissionCollectiblesInfo::Count' has a wrong offset!");

// ScriptStruct M1.M1BossGameGuideGroup
// 0x0010 (0x0010 - 0x0000)
struct FM1BossGameGuideGroup final
{
public:
	TArray<int32>                                 GroupIds;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BossGameGuideGroup) == 0x000008, "Wrong alignment on FM1BossGameGuideGroup");
static_assert(sizeof(FM1BossGameGuideGroup) == 0x000010, "Wrong size on FM1BossGameGuideGroup");
static_assert(offsetof(FM1BossGameGuideGroup, GroupIds) == 0x000000, "Member 'FM1BossGameGuideGroup::GroupIds' has a wrong offset!");

// ScriptStruct M1.M1EventSimpleInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1EventSimpleInfo final
{
public:
	int64                                         EventId;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          TemplateId;                                        // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              StartDateTime;                                     // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndDateTime;                                       // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EventSimpleInfo) == 0x000008, "Wrong alignment on FM1EventSimpleInfo");
static_assert(sizeof(FM1EventSimpleInfo) == 0x000020, "Wrong size on FM1EventSimpleInfo");
static_assert(offsetof(FM1EventSimpleInfo, EventId) == 0x000000, "Member 'FM1EventSimpleInfo::EventId' has a wrong offset!");
static_assert(offsetof(FM1EventSimpleInfo, TemplateId) == 0x000008, "Member 'FM1EventSimpleInfo::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1EventSimpleInfo, StartDateTime) == 0x000010, "Member 'FM1EventSimpleInfo::StartDateTime' has a wrong offset!");
static_assert(offsetof(FM1EventSimpleInfo, EndDateTime) == 0x000018, "Member 'FM1EventSimpleInfo::EndDateTime' has a wrong offset!");

// ScriptStruct M1.M1FieldObjectSpawnerInfoWrapper
// 0x0010 (0x0010 - 0x0000)
struct FM1FieldObjectSpawnerInfoWrapper final
{
public:
	TArray<struct FM1FieldObjectSpawnerInfo>      AllInfo;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FieldObjectSpawnerInfoWrapper) == 0x000008, "Wrong alignment on FM1FieldObjectSpawnerInfoWrapper");
static_assert(sizeof(FM1FieldObjectSpawnerInfoWrapper) == 0x000010, "Wrong size on FM1FieldObjectSpawnerInfoWrapper");
static_assert(offsetof(FM1FieldObjectSpawnerInfoWrapper, AllInfo) == 0x000000, "Member 'FM1FieldObjectSpawnerInfoWrapper::AllInfo' has a wrong offset!");

// ScriptStruct M1.M1SkillFTestTestCase
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FM1SkillFTestTestCase final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SkillFTestTestCase) == 0x000008, "Wrong alignment on FM1SkillFTestTestCase");
static_assert(sizeof(FM1SkillFTestTestCase) == 0x000068, "Wrong size on FM1SkillFTestTestCase");

// ScriptStruct M1.M1VariantData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FM1VariantData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1VariantData) == 0x000008, "Wrong alignment on FM1VariantData");
static_assert(sizeof(FM1VariantData) == 0x000018, "Wrong size on FM1VariantData");

// ScriptStruct M1.M1SkillFTestTestCaseSheetBase
// 0x0038 (0x0038 - 0x0000)
struct FM1SkillFTestTestCaseSheetBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RepeatTriggerTimer;                                // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1SkillFTestLockOnType                       LockOnType;                                        // 0x000C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AimOffset;                                         // 0x0010(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpentWholeTime;                                   // 0x0020(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1SkillFTestTestCase>          TestCases;                                         // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SkillFTestTestCaseSheetBase) == 0x000008, "Wrong alignment on FM1SkillFTestTestCaseSheetBase");
static_assert(sizeof(FM1SkillFTestTestCaseSheetBase) == 0x000038, "Wrong size on FM1SkillFTestTestCaseSheetBase");
static_assert(offsetof(FM1SkillFTestTestCaseSheetBase, RepeatTriggerTimer) == 0x000008, "Member 'FM1SkillFTestTestCaseSheetBase::RepeatTriggerTimer' has a wrong offset!");
static_assert(offsetof(FM1SkillFTestTestCaseSheetBase, LockOnType) == 0x00000C, "Member 'FM1SkillFTestTestCaseSheetBase::LockOnType' has a wrong offset!");
static_assert(offsetof(FM1SkillFTestTestCaseSheetBase, AimOffset) == 0x000010, "Member 'FM1SkillFTestTestCaseSheetBase::AimOffset' has a wrong offset!");
static_assert(offsetof(FM1SkillFTestTestCaseSheetBase, Timeout) == 0x00001C, "Member 'FM1SkillFTestTestCaseSheetBase::Timeout' has a wrong offset!");
static_assert(offsetof(FM1SkillFTestTestCaseSheetBase, bSpentWholeTime) == 0x000020, "Member 'FM1SkillFTestTestCaseSheetBase::bSpentWholeTime' has a wrong offset!");
static_assert(offsetof(FM1SkillFTestTestCaseSheetBase, TestCases) == 0x000028, "Member 'FM1SkillFTestTestCaseSheetBase::TestCases' has a wrong offset!");

// ScriptStruct M1.M1SkillFTestTestCaseSheet
// 0x0008 (0x0040 - 0x0038)
struct FM1SkillFTestTestCaseSheet final : public FM1SkillFTestTestCaseSheetBase
{
public:
	EM1SkillFTestTrigger                          Trigger;                                           // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1BattleKey                                  CustomBattleKey;                                   // 0x0039(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SkillFTestTestCaseSheet) == 0x000008, "Wrong alignment on FM1SkillFTestTestCaseSheet");
static_assert(sizeof(FM1SkillFTestTestCaseSheet) == 0x000040, "Wrong size on FM1SkillFTestTestCaseSheet");
static_assert(offsetof(FM1SkillFTestTestCaseSheet, Trigger) == 0x000038, "Member 'FM1SkillFTestTestCaseSheet::Trigger' has a wrong offset!");
static_assert(offsetof(FM1SkillFTestTestCaseSheet, CustomBattleKey) == 0x000039, "Member 'FM1SkillFTestTestCaseSheet::CustomBattleKey' has a wrong offset!");

// ScriptStruct M1.M1InteractionInvokerContext
// 0x0050 (0x0050 - 0x0000)
struct FM1InteractionInvokerContext final
{
public:
	bool                                          bShouldInteractionOnServer;                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1PlayerInteractionAnimInfo           PlayerAnimInfo;                                    // 0x0008(0x0048)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InteractionInvokerContext) == 0x000008, "Wrong alignment on FM1InteractionInvokerContext");
static_assert(sizeof(FM1InteractionInvokerContext) == 0x000050, "Wrong size on FM1InteractionInvokerContext");
static_assert(offsetof(FM1InteractionInvokerContext, bShouldInteractionOnServer) == 0x000000, "Member 'FM1InteractionInvokerContext::bShouldInteractionOnServer' has a wrong offset!");
static_assert(offsetof(FM1InteractionInvokerContext, PlayerAnimInfo) == 0x000008, "Member 'FM1InteractionInvokerContext::PlayerAnimInfo' has a wrong offset!");

// ScriptStruct M1.M1SkillFTestTestCaseSheetExt
// 0x0008 (0x0040 - 0x0038)
struct FM1SkillFTestTestCaseSheetExt final : public FM1SkillFTestTestCaseSheetBase
{
public:
	class UM1FunctionalTestTriggerBlueprint*      TriggerInstance;                                   // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SkillFTestTestCaseSheetExt) == 0x000008, "Wrong alignment on FM1SkillFTestTestCaseSheetExt");
static_assert(sizeof(FM1SkillFTestTestCaseSheetExt) == 0x000040, "Wrong size on FM1SkillFTestTestCaseSheetExt");
static_assert(offsetof(FM1SkillFTestTestCaseSheetExt, TriggerInstance) == 0x000038, "Member 'FM1SkillFTestTestCaseSheetExt::TriggerInstance' has a wrong offset!");

// ScriptStruct M1.M1NXAPISetting
// 0x0020 (0x0020 - 0x0000)
struct FM1NXAPISetting final
{
public:
	class FString                                 Version;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServiceId;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NXAPISetting) == 0x000008, "Wrong alignment on FM1NXAPISetting");
static_assert(sizeof(FM1NXAPISetting) == 0x000020, "Wrong size on FM1NXAPISetting");
static_assert(offsetof(FM1NXAPISetting, Version) == 0x000000, "Member 'FM1NXAPISetting::Version' has a wrong offset!");
static_assert(offsetof(FM1NXAPISetting, ServiceId) == 0x000010, "Member 'FM1NXAPISetting::ServiceId' has a wrong offset!");

// ScriptStruct M1.M1UserReportDetails
// 0x0020 (0x0020 - 0x0000)
struct FM1UserReportDetails final
{
public:
	struct FDateTime                              ExpirationDateTime;                                // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserName;                                          // 0x0008(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ReportReasonType                           ReportReason;                                      // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UserReportDetails) == 0x000008, "Wrong alignment on FM1UserReportDetails");
static_assert(sizeof(FM1UserReportDetails) == 0x000020, "Wrong size on FM1UserReportDetails");
static_assert(offsetof(FM1UserReportDetails, ExpirationDateTime) == 0x000000, "Member 'FM1UserReportDetails::ExpirationDateTime' has a wrong offset!");
static_assert(offsetof(FM1UserReportDetails, UserName) == 0x000008, "Member 'FM1UserReportDetails::UserName' has a wrong offset!");
static_assert(offsetof(FM1UserReportDetails, ReportReason) == 0x000018, "Member 'FM1UserReportDetails::ReportReason' has a wrong offset!");

// ScriptStruct M1.M1CameraSensitivitySetting
// 0x0018 (0x0018 - 0x0000)
struct FM1CameraSensitivitySetting final
{
public:
	float                                         BaseSensitivityStep;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SensitivityStepMin;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SensitivityStepMax;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseSensitivityValue;                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepValue;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SensitivityRatioWithScope;                         // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CameraSensitivitySetting) == 0x000004, "Wrong alignment on FM1CameraSensitivitySetting");
static_assert(sizeof(FM1CameraSensitivitySetting) == 0x000018, "Wrong size on FM1CameraSensitivitySetting");
static_assert(offsetof(FM1CameraSensitivitySetting, BaseSensitivityStep) == 0x000000, "Member 'FM1CameraSensitivitySetting::BaseSensitivityStep' has a wrong offset!");
static_assert(offsetof(FM1CameraSensitivitySetting, SensitivityStepMin) == 0x000004, "Member 'FM1CameraSensitivitySetting::SensitivityStepMin' has a wrong offset!");
static_assert(offsetof(FM1CameraSensitivitySetting, SensitivityStepMax) == 0x000008, "Member 'FM1CameraSensitivitySetting::SensitivityStepMax' has a wrong offset!");
static_assert(offsetof(FM1CameraSensitivitySetting, BaseSensitivityValue) == 0x00000C, "Member 'FM1CameraSensitivitySetting::BaseSensitivityValue' has a wrong offset!");
static_assert(offsetof(FM1CameraSensitivitySetting, StepValue) == 0x000010, "Member 'FM1CameraSensitivitySetting::StepValue' has a wrong offset!");
static_assert(offsetof(FM1CameraSensitivitySetting, SensitivityRatioWithScope) == 0x000014, "Member 'FM1CameraSensitivitySetting::SensitivityRatioWithScope' has a wrong offset!");

// ScriptStruct M1.M1AnnounceSetting
// 0x000C (0x000C - 0x0000)
struct FM1AnnounceSetting final
{
public:
	float                                         AnnounceDelayTime;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplitContextDelayTime;                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ContextMaxLength;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AnnounceSetting) == 0x000004, "Wrong alignment on FM1AnnounceSetting");
static_assert(sizeof(FM1AnnounceSetting) == 0x00000C, "Wrong size on FM1AnnounceSetting");
static_assert(offsetof(FM1AnnounceSetting, AnnounceDelayTime) == 0x000000, "Member 'FM1AnnounceSetting::AnnounceDelayTime' has a wrong offset!");
static_assert(offsetof(FM1AnnounceSetting, SplitContextDelayTime) == 0x000004, "Member 'FM1AnnounceSetting::SplitContextDelayTime' has a wrong offset!");
static_assert(offsetof(FM1AnnounceSetting, ContextMaxLength) == 0x000008, "Member 'FM1AnnounceSetting::ContextMaxLength' has a wrong offset!");

// ScriptStruct M1.M1VoiceChatDeviceVolumeSetting
// 0x0008 (0x0008 - 0x0000)
struct FM1VoiceChatDeviceVolumeSetting final
{
public:
	float                                         Volume;                                            // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMuted;                                            // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1VoiceChatDeviceVolumeSetting) == 0x000004, "Wrong alignment on FM1VoiceChatDeviceVolumeSetting");
static_assert(sizeof(FM1VoiceChatDeviceVolumeSetting) == 0x000008, "Wrong size on FM1VoiceChatDeviceVolumeSetting");
static_assert(offsetof(FM1VoiceChatDeviceVolumeSetting, Volume) == 0x000000, "Member 'FM1VoiceChatDeviceVolumeSetting::Volume' has a wrong offset!");
static_assert(offsetof(FM1VoiceChatDeviceVolumeSetting, bMuted) == 0x000004, "Member 'FM1VoiceChatDeviceVolumeSetting::bMuted' has a wrong offset!");

// ScriptStruct M1.M1VoiceChatParticipantFlagsChangedEventData
// 0x0010 (0x0010 - 0x0000)
struct FM1VoiceChatParticipantFlagsChangedEventData final
{
public:
	bool                                          bDesiredToBlock;                                   // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesiredToLocalMute;                               // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesiredToCrossMute;                               // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1VoiceChatDeviceVolumeSetting        OutputDeviceVolume;                                // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsLocallyMuted;                                   // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCrossMuted;                                     // 0x000D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1VoiceChatParticipantFlagsChangedEventData) == 0x000004, "Wrong alignment on FM1VoiceChatParticipantFlagsChangedEventData");
static_assert(sizeof(FM1VoiceChatParticipantFlagsChangedEventData) == 0x000010, "Wrong size on FM1VoiceChatParticipantFlagsChangedEventData");
static_assert(offsetof(FM1VoiceChatParticipantFlagsChangedEventData, bDesiredToBlock) == 0x000000, "Member 'FM1VoiceChatParticipantFlagsChangedEventData::bDesiredToBlock' has a wrong offset!");
static_assert(offsetof(FM1VoiceChatParticipantFlagsChangedEventData, bDesiredToLocalMute) == 0x000001, "Member 'FM1VoiceChatParticipantFlagsChangedEventData::bDesiredToLocalMute' has a wrong offset!");
static_assert(offsetof(FM1VoiceChatParticipantFlagsChangedEventData, bDesiredToCrossMute) == 0x000002, "Member 'FM1VoiceChatParticipantFlagsChangedEventData::bDesiredToCrossMute' has a wrong offset!");
static_assert(offsetof(FM1VoiceChatParticipantFlagsChangedEventData, OutputDeviceVolume) == 0x000004, "Member 'FM1VoiceChatParticipantFlagsChangedEventData::OutputDeviceVolume' has a wrong offset!");
static_assert(offsetof(FM1VoiceChatParticipantFlagsChangedEventData, bIsLocallyMuted) == 0x00000C, "Member 'FM1VoiceChatParticipantFlagsChangedEventData::bIsLocallyMuted' has a wrong offset!");
static_assert(offsetof(FM1VoiceChatParticipantFlagsChangedEventData, bIsCrossMuted) == 0x00000D, "Member 'FM1VoiceChatParticipantFlagsChangedEventData::bIsCrossMuted' has a wrong offset!");

// ScriptStruct M1.M1AimAssistSettingsSlowdown
// 0x000C (0x000C - 0x0000)
struct FM1AimAssistSettingsSlowdown final
{
public:
	float                                         DetectionRange;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetectionReduceRangeStart;                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowdownAimMultiplier;                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AimAssistSettingsSlowdown) == 0x000004, "Wrong alignment on FM1AimAssistSettingsSlowdown");
static_assert(sizeof(FM1AimAssistSettingsSlowdown) == 0x00000C, "Wrong size on FM1AimAssistSettingsSlowdown");
static_assert(offsetof(FM1AimAssistSettingsSlowdown, DetectionRange) == 0x000000, "Member 'FM1AimAssistSettingsSlowdown::DetectionRange' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettingsSlowdown, DetectionReduceRangeStart) == 0x000004, "Member 'FM1AimAssistSettingsSlowdown::DetectionReduceRangeStart' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettingsSlowdown, SlowdownAimMultiplier) == 0x000008, "Member 'FM1AimAssistSettingsSlowdown::SlowdownAimMultiplier' has a wrong offset!");

// ScriptStruct M1.M1AimAssistSettingsAutoAim
// 0x000C (0x000C - 0x0000)
struct FM1AimAssistSettingsAutoAim final
{
public:
	float                                         DetectionRange;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetectionReduceRangeStart;                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoAimDeltaMultiplier;                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AimAssistSettingsAutoAim) == 0x000004, "Wrong alignment on FM1AimAssistSettingsAutoAim");
static_assert(sizeof(FM1AimAssistSettingsAutoAim) == 0x00000C, "Wrong size on FM1AimAssistSettingsAutoAim");
static_assert(offsetof(FM1AimAssistSettingsAutoAim, DetectionRange) == 0x000000, "Member 'FM1AimAssistSettingsAutoAim::DetectionRange' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettingsAutoAim, DetectionReduceRangeStart) == 0x000004, "Member 'FM1AimAssistSettingsAutoAim::DetectionReduceRangeStart' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettingsAutoAim, AutoAimDeltaMultiplier) == 0x000008, "Member 'FM1AimAssistSettingsAutoAim::AutoAimDeltaMultiplier' has a wrong offset!");

// ScriptStruct M1.M1AimAssistSettingsBoth
// 0x0010 (0x0010 - 0x0000)
struct FM1AimAssistSettingsBoth final
{
public:
	float                                         DetectionRange;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetectionReduceRangeStart;                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoAimDeltaMultiplier;                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowdownAimMultiplier;                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AimAssistSettingsBoth) == 0x000004, "Wrong alignment on FM1AimAssistSettingsBoth");
static_assert(sizeof(FM1AimAssistSettingsBoth) == 0x000010, "Wrong size on FM1AimAssistSettingsBoth");
static_assert(offsetof(FM1AimAssistSettingsBoth, DetectionRange) == 0x000000, "Member 'FM1AimAssistSettingsBoth::DetectionRange' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettingsBoth, DetectionReduceRangeStart) == 0x000004, "Member 'FM1AimAssistSettingsBoth::DetectionReduceRangeStart' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettingsBoth, AutoAimDeltaMultiplier) == 0x000008, "Member 'FM1AimAssistSettingsBoth::AutoAimDeltaMultiplier' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettingsBoth, SlowdownAimMultiplier) == 0x00000C, "Member 'FM1AimAssistSettingsBoth::SlowdownAimMultiplier' has a wrong offset!");

// ScriptStruct M1.M1AimAssistSettingsPerWeapon
// 0x0048 (0x0048 - 0x0000)
struct FM1AimAssistSettingsPerWeapon final
{
public:
	float                                         DetectionRadius;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetectionRadiusForZoom;                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetectionRange;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetectionReduceRangeStart;                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1AimAssistSettingsSlowdown           AimSlowdown;                                       // 0x0010(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1AimAssistSettingsBoth               AimRotate;                                         // 0x001C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1AimAssistSettingsAutoAim            AimMagnet;                                         // 0x002C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1AimAssistSettingsBoth               StickyAim;                                         // 0x0038(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AimAssistSettingsPerWeapon) == 0x000004, "Wrong alignment on FM1AimAssistSettingsPerWeapon");
static_assert(sizeof(FM1AimAssistSettingsPerWeapon) == 0x000048, "Wrong size on FM1AimAssistSettingsPerWeapon");
static_assert(offsetof(FM1AimAssistSettingsPerWeapon, DetectionRadius) == 0x000000, "Member 'FM1AimAssistSettingsPerWeapon::DetectionRadius' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettingsPerWeapon, DetectionRadiusForZoom) == 0x000004, "Member 'FM1AimAssistSettingsPerWeapon::DetectionRadiusForZoom' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettingsPerWeapon, DetectionRange) == 0x000008, "Member 'FM1AimAssistSettingsPerWeapon::DetectionRange' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettingsPerWeapon, DetectionReduceRangeStart) == 0x00000C, "Member 'FM1AimAssistSettingsPerWeapon::DetectionReduceRangeStart' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettingsPerWeapon, AimSlowdown) == 0x000010, "Member 'FM1AimAssistSettingsPerWeapon::AimSlowdown' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettingsPerWeapon, AimRotate) == 0x00001C, "Member 'FM1AimAssistSettingsPerWeapon::AimRotate' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettingsPerWeapon, AimMagnet) == 0x00002C, "Member 'FM1AimAssistSettingsPerWeapon::AimMagnet' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettingsPerWeapon, StickyAim) == 0x000038, "Member 'FM1AimAssistSettingsPerWeapon::StickyAim' has a wrong offset!");

// ScriptStruct M1.M1AimAssistTimebasedTypeSettings
// 0x0008 (0x0008 - 0x0000)
struct FM1AimAssistTimebasedTypeSettings final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cooltime;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AimAssistTimebasedTypeSettings) == 0x000004, "Wrong alignment on FM1AimAssistTimebasedTypeSettings");
static_assert(sizeof(FM1AimAssistTimebasedTypeSettings) == 0x000008, "Wrong size on FM1AimAssistTimebasedTypeSettings");
static_assert(offsetof(FM1AimAssistTimebasedTypeSettings, Duration) == 0x000000, "Member 'FM1AimAssistTimebasedTypeSettings::Duration' has a wrong offset!");
static_assert(offsetof(FM1AimAssistTimebasedTypeSettings, Cooltime) == 0x000004, "Member 'FM1AimAssistTimebasedTypeSettings::Cooltime' has a wrong offset!");

// ScriptStruct M1.M1MissionRestrictPlayersInAreaInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1MissionRestrictPlayersInAreaInfo final
{
public:
	class AM1MissionActor*                        MissionActor;                                      // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EM1MissionTaskAreaState                       State;                                             // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MissionTaskAreaLimitTime;                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1MissionRestrictPlayersInAreaInfo) == 0x000008, "Wrong alignment on FM1MissionRestrictPlayersInAreaInfo");
static_assert(sizeof(FM1MissionRestrictPlayersInAreaInfo) == 0x000010, "Wrong size on FM1MissionRestrictPlayersInAreaInfo");
static_assert(offsetof(FM1MissionRestrictPlayersInAreaInfo, MissionActor) == 0x000000, "Member 'FM1MissionRestrictPlayersInAreaInfo::MissionActor' has a wrong offset!");
static_assert(offsetof(FM1MissionRestrictPlayersInAreaInfo, State) == 0x000008, "Member 'FM1MissionRestrictPlayersInAreaInfo::State' has a wrong offset!");
static_assert(offsetof(FM1MissionRestrictPlayersInAreaInfo, MissionTaskAreaLimitTime) == 0x00000C, "Member 'FM1MissionRestrictPlayersInAreaInfo::MissionTaskAreaLimitTime' has a wrong offset!");

// ScriptStruct M1.M1AimAssistAdditionalOperationContainer
// 0x0010 (0x0010 - 0x0000)
struct FM1AimAssistAdditionalOperationContainer final
{
public:
	TArray<EM1AimAssistAdditionalOperation>       Operations;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AimAssistAdditionalOperationContainer) == 0x000008, "Wrong alignment on FM1AimAssistAdditionalOperationContainer");
static_assert(sizeof(FM1AimAssistAdditionalOperationContainer) == 0x000010, "Wrong size on FM1AimAssistAdditionalOperationContainer");
static_assert(offsetof(FM1AimAssistAdditionalOperationContainer, Operations) == 0x000000, "Member 'FM1AimAssistAdditionalOperationContainer::Operations' has a wrong offset!");

// ScriptStruct M1.M1ComponentVisibilityControlInfos
// 0x0010 (0x0010 - 0x0000)
struct FM1ComponentVisibilityControlInfos final
{
public:
	TArray<struct FM1ComponentVisibilityControlInfo> ControlInfo;                                       // 0x0000(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ComponentVisibilityControlInfos) == 0x000008, "Wrong alignment on FM1ComponentVisibilityControlInfos");
static_assert(sizeof(FM1ComponentVisibilityControlInfos) == 0x000010, "Wrong size on FM1ComponentVisibilityControlInfos");
static_assert(offsetof(FM1ComponentVisibilityControlInfos, ControlInfo) == 0x000000, "Member 'FM1ComponentVisibilityControlInfos::ControlInfo' has a wrong offset!");

// ScriptStruct M1.M1AimAssistSettings
// 0x0118 (0x0118 - 0x0000)
struct FM1AimAssistSettings final
{
public:
	struct FM1AimAssistSettingsPerWeapon          DefaultSettingsForWeapon;                          // 0x0000(0x0048)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TMap<EM1EquipItemClassType, struct FM1AimAssistSettingsPerWeapon> SettingsPerWeapon;                                 // 0x0048(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FM1AimAssistTimebasedTypeSettings      AimMagnetTimeSettings;                             // 0x0098(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1AimAssistTimebasedTypeSettings      StickyAimTimeSettings;                             // 0x00A0(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AimRotateDeadZoneDistance;                         // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimTargetReleaseTime;                              // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitRotationAngleWhenUserAimInput;                // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AdditionalTargetableClassName;                     // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<struct FM1TemplateId, struct FM1AimAssistAdditionalOperationContainer> AdditionalOperationInfo;                           // 0x00C8(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1AimAssistSettings) == 0x000008, "Wrong alignment on FM1AimAssistSettings");
static_assert(sizeof(FM1AimAssistSettings) == 0x000118, "Wrong size on FM1AimAssistSettings");
static_assert(offsetof(FM1AimAssistSettings, DefaultSettingsForWeapon) == 0x000000, "Member 'FM1AimAssistSettings::DefaultSettingsForWeapon' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettings, SettingsPerWeapon) == 0x000048, "Member 'FM1AimAssistSettings::SettingsPerWeapon' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettings, AimMagnetTimeSettings) == 0x000098, "Member 'FM1AimAssistSettings::AimMagnetTimeSettings' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettings, StickyAimTimeSettings) == 0x0000A0, "Member 'FM1AimAssistSettings::StickyAimTimeSettings' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettings, AimRotateDeadZoneDistance) == 0x0000A8, "Member 'FM1AimAssistSettings::AimRotateDeadZoneDistance' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettings, AimTargetReleaseTime) == 0x0000AC, "Member 'FM1AimAssistSettings::AimTargetReleaseTime' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettings, LimitRotationAngleWhenUserAimInput) == 0x0000B0, "Member 'FM1AimAssistSettings::LimitRotationAngleWhenUserAimInput' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettings, AdditionalTargetableClassName) == 0x0000B8, "Member 'FM1AimAssistSettings::AdditionalTargetableClassName' has a wrong offset!");
static_assert(offsetof(FM1AimAssistSettings, AdditionalOperationInfo) == 0x0000C8, "Member 'FM1AimAssistSettings::AdditionalOperationInfo' has a wrong offset!");

// ScriptStruct M1.M1CollisionOptionSet
// 0x0010 (0x0010 - 0x0000)
struct FM1CollisionOptionSet final
{
public:
	TArray<EM1ComponentCollisionOption>           CollisionOptions;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CollisionOptionSet) == 0x000008, "Wrong alignment on FM1CollisionOptionSet");
static_assert(sizeof(FM1CollisionOptionSet) == 0x000010, "Wrong size on FM1CollisionOptionSet");
static_assert(offsetof(FM1CollisionOptionSet, CollisionOptions) == 0x000000, "Member 'FM1CollisionOptionSet::CollisionOptions' has a wrong offset!");

// ScriptStruct M1.M1MonsterHpBarSettingWithTargetPlatform
// 0x0018 (0x0018 - 0x0000)
struct FM1MonsterHpBarSettingWithTargetPlatform final
{
public:
	struct FM1MonsterHpBarSetting                 Setting;                                           // 0x0000(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<EM1Platform>                           TargetPlatform;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterHpBarSettingWithTargetPlatform) == 0x000008, "Wrong alignment on FM1MonsterHpBarSettingWithTargetPlatform");
static_assert(sizeof(FM1MonsterHpBarSettingWithTargetPlatform) == 0x000018, "Wrong size on FM1MonsterHpBarSettingWithTargetPlatform");
static_assert(offsetof(FM1MonsterHpBarSettingWithTargetPlatform, Setting) == 0x000000, "Member 'FM1MonsterHpBarSettingWithTargetPlatform::Setting' has a wrong offset!");
static_assert(offsetof(FM1MonsterHpBarSettingWithTargetPlatform, TargetPlatform) == 0x000008, "Member 'FM1MonsterHpBarSettingWithTargetPlatform::TargetPlatform' has a wrong offset!");

// ScriptStruct M1.M1MissionTaskDropContainer
// 0x0098 (0x00A0 - 0x0008)
struct FM1MissionTaskDropContainer final : public FTableRowBase
{
public:
	EM1MissionTaskDropType                        Type;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ItemUIData                          UIData;                                            // 0x0010(0x0060)(Edit, NativeAccessSpecifierPublic)
	class FString                                 StringId;                                          // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         PropClass;                                         // 0x0080(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionTaskDropContainer) == 0x000008, "Wrong alignment on FM1MissionTaskDropContainer");
static_assert(sizeof(FM1MissionTaskDropContainer) == 0x0000A0, "Wrong size on FM1MissionTaskDropContainer");
static_assert(offsetof(FM1MissionTaskDropContainer, Type) == 0x000008, "Member 'FM1MissionTaskDropContainer::Type' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskDropContainer, UIData) == 0x000010, "Member 'FM1MissionTaskDropContainer::UIData' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskDropContainer, StringId) == 0x000070, "Member 'FM1MissionTaskDropContainer::StringId' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskDropContainer, PropClass) == 0x000080, "Member 'FM1MissionTaskDropContainer::PropClass' has a wrong offset!");

// ScriptStruct M1.M1UIThemeData
// 0x0A68 (0x0A70 - 0x0008)
struct FM1UIThemeData final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1TypedUITheme_Brush                  TabControlStyle;                                   // 0x0010(0x00F0)(Edit, NativeAccessSpecifierPublic)
	struct FM1TypedUITheme_Button                 TabButtonStyle;                                    // 0x0100(0x0440)(Edit, NativeAccessSpecifierPublic)
	struct FM1TypedUITheme_Button                 CommonButtonStyle;                                 // 0x0540(0x0440)(Edit, NativeAccessSpecifierPublic)
	struct FM1TypedUITheme_Brush                  MetaBackStyle;                                     // 0x0980(0x00F0)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1UIThemeData) == 0x000010, "Wrong alignment on FM1UIThemeData");
static_assert(sizeof(FM1UIThemeData) == 0x000A70, "Wrong size on FM1UIThemeData");
static_assert(offsetof(FM1UIThemeData, TabControlStyle) == 0x000010, "Member 'FM1UIThemeData::TabControlStyle' has a wrong offset!");
static_assert(offsetof(FM1UIThemeData, TabButtonStyle) == 0x000100, "Member 'FM1UIThemeData::TabButtonStyle' has a wrong offset!");
static_assert(offsetof(FM1UIThemeData, CommonButtonStyle) == 0x000540, "Member 'FM1UIThemeData::CommonButtonStyle' has a wrong offset!");
static_assert(offsetof(FM1UIThemeData, MetaBackStyle) == 0x000980, "Member 'FM1UIThemeData::MetaBackStyle' has a wrong offset!");

// ScriptStruct M1.M1ItemBookmarkTag
// 0x0028 (0x0030 - 0x0008)
struct FM1ItemBookmarkTag final : public FTableRowBase
{
public:
	EM1ItemTagStatus                              Tag;                                               // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Image;                                             // 0x0010(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemBookmarkTag) == 0x000008, "Wrong alignment on FM1ItemBookmarkTag");
static_assert(sizeof(FM1ItemBookmarkTag) == 0x000030, "Wrong size on FM1ItemBookmarkTag");
static_assert(offsetof(FM1ItemBookmarkTag, Tag) == 0x000008, "Member 'FM1ItemBookmarkTag::Tag' has a wrong offset!");
static_assert(offsetof(FM1ItemBookmarkTag, Priority) == 0x00000C, "Member 'FM1ItemBookmarkTag::Priority' has a wrong offset!");
static_assert(offsetof(FM1ItemBookmarkTag, Image) == 0x000010, "Member 'FM1ItemBookmarkTag::Image' has a wrong offset!");

// ScriptStruct M1.M1GameGuideRow
// 0x00E8 (0x00F0 - 0x0008)
struct FM1GameGuideRow final : public FTableRowBase
{
public:
	int32                                         GroupId;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayOnce;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1GameGuideType                              GameGuideType;                                     // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EM1UIPlatform, class FString>            UIStringKeySet;                                    // 0x0018(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FM1GameGuideStartCondition>     StartConditions;                                   // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1GameGuideEndCondition>       EndConditions;                                     // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   TagKey;                                            // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1PositionType                               PositionType;                                      // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1AlignmentType                              AlignmentType;                                     // 0x0091(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1GameGuideHighlightOption            HighlightOption;                                   // 0x0092(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EM1UIPlatform, struct FSoftObjectPath>   VideoPathSet;                                      // 0x0098(0x0050)(Edit, NativeAccessSpecifierPublic)
	bool                                          bPauseGame;                                        // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1GameGuideRow) == 0x000008, "Wrong alignment on FM1GameGuideRow");
static_assert(sizeof(FM1GameGuideRow) == 0x0000F0, "Wrong size on FM1GameGuideRow");
static_assert(offsetof(FM1GameGuideRow, GroupId) == 0x000008, "Member 'FM1GameGuideRow::GroupId' has a wrong offset!");
static_assert(offsetof(FM1GameGuideRow, Priority) == 0x00000C, "Member 'FM1GameGuideRow::Priority' has a wrong offset!");
static_assert(offsetof(FM1GameGuideRow, bDisplayOnce) == 0x000010, "Member 'FM1GameGuideRow::bDisplayOnce' has a wrong offset!");
static_assert(offsetof(FM1GameGuideRow, GameGuideType) == 0x000011, "Member 'FM1GameGuideRow::GameGuideType' has a wrong offset!");
static_assert(offsetof(FM1GameGuideRow, UIStringKeySet) == 0x000018, "Member 'FM1GameGuideRow::UIStringKeySet' has a wrong offset!");
static_assert(offsetof(FM1GameGuideRow, StartConditions) == 0x000068, "Member 'FM1GameGuideRow::StartConditions' has a wrong offset!");
static_assert(offsetof(FM1GameGuideRow, EndConditions) == 0x000078, "Member 'FM1GameGuideRow::EndConditions' has a wrong offset!");
static_assert(offsetof(FM1GameGuideRow, TagKey) == 0x000088, "Member 'FM1GameGuideRow::TagKey' has a wrong offset!");
static_assert(offsetof(FM1GameGuideRow, PositionType) == 0x000090, "Member 'FM1GameGuideRow::PositionType' has a wrong offset!");
static_assert(offsetof(FM1GameGuideRow, AlignmentType) == 0x000091, "Member 'FM1GameGuideRow::AlignmentType' has a wrong offset!");
static_assert(offsetof(FM1GameGuideRow, HighlightOption) == 0x000092, "Member 'FM1GameGuideRow::HighlightOption' has a wrong offset!");
static_assert(offsetof(FM1GameGuideRow, VideoPathSet) == 0x000098, "Member 'FM1GameGuideRow::VideoPathSet' has a wrong offset!");
static_assert(offsetof(FM1GameGuideRow, bPauseGame) == 0x0000E8, "Member 'FM1GameGuideRow::bPauseGame' has a wrong offset!");

// ScriptStruct M1.M1KeySymbolSet
// 0x0050 (0x0050 - 0x0000)
struct FM1KeySymbolSet final
{
public:
	TMap<EM1UIPlatform, struct FM1KeySymbolContent> SymbolContent;                                     // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1KeySymbolSet) == 0x000008, "Wrong alignment on FM1KeySymbolSet");
static_assert(sizeof(FM1KeySymbolSet) == 0x000050, "Wrong size on FM1KeySymbolSet");
static_assert(offsetof(FM1KeySymbolSet, SymbolContent) == 0x000000, "Member 'FM1KeySymbolSet::SymbolContent' has a wrong offset!");

// ScriptStruct M1.M1OptionValueKeySetting
// 0x0088 (0x0088 - 0x0000)
struct FM1OptionValueKeySetting final
{
public:
	EM1BattleKey                                  BattleKey;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1BattleInputChord                    MainKey;                                           // 0x0008(0x0040)(Edit, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
	struct FM1BattleInputChord                    SubKey;                                            // 0x0048(0x0040)(Edit, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1OptionValueKeySetting) == 0x000008, "Wrong alignment on FM1OptionValueKeySetting");
static_assert(sizeof(FM1OptionValueKeySetting) == 0x000088, "Wrong size on FM1OptionValueKeySetting");
static_assert(offsetof(FM1OptionValueKeySetting, BattleKey) == 0x000000, "Member 'FM1OptionValueKeySetting::BattleKey' has a wrong offset!");
static_assert(offsetof(FM1OptionValueKeySetting, MainKey) == 0x000008, "Member 'FM1OptionValueKeySetting::MainKey' has a wrong offset!");
static_assert(offsetof(FM1OptionValueKeySetting, SubKey) == 0x000048, "Member 'FM1OptionValueKeySetting::SubKey' has a wrong offset!");

// ScriptStruct M1.M1RandomBox
// 0x0028 (0x0028 - 0x0000)
struct FM1RandomBox final
{
public:
	TArray<int32>                                 SourcePickUps;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 PickUps;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         TotalElementCount;                                 // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NextPickUpIndex;                                   // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1RandomBox) == 0x000008, "Wrong alignment on FM1RandomBox");
static_assert(sizeof(FM1RandomBox) == 0x000028, "Wrong size on FM1RandomBox");
static_assert(offsetof(FM1RandomBox, SourcePickUps) == 0x000000, "Member 'FM1RandomBox::SourcePickUps' has a wrong offset!");
static_assert(offsetof(FM1RandomBox, PickUps) == 0x000010, "Member 'FM1RandomBox::PickUps' has a wrong offset!");
static_assert(offsetof(FM1RandomBox, TotalElementCount) == 0x000020, "Member 'FM1RandomBox::TotalElementCount' has a wrong offset!");
static_assert(offsetof(FM1RandomBox, NextPickUpIndex) == 0x000024, "Member 'FM1RandomBox::NextPickUpIndex' has a wrong offset!");

// ScriptStruct M1.M1ReplicatedFollowSocialMotionInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1ReplicatedFollowSocialMotionInfo final
{
public:
	TArray<TWeakObjectPtr<class UM1FollowSocialMotion>> Motions;                                           // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ReplicatedFollowSocialMotionInfo) == 0x000008, "Wrong alignment on FM1ReplicatedFollowSocialMotionInfo");
static_assert(sizeof(FM1ReplicatedFollowSocialMotionInfo) == 0x000010, "Wrong size on FM1ReplicatedFollowSocialMotionInfo");
static_assert(offsetof(FM1ReplicatedFollowSocialMotionInfo, Motions) == 0x000000, "Member 'FM1ReplicatedFollowSocialMotionInfo::Motions' has a wrong offset!");

// ScriptStruct M1.M1InteractionRule
// 0x0010 (0x0010 - 0x0000)
struct FM1InteractionRule final
{
public:
	TSubclassOf<class UM1InteractableEntity>      EntityClass;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UM1InteractionJudgeRule>    RuleClass;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InteractionRule) == 0x000008, "Wrong alignment on FM1InteractionRule");
static_assert(sizeof(FM1InteractionRule) == 0x000010, "Wrong size on FM1InteractionRule");
static_assert(offsetof(FM1InteractionRule, EntityClass) == 0x000000, "Member 'FM1InteractionRule::EntityClass' has a wrong offset!");
static_assert(offsetof(FM1InteractionRule, RuleClass) == 0x000008, "Member 'FM1InteractionRule::RuleClass' has a wrong offset!");

// ScriptStruct M1.M1BestInteractableEntities
// 0x0010 (0x0010 - 0x0000)
struct FM1BestInteractableEntities final
{
public:
	TArray<class UM1InteractableEntity*>          Entities;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1BestInteractableEntities) == 0x000008, "Wrong alignment on FM1BestInteractableEntities");
static_assert(sizeof(FM1BestInteractableEntities) == 0x000010, "Wrong size on FM1BestInteractableEntities");
static_assert(offsetof(FM1BestInteractableEntities, Entities) == 0x000000, "Member 'FM1BestInteractableEntities::Entities' has a wrong offset!");

// ScriptStruct M1.M1EquipmentRandomOptionValue
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FM1EquipmentRandomOptionValue final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1EquipmentRandomOptionValue) == 0x000008, "Wrong alignment on FM1EquipmentRandomOptionValue");
static_assert(sizeof(FM1EquipmentRandomOptionValue) == 0x000020, "Wrong size on FM1EquipmentRandomOptionValue");

// ScriptStruct M1.M1LaboratorySpawnSetting
// 0x0028 (0x0028 - 0x0000)
struct FM1LaboratorySpawnSetting final
{
public:
	int32                                         SpawnDataIndex;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SpawnMonsterDataRowNames;                          // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MonsterLevel;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterCount;                                      // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FormationIndex;                                    // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1LaboratorySpawnSetting) == 0x000008, "Wrong alignment on FM1LaboratorySpawnSetting");
static_assert(sizeof(FM1LaboratorySpawnSetting) == 0x000028, "Wrong size on FM1LaboratorySpawnSetting");
static_assert(offsetof(FM1LaboratorySpawnSetting, SpawnDataIndex) == 0x000000, "Member 'FM1LaboratorySpawnSetting::SpawnDataIndex' has a wrong offset!");
static_assert(offsetof(FM1LaboratorySpawnSetting, SpawnMonsterDataRowNames) == 0x000008, "Member 'FM1LaboratorySpawnSetting::SpawnMonsterDataRowNames' has a wrong offset!");
static_assert(offsetof(FM1LaboratorySpawnSetting, MonsterLevel) == 0x000018, "Member 'FM1LaboratorySpawnSetting::MonsterLevel' has a wrong offset!");
static_assert(offsetof(FM1LaboratorySpawnSetting, MonsterCount) == 0x00001C, "Member 'FM1LaboratorySpawnSetting::MonsterCount' has a wrong offset!");
static_assert(offsetof(FM1LaboratorySpawnSetting, FormationIndex) == 0x000020, "Member 'FM1LaboratorySpawnSetting::FormationIndex' has a wrong offset!");

// ScriptStruct M1.M1ExtractedLevelInfo
// 0x0028 (0x0028 - 0x0000)
struct FM1ExtractedLevelInfo final
{
public:
	class FName                                   LevelName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MapObjectSoftPath;                                 // 0x0008(0x0020)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ExtractedLevelInfo) == 0x000008, "Wrong alignment on FM1ExtractedLevelInfo");
static_assert(sizeof(FM1ExtractedLevelInfo) == 0x000028, "Wrong size on FM1ExtractedLevelInfo");
static_assert(offsetof(FM1ExtractedLevelInfo, LevelName) == 0x000000, "Member 'FM1ExtractedLevelInfo::LevelName' has a wrong offset!");
static_assert(offsetof(FM1ExtractedLevelInfo, MapObjectSoftPath) == 0x000008, "Member 'FM1ExtractedLevelInfo::MapObjectSoftPath' has a wrong offset!");

// ScriptStruct M1.M1SequencePlayBackSettings
// 0x0078 (0x0078 - 0x0000)
struct FM1SequencePlayBackSettings final
{
public:
	struct FMovieSceneSequencePlaybackSettings    PlaybackSettings;                                  // 0x0000(0x0024)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bReplicatePlayback;                                // 0x0024(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        LevelSequence;                                     // 0x0028(0x0020)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AM1LevelSequenceActor>      SequenceActorClass;                                // 0x0048(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ObjectHasMovieSceneTransform;                      // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginLocationOffset;                              // 0x0058(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OriginRotationOffset;                              // 0x0064(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bActivateSkipButton;                               // 0x0070(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SequencePlayBackSettings) == 0x000008, "Wrong alignment on FM1SequencePlayBackSettings");
static_assert(sizeof(FM1SequencePlayBackSettings) == 0x000078, "Wrong size on FM1SequencePlayBackSettings");
static_assert(offsetof(FM1SequencePlayBackSettings, PlaybackSettings) == 0x000000, "Member 'FM1SequencePlayBackSettings::PlaybackSettings' has a wrong offset!");
static_assert(offsetof(FM1SequencePlayBackSettings, bReplicatePlayback) == 0x000024, "Member 'FM1SequencePlayBackSettings::bReplicatePlayback' has a wrong offset!");
static_assert(offsetof(FM1SequencePlayBackSettings, LevelSequence) == 0x000028, "Member 'FM1SequencePlayBackSettings::LevelSequence' has a wrong offset!");
static_assert(offsetof(FM1SequencePlayBackSettings, SequenceActorClass) == 0x000048, "Member 'FM1SequencePlayBackSettings::SequenceActorClass' has a wrong offset!");
static_assert(offsetof(FM1SequencePlayBackSettings, ObjectHasMovieSceneTransform) == 0x000050, "Member 'FM1SequencePlayBackSettings::ObjectHasMovieSceneTransform' has a wrong offset!");
static_assert(offsetof(FM1SequencePlayBackSettings, OriginLocationOffset) == 0x000058, "Member 'FM1SequencePlayBackSettings::OriginLocationOffset' has a wrong offset!");
static_assert(offsetof(FM1SequencePlayBackSettings, OriginRotationOffset) == 0x000064, "Member 'FM1SequencePlayBackSettings::OriginRotationOffset' has a wrong offset!");
static_assert(offsetof(FM1SequencePlayBackSettings, bActivateSkipButton) == 0x000070, "Member 'FM1SequencePlayBackSettings::bActivateSkipButton' has a wrong offset!");

// ScriptStruct M1.M1LobbySequenceTrackData
// 0x0008 (0x0040 - 0x0038)
struct FM1LobbySequenceTrackData final : public FM1SequenceTrackData
{
public:
	EM1LobbySequenceTrackType                     SequenceType;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LobbySequenceTrackType                     InterruptionSequenceType;                          // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterruptionDelaySecond;                           // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1LobbySequenceTrackData) == 0x000008, "Wrong alignment on FM1LobbySequenceTrackData");
static_assert(sizeof(FM1LobbySequenceTrackData) == 0x000040, "Wrong size on FM1LobbySequenceTrackData");
static_assert(offsetof(FM1LobbySequenceTrackData, SequenceType) == 0x000038, "Member 'FM1LobbySequenceTrackData::SequenceType' has a wrong offset!");
static_assert(offsetof(FM1LobbySequenceTrackData, InterruptionSequenceType) == 0x000039, "Member 'FM1LobbySequenceTrackData::InterruptionSequenceType' has a wrong offset!");
static_assert(offsetof(FM1LobbySequenceTrackData, InterruptionDelaySecond) == 0x00003C, "Member 'FM1LobbySequenceTrackData::InterruptionDelaySecond' has a wrong offset!");

// ScriptStruct M1.M1LocalActorVisibilityInfo
// 0x0002 (0x0002 - 0x0000)
struct FM1LocalActorVisibilityInfo final
{
public:
	bool                                          bLastHidden;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFiltered;                                         // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1LocalActorVisibilityInfo) == 0x000001, "Wrong alignment on FM1LocalActorVisibilityInfo");
static_assert(sizeof(FM1LocalActorVisibilityInfo) == 0x000002, "Wrong size on FM1LocalActorVisibilityInfo");
static_assert(offsetof(FM1LocalActorVisibilityInfo, bLastHidden) == 0x000000, "Member 'FM1LocalActorVisibilityInfo::bLastHidden' has a wrong offset!");
static_assert(offsetof(FM1LocalActorVisibilityInfo, bFiltered) == 0x000001, "Member 'FM1LocalActorVisibilityInfo::bFiltered' has a wrong offset!");

// ScriptStruct M1.LocalizationData
// 0x0010 (0x0010 - 0x0000)
struct FLocalizationData final
{
public:
	class FString                                 Text;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocalizationData) == 0x000008, "Wrong alignment on FLocalizationData");
static_assert(sizeof(FLocalizationData) == 0x000010, "Wrong size on FLocalizationData");
static_assert(offsetof(FLocalizationData, Text) == 0x000000, "Member 'FLocalizationData::Text' has a wrong offset!");

// ScriptStruct M1.M1FieldObjectSpawnData
// 0x000C (0x000C - 0x0000)
struct FM1FieldObjectSpawnData final
{
public:
	float                                         Rate;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FieldObjectRowName;                                // 0x0004(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FieldObjectSpawnData) == 0x000004, "Wrong alignment on FM1FieldObjectSpawnData");
static_assert(sizeof(FM1FieldObjectSpawnData) == 0x00000C, "Wrong size on FM1FieldObjectSpawnData");
static_assert(offsetof(FM1FieldObjectSpawnData, Rate) == 0x000000, "Member 'FM1FieldObjectSpawnData::Rate' has a wrong offset!");
static_assert(offsetof(FM1FieldObjectSpawnData, FieldObjectRowName) == 0x000004, "Member 'FM1FieldObjectSpawnData::FieldObjectRowName' has a wrong offset!");

// ScriptStruct M1.M1MonsterDropDataWrapper
// 0x0018 (0x0018 - 0x0000)
struct FM1MonsterDropDataWrapper final
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0000(0x0004)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1MonsterDropData>             MonsterDropDataList;                               // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterDropDataWrapper) == 0x000008, "Wrong alignment on FM1MonsterDropDataWrapper");
static_assert(sizeof(FM1MonsterDropDataWrapper) == 0x000018, "Wrong size on FM1MonsterDropDataWrapper");
static_assert(offsetof(FM1MonsterDropDataWrapper, TemplateId) == 0x000000, "Member 'FM1MonsterDropDataWrapper::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1MonsterDropDataWrapper, MonsterDropDataList) == 0x000008, "Member 'FM1MonsterDropDataWrapper::MonsterDropDataList' has a wrong offset!");

// ScriptStruct M1.M1MasteryLevelStat
// 0x0018 (0x0018 - 0x0000)
struct FM1MasteryLevelStat final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Exp;                                               // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MasteryLevelStat) == 0x000008, "Wrong alignment on FM1MasteryLevelStat");
static_assert(sizeof(FM1MasteryLevelStat) == 0x000018, "Wrong size on FM1MasteryLevelStat");
static_assert(offsetof(FM1MasteryLevelStat, Level) == 0x000000, "Member 'FM1MasteryLevelStat::Level' has a wrong offset!");
static_assert(offsetof(FM1MasteryLevelStat, Exp) == 0x000008, "Member 'FM1MasteryLevelStat::Exp' has a wrong offset!");

// ScriptStruct M1.M1ManipulatorCreationParam
// 0x0020 (0x0020 - 0x0000)
struct FM1ManipulatorCreationParam final
{
public:
	class UMeshComponent*                         TargetMesh;                                        // 0x0000(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     SourceMaterial;                                    // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UM1MaterialManipulator>     OptionalClass;                                     // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ManipulatorCreationParam) == 0x000008, "Wrong alignment on FM1ManipulatorCreationParam");
static_assert(sizeof(FM1ManipulatorCreationParam) == 0x000020, "Wrong size on FM1ManipulatorCreationParam");
static_assert(offsetof(FM1ManipulatorCreationParam, TargetMesh) == 0x000000, "Member 'FM1ManipulatorCreationParam::TargetMesh' has a wrong offset!");
static_assert(offsetof(FM1ManipulatorCreationParam, MaterialIndex) == 0x000008, "Member 'FM1ManipulatorCreationParam::MaterialIndex' has a wrong offset!");
static_assert(offsetof(FM1ManipulatorCreationParam, SourceMaterial) == 0x000010, "Member 'FM1ManipulatorCreationParam::SourceMaterial' has a wrong offset!");
static_assert(offsetof(FM1ManipulatorCreationParam, OptionalClass) == 0x000018, "Member 'FM1ManipulatorCreationParam::OptionalClass' has a wrong offset!");

// ScriptStruct M1.M1MiniGameStartParams
// 0x0010 (0x0010 - 0x0000)
struct FM1MiniGameStartParams final
{
public:
	struct FM1TemplateId                          MiniGameTemplateId;                                // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          PlayerTemplateId;                                  // 0x0004(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          FieldDifficultyTemplateId;                         // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MiniGameDifficulty                         Difficulty;                                        // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MiniGameStartParams) == 0x000004, "Wrong alignment on FM1MiniGameStartParams");
static_assert(sizeof(FM1MiniGameStartParams) == 0x000010, "Wrong size on FM1MiniGameStartParams");
static_assert(offsetof(FM1MiniGameStartParams, MiniGameTemplateId) == 0x000000, "Member 'FM1MiniGameStartParams::MiniGameTemplateId' has a wrong offset!");
static_assert(offsetof(FM1MiniGameStartParams, PlayerTemplateId) == 0x000004, "Member 'FM1MiniGameStartParams::PlayerTemplateId' has a wrong offset!");
static_assert(offsetof(FM1MiniGameStartParams, FieldDifficultyTemplateId) == 0x000008, "Member 'FM1MiniGameStartParams::FieldDifficultyTemplateId' has a wrong offset!");
static_assert(offsetof(FM1MiniGameStartParams, Difficulty) == 0x00000C, "Member 'FM1MiniGameStartParams::Difficulty' has a wrong offset!");

// ScriptStruct M1.M1DropShipRepInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1DropShipRepInfo final
{
public:
	float                                         Alpha;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Destination;                                       // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DropShipRepInfo) == 0x000004, "Wrong alignment on FM1DropShipRepInfo");
static_assert(sizeof(FM1DropShipRepInfo) == 0x000010, "Wrong size on FM1DropShipRepInfo");
static_assert(offsetof(FM1DropShipRepInfo, Alpha) == 0x000000, "Member 'FM1DropShipRepInfo::Alpha' has a wrong offset!");
static_assert(offsetof(FM1DropShipRepInfo, Destination) == 0x000004, "Member 'FM1DropShipRepInfo::Destination' has a wrong offset!");

// ScriptStruct M1.M1MissionBalanceDumpData
// 0x0038 (0x0038 - 0x0000)
struct FM1MissionBalanceDumpData final
{
public:
	struct FM1TemplateId                          MissionTemplateId;                                 // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         KilledMonsterCount;                                // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FM1MissionBalanceDumpDataWithTemplateId> FieldObjects;                                      // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FM1MissionBalanceDumpDataWithTemplateId> DroppedItems;                                      // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FM1MissionBalanceDumpDataWithTemplateId> UsedItems;                                         // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1MissionBalanceDumpData) == 0x000008, "Wrong alignment on FM1MissionBalanceDumpData");
static_assert(sizeof(FM1MissionBalanceDumpData) == 0x000038, "Wrong size on FM1MissionBalanceDumpData");
static_assert(offsetof(FM1MissionBalanceDumpData, MissionTemplateId) == 0x000000, "Member 'FM1MissionBalanceDumpData::MissionTemplateId' has a wrong offset!");
static_assert(offsetof(FM1MissionBalanceDumpData, KilledMonsterCount) == 0x000004, "Member 'FM1MissionBalanceDumpData::KilledMonsterCount' has a wrong offset!");
static_assert(offsetof(FM1MissionBalanceDumpData, FieldObjects) == 0x000008, "Member 'FM1MissionBalanceDumpData::FieldObjects' has a wrong offset!");
static_assert(offsetof(FM1MissionBalanceDumpData, DroppedItems) == 0x000018, "Member 'FM1MissionBalanceDumpData::DroppedItems' has a wrong offset!");
static_assert(offsetof(FM1MissionBalanceDumpData, UsedItems) == 0x000028, "Member 'FM1MissionBalanceDumpData::UsedItems' has a wrong offset!");

// ScriptStruct M1.M1SimpleMissionPlayerJoinInfoForRPC
// 0x0020 (0x0020 - 0x0000)
struct FM1SimpleMissionPlayerJoinInfoForRPC final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlatformOnlineId;                                  // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SimpleMissionPlayerJoinInfoForRPC) == 0x000008, "Wrong alignment on FM1SimpleMissionPlayerJoinInfoForRPC");
static_assert(sizeof(FM1SimpleMissionPlayerJoinInfoForRPC) == 0x000020, "Wrong size on FM1SimpleMissionPlayerJoinInfoForRPC");
static_assert(offsetof(FM1SimpleMissionPlayerJoinInfoForRPC, PlayerName) == 0x000000, "Member 'FM1SimpleMissionPlayerJoinInfoForRPC::PlayerName' has a wrong offset!");
static_assert(offsetof(FM1SimpleMissionPlayerJoinInfoForRPC, PlatformOnlineId) == 0x000010, "Member 'FM1SimpleMissionPlayerJoinInfoForRPC::PlatformOnlineId' has a wrong offset!");

// ScriptStruct M1.M1MissionScore
// 0x000C (0x000C - 0x0000)
struct FM1MissionScore final
{
public:
	int32                                         ScoreByMonsterKill;                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScoreByModifierBonus;                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScoreByTaskSucceeded;                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionScore) == 0x000004, "Wrong alignment on FM1MissionScore");
static_assert(sizeof(FM1MissionScore) == 0x00000C, "Wrong size on FM1MissionScore");
static_assert(offsetof(FM1MissionScore, ScoreByMonsterKill) == 0x000000, "Member 'FM1MissionScore::ScoreByMonsterKill' has a wrong offset!");
static_assert(offsetof(FM1MissionScore, ScoreByModifierBonus) == 0x000004, "Member 'FM1MissionScore::ScoreByModifierBonus' has a wrong offset!");
static_assert(offsetof(FM1MissionScore, ScoreByTaskSucceeded) == 0x000008, "Member 'FM1MissionScore::ScoreByTaskSucceeded' has a wrong offset!");

// ScriptStruct M1.M1MissionTableRow
// 0x0030 (0x0038 - 0x0008)
struct FM1MissionTableRow final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UM1DataMission>          MissionData;                                       // 0x0008(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionTableRow) == 0x000008, "Wrong alignment on FM1MissionTableRow");
static_assert(sizeof(FM1MissionTableRow) == 0x000038, "Wrong size on FM1MissionTableRow");
static_assert(offsetof(FM1MissionTableRow, MissionData) == 0x000008, "Member 'FM1MissionTableRow::MissionData' has a wrong offset!");

// ScriptStruct M1.M1TMissionTimeLimiter
// 0x000C (0x000C - 0x0000)
struct FM1TMissionTimeLimiter final
{
public:
	bool                                          bUseTimeLimit;                                     // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LimitTime;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ElapsedTimeSince;                                  // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1TMissionTimeLimiter) == 0x000004, "Wrong alignment on FM1TMissionTimeLimiter");
static_assert(sizeof(FM1TMissionTimeLimiter) == 0x00000C, "Wrong size on FM1TMissionTimeLimiter");
static_assert(offsetof(FM1TMissionTimeLimiter, bUseTimeLimit) == 0x000000, "Member 'FM1TMissionTimeLimiter::bUseTimeLimit' has a wrong offset!");
static_assert(offsetof(FM1TMissionTimeLimiter, LimitTime) == 0x000004, "Member 'FM1TMissionTimeLimiter::LimitTime' has a wrong offset!");
static_assert(offsetof(FM1TMissionTimeLimiter, ElapsedTimeSince) == 0x000008, "Member 'FM1TMissionTimeLimiter::ElapsedTimeSince' has a wrong offset!");

// ScriptStruct M1.M1ActorsSpawnedInMission
// 0x00A0 (0x00A0 - 0x0000)
struct FM1ActorsSpawnedInMission final
{
public:
	TSet<class AActor*>                           Actors;                                            // 0x0000(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class AActor*>                           MonstersForFastSearch;                             // 0x0050(0x0050)(Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1ActorsSpawnedInMission) == 0x000008, "Wrong alignment on FM1ActorsSpawnedInMission");
static_assert(sizeof(FM1ActorsSpawnedInMission) == 0x0000A0, "Wrong size on FM1ActorsSpawnedInMission");
static_assert(offsetof(FM1ActorsSpawnedInMission, Actors) == 0x000000, "Member 'FM1ActorsSpawnedInMission::Actors' has a wrong offset!");
static_assert(offsetof(FM1ActorsSpawnedInMission, MonstersForFastSearch) == 0x000050, "Member 'FM1ActorsSpawnedInMission::MonstersForFastSearch' has a wrong offset!");

// ScriptStruct M1.M1MissionRewardWeaponProficiencyExp
// 0x0008 (0x0038 - 0x0030)
struct FM1MissionRewardWeaponProficiencyExp final : public FM1MissionRewardExp
{
public:
	struct FM1TemplateId                          WeaponTemplateId;                                  // 0x0030(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MissionRewardWeaponProficiencyExp) == 0x000008, "Wrong alignment on FM1MissionRewardWeaponProficiencyExp");
static_assert(sizeof(FM1MissionRewardWeaponProficiencyExp) == 0x000038, "Wrong size on FM1MissionRewardWeaponProficiencyExp");
static_assert(offsetof(FM1MissionRewardWeaponProficiencyExp, WeaponTemplateId) == 0x000030, "Member 'FM1MissionRewardWeaponProficiencyExp::WeaponTemplateId' has a wrong offset!");

// ScriptStruct M1.M1MissionRewardCurrency
// 0x0008 (0x0030 - 0x0028)
struct FM1MissionRewardCurrency final : public FM1MissionRewardBase
{
public:
	EM1CurrencyType                               CurrencyType;                                      // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MissionRewardCurrency) == 0x000008, "Wrong alignment on FM1MissionRewardCurrency");
static_assert(sizeof(FM1MissionRewardCurrency) == 0x000030, "Wrong size on FM1MissionRewardCurrency");
static_assert(offsetof(FM1MissionRewardCurrency, CurrencyType) == 0x000028, "Member 'FM1MissionRewardCurrency::CurrencyType' has a wrong offset!");

// ScriptStruct M1.M1MissionRewardItem
// 0x0010 (0x0010 - 0x0000)
struct FM1MissionRewardItem final
{
public:
	TWeakObjectPtr<class UM1InventoryItem>        InventoryItem;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Quantity;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionRewardItem) == 0x000008, "Wrong alignment on FM1MissionRewardItem");
static_assert(sizeof(FM1MissionRewardItem) == 0x000010, "Wrong size on FM1MissionRewardItem");
static_assert(offsetof(FM1MissionRewardItem, InventoryItem) == 0x000000, "Member 'FM1MissionRewardItem::InventoryItem' has a wrong offset!");
static_assert(offsetof(FM1MissionRewardItem, Quantity) == 0x000008, "Member 'FM1MissionRewardItem::Quantity' has a wrong offset!");

// ScriptStruct M1.M1MissionRewardedWrapper
// 0x00D0 (0x00D0 - 0x0000)
struct FM1MissionRewardedWrapper final
{
public:
	struct FM1MissionRewardBase                   MasteryRankExpByLevelUpReward;                     // 0x0000(0x0028)(NativeAccessSpecifierPublic)
	struct FM1MissionRewardBase                   MasteryRankExpByMissionClear;                      // 0x0028(0x0028)(NativeAccessSpecifierPublic)
	struct FM1MissionRewardBase                   CharacterExpByMonsterKill;                         // 0x0050(0x0028)(NativeAccessSpecifierPublic)
	struct FM1MissionRewardBase                   CharacterExpByMissionClear;                        // 0x0078(0x0028)(NativeAccessSpecifierPublic)
	TArray<struct FM1MissionRewardWeaponProficiencyExp> WeaponProficiencyExpList;                          // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1MissionRewardCurrency>       Currencies;                                        // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         TotalScoreByMonsterKill;                           // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalScoreBySucceededTask;                         // 0x00C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalScoreByModifierBonus;                         // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MissionRewardedWrapper) == 0x000008, "Wrong alignment on FM1MissionRewardedWrapper");
static_assert(sizeof(FM1MissionRewardedWrapper) == 0x0000D0, "Wrong size on FM1MissionRewardedWrapper");
static_assert(offsetof(FM1MissionRewardedWrapper, MasteryRankExpByLevelUpReward) == 0x000000, "Member 'FM1MissionRewardedWrapper::MasteryRankExpByLevelUpReward' has a wrong offset!");
static_assert(offsetof(FM1MissionRewardedWrapper, MasteryRankExpByMissionClear) == 0x000028, "Member 'FM1MissionRewardedWrapper::MasteryRankExpByMissionClear' has a wrong offset!");
static_assert(offsetof(FM1MissionRewardedWrapper, CharacterExpByMonsterKill) == 0x000050, "Member 'FM1MissionRewardedWrapper::CharacterExpByMonsterKill' has a wrong offset!");
static_assert(offsetof(FM1MissionRewardedWrapper, CharacterExpByMissionClear) == 0x000078, "Member 'FM1MissionRewardedWrapper::CharacterExpByMissionClear' has a wrong offset!");
static_assert(offsetof(FM1MissionRewardedWrapper, WeaponProficiencyExpList) == 0x0000A0, "Member 'FM1MissionRewardedWrapper::WeaponProficiencyExpList' has a wrong offset!");
static_assert(offsetof(FM1MissionRewardedWrapper, Currencies) == 0x0000B0, "Member 'FM1MissionRewardedWrapper::Currencies' has a wrong offset!");
static_assert(offsetof(FM1MissionRewardedWrapper, TotalScoreByMonsterKill) == 0x0000C0, "Member 'FM1MissionRewardedWrapper::TotalScoreByMonsterKill' has a wrong offset!");
static_assert(offsetof(FM1MissionRewardedWrapper, TotalScoreBySucceededTask) == 0x0000C4, "Member 'FM1MissionRewardedWrapper::TotalScoreBySucceededTask' has a wrong offset!");
static_assert(offsetof(FM1MissionRewardedWrapper, TotalScoreByModifierBonus) == 0x0000C8, "Member 'FM1MissionRewardedWrapper::TotalScoreByModifierBonus' has a wrong offset!");

// ScriptStruct M1.M1AutoStartMission
// 0x00B0 (0x00B0 - 0x0000)
struct FM1AutoStartMission final
{
public:
	class AM1MissionActor*                        MissionActor;                                      // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AM1PlayerControllerInGame*>      ReadyControllers;                                  // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           TimerHandle_StartGameDelayed;                      // 0x0018(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           TimerHandle_CountdownToMissionStart;               // 0x0020(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bGameStarted;                                      // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CountdownToMissionStart;                           // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AM1PlayerControllerInGame*>        PCsAreWaitingForMission;                           // 0x0060(0x0050)(Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1AutoStartMission) == 0x000008, "Wrong alignment on FM1AutoStartMission");
static_assert(sizeof(FM1AutoStartMission) == 0x0000B0, "Wrong size on FM1AutoStartMission");
static_assert(offsetof(FM1AutoStartMission, MissionActor) == 0x000000, "Member 'FM1AutoStartMission::MissionActor' has a wrong offset!");
static_assert(offsetof(FM1AutoStartMission, ReadyControllers) == 0x000008, "Member 'FM1AutoStartMission::ReadyControllers' has a wrong offset!");
static_assert(offsetof(FM1AutoStartMission, TimerHandle_StartGameDelayed) == 0x000018, "Member 'FM1AutoStartMission::TimerHandle_StartGameDelayed' has a wrong offset!");
static_assert(offsetof(FM1AutoStartMission, TimerHandle_CountdownToMissionStart) == 0x000020, "Member 'FM1AutoStartMission::TimerHandle_CountdownToMissionStart' has a wrong offset!");
static_assert(offsetof(FM1AutoStartMission, bGameStarted) == 0x000028, "Member 'FM1AutoStartMission::bGameStarted' has a wrong offset!");
static_assert(offsetof(FM1AutoStartMission, CountdownToMissionStart) == 0x00002C, "Member 'FM1AutoStartMission::CountdownToMissionStart' has a wrong offset!");
static_assert(offsetof(FM1AutoStartMission, PCsAreWaitingForMission) == 0x000060, "Member 'FM1AutoStartMission::PCsAreWaitingForMission' has a wrong offset!");

// ScriptStruct M1.M1MissionCategoryUIData
// 0x0048 (0x0048 - 0x0000)
struct FM1MissionCategoryUIData final
{
public:
	class FName                                   StringId;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                NewMissionIconPaths;                               // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                PlayableMissionIconPaths;                          // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                DimmedMissionIconPaths;                            // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                HardMissionIconPaths;                              // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionCategoryUIData) == 0x000008, "Wrong alignment on FM1MissionCategoryUIData");
static_assert(sizeof(FM1MissionCategoryUIData) == 0x000048, "Wrong size on FM1MissionCategoryUIData");
static_assert(offsetof(FM1MissionCategoryUIData, StringId) == 0x000000, "Member 'FM1MissionCategoryUIData::StringId' has a wrong offset!");
static_assert(offsetof(FM1MissionCategoryUIData, NewMissionIconPaths) == 0x000008, "Member 'FM1MissionCategoryUIData::NewMissionIconPaths' has a wrong offset!");
static_assert(offsetof(FM1MissionCategoryUIData, PlayableMissionIconPaths) == 0x000018, "Member 'FM1MissionCategoryUIData::PlayableMissionIconPaths' has a wrong offset!");
static_assert(offsetof(FM1MissionCategoryUIData, DimmedMissionIconPaths) == 0x000028, "Member 'FM1MissionCategoryUIData::DimmedMissionIconPaths' has a wrong offset!");
static_assert(offsetof(FM1MissionCategoryUIData, HardMissionIconPaths) == 0x000038, "Member 'FM1MissionCategoryUIData::HardMissionIconPaths' has a wrong offset!");

// ScriptStruct M1.M1InstanceDungeonModifierDataByPlayerCount
// 0x0018 (0x0018 - 0x0000)
struct FM1InstanceDungeonModifierDataByPlayerCount final
{
public:
	int32                                         PlayerCount;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AbilityRowName;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstanceDungeonModifierDataByPlayerCount) == 0x000008, "Wrong alignment on FM1InstanceDungeonModifierDataByPlayerCount");
static_assert(sizeof(FM1InstanceDungeonModifierDataByPlayerCount) == 0x000018, "Wrong size on FM1InstanceDungeonModifierDataByPlayerCount");
static_assert(offsetof(FM1InstanceDungeonModifierDataByPlayerCount, PlayerCount) == 0x000000, "Member 'FM1InstanceDungeonModifierDataByPlayerCount::PlayerCount' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonModifierDataByPlayerCount, AbilityRowName) == 0x000008, "Member 'FM1InstanceDungeonModifierDataByPlayerCount::AbilityRowName' has a wrong offset!");

// ScriptStruct M1.M1MissionTargetActivationInfo
// 0x0003 (0x0003 - 0x0000)
struct FM1MissionTargetActivationInfo final
{
public:
	bool                                          bActivated;                                        // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bParentTaskActivated;                              // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EM1ResetType                                  ResetType;                                         // 0x0002(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1MissionTargetActivationInfo) == 0x000001, "Wrong alignment on FM1MissionTargetActivationInfo");
static_assert(sizeof(FM1MissionTargetActivationInfo) == 0x000003, "Wrong size on FM1MissionTargetActivationInfo");
static_assert(offsetof(FM1MissionTargetActivationInfo, bActivated) == 0x000000, "Member 'FM1MissionTargetActivationInfo::bActivated' has a wrong offset!");
static_assert(offsetof(FM1MissionTargetActivationInfo, bParentTaskActivated) == 0x000001, "Member 'FM1MissionTargetActivationInfo::bParentTaskActivated' has a wrong offset!");
static_assert(offsetof(FM1MissionTargetActivationInfo, ResetType) == 0x000002, "Member 'FM1MissionTargetActivationInfo::ResetType' has a wrong offset!");

// ScriptStruct M1.M1MissionTargetDestructionIronHeartFXData
// 0x0040 (0x0040 - 0x0000)
struct FM1MissionTargetDestructionIronHeartFXData final
{
public:
	TArray<TSoftObjectPtr<class UNiagaraSystem>>  FXAssets;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioEvent>           AkEvent;                                           // 0x0010(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionTargetDestructionIronHeartFXData) == 0x000008, "Wrong alignment on FM1MissionTargetDestructionIronHeartFXData");
static_assert(sizeof(FM1MissionTargetDestructionIronHeartFXData) == 0x000040, "Wrong size on FM1MissionTargetDestructionIronHeartFXData");
static_assert(offsetof(FM1MissionTargetDestructionIronHeartFXData, FXAssets) == 0x000000, "Member 'FM1MissionTargetDestructionIronHeartFXData::FXAssets' has a wrong offset!");
static_assert(offsetof(FM1MissionTargetDestructionIronHeartFXData, AkEvent) == 0x000010, "Member 'FM1MissionTargetDestructionIronHeartFXData::AkEvent' has a wrong offset!");

// ScriptStruct M1.M1MissionObjectBarrierActivatorBarrierData
// 0x0070 (0x0070 - 0x0000)
struct FM1MissionObjectBarrierActivatorBarrierData final
{
public:
	EM1MissionObjectBarrierActivatorBarrierFxType Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartDelay;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          StartFxAsset;                                      // 0x0008(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextDelay;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UNiagaraSystem>          NextFxAsset;                                       // 0x0040(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionObjectBarrierActivatorBarrierData) == 0x000008, "Wrong alignment on FM1MissionObjectBarrierActivatorBarrierData");
static_assert(sizeof(FM1MissionObjectBarrierActivatorBarrierData) == 0x000070, "Wrong size on FM1MissionObjectBarrierActivatorBarrierData");
static_assert(offsetof(FM1MissionObjectBarrierActivatorBarrierData, Type) == 0x000000, "Member 'FM1MissionObjectBarrierActivatorBarrierData::Type' has a wrong offset!");
static_assert(offsetof(FM1MissionObjectBarrierActivatorBarrierData, StartDelay) == 0x000004, "Member 'FM1MissionObjectBarrierActivatorBarrierData::StartDelay' has a wrong offset!");
static_assert(offsetof(FM1MissionObjectBarrierActivatorBarrierData, StartFxAsset) == 0x000008, "Member 'FM1MissionObjectBarrierActivatorBarrierData::StartFxAsset' has a wrong offset!");
static_assert(offsetof(FM1MissionObjectBarrierActivatorBarrierData, NextDelay) == 0x000038, "Member 'FM1MissionObjectBarrierActivatorBarrierData::NextDelay' has a wrong offset!");
static_assert(offsetof(FM1MissionObjectBarrierActivatorBarrierData, NextFxAsset) == 0x000040, "Member 'FM1MissionObjectBarrierActivatorBarrierData::NextFxAsset' has a wrong offset!");

// ScriptStruct M1.M1DropItemList
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FM1DropItemList final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1DropItemList) == 0x000008, "Wrong alignment on FM1DropItemList");
static_assert(sizeof(FM1DropItemList) == 0x000010, "Wrong size on FM1DropItemList");

// ScriptStruct M1.M1TaskEvents
// 0x0020 (0x0020 - 0x0000)
struct FM1TaskEvents final
{
public:
	class FString                                 PhaseName;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UM1TaskEvent*>                   TaskEvents;                                        // 0x0010(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TaskEvents) == 0x000008, "Wrong alignment on FM1TaskEvents");
static_assert(sizeof(FM1TaskEvents) == 0x000020, "Wrong size on FM1TaskEvents");
static_assert(offsetof(FM1TaskEvents, PhaseName) == 0x000000, "Member 'FM1TaskEvents::PhaseName' has a wrong offset!");
static_assert(offsetof(FM1TaskEvents, TaskEvents) == 0x000010, "Member 'FM1TaskEvents::TaskEvents' has a wrong offset!");

// ScriptStruct M1.M1OnSuccessTraitsForKilledMonsterList
// 0x0010 (0x0010 - 0x0000)
struct FM1OnSuccessTraitsForKilledMonsterList final
{
public:
	TArray<class UM1SpawnedActorTraitMission_OnSuccessForKilledMonster*> SpawnedActorTraits;                                // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1OnSuccessTraitsForKilledMonsterList) == 0x000008, "Wrong alignment on FM1OnSuccessTraitsForKilledMonsterList");
static_assert(sizeof(FM1OnSuccessTraitsForKilledMonsterList) == 0x000010, "Wrong size on FM1OnSuccessTraitsForKilledMonsterList");
static_assert(offsetof(FM1OnSuccessTraitsForKilledMonsterList, SpawnedActorTraits) == 0x000000, "Member 'FM1OnSuccessTraitsForKilledMonsterList::SpawnedActorTraits' has a wrong offset!");

// ScriptStruct M1.M1SubTaskList
// 0x0018 (0x0018 - 0x0000)
struct FM1SubTaskList final
{
public:
	TWeakObjectPtr<class AM1MissionSubTaskActor>  StartTaskActor;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AM1MissionSubTaskActor>> NextTaskActors;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SubTaskList) == 0x000008, "Wrong alignment on FM1SubTaskList");
static_assert(sizeof(FM1SubTaskList) == 0x000018, "Wrong size on FM1SubTaskList");
static_assert(offsetof(FM1SubTaskList, StartTaskActor) == 0x000000, "Member 'FM1SubTaskList::StartTaskActor' has a wrong offset!");
static_assert(offsetof(FM1SubTaskList, NextTaskActors) == 0x000008, "Member 'FM1SubTaskList::NextTaskActors' has a wrong offset!");

// ScriptStruct M1.M1MissionCollectionReturnTargetInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1MissionCollectionReturnTargetInfo final
{
public:
	class FString                                 StringId;                                          // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentHp;                                         // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyed;                                        // 0x0014(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MissionCollectionReturnTargetInfo) == 0x000008, "Wrong alignment on FM1MissionCollectionReturnTargetInfo");
static_assert(sizeof(FM1MissionCollectionReturnTargetInfo) == 0x000018, "Wrong size on FM1MissionCollectionReturnTargetInfo");
static_assert(offsetof(FM1MissionCollectionReturnTargetInfo, StringId) == 0x000000, "Member 'FM1MissionCollectionReturnTargetInfo::StringId' has a wrong offset!");
static_assert(offsetof(FM1MissionCollectionReturnTargetInfo, CurrentHp) == 0x000010, "Member 'FM1MissionCollectionReturnTargetInfo::CurrentHp' has a wrong offset!");
static_assert(offsetof(FM1MissionCollectionReturnTargetInfo, bDestroyed) == 0x000014, "Member 'FM1MissionCollectionReturnTargetInfo::bDestroyed' has a wrong offset!");

// ScriptStruct M1.M1MissionDeathEvasionTargetInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1MissionDeathEvasionTargetInfo final
{
public:
	class FString                                 StringId;                                          // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetHitCount;                                    // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentHitCount;                                   // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyed;                                        // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MissionDeathEvasionTargetInfo) == 0x000008, "Wrong alignment on FM1MissionDeathEvasionTargetInfo");
static_assert(sizeof(FM1MissionDeathEvasionTargetInfo) == 0x000020, "Wrong size on FM1MissionDeathEvasionTargetInfo");
static_assert(offsetof(FM1MissionDeathEvasionTargetInfo, StringId) == 0x000000, "Member 'FM1MissionDeathEvasionTargetInfo::StringId' has a wrong offset!");
static_assert(offsetof(FM1MissionDeathEvasionTargetInfo, TargetHitCount) == 0x000010, "Member 'FM1MissionDeathEvasionTargetInfo::TargetHitCount' has a wrong offset!");
static_assert(offsetof(FM1MissionDeathEvasionTargetInfo, CurrentHitCount) == 0x000014, "Member 'FM1MissionDeathEvasionTargetInfo::CurrentHitCount' has a wrong offset!");
static_assert(offsetof(FM1MissionDeathEvasionTargetInfo, bDestroyed) == 0x000018, "Member 'FM1MissionDeathEvasionTargetInfo::bDestroyed' has a wrong offset!");

// ScriptStruct M1.M1DestructionTargetInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1DestructionTargetInfo final
{
public:
	class FString                                 StringId;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentHp;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1DestructionTargetInfo) == 0x000008, "Wrong alignment on FM1DestructionTargetInfo");
static_assert(sizeof(FM1DestructionTargetInfo) == 0x000018, "Wrong size on FM1DestructionTargetInfo");
static_assert(offsetof(FM1DestructionTargetInfo, StringId) == 0x000000, "Member 'FM1DestructionTargetInfo::StringId' has a wrong offset!");
static_assert(offsetof(FM1DestructionTargetInfo, CurrentHp) == 0x000010, "Member 'FM1DestructionTargetInfo::CurrentHp' has a wrong offset!");

// ScriptStruct M1.M1TaskDestructionInfo
// 0x0050 (0x0050 - 0x0000)
struct FM1TaskDestructionInfo final
{
public:
	TArray<struct FM1DestructionCountInfo>        DestructionCountInfos;                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         LimitTime;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingTime;                                     // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentMonsterKillCount;                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetMonsterkillCount;                            // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UM1State>                   CurrentState;                                      // 0x0020(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UM1MissionTaskDestructionPhase*> Phases;                                            // 0x0028(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         CurrentPhase;                                      // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1DestructionTargetInfo>       DestructionTargetInfos;                            // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TaskDestructionInfo) == 0x000008, "Wrong alignment on FM1TaskDestructionInfo");
static_assert(sizeof(FM1TaskDestructionInfo) == 0x000050, "Wrong size on FM1TaskDestructionInfo");
static_assert(offsetof(FM1TaskDestructionInfo, DestructionCountInfos) == 0x000000, "Member 'FM1TaskDestructionInfo::DestructionCountInfos' has a wrong offset!");
static_assert(offsetof(FM1TaskDestructionInfo, LimitTime) == 0x000010, "Member 'FM1TaskDestructionInfo::LimitTime' has a wrong offset!");
static_assert(offsetof(FM1TaskDestructionInfo, RemainingTime) == 0x000014, "Member 'FM1TaskDestructionInfo::RemainingTime' has a wrong offset!");
static_assert(offsetof(FM1TaskDestructionInfo, CurrentMonsterKillCount) == 0x000018, "Member 'FM1TaskDestructionInfo::CurrentMonsterKillCount' has a wrong offset!");
static_assert(offsetof(FM1TaskDestructionInfo, TargetMonsterkillCount) == 0x00001C, "Member 'FM1TaskDestructionInfo::TargetMonsterkillCount' has a wrong offset!");
static_assert(offsetof(FM1TaskDestructionInfo, CurrentState) == 0x000020, "Member 'FM1TaskDestructionInfo::CurrentState' has a wrong offset!");
static_assert(offsetof(FM1TaskDestructionInfo, Phases) == 0x000028, "Member 'FM1TaskDestructionInfo::Phases' has a wrong offset!");
static_assert(offsetof(FM1TaskDestructionInfo, CurrentPhase) == 0x000038, "Member 'FM1TaskDestructionInfo::CurrentPhase' has a wrong offset!");
static_assert(offsetof(FM1TaskDestructionInfo, DestructionTargetInfos) == 0x000040, "Member 'FM1TaskDestructionInfo::DestructionTargetInfos' has a wrong offset!");

// ScriptStruct M1.M1HackingTargetInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1HackingTargetInfo final
{
public:
	class FString                                 HackingStringId;                                   // 0x0000(0x0010)(ZeroConstructor, RepSkip, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetIndex;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1BaseMissionProgressState                   TargetState;                                       // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProgressRatio;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1HackingTargetInfo) == 0x000008, "Wrong alignment on FM1HackingTargetInfo");
static_assert(sizeof(FM1HackingTargetInfo) == 0x000020, "Wrong size on FM1HackingTargetInfo");
static_assert(offsetof(FM1HackingTargetInfo, HackingStringId) == 0x000000, "Member 'FM1HackingTargetInfo::HackingStringId' has a wrong offset!");
static_assert(offsetof(FM1HackingTargetInfo, TargetIndex) == 0x000010, "Member 'FM1HackingTargetInfo::TargetIndex' has a wrong offset!");
static_assert(offsetof(FM1HackingTargetInfo, TargetState) == 0x000014, "Member 'FM1HackingTargetInfo::TargetState' has a wrong offset!");
static_assert(offsetof(FM1HackingTargetInfo, ProgressRatio) == 0x000018, "Member 'FM1HackingTargetInfo::ProgressRatio' has a wrong offset!");

// ScriptStruct M1.M1StealTargetInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1StealTargetInfo final
{
public:
	class FString                                 StringId;                                          // 0x0000(0x0010)(ZeroConstructor, RepSkip, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetIndex;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MissionTaskStealProgressState              ProgressState;                                     // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProgressRatio;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisturbed;                                        // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1StealTargetInfo) == 0x000008, "Wrong alignment on FM1StealTargetInfo");
static_assert(sizeof(FM1StealTargetInfo) == 0x000020, "Wrong size on FM1StealTargetInfo");
static_assert(offsetof(FM1StealTargetInfo, StringId) == 0x000000, "Member 'FM1StealTargetInfo::StringId' has a wrong offset!");
static_assert(offsetof(FM1StealTargetInfo, TargetIndex) == 0x000010, "Member 'FM1StealTargetInfo::TargetIndex' has a wrong offset!");
static_assert(offsetof(FM1StealTargetInfo, ProgressState) == 0x000014, "Member 'FM1StealTargetInfo::ProgressState' has a wrong offset!");
static_assert(offsetof(FM1StealTargetInfo, ProgressRatio) == 0x000018, "Member 'FM1StealTargetInfo::ProgressRatio' has a wrong offset!");
static_assert(offsetof(FM1StealTargetInfo, bDisturbed) == 0x00001C, "Member 'FM1StealTargetInfo::bDisturbed' has a wrong offset!");

// ScriptStruct M1.M1PhaseSettingForSupply
// 0x0008 (0x0008 - 0x0000)
struct FM1PhaseSettingForSupply final
{
public:
	int32                                         PhaseIndex;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropPercentageOverride;                            // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PhaseSettingForSupply) == 0x000004, "Wrong alignment on FM1PhaseSettingForSupply");
static_assert(sizeof(FM1PhaseSettingForSupply) == 0x000008, "Wrong size on FM1PhaseSettingForSupply");
static_assert(offsetof(FM1PhaseSettingForSupply, PhaseIndex) == 0x000000, "Member 'FM1PhaseSettingForSupply::PhaseIndex' has a wrong offset!");
static_assert(offsetof(FM1PhaseSettingForSupply, DropPercentageOverride) == 0x000004, "Member 'FM1PhaseSettingForSupply::DropPercentageOverride' has a wrong offset!");

// ScriptStruct M1.M1MissionWavePlayerProgressStateInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1MissionWavePlayerProgressStateInfo final
{
public:
	class AM1Player*                              IncludedPlayer;                                    // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MissionWavePlayerProgressState             ProgressState;                                     // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MissionWavePlayerProgressStateInfo) == 0x000008, "Wrong alignment on FM1MissionWavePlayerProgressStateInfo");
static_assert(sizeof(FM1MissionWavePlayerProgressStateInfo) == 0x000010, "Wrong size on FM1MissionWavePlayerProgressStateInfo");
static_assert(offsetof(FM1MissionWavePlayerProgressStateInfo, IncludedPlayer) == 0x000000, "Member 'FM1MissionWavePlayerProgressStateInfo::IncludedPlayer' has a wrong offset!");
static_assert(offsetof(FM1MissionWavePlayerProgressStateInfo, ProgressState) == 0x000008, "Member 'FM1MissionWavePlayerProgressStateInfo::ProgressState' has a wrong offset!");

// ScriptStruct M1.M1WaveDefenseRunningTimeEventInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1WaveDefenseRunningTimeEventInfo final
{
public:
	float                                         RemainingRunningTimeRatio;                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OptionalEventName;                                 // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActivated;                                      // 0x000C(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1WaveDefenseRunningTimeEventInfo) == 0x000004, "Wrong alignment on FM1WaveDefenseRunningTimeEventInfo");
static_assert(sizeof(FM1WaveDefenseRunningTimeEventInfo) == 0x000010, "Wrong size on FM1WaveDefenseRunningTimeEventInfo");
static_assert(offsetof(FM1WaveDefenseRunningTimeEventInfo, RemainingRunningTimeRatio) == 0x000000, "Member 'FM1WaveDefenseRunningTimeEventInfo::RemainingRunningTimeRatio' has a wrong offset!");
static_assert(offsetof(FM1WaveDefenseRunningTimeEventInfo, OptionalEventName) == 0x000004, "Member 'FM1WaveDefenseRunningTimeEventInfo::OptionalEventName' has a wrong offset!");
static_assert(offsetof(FM1WaveDefenseRunningTimeEventInfo, bIsActivated) == 0x00000C, "Member 'FM1WaveDefenseRunningTimeEventInfo::bIsActivated' has a wrong offset!");

// ScriptStruct M1.M1MissionWaveSurvivalCompleteInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1MissionWaveSurvivalCompleteInfo final
{
public:
	int32                                         TargetIndex;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetTag;                                         // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentMonsterKillCount;                           // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetMonsterkillCount;                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasNamedMonsterSpawned;                           // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MissionWaveSurvivalCompleteInfo) == 0x000004, "Wrong alignment on FM1MissionWaveSurvivalCompleteInfo");
static_assert(sizeof(FM1MissionWaveSurvivalCompleteInfo) == 0x000018, "Wrong size on FM1MissionWaveSurvivalCompleteInfo");
static_assert(offsetof(FM1MissionWaveSurvivalCompleteInfo, TargetIndex) == 0x000000, "Member 'FM1MissionWaveSurvivalCompleteInfo::TargetIndex' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveSurvivalCompleteInfo, TargetTag) == 0x000004, "Member 'FM1MissionWaveSurvivalCompleteInfo::TargetTag' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveSurvivalCompleteInfo, CurrentMonsterKillCount) == 0x00000C, "Member 'FM1MissionWaveSurvivalCompleteInfo::CurrentMonsterKillCount' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveSurvivalCompleteInfo, TargetMonsterkillCount) == 0x000010, "Member 'FM1MissionWaveSurvivalCompleteInfo::TargetMonsterkillCount' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveSurvivalCompleteInfo, bHasNamedMonsterSpawned) == 0x000014, "Member 'FM1MissionWaveSurvivalCompleteInfo::bHasNamedMonsterSpawned' has a wrong offset!");

// ScriptStruct M1.M1MissionWaveSurvivalNamedMonsterInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1MissionWaveSurvivalNamedMonsterInfo final
{
public:
	class AM1Monster*                             NamedMonster;                                      // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasNamedMonsterSpawned;                           // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bNamedMonsterKilled;                               // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MissionWaveSurvivalNamedMonsterInfo) == 0x000008, "Wrong alignment on FM1MissionWaveSurvivalNamedMonsterInfo");
static_assert(sizeof(FM1MissionWaveSurvivalNamedMonsterInfo) == 0x000010, "Wrong size on FM1MissionWaveSurvivalNamedMonsterInfo");
static_assert(offsetof(FM1MissionWaveSurvivalNamedMonsterInfo, NamedMonster) == 0x000000, "Member 'FM1MissionWaveSurvivalNamedMonsterInfo::NamedMonster' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveSurvivalNamedMonsterInfo, bHasNamedMonsterSpawned) == 0x000008, "Member 'FM1MissionWaveSurvivalNamedMonsterInfo::bHasNamedMonsterSpawned' has a wrong offset!");
static_assert(offsetof(FM1MissionWaveSurvivalNamedMonsterInfo, bNamedMonsterKilled) == 0x000009, "Member 'FM1MissionWaveSurvivalNamedMonsterInfo::bNamedMonsterKilled' has a wrong offset!");

// ScriptStruct M1.M1OccupationContributeInfo
// 0x000C (0x000C - 0x0000)
struct FM1OccupationContributeInfo final
{
public:
	float                                         OccupiedTime;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysInside;                                     // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SafetyStealLongestTime;                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1OccupationContributeInfo) == 0x000004, "Wrong alignment on FM1OccupationContributeInfo");
static_assert(sizeof(FM1OccupationContributeInfo) == 0x00000C, "Wrong size on FM1OccupationContributeInfo");
static_assert(offsetof(FM1OccupationContributeInfo, OccupiedTime) == 0x000000, "Member 'FM1OccupationContributeInfo::OccupiedTime' has a wrong offset!");
static_assert(offsetof(FM1OccupationContributeInfo, bAlwaysInside) == 0x000004, "Member 'FM1OccupationContributeInfo::bAlwaysInside' has a wrong offset!");
static_assert(offsetof(FM1OccupationContributeInfo, SafetyStealLongestTime) == 0x000008, "Member 'FM1OccupationContributeInfo::SafetyStealLongestTime' has a wrong offset!");

// ScriptStruct M1.M1MissionTaskSupplyInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1MissionTaskSupplyInfo final
{
public:
	int32                                         SupplyCollectorTid;                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SuppliesNames;                                     // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         CurrentSupplyRate;                                 // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetSupplyRate;                                  // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionTaskSupplyInfo) == 0x000008, "Wrong alignment on FM1MissionTaskSupplyInfo");
static_assert(sizeof(FM1MissionTaskSupplyInfo) == 0x000020, "Wrong size on FM1MissionTaskSupplyInfo");
static_assert(offsetof(FM1MissionTaskSupplyInfo, SupplyCollectorTid) == 0x000000, "Member 'FM1MissionTaskSupplyInfo::SupplyCollectorTid' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskSupplyInfo, SuppliesNames) == 0x000008, "Member 'FM1MissionTaskSupplyInfo::SuppliesNames' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskSupplyInfo, CurrentSupplyRate) == 0x000018, "Member 'FM1MissionTaskSupplyInfo::CurrentSupplyRate' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskSupplyInfo, TargetSupplyRate) == 0x00001C, "Member 'FM1MissionTaskSupplyInfo::TargetSupplyRate' has a wrong offset!");

// ScriptStruct M1.M1TaskSupplyBalanceInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1TaskSupplyBalanceInfo final
{
public:
	bool                                          bDecreaseSupply;                                   // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TaskSupplyDefault;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TaskSupplyOverCharging;                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TaskSupplyDecreaseInterval;                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TaskSupplyDecrease;                                // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TaskSupplyThiefDecreaseInterval;                   // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TaskSupplyThiefDecrease;                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SupplyAlert;                                       // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TaskSupplyBalanceInfo) == 0x000004, "Wrong alignment on FM1TaskSupplyBalanceInfo");
static_assert(sizeof(FM1TaskSupplyBalanceInfo) == 0x000020, "Wrong size on FM1TaskSupplyBalanceInfo");
static_assert(offsetof(FM1TaskSupplyBalanceInfo, bDecreaseSupply) == 0x000000, "Member 'FM1TaskSupplyBalanceInfo::bDecreaseSupply' has a wrong offset!");
static_assert(offsetof(FM1TaskSupplyBalanceInfo, TaskSupplyDefault) == 0x000004, "Member 'FM1TaskSupplyBalanceInfo::TaskSupplyDefault' has a wrong offset!");
static_assert(offsetof(FM1TaskSupplyBalanceInfo, TaskSupplyOverCharging) == 0x000008, "Member 'FM1TaskSupplyBalanceInfo::TaskSupplyOverCharging' has a wrong offset!");
static_assert(offsetof(FM1TaskSupplyBalanceInfo, TaskSupplyDecreaseInterval) == 0x00000C, "Member 'FM1TaskSupplyBalanceInfo::TaskSupplyDecreaseInterval' has a wrong offset!");
static_assert(offsetof(FM1TaskSupplyBalanceInfo, TaskSupplyDecrease) == 0x000010, "Member 'FM1TaskSupplyBalanceInfo::TaskSupplyDecrease' has a wrong offset!");
static_assert(offsetof(FM1TaskSupplyBalanceInfo, TaskSupplyThiefDecreaseInterval) == 0x000014, "Member 'FM1TaskSupplyBalanceInfo::TaskSupplyThiefDecreaseInterval' has a wrong offset!");
static_assert(offsetof(FM1TaskSupplyBalanceInfo, TaskSupplyThiefDecrease) == 0x000018, "Member 'FM1TaskSupplyBalanceInfo::TaskSupplyThiefDecrease' has a wrong offset!");
static_assert(offsetof(FM1TaskSupplyBalanceInfo, SupplyAlert) == 0x00001C, "Member 'FM1TaskSupplyBalanceInfo::SupplyAlert' has a wrong offset!");

// ScriptStruct M1.M1MissionTaskNamedMonsterPhaseInfo
// 0x000C (0x000C - 0x0000)
struct FM1MissionTaskNamedMonsterPhaseInfo final
{
public:
	bool                                          bNamedMonsterSpawned;                              // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNamedMonsterImmuned;                              // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AM1Monster>              NamedMonster;                                      // 0x0004(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionTaskNamedMonsterPhaseInfo) == 0x000004, "Wrong alignment on FM1MissionTaskNamedMonsterPhaseInfo");
static_assert(sizeof(FM1MissionTaskNamedMonsterPhaseInfo) == 0x00000C, "Wrong size on FM1MissionTaskNamedMonsterPhaseInfo");
static_assert(offsetof(FM1MissionTaskNamedMonsterPhaseInfo, bNamedMonsterSpawned) == 0x000000, "Member 'FM1MissionTaskNamedMonsterPhaseInfo::bNamedMonsterSpawned' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskNamedMonsterPhaseInfo, bNamedMonsterImmuned) == 0x000001, "Member 'FM1MissionTaskNamedMonsterPhaseInfo::bNamedMonsterImmuned' has a wrong offset!");
static_assert(offsetof(FM1MissionTaskNamedMonsterPhaseInfo, NamedMonster) == 0x000004, "Member 'FM1MissionTaskNamedMonsterPhaseInfo::NamedMonster' has a wrong offset!");

// ScriptStruct M1.M1PathUpdateSet
// 0x0030 (0x0030 - 0x0000)
struct FM1PathUpdateSet final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1PathUpdateSet) == 0x000008, "Wrong alignment on FM1PathUpdateSet");
static_assert(sizeof(FM1PathUpdateSet) == 0x000030, "Wrong size on FM1PathUpdateSet");
static_assert(offsetof(FM1PathUpdateSet, NiagaraComponent) == 0x000028, "Member 'FM1PathUpdateSet::NiagaraComponent' has a wrong offset!");

// ScriptStruct M1.M1ReceivedWaveReward
// 0x0018 (0x0018 - 0x0000)
struct FM1ReceivedWaveReward final
{
public:
	class FName                                   WaveRowName;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CheckPointIndex;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemType                                   ItemType;                                          // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1TemplateId                          ItemTid;                                           // 0x0010(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ReceivedWaveReward) == 0x000004, "Wrong alignment on FM1ReceivedWaveReward");
static_assert(sizeof(FM1ReceivedWaveReward) == 0x000018, "Wrong size on FM1ReceivedWaveReward");
static_assert(offsetof(FM1ReceivedWaveReward, WaveRowName) == 0x000000, "Member 'FM1ReceivedWaveReward::WaveRowName' has a wrong offset!");
static_assert(offsetof(FM1ReceivedWaveReward, CheckPointIndex) == 0x000008, "Member 'FM1ReceivedWaveReward::CheckPointIndex' has a wrong offset!");
static_assert(offsetof(FM1ReceivedWaveReward, ItemType) == 0x00000C, "Member 'FM1ReceivedWaveReward::ItemType' has a wrong offset!");
static_assert(offsetof(FM1ReceivedWaveReward, ItemTid) == 0x000010, "Member 'FM1ReceivedWaveReward::ItemTid' has a wrong offset!");
static_assert(offsetof(FM1ReceivedWaveReward, Amount) == 0x000014, "Member 'FM1ReceivedWaveReward::Amount' has a wrong offset!");

// ScriptStruct M1.M1MonsterAIDebugData
// 0x002C (0x002C - 0x0000)
struct FM1MonsterAIDebugData final
{
public:
	class FName                                   MonsterName;                                       // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MonsterAIDebugState                        AIState;                                           // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MainTarget;                                        // 0x000C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaskFilter;                                        // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GoalLocation;                                      // 0x0018(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedSkillIndex;                                // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1BattleState                                BattleState;                                       // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MonsterAIDebugData) == 0x000004, "Wrong alignment on FM1MonsterAIDebugData");
static_assert(sizeof(FM1MonsterAIDebugData) == 0x00002C, "Wrong size on FM1MonsterAIDebugData");
static_assert(offsetof(FM1MonsterAIDebugData, MonsterName) == 0x000000, "Member 'FM1MonsterAIDebugData::MonsterName' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIDebugData, AIState) == 0x000008, "Member 'FM1MonsterAIDebugData::AIState' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIDebugData, MainTarget) == 0x00000C, "Member 'FM1MonsterAIDebugData::MainTarget' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIDebugData, MaskFilter) == 0x000014, "Member 'FM1MonsterAIDebugData::MaskFilter' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIDebugData, GoalLocation) == 0x000018, "Member 'FM1MonsterAIDebugData::GoalLocation' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIDebugData, SelectedSkillIndex) == 0x000024, "Member 'FM1MonsterAIDebugData::SelectedSkillIndex' has a wrong offset!");
static_assert(offsetof(FM1MonsterAIDebugData, BattleState) == 0x000028, "Member 'FM1MonsterAIDebugData::BattleState' has a wrong offset!");

// ScriptStruct M1.M1MonsterMoveDebugData
// 0x0020 (0x0020 - 0x0000)
struct FM1MonsterMoveDebugData final
{
public:
	EMovementMode                                 MovementMode;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MoveName;                                          // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MoveNodeNumber;                                    // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MoveIndex;                                         // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1AIMoveTarget                               MoveTarget;                                        // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxMoveDuration;                                   // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1AIMoveResult                               MoveResult;                                        // 0x001C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MonsterMoveDebugData) == 0x000004, "Wrong alignment on FM1MonsterMoveDebugData");
static_assert(sizeof(FM1MonsterMoveDebugData) == 0x000020, "Wrong size on FM1MonsterMoveDebugData");
static_assert(offsetof(FM1MonsterMoveDebugData, MovementMode) == 0x000000, "Member 'FM1MonsterMoveDebugData::MovementMode' has a wrong offset!");
static_assert(offsetof(FM1MonsterMoveDebugData, MoveName) == 0x000004, "Member 'FM1MonsterMoveDebugData::MoveName' has a wrong offset!");
static_assert(offsetof(FM1MonsterMoveDebugData, MoveNodeNumber) == 0x00000C, "Member 'FM1MonsterMoveDebugData::MoveNodeNumber' has a wrong offset!");
static_assert(offsetof(FM1MonsterMoveDebugData, MoveIndex) == 0x000010, "Member 'FM1MonsterMoveDebugData::MoveIndex' has a wrong offset!");
static_assert(offsetof(FM1MonsterMoveDebugData, MoveTarget) == 0x000014, "Member 'FM1MonsterMoveDebugData::MoveTarget' has a wrong offset!");
static_assert(offsetof(FM1MonsterMoveDebugData, MaxMoveDuration) == 0x000018, "Member 'FM1MonsterMoveDebugData::MaxMoveDuration' has a wrong offset!");
static_assert(offsetof(FM1MonsterMoveDebugData, MoveResult) == 0x00001C, "Member 'FM1MonsterMoveDebugData::MoveResult' has a wrong offset!");

// ScriptStruct M1.M1MonsterCoverDebugData
// 0x0020 (0x0020 - 0x0000)
struct FM1MonsterCoverDebugData final
{
public:
	bool                                          bInCoverBattle;                                    // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CoverAttackLocation;                               // 0x0004(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1CoverState                                 CoverBattleState;                                  // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurCoverLocationVolume;                            // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CoverAttackCount;                                  // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterCoverDebugData) == 0x000004, "Wrong alignment on FM1MonsterCoverDebugData");
static_assert(sizeof(FM1MonsterCoverDebugData) == 0x000020, "Wrong size on FM1MonsterCoverDebugData");
static_assert(offsetof(FM1MonsterCoverDebugData, bInCoverBattle) == 0x000000, "Member 'FM1MonsterCoverDebugData::bInCoverBattle' has a wrong offset!");
static_assert(offsetof(FM1MonsterCoverDebugData, CoverAttackLocation) == 0x000004, "Member 'FM1MonsterCoverDebugData::CoverAttackLocation' has a wrong offset!");
static_assert(offsetof(FM1MonsterCoverDebugData, CoverBattleState) == 0x000010, "Member 'FM1MonsterCoverDebugData::CoverBattleState' has a wrong offset!");
static_assert(offsetof(FM1MonsterCoverDebugData, CurCoverLocationVolume) == 0x000014, "Member 'FM1MonsterCoverDebugData::CurCoverLocationVolume' has a wrong offset!");
static_assert(offsetof(FM1MonsterCoverDebugData, CoverAttackCount) == 0x00001C, "Member 'FM1MonsterCoverDebugData::CoverAttackCount' has a wrong offset!");

// ScriptStruct M1.M1MonsterPatrolDebugData
// 0x0008 (0x0008 - 0x0000)
struct FM1MonsterPatrolDebugData final
{
public:
	bool                                          bPatrolSubPost;                                    // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WayPointIndex;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MonsterPatrolDebugData) == 0x000004, "Wrong alignment on FM1MonsterPatrolDebugData");
static_assert(sizeof(FM1MonsterPatrolDebugData) == 0x000008, "Wrong size on FM1MonsterPatrolDebugData");
static_assert(offsetof(FM1MonsterPatrolDebugData, bPatrolSubPost) == 0x000000, "Member 'FM1MonsterPatrolDebugData::bPatrolSubPost' has a wrong offset!");
static_assert(offsetof(FM1MonsterPatrolDebugData, WayPointIndex) == 0x000004, "Member 'FM1MonsterPatrolDebugData::WayPointIndex' has a wrong offset!");

// ScriptStruct M1.M1CoverLocationData
// 0x0020 (0x0020 - 0x0000)
struct FM1CoverLocationData final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttackLocation;                                    // 0x000C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  OccupiedActor;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CoverLocationData) == 0x000004, "Wrong alignment on FM1CoverLocationData");
static_assert(sizeof(FM1CoverLocationData) == 0x000020, "Wrong size on FM1CoverLocationData");
static_assert(offsetof(FM1CoverLocationData, Location) == 0x000000, "Member 'FM1CoverLocationData::Location' has a wrong offset!");
static_assert(offsetof(FM1CoverLocationData, AttackLocation) == 0x00000C, "Member 'FM1CoverLocationData::AttackLocation' has a wrong offset!");
static_assert(offsetof(FM1CoverLocationData, OccupiedActor) == 0x000018, "Member 'FM1CoverLocationData::OccupiedActor' has a wrong offset!");

// ScriptStruct M1.M1SplineMovingActorDebugData
// 0x0020 (0x0020 - 0x0000)
struct FM1SplineMovingActorDebugData final
{
public:
	float                                         MovingElapsedTime;                                 // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MovingPlatformLoc;                                 // 0x0004(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MovingPlatformRot;                                 // 0x0010(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bReversePlay;                                      // 0x001C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SplineMovingActorDebugData) == 0x000004, "Wrong alignment on FM1SplineMovingActorDebugData");
static_assert(sizeof(FM1SplineMovingActorDebugData) == 0x000020, "Wrong size on FM1SplineMovingActorDebugData");
static_assert(offsetof(FM1SplineMovingActorDebugData, MovingElapsedTime) == 0x000000, "Member 'FM1SplineMovingActorDebugData::MovingElapsedTime' has a wrong offset!");
static_assert(offsetof(FM1SplineMovingActorDebugData, MovingPlatformLoc) == 0x000004, "Member 'FM1SplineMovingActorDebugData::MovingPlatformLoc' has a wrong offset!");
static_assert(offsetof(FM1SplineMovingActorDebugData, MovingPlatformRot) == 0x000010, "Member 'FM1SplineMovingActorDebugData::MovingPlatformRot' has a wrong offset!");
static_assert(offsetof(FM1SplineMovingActorDebugData, bReversePlay) == 0x00001C, "Member 'FM1SplineMovingActorDebugData::bReversePlay' has a wrong offset!");

// ScriptStruct M1.VectorAndRotator
// 0x0018 (0x0018 - 0x0000)
struct FVectorAndRotator final
{
public:
	struct FVector                                Vector;                                            // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotator;                                           // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVectorAndRotator) == 0x000004, "Wrong alignment on FVectorAndRotator");
static_assert(sizeof(FVectorAndRotator) == 0x000018, "Wrong size on FVectorAndRotator");
static_assert(offsetof(FVectorAndRotator, Vector) == 0x000000, "Member 'FVectorAndRotator::Vector' has a wrong offset!");
static_assert(offsetof(FVectorAndRotator, Rotator) == 0x00000C, "Member 'FVectorAndRotator::Rotator' has a wrong offset!");

// ScriptStruct M1.M1NpcRandomTalkSettings
// 0x0014 (0x0014 - 0x0000)
struct FM1NpcRandomTalkSettings final
{
public:
	bool                                          bEnableRandomTalk;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomTalkIntervalMin;                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomTalkIntervalMax;                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomTalkRangeRadius;                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowRange;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1NpcRandomTalkSettings) == 0x000004, "Wrong alignment on FM1NpcRandomTalkSettings");
static_assert(sizeof(FM1NpcRandomTalkSettings) == 0x000014, "Wrong size on FM1NpcRandomTalkSettings");
static_assert(offsetof(FM1NpcRandomTalkSettings, bEnableRandomTalk) == 0x000000, "Member 'FM1NpcRandomTalkSettings::bEnableRandomTalk' has a wrong offset!");
static_assert(offsetof(FM1NpcRandomTalkSettings, RandomTalkIntervalMin) == 0x000004, "Member 'FM1NpcRandomTalkSettings::RandomTalkIntervalMin' has a wrong offset!");
static_assert(offsetof(FM1NpcRandomTalkSettings, RandomTalkIntervalMax) == 0x000008, "Member 'FM1NpcRandomTalkSettings::RandomTalkIntervalMax' has a wrong offset!");
static_assert(offsetof(FM1NpcRandomTalkSettings, RandomTalkRangeRadius) == 0x00000C, "Member 'FM1NpcRandomTalkSettings::RandomTalkRangeRadius' has a wrong offset!");
static_assert(offsetof(FM1NpcRandomTalkSettings, bShowRange) == 0x000010, "Member 'FM1NpcRandomTalkSettings::bShowRange' has a wrong offset!");

// ScriptStruct M1.M1NpcIdleAnimSettings
// 0x0058 (0x0058 - 0x0000)
struct FM1NpcIdleAnimSettings final
{
public:
	bool                                          bShouldRepeat;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomRepeatCount;                                // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EM1NpcAnimState, int32>                  RepeatCountPerAnimState;                           // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NpcIdleAnimSettings) == 0x000008, "Wrong alignment on FM1NpcIdleAnimSettings");
static_assert(sizeof(FM1NpcIdleAnimSettings) == 0x000058, "Wrong size on FM1NpcIdleAnimSettings");
static_assert(offsetof(FM1NpcIdleAnimSettings, bShouldRepeat) == 0x000000, "Member 'FM1NpcIdleAnimSettings::bShouldRepeat' has a wrong offset!");
static_assert(offsetof(FM1NpcIdleAnimSettings, bRandomRepeatCount) == 0x000001, "Member 'FM1NpcIdleAnimSettings::bRandomRepeatCount' has a wrong offset!");
static_assert(offsetof(FM1NpcIdleAnimSettings, RepeatCountPerAnimState) == 0x000008, "Member 'FM1NpcIdleAnimSettings::RepeatCountPerAnimState' has a wrong offset!");

// ScriptStruct M1.M1NpcHandIkInfo
// 0x0060 (0x0060 - 0x0000)
struct FM1NpcHandIkInfo final
{
public:
	float                                         LeftHandIkAlpha;                                   // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LeftHandIkEndEffector;                             // 0x0010(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandFingerAlpha;                               // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1BoneTransformArray                  LeftHandBones;                                     // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1NpcHandIkInfo) == 0x000010, "Wrong alignment on FM1NpcHandIkInfo");
static_assert(sizeof(FM1NpcHandIkInfo) == 0x000060, "Wrong size on FM1NpcHandIkInfo");
static_assert(offsetof(FM1NpcHandIkInfo, LeftHandIkAlpha) == 0x000000, "Member 'FM1NpcHandIkInfo::LeftHandIkAlpha' has a wrong offset!");
static_assert(offsetof(FM1NpcHandIkInfo, LeftHandIkEndEffector) == 0x000010, "Member 'FM1NpcHandIkInfo::LeftHandIkEndEffector' has a wrong offset!");
static_assert(offsetof(FM1NpcHandIkInfo, LeftHandFingerAlpha) == 0x000040, "Member 'FM1NpcHandIkInfo::LeftHandFingerAlpha' has a wrong offset!");
static_assert(offsetof(FM1NpcHandIkInfo, LeftHandBones) == 0x000048, "Member 'FM1NpcHandIkInfo::LeftHandBones' has a wrong offset!");

// ScriptStruct M1.M1NxLogChangeInfo
// 0x0070 (0x0070 - 0x0000)
struct FM1NxLogChangeInfo final
{
public:
	class FString                                 Changeinfoaft;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Changeinfobef;                                     // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Changeinfoid;                                      // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Changeinfoidcategory;                              // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Changeinfosubtype;                                 // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Changeinfotype;                                    // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Changeinfovalue;                                   // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLogChangeInfo) == 0x000008, "Wrong alignment on FM1NxLogChangeInfo");
static_assert(sizeof(FM1NxLogChangeInfo) == 0x000070, "Wrong size on FM1NxLogChangeInfo");
static_assert(offsetof(FM1NxLogChangeInfo, Changeinfoaft) == 0x000000, "Member 'FM1NxLogChangeInfo::Changeinfoaft' has a wrong offset!");
static_assert(offsetof(FM1NxLogChangeInfo, Changeinfobef) == 0x000010, "Member 'FM1NxLogChangeInfo::Changeinfobef' has a wrong offset!");
static_assert(offsetof(FM1NxLogChangeInfo, Changeinfoid) == 0x000020, "Member 'FM1NxLogChangeInfo::Changeinfoid' has a wrong offset!");
static_assert(offsetof(FM1NxLogChangeInfo, Changeinfoidcategory) == 0x000030, "Member 'FM1NxLogChangeInfo::Changeinfoidcategory' has a wrong offset!");
static_assert(offsetof(FM1NxLogChangeInfo, Changeinfosubtype) == 0x000040, "Member 'FM1NxLogChangeInfo::Changeinfosubtype' has a wrong offset!");
static_assert(offsetof(FM1NxLogChangeInfo, Changeinfotype) == 0x000050, "Member 'FM1NxLogChangeInfo::Changeinfotype' has a wrong offset!");
static_assert(offsetof(FM1NxLogChangeInfo, Changeinfovalue) == 0x000060, "Member 'FM1NxLogChangeInfo::Changeinfovalue' has a wrong offset!");

// ScriptStruct M1.M1NxLog_User_MonsterKill_Base
// 0x00A0 (0x0180 - 0x00E0)
struct FM1NxLog_User_MonsterKill_Base final : public FM1NxLog_Base
{
public:
	struct FM1NxLog_User_MonsterKill              User_MonsterKill;                                  // 0x00E0(0x00A0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_User_MonsterKill_Base) == 0x000008, "Wrong alignment on FM1NxLog_User_MonsterKill_Base");
static_assert(sizeof(FM1NxLog_User_MonsterKill_Base) == 0x000180, "Wrong size on FM1NxLog_User_MonsterKill_Base");
static_assert(offsetof(FM1NxLog_User_MonsterKill_Base, User_MonsterKill) == 0x0000E0, "Member 'FM1NxLog_User_MonsterKill_Base::User_MonsterKill' has a wrong offset!");

// ScriptStruct M1.M1NxLog_User_Dead
// 0x00E0 (0x00E0 - 0x0000)
struct FM1NxLog_User_Dead final
{
public:
	class FString                                 Actionid;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 battletargettype;                                  // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Damagereceive;                                     // 0x0020(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 FieldId;                                           // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldUid;                                          // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetId;                                          // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Targetlevel;                                       // 0x0060(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 TargetName;                                        // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetType;                                        // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Userlevel;                                         // 0x0090(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Usernickname;                                      // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Deadstatustype;                                    // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tfdplayeritemid;                                   // 0x00C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Tfdplayeritemlevel;                                // 0x00D0(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_User_Dead) == 0x000008, "Wrong alignment on FM1NxLog_User_Dead");
static_assert(sizeof(FM1NxLog_User_Dead) == 0x0000E0, "Wrong size on FM1NxLog_User_Dead");
static_assert(offsetof(FM1NxLog_User_Dead, Actionid) == 0x000000, "Member 'FM1NxLog_User_Dead::Actionid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Dead, battletargettype) == 0x000010, "Member 'FM1NxLog_User_Dead::battletargettype' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Dead, Damagereceive) == 0x000020, "Member 'FM1NxLog_User_Dead::Damagereceive' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Dead, FieldId) == 0x000030, "Member 'FM1NxLog_User_Dead::FieldId' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Dead, FieldUid) == 0x000040, "Member 'FM1NxLog_User_Dead::FieldUid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Dead, TargetId) == 0x000050, "Member 'FM1NxLog_User_Dead::TargetId' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Dead, Targetlevel) == 0x000060, "Member 'FM1NxLog_User_Dead::Targetlevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Dead, TargetName) == 0x000070, "Member 'FM1NxLog_User_Dead::TargetName' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Dead, TargetType) == 0x000080, "Member 'FM1NxLog_User_Dead::TargetType' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Dead, Userlevel) == 0x000090, "Member 'FM1NxLog_User_Dead::Userlevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Dead, Usernickname) == 0x0000A0, "Member 'FM1NxLog_User_Dead::Usernickname' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Dead, Deadstatustype) == 0x0000B0, "Member 'FM1NxLog_User_Dead::Deadstatustype' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Dead, Tfdplayeritemid) == 0x0000C0, "Member 'FM1NxLog_User_Dead::Tfdplayeritemid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_User_Dead, Tfdplayeritemlevel) == 0x0000D0, "Member 'FM1NxLog_User_Dead::Tfdplayeritemlevel' has a wrong offset!");

// ScriptStruct M1.M1NxLog_User_Dead_Base
// 0x00E0 (0x01C0 - 0x00E0)
struct FM1NxLog_User_Dead_Base final : public FM1NxLog_Base
{
public:
	struct FM1NxLog_User_Dead                     User_Dead;                                         // 0x00E0(0x00E0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_User_Dead_Base) == 0x000008, "Wrong alignment on FM1NxLog_User_Dead_Base");
static_assert(sizeof(FM1NxLog_User_Dead_Base) == 0x0001C0, "Wrong size on FM1NxLog_User_Dead_Base");
static_assert(offsetof(FM1NxLog_User_Dead_Base, User_Dead) == 0x0000E0, "Member 'FM1NxLog_User_Dead_Base::User_Dead' has a wrong offset!");

// ScriptStruct M1.M1NxLog_User_Revive_Base
// 0x00D0 (0x01B0 - 0x00E0)
struct FM1NxLog_User_Revive_Base final : public FM1NxLog_Base
{
public:
	struct FM1NxLog_User_Revive                   User_Revive;                                       // 0x00E0(0x00D0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_User_Revive_Base) == 0x000008, "Wrong alignment on FM1NxLog_User_Revive_Base");
static_assert(sizeof(FM1NxLog_User_Revive_Base) == 0x0001B0, "Wrong size on FM1NxLog_User_Revive_Base");
static_assert(offsetof(FM1NxLog_User_Revive_Base, User_Revive) == 0x0000E0, "Member 'FM1NxLog_User_Revive_Base::User_Revive' has a wrong offset!");

// ScriptStruct M1.M1NxLog_Play_PlayerFlow_Base
// 0x0180 (0x0260 - 0x00E0)
struct FM1NxLog_Play_PlayerFlow_Base final : public FM1NxLog_Base
{
public:
	struct FM1NxLog_Play_PlayerFlow               Play_PlayerFlow;                                   // 0x00E0(0x0180)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_Play_PlayerFlow_Base) == 0x000008, "Wrong alignment on FM1NxLog_Play_PlayerFlow_Base");
static_assert(sizeof(FM1NxLog_Play_PlayerFlow_Base) == 0x000260, "Wrong size on FM1NxLog_Play_PlayerFlow_Base");
static_assert(offsetof(FM1NxLog_Play_PlayerFlow_Base, Play_PlayerFlow) == 0x0000E0, "Member 'FM1NxLog_Play_PlayerFlow_Base::Play_PlayerFlow' has a wrong offset!");

// ScriptStruct M1.M1NxLog_Play_PlayerEvent
// 0x0120 (0x0120 - 0x0000)
struct FM1NxLog_Play_PlayerEvent final
{
public:
	class FString                                 Actionid;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1NxLogChangeInfo>             Changeinfoarray;                                   // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Contentsid;                                        // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Contentsmeta;                                      // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ContentsType;                                      // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldId;                                           // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldUid;                                          // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1NxLogItemChangeInfo>         Itemchangearray;                                   // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Pcid;                                              // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Pclevel;                                           // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Pcname;                                            // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Pctype;                                            // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Playplayereventid;                                 // 0x00C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Playplayereventreason;                             // 0x00D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Playplayereventtype;                               // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tfdplayeritemid;                                   // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Tfdplayeritemlevel;                                // 0x0100(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FM1NxLogExtraInfo>              Extrainfoarray;                                    // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_Play_PlayerEvent) == 0x000008, "Wrong alignment on FM1NxLog_Play_PlayerEvent");
static_assert(sizeof(FM1NxLog_Play_PlayerEvent) == 0x000120, "Wrong size on FM1NxLog_Play_PlayerEvent");
static_assert(offsetof(FM1NxLog_Play_PlayerEvent, Actionid) == 0x000000, "Member 'FM1NxLog_Play_PlayerEvent::Actionid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerEvent, Changeinfoarray) == 0x000010, "Member 'FM1NxLog_Play_PlayerEvent::Changeinfoarray' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerEvent, Contentsid) == 0x000020, "Member 'FM1NxLog_Play_PlayerEvent::Contentsid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerEvent, Contentsmeta) == 0x000030, "Member 'FM1NxLog_Play_PlayerEvent::Contentsmeta' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerEvent, ContentsType) == 0x000040, "Member 'FM1NxLog_Play_PlayerEvent::ContentsType' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerEvent, FieldId) == 0x000050, "Member 'FM1NxLog_Play_PlayerEvent::FieldId' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerEvent, FieldUid) == 0x000060, "Member 'FM1NxLog_Play_PlayerEvent::FieldUid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerEvent, Itemchangearray) == 0x000070, "Member 'FM1NxLog_Play_PlayerEvent::Itemchangearray' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerEvent, Pcid) == 0x000080, "Member 'FM1NxLog_Play_PlayerEvent::Pcid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerEvent, Pclevel) == 0x000090, "Member 'FM1NxLog_Play_PlayerEvent::Pclevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerEvent, Pcname) == 0x0000A0, "Member 'FM1NxLog_Play_PlayerEvent::Pcname' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerEvent, Pctype) == 0x0000B0, "Member 'FM1NxLog_Play_PlayerEvent::Pctype' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerEvent, Playplayereventid) == 0x0000C0, "Member 'FM1NxLog_Play_PlayerEvent::Playplayereventid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerEvent, Playplayereventreason) == 0x0000D0, "Member 'FM1NxLog_Play_PlayerEvent::Playplayereventreason' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerEvent, Playplayereventtype) == 0x0000E0, "Member 'FM1NxLog_Play_PlayerEvent::Playplayereventtype' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerEvent, Tfdplayeritemid) == 0x0000F0, "Member 'FM1NxLog_Play_PlayerEvent::Tfdplayeritemid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerEvent, Tfdplayeritemlevel) == 0x000100, "Member 'FM1NxLog_Play_PlayerEvent::Tfdplayeritemlevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_Play_PlayerEvent, Extrainfoarray) == 0x000110, "Member 'FM1NxLog_Play_PlayerEvent::Extrainfoarray' has a wrong offset!");

// ScriptStruct M1.M1NxLog_Play_PlayerEvent_Base
// 0x0120 (0x0200 - 0x00E0)
struct FM1NxLog_Play_PlayerEvent_Base final : public FM1NxLog_Base
{
public:
	struct FM1NxLog_Play_PlayerEvent              Play_PlayerEvent;                                  // 0x00E0(0x0120)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_Play_PlayerEvent_Base) == 0x000008, "Wrong alignment on FM1NxLog_Play_PlayerEvent_Base");
static_assert(sizeof(FM1NxLog_Play_PlayerEvent_Base) == 0x000200, "Wrong size on FM1NxLog_Play_PlayerEvent_Base");
static_assert(offsetof(FM1NxLog_Play_PlayerEvent_Base, Play_PlayerEvent) == 0x0000E0, "Member 'FM1NxLog_Play_PlayerEvent_Base::Play_PlayerEvent' has a wrong offset!");

// ScriptStruct M1.M1NxLog_MoveTimeValidationError
// 0x00B0 (0x00B0 - 0x0000)
struct FM1NxLog_MoveTimeValidationError final
{
public:
	class FString                                 Actionid;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Userlevel;                                         // 0x0010(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Usernickname;                                      // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tfdplayeritemid;                                   // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Tfdplayeritemlevel;                                // 0x0040(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Tfdweaponitemid;                                   // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Tfdweaponitemlevel;                                // 0x0060(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 FieldId;                                           // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldUid;                                          // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogDouble                         Timediscrepancyerror;                              // 0x0090(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1NxLogDouble                         Timediscrepancymax;                                // 0x00A0(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_MoveTimeValidationError) == 0x000008, "Wrong alignment on FM1NxLog_MoveTimeValidationError");
static_assert(sizeof(FM1NxLog_MoveTimeValidationError) == 0x0000B0, "Wrong size on FM1NxLog_MoveTimeValidationError");
static_assert(offsetof(FM1NxLog_MoveTimeValidationError, Actionid) == 0x000000, "Member 'FM1NxLog_MoveTimeValidationError::Actionid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_MoveTimeValidationError, Userlevel) == 0x000010, "Member 'FM1NxLog_MoveTimeValidationError::Userlevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_MoveTimeValidationError, Usernickname) == 0x000020, "Member 'FM1NxLog_MoveTimeValidationError::Usernickname' has a wrong offset!");
static_assert(offsetof(FM1NxLog_MoveTimeValidationError, Tfdplayeritemid) == 0x000030, "Member 'FM1NxLog_MoveTimeValidationError::Tfdplayeritemid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_MoveTimeValidationError, Tfdplayeritemlevel) == 0x000040, "Member 'FM1NxLog_MoveTimeValidationError::Tfdplayeritemlevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_MoveTimeValidationError, Tfdweaponitemid) == 0x000050, "Member 'FM1NxLog_MoveTimeValidationError::Tfdweaponitemid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_MoveTimeValidationError, Tfdweaponitemlevel) == 0x000060, "Member 'FM1NxLog_MoveTimeValidationError::Tfdweaponitemlevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_MoveTimeValidationError, FieldId) == 0x000070, "Member 'FM1NxLog_MoveTimeValidationError::FieldId' has a wrong offset!");
static_assert(offsetof(FM1NxLog_MoveTimeValidationError, FieldUid) == 0x000080, "Member 'FM1NxLog_MoveTimeValidationError::FieldUid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_MoveTimeValidationError, Timediscrepancyerror) == 0x000090, "Member 'FM1NxLog_MoveTimeValidationError::Timediscrepancyerror' has a wrong offset!");
static_assert(offsetof(FM1NxLog_MoveTimeValidationError, Timediscrepancymax) == 0x0000A0, "Member 'FM1NxLog_MoveTimeValidationError::Timediscrepancymax' has a wrong offset!");

// ScriptStruct M1.M1NxLog_MoveTimeValidationError_Base
// 0x00B0 (0x0190 - 0x00E0)
struct FM1NxLog_MoveTimeValidationError_Base final : public FM1NxLog_Base
{
public:
	struct FM1NxLog_MoveTimeValidationError       ETC_MoveTimeValidationError;                       // 0x00E0(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_MoveTimeValidationError_Base) == 0x000008, "Wrong alignment on FM1NxLog_MoveTimeValidationError_Base");
static_assert(sizeof(FM1NxLog_MoveTimeValidationError_Base) == 0x000190, "Wrong size on FM1NxLog_MoveTimeValidationError_Base");
static_assert(offsetof(FM1NxLog_MoveTimeValidationError_Base, ETC_MoveTimeValidationError) == 0x0000E0, "Member 'FM1NxLog_MoveTimeValidationError_Base::ETC_MoveTimeValidationError' has a wrong offset!");

// ScriptStruct M1.M1NxLog_FireLocValidationError_Base
// 0x0110 (0x01F0 - 0x00E0)
struct FM1NxLog_FireLocValidationError_Base final : public FM1NxLog_Base
{
public:
	struct FM1NxLog_FireLocValidationError        ETC_FireLocValidationError;                        // 0x00E0(0x0110)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_FireLocValidationError_Base) == 0x000008, "Wrong alignment on FM1NxLog_FireLocValidationError_Base");
static_assert(sizeof(FM1NxLog_FireLocValidationError_Base) == 0x0001F0, "Wrong size on FM1NxLog_FireLocValidationError_Base");
static_assert(offsetof(FM1NxLog_FireLocValidationError_Base, ETC_FireLocValidationError) == 0x0000E0, "Member 'FM1NxLog_FireLocValidationError_Base::ETC_FireLocValidationError' has a wrong offset!");

// ScriptStruct M1.M1NxLog_HitLocValidationError
// 0x0110 (0x0110 - 0x0000)
struct FM1NxLog_HitLocValidationError final
{
public:
	class FString                                 Actionid;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Userlevel;                                         // 0x0010(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Usernickname;                                      // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tfdplayeritemid;                                   // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Tfdplayeritemlevel;                                // 0x0040(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Tfdweaponitemid;                                   // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLogInteger                        Tfdweaponitemlevel;                                // 0x0060(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 FieldId;                                           // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldUid;                                          // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NxLog_Location                      Clienthitloc;                                      // 0x0090(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1NxLog_Location                      Serverbaseloc;                                     // 0x00C0(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1NxLogDouble                         Validationlocdiff;                                 // 0x00F0(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1NxLogDouble                         Validationsize;                                    // 0x0100(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_HitLocValidationError) == 0x000008, "Wrong alignment on FM1NxLog_HitLocValidationError");
static_assert(sizeof(FM1NxLog_HitLocValidationError) == 0x000110, "Wrong size on FM1NxLog_HitLocValidationError");
static_assert(offsetof(FM1NxLog_HitLocValidationError, Actionid) == 0x000000, "Member 'FM1NxLog_HitLocValidationError::Actionid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_HitLocValidationError, Userlevel) == 0x000010, "Member 'FM1NxLog_HitLocValidationError::Userlevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_HitLocValidationError, Usernickname) == 0x000020, "Member 'FM1NxLog_HitLocValidationError::Usernickname' has a wrong offset!");
static_assert(offsetof(FM1NxLog_HitLocValidationError, Tfdplayeritemid) == 0x000030, "Member 'FM1NxLog_HitLocValidationError::Tfdplayeritemid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_HitLocValidationError, Tfdplayeritemlevel) == 0x000040, "Member 'FM1NxLog_HitLocValidationError::Tfdplayeritemlevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_HitLocValidationError, Tfdweaponitemid) == 0x000050, "Member 'FM1NxLog_HitLocValidationError::Tfdweaponitemid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_HitLocValidationError, Tfdweaponitemlevel) == 0x000060, "Member 'FM1NxLog_HitLocValidationError::Tfdweaponitemlevel' has a wrong offset!");
static_assert(offsetof(FM1NxLog_HitLocValidationError, FieldId) == 0x000070, "Member 'FM1NxLog_HitLocValidationError::FieldId' has a wrong offset!");
static_assert(offsetof(FM1NxLog_HitLocValidationError, FieldUid) == 0x000080, "Member 'FM1NxLog_HitLocValidationError::FieldUid' has a wrong offset!");
static_assert(offsetof(FM1NxLog_HitLocValidationError, Clienthitloc) == 0x000090, "Member 'FM1NxLog_HitLocValidationError::Clienthitloc' has a wrong offset!");
static_assert(offsetof(FM1NxLog_HitLocValidationError, Serverbaseloc) == 0x0000C0, "Member 'FM1NxLog_HitLocValidationError::Serverbaseloc' has a wrong offset!");
static_assert(offsetof(FM1NxLog_HitLocValidationError, Validationlocdiff) == 0x0000F0, "Member 'FM1NxLog_HitLocValidationError::Validationlocdiff' has a wrong offset!");
static_assert(offsetof(FM1NxLog_HitLocValidationError, Validationsize) == 0x000100, "Member 'FM1NxLog_HitLocValidationError::Validationsize' has a wrong offset!");

// ScriptStruct M1.M1NxLog_HitLocValidationError_Base
// 0x0110 (0x01F0 - 0x00E0)
struct FM1NxLog_HitLocValidationError_Base final : public FM1NxLog_Base
{
public:
	struct FM1NxLog_HitLocValidationError         ETC_HitLocValidationError;                         // 0x00E0(0x0110)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_HitLocValidationError_Base) == 0x000008, "Wrong alignment on FM1NxLog_HitLocValidationError_Base");
static_assert(sizeof(FM1NxLog_HitLocValidationError_Base) == 0x0001F0, "Wrong size on FM1NxLog_HitLocValidationError_Base");
static_assert(offsetof(FM1NxLog_HitLocValidationError_Base, ETC_HitLocValidationError) == 0x0000E0, "Member 'FM1NxLog_HitLocValidationError_Base::ETC_HitLocValidationError' has a wrong offset!");

// ScriptStruct M1.M1NxLog_FireIntervalValidationError_Base
// 0x00F0 (0x01D0 - 0x00E0)
struct FM1NxLog_FireIntervalValidationError_Base final : public FM1NxLog_Base
{
public:
	struct FM1NxLog_FireIntervalValidationError   ETC_FireIntervalValidationError;                   // 0x00E0(0x00F0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NxLog_FireIntervalValidationError_Base) == 0x000008, "Wrong alignment on FM1NxLog_FireIntervalValidationError_Base");
static_assert(sizeof(FM1NxLog_FireIntervalValidationError_Base) == 0x0001D0, "Wrong size on FM1NxLog_FireIntervalValidationError_Base");
static_assert(offsetof(FM1NxLog_FireIntervalValidationError_Base, ETC_FireIntervalValidationError) == 0x0000E0, "Member 'FM1NxLog_FireIntervalValidationError_Base::ETC_FireIntervalValidationError' has a wrong offset!");

// ScriptStruct M1.M1DroppedItemsByMonsters
// 0x0060 (0x0060 - 0x0000)
struct FM1DroppedItemsByMonsters final
{
public:
	int64                                         MonsterIdWhoDroppedItem;                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MonsterPartsTid;                                   // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int64, struct FM1DropItemInfoList>       DropItemInfoListForAccount;                        // 0x0010(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DroppedItemsByMonsters) == 0x000008, "Wrong alignment on FM1DroppedItemsByMonsters");
static_assert(sizeof(FM1DroppedItemsByMonsters) == 0x000060, "Wrong size on FM1DroppedItemsByMonsters");
static_assert(offsetof(FM1DroppedItemsByMonsters, MonsterIdWhoDroppedItem) == 0x000000, "Member 'FM1DroppedItemsByMonsters::MonsterIdWhoDroppedItem' has a wrong offset!");
static_assert(offsetof(FM1DroppedItemsByMonsters, MonsterPartsTid) == 0x000008, "Member 'FM1DroppedItemsByMonsters::MonsterPartsTid' has a wrong offset!");
static_assert(offsetof(FM1DroppedItemsByMonsters, DropItemInfoListForAccount) == 0x000010, "Member 'FM1DroppedItemsByMonsters::DropItemInfoListForAccount' has a wrong offset!");

// ScriptStruct M1.M1DroppedItemByMissionMonster
// 0x0028 (0x0028 - 0x0000)
struct FM1DroppedItemByMissionMonster final
{
public:
	TArray<class AM1Character*>                   WhoKilledMonsters;                                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class AM1Monster*                             MonsterKilled;                                     // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterLevel;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MissionCategory                            MissionCategory;                                   // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1TemplateId                          MissionTaskTemplateId;                             // 0x0020(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1DroppedItemByMissionMonster) == 0x000008, "Wrong alignment on FM1DroppedItemByMissionMonster");
static_assert(sizeof(FM1DroppedItemByMissionMonster) == 0x000028, "Wrong size on FM1DroppedItemByMissionMonster");
static_assert(offsetof(FM1DroppedItemByMissionMonster, WhoKilledMonsters) == 0x000000, "Member 'FM1DroppedItemByMissionMonster::WhoKilledMonsters' has a wrong offset!");
static_assert(offsetof(FM1DroppedItemByMissionMonster, MonsterKilled) == 0x000010, "Member 'FM1DroppedItemByMissionMonster::MonsterKilled' has a wrong offset!");
static_assert(offsetof(FM1DroppedItemByMissionMonster, MonsterLevel) == 0x000018, "Member 'FM1DroppedItemByMissionMonster::MonsterLevel' has a wrong offset!");
static_assert(offsetof(FM1DroppedItemByMissionMonster, MissionCategory) == 0x00001C, "Member 'FM1DroppedItemByMissionMonster::MissionCategory' has a wrong offset!");
static_assert(offsetof(FM1DroppedItemByMissionMonster, MissionTaskTemplateId) == 0x000020, "Member 'FM1DroppedItemByMissionMonster::MissionTaskTemplateId' has a wrong offset!");

// ScriptStruct M1.M1DroppedItemByMissionWaveMonster
// 0x0020 (0x0020 - 0x0000)
struct FM1DroppedItemByMissionWaveMonster final
{
public:
	TArray<class AM1Character*>                   WhoKilledMonsters;                                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class AM1Monster*                             MonsterKilled;                                     // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonsterLevel;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MissionWaveTemplateId;                             // 0x001C(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DroppedItemByMissionWaveMonster) == 0x000008, "Wrong alignment on FM1DroppedItemByMissionWaveMonster");
static_assert(sizeof(FM1DroppedItemByMissionWaveMonster) == 0x000020, "Wrong size on FM1DroppedItemByMissionWaveMonster");
static_assert(offsetof(FM1DroppedItemByMissionWaveMonster, WhoKilledMonsters) == 0x000000, "Member 'FM1DroppedItemByMissionWaveMonster::WhoKilledMonsters' has a wrong offset!");
static_assert(offsetof(FM1DroppedItemByMissionWaveMonster, MonsterKilled) == 0x000010, "Member 'FM1DroppedItemByMissionWaveMonster::MonsterKilled' has a wrong offset!");
static_assert(offsetof(FM1DroppedItemByMissionWaveMonster, MonsterLevel) == 0x000018, "Member 'FM1DroppedItemByMissionWaveMonster::MonsterLevel' has a wrong offset!");
static_assert(offsetof(FM1DroppedItemByMissionWaveMonster, MissionWaveTemplateId) == 0x00001C, "Member 'FM1DroppedItemByMissionWaveMonster::MissionWaveTemplateId' has a wrong offset!");

// ScriptStruct M1.M1DroppedItemByFieldObject
// 0x0058 (0x0058 - 0x0000)
struct FM1DroppedItemByFieldObject final
{
public:
	int64                                         FieldObjectUidWhoDroppedItem;                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int64, struct FM1DropItemInfoList>       DropItemInfoListForAccount;                        // 0x0008(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DroppedItemByFieldObject) == 0x000008, "Wrong alignment on FM1DroppedItemByFieldObject");
static_assert(sizeof(FM1DroppedItemByFieldObject) == 0x000058, "Wrong size on FM1DroppedItemByFieldObject");
static_assert(offsetof(FM1DroppedItemByFieldObject, FieldObjectUidWhoDroppedItem) == 0x000000, "Member 'FM1DroppedItemByFieldObject::FieldObjectUidWhoDroppedItem' has a wrong offset!");
static_assert(offsetof(FM1DroppedItemByFieldObject, DropItemInfoListForAccount) == 0x000008, "Member 'FM1DroppedItemByFieldObject::DropItemInfoListForAccount' has a wrong offset!");

// ScriptStruct M1.M1DropItemAcquisition
// 0x0020 (0x0020 - 0x0000)
struct FM1DropItemAcquisition final
{
public:
	int64                                         MonsterUniqueId;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ItemTidBox                          ItemBox;                                           // 0x000C(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ItemOid;                                           // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DropItemAcquisition) == 0x000008, "Wrong alignment on FM1DropItemAcquisition");
static_assert(sizeof(FM1DropItemAcquisition) == 0x000020, "Wrong size on FM1DropItemAcquisition");
static_assert(offsetof(FM1DropItemAcquisition, MonsterUniqueId) == 0x000000, "Member 'FM1DropItemAcquisition::MonsterUniqueId' has a wrong offset!");
static_assert(offsetof(FM1DropItemAcquisition, Count) == 0x000008, "Member 'FM1DropItemAcquisition::Count' has a wrong offset!");
static_assert(offsetof(FM1DropItemAcquisition, ItemBox) == 0x00000C, "Member 'FM1DropItemAcquisition::ItemBox' has a wrong offset!");
static_assert(offsetof(FM1DropItemAcquisition, ItemOid) == 0x000018, "Member 'FM1DropItemAcquisition::ItemOid' has a wrong offset!");

// ScriptStruct M1.M1ChangeLoadoutSlotNameParam
// 0x0030 (0x0030 - 0x0000)
struct FM1ChangeLoadoutSlotNameParam final
{
public:
	EM1RuneSocketOwnerType                        OwnerType;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1TemplateId                          OwnerTid;                                          // 0x0004(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoadoutSlotIndex;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Language;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SlotName;                                          // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ChangeLoadoutSlotNameParam) == 0x000008, "Wrong alignment on FM1ChangeLoadoutSlotNameParam");
static_assert(sizeof(FM1ChangeLoadoutSlotNameParam) == 0x000030, "Wrong size on FM1ChangeLoadoutSlotNameParam");
static_assert(offsetof(FM1ChangeLoadoutSlotNameParam, OwnerType) == 0x000000, "Member 'FM1ChangeLoadoutSlotNameParam::OwnerType' has a wrong offset!");
static_assert(offsetof(FM1ChangeLoadoutSlotNameParam, OwnerTid) == 0x000004, "Member 'FM1ChangeLoadoutSlotNameParam::OwnerTid' has a wrong offset!");
static_assert(offsetof(FM1ChangeLoadoutSlotNameParam, LoadoutSlotIndex) == 0x000008, "Member 'FM1ChangeLoadoutSlotNameParam::LoadoutSlotIndex' has a wrong offset!");
static_assert(offsetof(FM1ChangeLoadoutSlotNameParam, Language) == 0x000010, "Member 'FM1ChangeLoadoutSlotNameParam::Language' has a wrong offset!");
static_assert(offsetof(FM1ChangeLoadoutSlotNameParam, SlotName) == 0x000020, "Member 'FM1ChangeLoadoutSlotNameParam::SlotName' has a wrong offset!");

// ScriptStruct M1.M1ChangePresetSlotNameParam
// 0x0028 (0x0028 - 0x0000)
struct FM1ChangePresetSlotNameParam final
{
public:
	int32                                         PresetIndex;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Language;                                          // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SlotName;                                          // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ChangePresetSlotNameParam) == 0x000008, "Wrong alignment on FM1ChangePresetSlotNameParam");
static_assert(sizeof(FM1ChangePresetSlotNameParam) == 0x000028, "Wrong size on FM1ChangePresetSlotNameParam");
static_assert(offsetof(FM1ChangePresetSlotNameParam, PresetIndex) == 0x000000, "Member 'FM1ChangePresetSlotNameParam::PresetIndex' has a wrong offset!");
static_assert(offsetof(FM1ChangePresetSlotNameParam, Language) == 0x000008, "Member 'FM1ChangePresetSlotNameParam::Language' has a wrong offset!");
static_assert(offsetof(FM1ChangePresetSlotNameParam, SlotName) == 0x000018, "Member 'FM1ChangePresetSlotNameParam::SlotName' has a wrong offset!");

// ScriptStruct M1.M1BuyLoadoutSlotParam
// 0x0008 (0x0008 - 0x0000)
struct FM1BuyLoadoutSlotParam final
{
public:
	EM1RuneSocketOwnerType                        OwnerType;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1TemplateId                          OwnerTid;                                          // 0x0004(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BuyLoadoutSlotParam) == 0x000004, "Wrong alignment on FM1BuyLoadoutSlotParam");
static_assert(sizeof(FM1BuyLoadoutSlotParam) == 0x000008, "Wrong size on FM1BuyLoadoutSlotParam");
static_assert(offsetof(FM1BuyLoadoutSlotParam, OwnerType) == 0x000000, "Member 'FM1BuyLoadoutSlotParam::OwnerType' has a wrong offset!");
static_assert(offsetof(FM1BuyLoadoutSlotParam, OwnerTid) == 0x000004, "Member 'FM1BuyLoadoutSlotParam::OwnerTid' has a wrong offset!");

// ScriptStruct M1.M1EnchantRuneInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1EnchantRuneInfo final
{
public:
	struct FM1ItemUidBox                          RuneUid;                                           // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         TargetEnchantLevel;                                // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1EnchantRuneInfo) == 0x000008, "Wrong alignment on FM1EnchantRuneInfo");
static_assert(sizeof(FM1EnchantRuneInfo) == 0x000018, "Wrong size on FM1EnchantRuneInfo");
static_assert(offsetof(FM1EnchantRuneInfo, RuneUid) == 0x000000, "Member 'FM1EnchantRuneInfo::RuneUid' has a wrong offset!");
static_assert(offsetof(FM1EnchantRuneInfo, TargetEnchantLevel) == 0x000010, "Member 'FM1EnchantRuneInfo::TargetEnchantLevel' has a wrong offset!");

// ScriptStruct M1.M1ComposeRuneInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1ComposeRuneInfo final
{
public:
	struct FM1ItemBoxesInfo                       RuneUidsInfo;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ComposeRuneInfo) == 0x000008, "Wrong alignment on FM1ComposeRuneInfo");
static_assert(sizeof(FM1ComposeRuneInfo) == 0x000010, "Wrong size on FM1ComposeRuneInfo");
static_assert(offsetof(FM1ComposeRuneInfo, RuneUidsInfo) == 0x000000, "Member 'FM1ComposeRuneInfo::RuneUidsInfo' has a wrong offset!");

// ScriptStruct M1.M1DecomposeRuneInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1DecomposeRuneInfo final
{
public:
	TArray<struct FM1TemplateId>                  RuneTemplateIds;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 RuneEnchantLevels;                                 // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DecomposeRuneInfo) == 0x000008, "Wrong alignment on FM1DecomposeRuneInfo");
static_assert(sizeof(FM1DecomposeRuneInfo) == 0x000020, "Wrong size on FM1DecomposeRuneInfo");
static_assert(offsetof(FM1DecomposeRuneInfo, RuneTemplateIds) == 0x000000, "Member 'FM1DecomposeRuneInfo::RuneTemplateIds' has a wrong offset!");
static_assert(offsetof(FM1DecomposeRuneInfo, RuneEnchantLevels) == 0x000010, "Member 'FM1DecomposeRuneInfo::RuneEnchantLevels' has a wrong offset!");

// ScriptStruct M1.M1CustomizeEvolutionInfo
// 0x000C (0x000C - 0x0000)
struct FM1CustomizeEvolutionInfo final
{
public:
	struct FM1TemplateId                          SkinTid;                                           // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EvolutionIdx;                                      // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EvolutionComplete;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizeEvolutionInfo) == 0x000004, "Wrong alignment on FM1CustomizeEvolutionInfo");
static_assert(sizeof(FM1CustomizeEvolutionInfo) == 0x00000C, "Wrong size on FM1CustomizeEvolutionInfo");
static_assert(offsetof(FM1CustomizeEvolutionInfo, SkinTid) == 0x000000, "Member 'FM1CustomizeEvolutionInfo::SkinTid' has a wrong offset!");
static_assert(offsetof(FM1CustomizeEvolutionInfo, EvolutionIdx) == 0x000004, "Member 'FM1CustomizeEvolutionInfo::EvolutionIdx' has a wrong offset!");
static_assert(offsetof(FM1CustomizeEvolutionInfo, EvolutionComplete) == 0x000008, "Member 'FM1CustomizeEvolutionInfo::EvolutionComplete' has a wrong offset!");

// ScriptStruct M1.M1SocialMotionInfoWrapper
// 0x000C (0x000C - 0x0000)
struct FM1SocialMotionInfoWrapper final
{
public:
	struct FM1ItemTidBox                          ItemBox;                                           // 0x0000(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNewItem;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SocialMotionInfoWrapper) == 0x000004, "Wrong alignment on FM1SocialMotionInfoWrapper");
static_assert(sizeof(FM1SocialMotionInfoWrapper) == 0x00000C, "Wrong size on FM1SocialMotionInfoWrapper");
static_assert(offsetof(FM1SocialMotionInfoWrapper, ItemBox) == 0x000000, "Member 'FM1SocialMotionInfoWrapper::ItemBox' has a wrong offset!");
static_assert(offsetof(FM1SocialMotionInfoWrapper, bNewItem) == 0x000008, "Member 'FM1SocialMotionInfoWrapper::bNewItem' has a wrong offset!");

// ScriptStruct M1.M1ShopBuyItemInfo
// 0x0028 (0x0028 - 0x0000)
struct FM1ShopBuyItemInfo final
{
public:
	struct FM1TemplateId                          ShopTemplateId;                                    // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ProductTid;                                        // 0x0004(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1BuyAdditionalData                   AdditionalData;                                    // 0x0008(0x0018)(NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ShopBuyItemInfo) == 0x000008, "Wrong alignment on FM1ShopBuyItemInfo");
static_assert(sizeof(FM1ShopBuyItemInfo) == 0x000028, "Wrong size on FM1ShopBuyItemInfo");
static_assert(offsetof(FM1ShopBuyItemInfo, ShopTemplateId) == 0x000000, "Member 'FM1ShopBuyItemInfo::ShopTemplateId' has a wrong offset!");
static_assert(offsetof(FM1ShopBuyItemInfo, ProductTid) == 0x000004, "Member 'FM1ShopBuyItemInfo::ProductTid' has a wrong offset!");
static_assert(offsetof(FM1ShopBuyItemInfo, AdditionalData) == 0x000008, "Member 'FM1ShopBuyItemInfo::AdditionalData' has a wrong offset!");
static_assert(offsetof(FM1ShopBuyItemInfo, Count) == 0x000020, "Member 'FM1ShopBuyItemInfo::Count' has a wrong offset!");

// ScriptStruct M1.M1ShopSellItemInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1ShopSellItemInfo final
{
public:
	struct FM1ItemUidBox                          ItemBox;                                           // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ItemTemplateId;                                    // 0x0010(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ShopSellItemInfo) == 0x000008, "Wrong alignment on FM1ShopSellItemInfo");
static_assert(sizeof(FM1ShopSellItemInfo) == 0x000018, "Wrong size on FM1ShopSellItemInfo");
static_assert(offsetof(FM1ShopSellItemInfo, ItemBox) == 0x000000, "Member 'FM1ShopSellItemInfo::ItemBox' has a wrong offset!");
static_assert(offsetof(FM1ShopSellItemInfo, ItemTemplateId) == 0x000010, "Member 'FM1ShopSellItemInfo::ItemTemplateId' has a wrong offset!");
static_assert(offsetof(FM1ShopSellItemInfo, Count) == 0x000014, "Member 'FM1ShopSellItemInfo::Count' has a wrong offset!");

// ScriptStruct M1.M1SetItemTagInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1SetItemTagInfo final
{
public:
	struct FM1ItemUidBox                          ItemBox;                                           // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	EM1ItemTagStatus                              ItemTagStatus;                                     // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SetItemTagInfo) == 0x000008, "Wrong alignment on FM1SetItemTagInfo");
static_assert(sizeof(FM1SetItemTagInfo) == 0x000018, "Wrong size on FM1SetItemTagInfo");
static_assert(offsetof(FM1SetItemTagInfo, ItemBox) == 0x000000, "Member 'FM1SetItemTagInfo::ItemBox' has a wrong offset!");
static_assert(offsetof(FM1SetItemTagInfo, ItemTagStatus) == 0x000010, "Member 'FM1SetItemTagInfo::ItemTagStatus' has a wrong offset!");

// ScriptStruct M1.M1WeaponBurstFireParams
// 0x0004 (0x0004 - 0x0000)
struct FM1WeaponBurstFireParams final
{
public:
	float                                         Interval;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponBurstFireParams) == 0x000004, "Wrong alignment on FM1WeaponBurstFireParams");
static_assert(sizeof(FM1WeaponBurstFireParams) == 0x000004, "Wrong size on FM1WeaponBurstFireParams");
static_assert(offsetof(FM1WeaponBurstFireParams, Interval) == 0x000000, "Member 'FM1WeaponBurstFireParams::Interval' has a wrong offset!");

// ScriptStruct M1.M1DeleteJunkInfo
// 0x0001 (0x0001 - 0x0000)
struct FM1DeleteJunkInfo final
{
public:
	EM1ItemType                                   ItemType;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DeleteJunkInfo) == 0x000001, "Wrong alignment on FM1DeleteJunkInfo");
static_assert(sizeof(FM1DeleteJunkInfo) == 0x000001, "Wrong size on FM1DeleteJunkInfo");
static_assert(offsetof(FM1DeleteJunkInfo, ItemType) == 0x000000, "Member 'FM1DeleteJunkInfo::ItemType' has a wrong offset!");

// ScriptStruct M1.M1SellJunkInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1SellJunkInfo final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ItemType                                   ItemType;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SellJunkInfo) == 0x000008, "Wrong alignment on FM1SellJunkInfo");
static_assert(sizeof(FM1SellJunkInfo) == 0x000010, "Wrong size on FM1SellJunkInfo");
static_assert(offsetof(FM1SellJunkInfo, AccountUid) == 0x000000, "Member 'FM1SellJunkInfo::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1SellJunkInfo, ItemType) == 0x000008, "Member 'FM1SellJunkInfo::ItemType' has a wrong offset!");

// ScriptStruct M1.M1RequestMatching
// 0x0040 (0x0040 - 0x0000)
struct FM1RequestMatching final
{
public:
	struct FM1TemplateId                          MapId;                                             // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1MapSubData                          MapSubData;                                        // 0x0004(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1RegionLatencyInfosMs                Req_3;                                             // 0x0018(0x0010)(NativeAccessSpecifierPublic)
	TArray<struct FM1TemplateId>                  ModifierIds;                                       // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsPrivate;                                         // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RequestMatching) == 0x000008, "Wrong alignment on FM1RequestMatching");
static_assert(sizeof(FM1RequestMatching) == 0x000040, "Wrong size on FM1RequestMatching");
static_assert(offsetof(FM1RequestMatching, MapId) == 0x000000, "Member 'FM1RequestMatching::MapId' has a wrong offset!");
static_assert(offsetof(FM1RequestMatching, MapSubData) == 0x000004, "Member 'FM1RequestMatching::MapSubData' has a wrong offset!");
static_assert(offsetof(FM1RequestMatching, Req_3) == 0x000018, "Member 'FM1RequestMatching::Req_3' has a wrong offset!");
static_assert(offsetof(FM1RequestMatching, ModifierIds) == 0x000028, "Member 'FM1RequestMatching::ModifierIds' has a wrong offset!");
static_assert(offsetof(FM1RequestMatching, IsPrivate) == 0x000038, "Member 'FM1RequestMatching::IsPrivate' has a wrong offset!");

// ScriptStruct M1.M1InvasionDungeonCompleteResultInfo
// 0x0014 (0x0014 - 0x0000)
struct FM1InvasionDungeonCompleteResultInfo final
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardBaseExp;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardBonusExp;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalRewardExpBefore;                              // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalRewardExpAfter;                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InvasionDungeonCompleteResultInfo) == 0x000004, "Wrong alignment on FM1InvasionDungeonCompleteResultInfo");
static_assert(sizeof(FM1InvasionDungeonCompleteResultInfo) == 0x000014, "Wrong size on FM1InvasionDungeonCompleteResultInfo");
static_assert(offsetof(FM1InvasionDungeonCompleteResultInfo, TemplateId) == 0x000000, "Member 'FM1InvasionDungeonCompleteResultInfo::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonCompleteResultInfo, RewardBaseExp) == 0x000004, "Member 'FM1InvasionDungeonCompleteResultInfo::RewardBaseExp' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonCompleteResultInfo, RewardBonusExp) == 0x000008, "Member 'FM1InvasionDungeonCompleteResultInfo::RewardBonusExp' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonCompleteResultInfo, TotalRewardExpBefore) == 0x00000C, "Member 'FM1InvasionDungeonCompleteResultInfo::TotalRewardExpBefore' has a wrong offset!");
static_assert(offsetof(FM1InvasionDungeonCompleteResultInfo, TotalRewardExpAfter) == 0x000010, "Member 'FM1InvasionDungeonCompleteResultInfo::TotalRewardExpAfter' has a wrong offset!");

// ScriptStruct M1.M1GetQuestInfoResult
// 0x0030 (0x0030 - 0x0000)
struct FM1GetQuestInfoResult final
{
public:
	EM1QuestType                                  QuestType;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1QuestInfoList                       QuestInfoList;                                     // 0x0008(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GetQuestInfoResult) == 0x000008, "Wrong alignment on FM1GetQuestInfoResult");
static_assert(sizeof(FM1GetQuestInfoResult) == 0x000030, "Wrong size on FM1GetQuestInfoResult");
static_assert(offsetof(FM1GetQuestInfoResult, QuestType) == 0x000000, "Member 'FM1GetQuestInfoResult::QuestType' has a wrong offset!");
static_assert(offsetof(FM1GetQuestInfoResult, QuestInfoList) == 0x000008, "Member 'FM1GetQuestInfoResult::QuestInfoList' has a wrong offset!");

// ScriptStruct M1.M1WeaponReloadRepData
// 0x000C (0x000C - 0x0000)
struct FM1WeaponReloadRepData final
{
public:
	EM1WeaponReloadState                          WeaponReloadState;                                 // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndedByInterrupt;                                 // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1WeaponReloadRepData) == 0x000004, "Wrong alignment on FM1WeaponReloadRepData");
static_assert(sizeof(FM1WeaponReloadRepData) == 0x00000C, "Wrong size on FM1WeaponReloadRepData");
static_assert(offsetof(FM1WeaponReloadRepData, WeaponReloadState) == 0x000000, "Member 'FM1WeaponReloadRepData::WeaponReloadState' has a wrong offset!");
static_assert(offsetof(FM1WeaponReloadRepData, PlayRate) == 0x000004, "Member 'FM1WeaponReloadRepData::PlayRate' has a wrong offset!");
static_assert(offsetof(FM1WeaponReloadRepData, bEndedByInterrupt) == 0x000008, "Member 'FM1WeaponReloadRepData::bEndedByInterrupt' has a wrong offset!");

// ScriptStruct M1.M1RecordMatchedGameEnd
// 0x0010 (0x0010 - 0x0000)
struct FM1RecordMatchedGameEnd final
{
public:
	int32                                         MatchFinalRound;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MatchElapsedtime;                                  // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchRecordDeath;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MatchRecordDamagegive;                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RecordMatchedGameEnd) == 0x000004, "Wrong alignment on FM1RecordMatchedGameEnd");
static_assert(sizeof(FM1RecordMatchedGameEnd) == 0x000010, "Wrong size on FM1RecordMatchedGameEnd");
static_assert(offsetof(FM1RecordMatchedGameEnd, MatchFinalRound) == 0x000000, "Member 'FM1RecordMatchedGameEnd::MatchFinalRound' has a wrong offset!");
static_assert(offsetof(FM1RecordMatchedGameEnd, MatchElapsedtime) == 0x000004, "Member 'FM1RecordMatchedGameEnd::MatchElapsedtime' has a wrong offset!");
static_assert(offsetof(FM1RecordMatchedGameEnd, MatchRecordDeath) == 0x000008, "Member 'FM1RecordMatchedGameEnd::MatchRecordDeath' has a wrong offset!");
static_assert(offsetof(FM1RecordMatchedGameEnd, MatchRecordDamagegive) == 0x00000C, "Member 'FM1RecordMatchedGameEnd::MatchRecordDamagegive' has a wrong offset!");

// ScriptStruct M1.M1InstanceDungeonSelectedReward
// 0x0010 (0x0010 - 0x0000)
struct FM1InstanceDungeonSelectedReward final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardTid;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1InstanceDungeonSelectedReward) == 0x000008, "Wrong alignment on FM1InstanceDungeonSelectedReward");
static_assert(sizeof(FM1InstanceDungeonSelectedReward) == 0x000010, "Wrong size on FM1InstanceDungeonSelectedReward");
static_assert(offsetof(FM1InstanceDungeonSelectedReward, AccountUid) == 0x000000, "Member 'FM1InstanceDungeonSelectedReward::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1InstanceDungeonSelectedReward, RewardTid) == 0x000008, "Member 'FM1InstanceDungeonSelectedReward::RewardTid' has a wrong offset!");

// ScriptStruct M1.M1Request_LoginToGameServer
// 0x0048 (0x0048 - 0x0000)
struct FM1Request_LoginToGameServer final : public FM1Request
{
public:
	class FString                                 LoginId;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Token;                                             // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameServerIp;                                      // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GameServerPort;                                    // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AccountLinkInfo;                                   // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Request_LoginToGameServer) == 0x000008, "Wrong alignment on FM1Request_LoginToGameServer");
static_assert(sizeof(FM1Request_LoginToGameServer) == 0x000048, "Wrong size on FM1Request_LoginToGameServer");
static_assert(offsetof(FM1Request_LoginToGameServer, LoginId) == 0x000000, "Member 'FM1Request_LoginToGameServer::LoginId' has a wrong offset!");
static_assert(offsetof(FM1Request_LoginToGameServer, Token) == 0x000010, "Member 'FM1Request_LoginToGameServer::Token' has a wrong offset!");
static_assert(offsetof(FM1Request_LoginToGameServer, GameServerIp) == 0x000020, "Member 'FM1Request_LoginToGameServer::GameServerIp' has a wrong offset!");
static_assert(offsetof(FM1Request_LoginToGameServer, GameServerPort) == 0x000030, "Member 'FM1Request_LoginToGameServer::GameServerPort' has a wrong offset!");
static_assert(offsetof(FM1Request_LoginToGameServer, AccountLinkInfo) == 0x000038, "Member 'FM1Request_LoginToGameServer::AccountLinkInfo' has a wrong offset!");

// ScriptStruct M1.M1RequestMiniGameDropItemInfo
// 0x0038 (0x0038 - 0x0000)
struct FM1RequestMiniGameDropItemInfo final
{
public:
	TArray<int64>                                 AccountIDs;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FM1TemplateId                          MiniGameTid;                                       // 0x0010(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MiniGameUid;                                       // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 WhoDroppedThis;                                    // 0x0020(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                DropLocation;                                      // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RequestMiniGameDropItemInfo) == 0x000008, "Wrong alignment on FM1RequestMiniGameDropItemInfo");
static_assert(sizeof(FM1RequestMiniGameDropItemInfo) == 0x000038, "Wrong size on FM1RequestMiniGameDropItemInfo");
static_assert(offsetof(FM1RequestMiniGameDropItemInfo, AccountIDs) == 0x000000, "Member 'FM1RequestMiniGameDropItemInfo::AccountIDs' has a wrong offset!");
static_assert(offsetof(FM1RequestMiniGameDropItemInfo, MiniGameTid) == 0x000010, "Member 'FM1RequestMiniGameDropItemInfo::MiniGameTid' has a wrong offset!");
static_assert(offsetof(FM1RequestMiniGameDropItemInfo, MiniGameUid) == 0x000018, "Member 'FM1RequestMiniGameDropItemInfo::MiniGameUid' has a wrong offset!");
static_assert(offsetof(FM1RequestMiniGameDropItemInfo, WhoDroppedThis) == 0x000020, "Member 'FM1RequestMiniGameDropItemInfo::WhoDroppedThis' has a wrong offset!");
static_assert(offsetof(FM1RequestMiniGameDropItemInfo, DropLocation) == 0x000028, "Member 'FM1RequestMiniGameDropItemInfo::DropLocation' has a wrong offset!");

// ScriptStruct M1.M1RequestAbilityDropItemInfo
// 0x0058 (0x0058 - 0x0000)
struct FM1RequestAbilityDropItemInfo final
{
public:
	TArray<int64>                                 AccountIDs;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class AActor*                                 Instigator;                                        // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 WhoDroppedThis;                                    // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DropItemRowName;                                   // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                DropLocation;                                      // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBox                                   DesiredContainerBounds;                            // 0x0034(0x001C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         AdditionalLaunchForce;                             // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RequestAbilityDropItemInfo) == 0x000008, "Wrong alignment on FM1RequestAbilityDropItemInfo");
static_assert(sizeof(FM1RequestAbilityDropItemInfo) == 0x000058, "Wrong size on FM1RequestAbilityDropItemInfo");
static_assert(offsetof(FM1RequestAbilityDropItemInfo, AccountIDs) == 0x000000, "Member 'FM1RequestAbilityDropItemInfo::AccountIDs' has a wrong offset!");
static_assert(offsetof(FM1RequestAbilityDropItemInfo, Instigator) == 0x000010, "Member 'FM1RequestAbilityDropItemInfo::Instigator' has a wrong offset!");
static_assert(offsetof(FM1RequestAbilityDropItemInfo, WhoDroppedThis) == 0x000018, "Member 'FM1RequestAbilityDropItemInfo::WhoDroppedThis' has a wrong offset!");
static_assert(offsetof(FM1RequestAbilityDropItemInfo, DropItemRowName) == 0x000020, "Member 'FM1RequestAbilityDropItemInfo::DropItemRowName' has a wrong offset!");
static_assert(offsetof(FM1RequestAbilityDropItemInfo, DropLocation) == 0x000028, "Member 'FM1RequestAbilityDropItemInfo::DropLocation' has a wrong offset!");
static_assert(offsetof(FM1RequestAbilityDropItemInfo, DesiredContainerBounds) == 0x000034, "Member 'FM1RequestAbilityDropItemInfo::DesiredContainerBounds' has a wrong offset!");
static_assert(offsetof(FM1RequestAbilityDropItemInfo, AdditionalLaunchForce) == 0x000050, "Member 'FM1RequestAbilityDropItemInfo::AdditionalLaunchForce' has a wrong offset!");

// ScriptStruct M1.M1MissionSucceededAccountInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1MissionSucceededAccountInfo final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MissionResultGrade;                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MissionSucceededAccountInfo) == 0x000008, "Wrong alignment on FM1MissionSucceededAccountInfo");
static_assert(sizeof(FM1MissionSucceededAccountInfo) == 0x000010, "Wrong size on FM1MissionSucceededAccountInfo");
static_assert(offsetof(FM1MissionSucceededAccountInfo, AccountUid) == 0x000000, "Member 'FM1MissionSucceededAccountInfo::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1MissionSucceededAccountInfo, MissionResultGrade) == 0x000008, "Member 'FM1MissionSucceededAccountInfo::MissionResultGrade' has a wrong offset!");

// ScriptStruct M1.M1Request_MissionSucceeded
// 0x0018 (0x0018 - 0x0000)
struct FM1Request_MissionSucceeded final
{
public:
	TArray<struct FM1MissionSucceededAccountInfo> AccountInfos;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MissionTemplateId;                                 // 0x0010(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_MissionSucceeded) == 0x000008, "Wrong alignment on FM1Request_MissionSucceeded");
static_assert(sizeof(FM1Request_MissionSucceeded) == 0x000018, "Wrong size on FM1Request_MissionSucceeded");
static_assert(offsetof(FM1Request_MissionSucceeded, AccountInfos) == 0x000000, "Member 'FM1Request_MissionSucceeded::AccountInfos' has a wrong offset!");
static_assert(offsetof(FM1Request_MissionSucceeded, MissionTemplateId) == 0x000010, "Member 'FM1Request_MissionSucceeded::MissionTemplateId' has a wrong offset!");

// ScriptStruct M1.M1Request_SaveSetting
// 0x0010 (0x0010 - 0x0000)
struct FM1Request_SaveSetting final : public FM1Request
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1SettingInfo                         SettingInfo;                                       // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1Request_SaveSetting) == 0x000008, "Wrong alignment on FM1Request_SaveSetting");
static_assert(sizeof(FM1Request_SaveSetting) == 0x000010, "Wrong size on FM1Request_SaveSetting");
static_assert(offsetof(FM1Request_SaveSetting, AccountUid) == 0x000000, "Member 'FM1Request_SaveSetting::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1Request_SaveSetting, SettingInfo) == 0x000008, "Member 'FM1Request_SaveSetting::SettingInfo' has a wrong offset!");

// ScriptStruct M1.M1Response_AuthToGameServer
// 0x0004 (0x0004 - 0x0000)
struct FM1Response_AuthToGameServer final
{
public:
	EM1AuthResults                                Notification;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_AuthToGameServer) == 0x000004, "Wrong alignment on FM1Response_AuthToGameServer");
static_assert(sizeof(FM1Response_AuthToGameServer) == 0x000004, "Wrong size on FM1Response_AuthToGameServer");
static_assert(offsetof(FM1Response_AuthToGameServer, Notification) == 0x000000, "Member 'FM1Response_AuthToGameServer::Notification' has a wrong offset!");

// ScriptStruct M1.M1Response_GetAccountInfoToGameServer
// 0x00B8 (0x00B8 - 0x0000)
struct FM1Response_GetAccountInfoToGameServer final
{
public:
	struct FM1AccountSimpleInfo                   Notification;                                      // 0x0000(0x00B8)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1Response_GetAccountInfoToGameServer) == 0x000008, "Wrong alignment on FM1Response_GetAccountInfoToGameServer");
static_assert(sizeof(FM1Response_GetAccountInfoToGameServer) == 0x0000B8, "Wrong size on FM1Response_GetAccountInfoToGameServer");
static_assert(offsetof(FM1Response_GetAccountInfoToGameServer, Notification) == 0x000000, "Member 'FM1Response_GetAccountInfoToGameServer::Notification' has a wrong offset!");

// ScriptStruct M1.M1GameServiceNewCharacterForNewAccount
// 0x00B8 (0x00B8 - 0x0000)
struct FM1GameServiceNewCharacterForNewAccount final
{
public:
	struct FM1AccountSimpleInfo                   Account;                                           // 0x0000(0x00B8)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GameServiceNewCharacterForNewAccount) == 0x000008, "Wrong alignment on FM1GameServiceNewCharacterForNewAccount");
static_assert(sizeof(FM1GameServiceNewCharacterForNewAccount) == 0x0000B8, "Wrong size on FM1GameServiceNewCharacterForNewAccount");
static_assert(offsetof(FM1GameServiceNewCharacterForNewAccount, Account) == 0x000000, "Member 'FM1GameServiceNewCharacterForNewAccount::Account' has a wrong offset!");

// ScriptStruct M1.M1ItemServiceDropItemResult
// 0x0008 (0x0008 - 0x0000)
struct FM1ItemServiceDropItemResult final
{
public:
	int32                                         WhyItemDropped;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ItemTemplateId;                                    // 0x0004(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemServiceDropItemResult) == 0x000004, "Wrong alignment on FM1ItemServiceDropItemResult");
static_assert(sizeof(FM1ItemServiceDropItemResult) == 0x000008, "Wrong size on FM1ItemServiceDropItemResult");
static_assert(offsetof(FM1ItemServiceDropItemResult, WhyItemDropped) == 0x000000, "Member 'FM1ItemServiceDropItemResult::WhyItemDropped' has a wrong offset!");
static_assert(offsetof(FM1ItemServiceDropItemResult, ItemTemplateId) == 0x000004, "Member 'FM1ItemServiceDropItemResult::ItemTemplateId' has a wrong offset!");

// ScriptStruct M1.M1GameServiceJoinGameByMapResult
// 0x00C0 (0x00C0 - 0x0000)
struct FM1GameServiceJoinGameByMapResult final
{
public:
	struct FM1JoinDedicatedServerRes              JoinGameResult;                                    // 0x0000(0x00B0)(NativeAccessSpecifierPublic)
	class FString                                 StartLocationId;                                   // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GameServiceJoinGameByMapResult) == 0x000008, "Wrong alignment on FM1GameServiceJoinGameByMapResult");
static_assert(sizeof(FM1GameServiceJoinGameByMapResult) == 0x0000C0, "Wrong size on FM1GameServiceJoinGameByMapResult");
static_assert(offsetof(FM1GameServiceJoinGameByMapResult, JoinGameResult) == 0x000000, "Member 'FM1GameServiceJoinGameByMapResult::JoinGameResult' has a wrong offset!");
static_assert(offsetof(FM1GameServiceJoinGameByMapResult, StartLocationId) == 0x0000B0, "Member 'FM1GameServiceJoinGameByMapResult::StartLocationId' has a wrong offset!");

// ScriptStruct M1.M1GameSessionServicePlayerInfoToCreateAccount
// 0x01C0 (0x01C0 - 0x0000)
struct FM1GameSessionServicePlayerInfoToCreateAccount final
{
public:
	class FString                                 ServiceId;                                         // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RegionId;                                          // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1AccountInfo                         AccountInfo;                                       // 0x0020(0x0198)(NativeAccessSpecifierPublic)
	bool                                          bSuccess;                                          // 0x01B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B9[0x7];                                      // 0x01B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1GameSessionServicePlayerInfoToCreateAccount) == 0x000008, "Wrong alignment on FM1GameSessionServicePlayerInfoToCreateAccount");
static_assert(sizeof(FM1GameSessionServicePlayerInfoToCreateAccount) == 0x0001C0, "Wrong size on FM1GameSessionServicePlayerInfoToCreateAccount");
static_assert(offsetof(FM1GameSessionServicePlayerInfoToCreateAccount, ServiceId) == 0x000000, "Member 'FM1GameSessionServicePlayerInfoToCreateAccount::ServiceId' has a wrong offset!");
static_assert(offsetof(FM1GameSessionServicePlayerInfoToCreateAccount, RegionId) == 0x000010, "Member 'FM1GameSessionServicePlayerInfoToCreateAccount::RegionId' has a wrong offset!");
static_assert(offsetof(FM1GameSessionServicePlayerInfoToCreateAccount, AccountInfo) == 0x000020, "Member 'FM1GameSessionServicePlayerInfoToCreateAccount::AccountInfo' has a wrong offset!");
static_assert(offsetof(FM1GameSessionServicePlayerInfoToCreateAccount, bSuccess) == 0x0001B8, "Member 'FM1GameSessionServicePlayerInfoToCreateAccount::bSuccess' has a wrong offset!");

// ScriptStruct M1.M1GameplayServiceEventItemDropped
// 0x0020 (0x0020 - 0x0000)
struct FM1GameplayServiceEventItemDropped final
{
public:
	struct FM1DropItemInfoNoti                    Notification;                                      // 0x0000(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GameplayServiceEventItemDropped) == 0x000008, "Wrong alignment on FM1GameplayServiceEventItemDropped");
static_assert(sizeof(FM1GameplayServiceEventItemDropped) == 0x000020, "Wrong size on FM1GameplayServiceEventItemDropped");
static_assert(offsetof(FM1GameplayServiceEventItemDropped, Notification) == 0x000000, "Member 'FM1GameplayServiceEventItemDropped::Notification' has a wrong offset!");

// ScriptStruct M1.M1GameplayServiceEventResearchResult
// 0x0028 (0x0028 - 0x0000)
struct FM1GameplayServiceEventResearchResult final
{
public:
	EM1ResearchActionType                         ActionType;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ResearchResultNoti                  Notification;                                      // 0x0008(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GameplayServiceEventResearchResult) == 0x000008, "Wrong alignment on FM1GameplayServiceEventResearchResult");
static_assert(sizeof(FM1GameplayServiceEventResearchResult) == 0x000028, "Wrong size on FM1GameplayServiceEventResearchResult");
static_assert(offsetof(FM1GameplayServiceEventResearchResult, ActionType) == 0x000000, "Member 'FM1GameplayServiceEventResearchResult::ActionType' has a wrong offset!");
static_assert(offsetof(FM1GameplayServiceEventResearchResult, Notification) == 0x000008, "Member 'FM1GameplayServiceEventResearchResult::Notification' has a wrong offset!");

// ScriptStruct M1.M1ItemServiceSaveRuneQuickSlotResult
// 0x0010 (0x0010 - 0x0000)
struct FM1ItemServiceSaveRuneQuickSlotResult final
{
public:
	int64                                         RuneUid;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuickSlotIndex;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ItemServiceSaveRuneQuickSlotResult) == 0x000008, "Wrong alignment on FM1ItemServiceSaveRuneQuickSlotResult");
static_assert(sizeof(FM1ItemServiceSaveRuneQuickSlotResult) == 0x000010, "Wrong size on FM1ItemServiceSaveRuneQuickSlotResult");
static_assert(offsetof(FM1ItemServiceSaveRuneQuickSlotResult, RuneUid) == 0x000000, "Member 'FM1ItemServiceSaveRuneQuickSlotResult::RuneUid' has a wrong offset!");
static_assert(offsetof(FM1ItemServiceSaveRuneQuickSlotResult, QuickSlotIndex) == 0x000008, "Member 'FM1ItemServiceSaveRuneQuickSlotResult::QuickSlotIndex' has a wrong offset!");

// ScriptStruct M1.M1ItemServiceBuyItemResult
// 0x0010 (0x0010 - 0x0000)
struct FM1ItemServiceBuyItemResult final
{
public:
	struct FM1ShopBuyInfoBundle                   Notification;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemServiceBuyItemResult) == 0x000008, "Wrong alignment on FM1ItemServiceBuyItemResult");
static_assert(sizeof(FM1ItemServiceBuyItemResult) == 0x000010, "Wrong size on FM1ItemServiceBuyItemResult");
static_assert(offsetof(FM1ItemServiceBuyItemResult, Notification) == 0x000000, "Member 'FM1ItemServiceBuyItemResult::Notification' has a wrong offset!");

// ScriptStruct M1.M1ItemServiceSellItemResult
// 0x0028 (0x0028 - 0x0000)
struct FM1ItemServiceSellItemResult final
{
public:
	struct FM1ShopSellInfoNoti                    Notification;                                      // 0x0000(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          ItemTemplateId;                                    // 0x0020(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ItemServiceSellItemResult) == 0x000008, "Wrong alignment on FM1ItemServiceSellItemResult");
static_assert(sizeof(FM1ItemServiceSellItemResult) == 0x000028, "Wrong size on FM1ItemServiceSellItemResult");
static_assert(offsetof(FM1ItemServiceSellItemResult, Notification) == 0x000000, "Member 'FM1ItemServiceSellItemResult::Notification' has a wrong offset!");
static_assert(offsetof(FM1ItemServiceSellItemResult, ItemTemplateId) == 0x000020, "Member 'FM1ItemServiceSellItemResult::ItemTemplateId' has a wrong offset!");

// ScriptStruct M1.M1ItemServiceDeleteJunkResult
// 0x0010 (0x0010 - 0x0000)
struct FM1ItemServiceDeleteJunkResult final
{
public:
	struct FM1ItemBoxesInfo                       Notification;                                      // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemServiceDeleteJunkResult) == 0x000008, "Wrong alignment on FM1ItemServiceDeleteJunkResult");
static_assert(sizeof(FM1ItemServiceDeleteJunkResult) == 0x000010, "Wrong size on FM1ItemServiceDeleteJunkResult");
static_assert(offsetof(FM1ItemServiceDeleteJunkResult, Notification) == 0x000000, "Member 'FM1ItemServiceDeleteJunkResult::Notification' has a wrong offset!");

// ScriptStruct M1.M1GameSessionServiceQuestsInfo
// 0x0028 (0x0028 - 0x0000)
struct FM1GameSessionServiceQuestsInfo final
{
public:
	struct FM1QuestInfoList                       QuestInfo;                                         // 0x0000(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GameSessionServiceQuestsInfo) == 0x000008, "Wrong alignment on FM1GameSessionServiceQuestsInfo");
static_assert(sizeof(FM1GameSessionServiceQuestsInfo) == 0x000028, "Wrong size on FM1GameSessionServiceQuestsInfo");
static_assert(offsetof(FM1GameSessionServiceQuestsInfo, QuestInfo) == 0x000000, "Member 'FM1GameSessionServiceQuestsInfo::QuestInfo' has a wrong offset!");

// ScriptStruct M1.M1GameSessionServiceIncQuestProgress
// 0x0014 (0x0014 - 0x0000)
struct FM1GameSessionServiceIncQuestProgress final
{
public:
	struct FM1TemplateId                          QuestTemplateId;                                   // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConditionIndex;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1QuestCompleteState                         QuestCompleteState;                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1QuestParam                          ConditionParam;                                    // 0x000C(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GameSessionServiceIncQuestProgress) == 0x000004, "Wrong alignment on FM1GameSessionServiceIncQuestProgress");
static_assert(sizeof(FM1GameSessionServiceIncQuestProgress) == 0x000014, "Wrong size on FM1GameSessionServiceIncQuestProgress");
static_assert(offsetof(FM1GameSessionServiceIncQuestProgress, QuestTemplateId) == 0x000000, "Member 'FM1GameSessionServiceIncQuestProgress::QuestTemplateId' has a wrong offset!");
static_assert(offsetof(FM1GameSessionServiceIncQuestProgress, ConditionIndex) == 0x000004, "Member 'FM1GameSessionServiceIncQuestProgress::ConditionIndex' has a wrong offset!");
static_assert(offsetof(FM1GameSessionServiceIncQuestProgress, QuestCompleteState) == 0x000008, "Member 'FM1GameSessionServiceIncQuestProgress::QuestCompleteState' has a wrong offset!");
static_assert(offsetof(FM1GameSessionServiceIncQuestProgress, ConditionParam) == 0x00000C, "Member 'FM1GameSessionServiceIncQuestProgress::ConditionParam' has a wrong offset!");

// ScriptStruct M1.M1GameSessionServiceIncQuestProgressResList
// 0x0018 (0x0018 - 0x0000)
struct FM1GameSessionServiceIncQuestProgressResList final
{
public:
	TArray<struct FM1GameSessionServiceIncQuestProgress> ResList;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bSimulated;                                        // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1GameSessionServiceIncQuestProgressResList) == 0x000008, "Wrong alignment on FM1GameSessionServiceIncQuestProgressResList");
static_assert(sizeof(FM1GameSessionServiceIncQuestProgressResList) == 0x000018, "Wrong size on FM1GameSessionServiceIncQuestProgressResList");
static_assert(offsetof(FM1GameSessionServiceIncQuestProgressResList, ResList) == 0x000000, "Member 'FM1GameSessionServiceIncQuestProgressResList::ResList' has a wrong offset!");
static_assert(offsetof(FM1GameSessionServiceIncQuestProgressResList, bSimulated) == 0x000010, "Member 'FM1GameSessionServiceIncQuestProgressResList::bSimulated' has a wrong offset!");

// ScriptStruct M1.M1GameSessionServiceMainQuestJumpResult
// 0x0010 (0x0010 - 0x0000)
struct FM1GameSessionServiceMainQuestJumpResult final
{
public:
	struct FM1MainQuestJumpResult                 MainQuestJumpResult;                               // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GameSessionServiceMainQuestJumpResult) == 0x000008, "Wrong alignment on FM1GameSessionServiceMainQuestJumpResult");
static_assert(sizeof(FM1GameSessionServiceMainQuestJumpResult) == 0x000010, "Wrong size on FM1GameSessionServiceMainQuestJumpResult");
static_assert(offsetof(FM1GameSessionServiceMainQuestJumpResult, MainQuestJumpResult) == 0x000000, "Member 'FM1GameSessionServiceMainQuestJumpResult::MainQuestJumpResult' has a wrong offset!");

// ScriptStruct M1.M1SocialServiceSearchUser
// 0x0068 (0x0068 - 0x0000)
struct FM1SocialServiceSearchUser final
{
public:
	struct FM1SearchResponse                      SearchResponse;                                    // 0x0000(0x0068)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SocialServiceSearchUser) == 0x000008, "Wrong alignment on FM1SocialServiceSearchUser");
static_assert(sizeof(FM1SocialServiceSearchUser) == 0x000068, "Wrong size on FM1SocialServiceSearchUser");
static_assert(offsetof(FM1SocialServiceSearchUser, SearchResponse) == 0x000000, "Member 'FM1SocialServiceSearchUser::SearchResponse' has a wrong offset!");

// ScriptStruct M1.M1SocialServicePartyCommonResult
// 0x0018 (0x0018 - 0x0000)
struct FM1SocialServicePartyCommonResult final
{
public:
	int64                                         PartyUID;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         AccountID;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1PartyErrorCode                             PartyErrorCode;                                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SocialServicePartyCommonResult) == 0x000008, "Wrong alignment on FM1SocialServicePartyCommonResult");
static_assert(sizeof(FM1SocialServicePartyCommonResult) == 0x000018, "Wrong size on FM1SocialServicePartyCommonResult");
static_assert(offsetof(FM1SocialServicePartyCommonResult, PartyUID) == 0x000000, "Member 'FM1SocialServicePartyCommonResult::PartyUID' has a wrong offset!");
static_assert(offsetof(FM1SocialServicePartyCommonResult, AccountID) == 0x000008, "Member 'FM1SocialServicePartyCommonResult::AccountID' has a wrong offset!");
static_assert(offsetof(FM1SocialServicePartyCommonResult, PartyErrorCode) == 0x000010, "Member 'FM1SocialServicePartyCommonResult::PartyErrorCode' has a wrong offset!");

// ScriptStruct M1.M1SocialServiceMailList
// 0x0018 (0x0018 - 0x0000)
struct FM1SocialServiceMailList final
{
public:
	struct FM1MailInfoBundle                      MailInfoBundle;                                    // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SocialServiceMailList) == 0x000008, "Wrong alignment on FM1SocialServiceMailList");
static_assert(sizeof(FM1SocialServiceMailList) == 0x000018, "Wrong size on FM1SocialServiceMailList");
static_assert(offsetof(FM1SocialServiceMailList, MailInfoBundle) == 0x000000, "Member 'FM1SocialServiceMailList::MailInfoBundle' has a wrong offset!");

// ScriptStruct M1.M1SocialServiceMailCommon
// 0x0010 (0x0010 - 0x0000)
struct FM1SocialServiceMailCommon final
{
public:
	EM1MailReason                                 MailReason;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MailId;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SocialServiceMailCommon) == 0x000008, "Wrong alignment on FM1SocialServiceMailCommon");
static_assert(sizeof(FM1SocialServiceMailCommon) == 0x000010, "Wrong size on FM1SocialServiceMailCommon");
static_assert(offsetof(FM1SocialServiceMailCommon, MailReason) == 0x000000, "Member 'FM1SocialServiceMailCommon::MailReason' has a wrong offset!");
static_assert(offsetof(FM1SocialServiceMailCommon, MailId) == 0x000008, "Member 'FM1SocialServiceMailCommon::MailId' has a wrong offset!");

// ScriptStruct M1.M1UIEvent_BoostItemActivated
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FM1UIEvent_BoostItemActivated final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_BoostItemActivated) == 0x000008, "Wrong alignment on FM1UIEvent_BoostItemActivated");
static_assert(sizeof(FM1UIEvent_BoostItemActivated) == 0x000018, "Wrong size on FM1UIEvent_BoostItemActivated");

// ScriptStruct M1.M1SocialServiceReceiveMailAttachment
// 0x0018 (0x0018 - 0x0000)
struct FM1SocialServiceReceiveMailAttachment final
{
public:
	EM1MailReason                                 MailReason;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MailId;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttachmentIndex;                                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SocialServiceReceiveMailAttachment) == 0x000008, "Wrong alignment on FM1SocialServiceReceiveMailAttachment");
static_assert(sizeof(FM1SocialServiceReceiveMailAttachment) == 0x000018, "Wrong size on FM1SocialServiceReceiveMailAttachment");
static_assert(offsetof(FM1SocialServiceReceiveMailAttachment, MailReason) == 0x000000, "Member 'FM1SocialServiceReceiveMailAttachment::MailReason' has a wrong offset!");
static_assert(offsetof(FM1SocialServiceReceiveMailAttachment, MailId) == 0x000008, "Member 'FM1SocialServiceReceiveMailAttachment::MailId' has a wrong offset!");
static_assert(offsetof(FM1SocialServiceReceiveMailAttachment, AttachmentIndex) == 0x000010, "Member 'FM1SocialServiceReceiveMailAttachment::AttachmentIndex' has a wrong offset!");

// ScriptStruct M1.M1SocialServiceReceiveMultipleMailAttachmentAll
// 0x0010 (0x0010 - 0x0000)
struct FM1SocialServiceReceiveMultipleMailAttachmentAll final
{
public:
	TArray<struct FM1MultipleMailResult>          Results;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SocialServiceReceiveMultipleMailAttachmentAll) == 0x000008, "Wrong alignment on FM1SocialServiceReceiveMultipleMailAttachmentAll");
static_assert(sizeof(FM1SocialServiceReceiveMultipleMailAttachmentAll) == 0x000010, "Wrong size on FM1SocialServiceReceiveMultipleMailAttachmentAll");
static_assert(offsetof(FM1SocialServiceReceiveMultipleMailAttachmentAll, Results) == 0x000000, "Member 'FM1SocialServiceReceiveMultipleMailAttachmentAll::Results' has a wrong offset!");

// ScriptStruct M1.M1ChattingSetting
// 0x0060 (0x0060 - 0x0000)
struct FM1ChattingSetting final
{
public:
	struct FLinearColor                           ChatWorldColor;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ChatNormalColor;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ChatPartyColor;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ChatDirectMessageColor;                            // 0x0030(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ChatSystemColor;                                   // 0x0040(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ChatNoticeColor;                                   // 0x0050(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ChattingSetting) == 0x000004, "Wrong alignment on FM1ChattingSetting");
static_assert(sizeof(FM1ChattingSetting) == 0x000060, "Wrong size on FM1ChattingSetting");
static_assert(offsetof(FM1ChattingSetting, ChatWorldColor) == 0x000000, "Member 'FM1ChattingSetting::ChatWorldColor' has a wrong offset!");
static_assert(offsetof(FM1ChattingSetting, ChatNormalColor) == 0x000010, "Member 'FM1ChattingSetting::ChatNormalColor' has a wrong offset!");
static_assert(offsetof(FM1ChattingSetting, ChatPartyColor) == 0x000020, "Member 'FM1ChattingSetting::ChatPartyColor' has a wrong offset!");
static_assert(offsetof(FM1ChattingSetting, ChatDirectMessageColor) == 0x000030, "Member 'FM1ChattingSetting::ChatDirectMessageColor' has a wrong offset!");
static_assert(offsetof(FM1ChattingSetting, ChatSystemColor) == 0x000040, "Member 'FM1ChattingSetting::ChatSystemColor' has a wrong offset!");
static_assert(offsetof(FM1ChattingSetting, ChatNoticeColor) == 0x000050, "Member 'FM1ChattingSetting::ChatNoticeColor' has a wrong offset!");

// ScriptStruct M1.M1ChattingServiceSendMessageResult
// 0x0004 (0x0004 - 0x0000)
struct FM1ChattingServiceSendMessageResult final
{
public:
	EM1ChattingErrorCode                          Result;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ChattingServiceSendMessageResult) == 0x000004, "Wrong alignment on FM1ChattingServiceSendMessageResult");
static_assert(sizeof(FM1ChattingServiceSendMessageResult) == 0x000004, "Wrong size on FM1ChattingServiceSendMessageResult");
static_assert(offsetof(FM1ChattingServiceSendMessageResult, Result) == 0x000000, "Member 'FM1ChattingServiceSendMessageResult::Result' has a wrong offset!");

// ScriptStruct M1.M1ChattingServiceReceiveMessageNoti
// 0x0010 (0x0010 - 0x0000)
struct FM1ChattingServiceReceiveMessageNoti final
{
public:
	TArray<struct FM1ChattingMessage>             Messages;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ChattingServiceReceiveMessageNoti) == 0x000008, "Wrong alignment on FM1ChattingServiceReceiveMessageNoti");
static_assert(sizeof(FM1ChattingServiceReceiveMessageNoti) == 0x000010, "Wrong size on FM1ChattingServiceReceiveMessageNoti");
static_assert(offsetof(FM1ChattingServiceReceiveMessageNoti, Messages) == 0x000000, "Member 'FM1ChattingServiceReceiveMessageNoti::Messages' has a wrong offset!");

// ScriptStruct M1.M1SearchResponseNoti
// 0x0068 (0x0068 - 0x0000)
struct FM1SearchResponseNoti final
{
public:
	struct FM1SearchResponse                      Result;                                            // 0x0000(0x0068)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SearchResponseNoti) == 0x000008, "Wrong alignment on FM1SearchResponseNoti");
static_assert(sizeof(FM1SearchResponseNoti) == 0x000068, "Wrong size on FM1SearchResponseNoti");
static_assert(offsetof(FM1SearchResponseNoti, Result) == 0x000000, "Member 'FM1SearchResponseNoti::Result' has a wrong offset!");

// ScriptStruct M1.M1GameplayDebugPropertyInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1GameplayDebugPropertyInfo final
{
public:
	class FString                                 PropertyName;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PropertyValue;                                     // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1GameplayDebugPropertyInfo) == 0x000008, "Wrong alignment on FM1GameplayDebugPropertyInfo");
static_assert(sizeof(FM1GameplayDebugPropertyInfo) == 0x000020, "Wrong size on FM1GameplayDebugPropertyInfo");
static_assert(offsetof(FM1GameplayDebugPropertyInfo, PropertyName) == 0x000000, "Member 'FM1GameplayDebugPropertyInfo::PropertyName' has a wrong offset!");
static_assert(offsetof(FM1GameplayDebugPropertyInfo, PropertyValue) == 0x000010, "Member 'FM1GameplayDebugPropertyInfo::PropertyValue' has a wrong offset!");

// ScriptStruct M1.M1OptionCategoryTableRow
// 0x0078 (0x0080 - 0x0008)
struct FM1OptionCategoryTableRow final : public FTableRowBase
{
public:
	class FName                                   DevName;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringId;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1OptionPlatformInfo                  Platform;                                          // 0x0028(0x000B)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   OptionPageClass;                                   // 0x0038(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1OptionCategoryExposureArea                 ExposureArea;                                      // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SubclassNames;                                     // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1OptionCategoryTableRow) == 0x000008, "Wrong alignment on FM1OptionCategoryTableRow");
static_assert(sizeof(FM1OptionCategoryTableRow) == 0x000080, "Wrong size on FM1OptionCategoryTableRow");
static_assert(offsetof(FM1OptionCategoryTableRow, DevName) == 0x000008, "Member 'FM1OptionCategoryTableRow::DevName' has a wrong offset!");
static_assert(offsetof(FM1OptionCategoryTableRow, SortOrder) == 0x000010, "Member 'FM1OptionCategoryTableRow::SortOrder' has a wrong offset!");
static_assert(offsetof(FM1OptionCategoryTableRow, StringId) == 0x000018, "Member 'FM1OptionCategoryTableRow::StringId' has a wrong offset!");
static_assert(offsetof(FM1OptionCategoryTableRow, Platform) == 0x000028, "Member 'FM1OptionCategoryTableRow::Platform' has a wrong offset!");
static_assert(offsetof(FM1OptionCategoryTableRow, OptionPageClass) == 0x000038, "Member 'FM1OptionCategoryTableRow::OptionPageClass' has a wrong offset!");
static_assert(offsetof(FM1OptionCategoryTableRow, ExposureArea) == 0x000068, "Member 'FM1OptionCategoryTableRow::ExposureArea' has a wrong offset!");
static_assert(offsetof(FM1OptionCategoryTableRow, SubclassNames) == 0x000070, "Member 'FM1OptionCategoryTableRow::SubclassNames' has a wrong offset!");

// ScriptStruct M1.M1OptionSubclassTableRow
// 0x0060 (0x0068 - 0x0008)
struct FM1OptionSubclassTableRow final : public FTableRowBase
{
public:
	class FName                                   DevName;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1OptionSubClassType                         SubClassType;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SortOrder;                                         // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StringId;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        IconPath;                                          // 0x0028(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1OptionPlatformInfo                  Platform;                                          // 0x0048(0x000B)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x5];                                       // 0x0053(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           IndividualNames;                                   // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1OptionSubclassTableRow) == 0x000008, "Wrong alignment on FM1OptionSubclassTableRow");
static_assert(sizeof(FM1OptionSubclassTableRow) == 0x000068, "Wrong size on FM1OptionSubclassTableRow");
static_assert(offsetof(FM1OptionSubclassTableRow, DevName) == 0x000008, "Member 'FM1OptionSubclassTableRow::DevName' has a wrong offset!");
static_assert(offsetof(FM1OptionSubclassTableRow, SubClassType) == 0x000010, "Member 'FM1OptionSubclassTableRow::SubClassType' has a wrong offset!");
static_assert(offsetof(FM1OptionSubclassTableRow, SortOrder) == 0x000014, "Member 'FM1OptionSubclassTableRow::SortOrder' has a wrong offset!");
static_assert(offsetof(FM1OptionSubclassTableRow, StringId) == 0x000018, "Member 'FM1OptionSubclassTableRow::StringId' has a wrong offset!");
static_assert(offsetof(FM1OptionSubclassTableRow, IconPath) == 0x000028, "Member 'FM1OptionSubclassTableRow::IconPath' has a wrong offset!");
static_assert(offsetof(FM1OptionSubclassTableRow, Platform) == 0x000048, "Member 'FM1OptionSubclassTableRow::Platform' has a wrong offset!");
static_assert(offsetof(FM1OptionSubclassTableRow, IndividualNames) == 0x000058, "Member 'FM1OptionSubclassTableRow::IndividualNames' has a wrong offset!");

// ScriptStruct M1.M1LoadingImageGroupData
// 0x0020 (0x0028 - 0x0008)
struct FM1LoadingImageGroupData final : public FTableRowBase
{
public:
	class FString                                 Comment;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                LoadingImages;                                     // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1LoadingImageGroupData) == 0x000008, "Wrong alignment on FM1LoadingImageGroupData");
static_assert(sizeof(FM1LoadingImageGroupData) == 0x000028, "Wrong size on FM1LoadingImageGroupData");
static_assert(offsetof(FM1LoadingImageGroupData, Comment) == 0x000008, "Member 'FM1LoadingImageGroupData::Comment' has a wrong offset!");
static_assert(offsetof(FM1LoadingImageGroupData, LoadingImages) == 0x000018, "Member 'FM1LoadingImageGroupData::LoadingImages' has a wrong offset!");

// ScriptStruct M1.M1OutOfPlayableAreaEffectMaterialParamInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1OutOfPlayableAreaEffectMaterialParamInfo final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveBase*                             Curve;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1OutOfPlayableAreaEffectMaterialParamInfo) == 0x000008, "Wrong alignment on FM1OutOfPlayableAreaEffectMaterialParamInfo");
static_assert(sizeof(FM1OutOfPlayableAreaEffectMaterialParamInfo) == 0x000010, "Wrong size on FM1OutOfPlayableAreaEffectMaterialParamInfo");
static_assert(offsetof(FM1OutOfPlayableAreaEffectMaterialParamInfo, ParamName) == 0x000000, "Member 'FM1OutOfPlayableAreaEffectMaterialParamInfo::ParamName' has a wrong offset!");
static_assert(offsetof(FM1OutOfPlayableAreaEffectMaterialParamInfo, Curve) == 0x000008, "Member 'FM1OutOfPlayableAreaEffectMaterialParamInfo::Curve' has a wrong offset!");

// ScriptStruct M1.M1OutOfPlayableAreaVolumeData
// 0x0008 (0x0008 - 0x0000)
struct FM1OutOfPlayableAreaVolumeData final
{
public:
	EM1OutOfPlayableAreaVolumeType                VolumeType;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumeDelayTime;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1OutOfPlayableAreaVolumeData) == 0x000004, "Wrong alignment on FM1OutOfPlayableAreaVolumeData");
static_assert(sizeof(FM1OutOfPlayableAreaVolumeData) == 0x000008, "Wrong size on FM1OutOfPlayableAreaVolumeData");
static_assert(offsetof(FM1OutOfPlayableAreaVolumeData, VolumeType) == 0x000000, "Member 'FM1OutOfPlayableAreaVolumeData::VolumeType' has a wrong offset!");
static_assert(offsetof(FM1OutOfPlayableAreaVolumeData, VolumeDelayTime) == 0x000004, "Member 'FM1OutOfPlayableAreaVolumeData::VolumeDelayTime' has a wrong offset!");

// ScriptStruct M1.M1PartyMemberData
// 0x0040 (0x0040 - 0x0000)
struct FM1PartyMemberData final
{
public:
	int64                                         AccountUid;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccountName;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Master;                                            // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlatformOnlineId;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         PlatformUid;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         PlatformType;                                      // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PartyMemberData) == 0x000008, "Wrong alignment on FM1PartyMemberData");
static_assert(sizeof(FM1PartyMemberData) == 0x000040, "Wrong size on FM1PartyMemberData");
static_assert(offsetof(FM1PartyMemberData, AccountUid) == 0x000000, "Member 'FM1PartyMemberData::AccountUid' has a wrong offset!");
static_assert(offsetof(FM1PartyMemberData, AccountName) == 0x000008, "Member 'FM1PartyMemberData::AccountName' has a wrong offset!");
static_assert(offsetof(FM1PartyMemberData, Master) == 0x000018, "Member 'FM1PartyMemberData::Master' has a wrong offset!");
static_assert(offsetof(FM1PartyMemberData, PlatformOnlineId) == 0x000020, "Member 'FM1PartyMemberData::PlatformOnlineId' has a wrong offset!");
static_assert(offsetof(FM1PartyMemberData, PlatformUid) == 0x000030, "Member 'FM1PartyMemberData::PlatformUid' has a wrong offset!");
static_assert(offsetof(FM1PartyMemberData, PlatformType) == 0x000038, "Member 'FM1PartyMemberData::PlatformType' has a wrong offset!");

// ScriptStruct M1.M1DamageInfoOfDeathReason
// 0x0140 (0x0140 - 0x0000)
struct FM1DamageInfoOfDeathReason final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1CalcDamageInfo                      DamageInfo;                                        // 0x0008(0x0138)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DamageInfoOfDeathReason) == 0x000008, "Wrong alignment on FM1DamageInfoOfDeathReason");
static_assert(sizeof(FM1DamageInfoOfDeathReason) == 0x000140, "Wrong size on FM1DamageInfoOfDeathReason");
static_assert(offsetof(FM1DamageInfoOfDeathReason, DamageInfo) == 0x000008, "Member 'FM1DamageInfoOfDeathReason::DamageInfo' has a wrong offset!");

// ScriptStruct M1.M1LeanSetting
// 0x0018 (0x0018 - 0x0000)
struct FM1LeanSetting final
{
public:
	float                                         LeanInterpolationTime;                             // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanStartYawScale;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LeanYawInRange;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LeanYawOutRange;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1LeanSetting) == 0x000004, "Wrong alignment on FM1LeanSetting");
static_assert(sizeof(FM1LeanSetting) == 0x000018, "Wrong size on FM1LeanSetting");
static_assert(offsetof(FM1LeanSetting, LeanInterpolationTime) == 0x000000, "Member 'FM1LeanSetting::LeanInterpolationTime' has a wrong offset!");
static_assert(offsetof(FM1LeanSetting, LeanStartYawScale) == 0x000004, "Member 'FM1LeanSetting::LeanStartYawScale' has a wrong offset!");
static_assert(offsetof(FM1LeanSetting, LeanYawInRange) == 0x000008, "Member 'FM1LeanSetting::LeanYawInRange' has a wrong offset!");
static_assert(offsetof(FM1LeanSetting, LeanYawOutRange) == 0x000010, "Member 'FM1LeanSetting::LeanYawOutRange' has a wrong offset!");

// ScriptStruct M1.M1PlayerAnimationSettingItem
// 0x00F0 (0x00F0 - 0x0000)
struct FM1PlayerAnimationSettingItem final
{
public:
	TSoftObjectPtr<class UAnimMontage>            TeleportStart;                                     // 0x0000(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            TeleportEnd;                                       // 0x0030(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            DBNODead;                                          // 0x0060(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            StandDead;                                         // 0x0090(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            DBNORevive;                                        // 0x00C0(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PlayerAnimationSettingItem) == 0x000008, "Wrong alignment on FM1PlayerAnimationSettingItem");
static_assert(sizeof(FM1PlayerAnimationSettingItem) == 0x0000F0, "Wrong size on FM1PlayerAnimationSettingItem");
static_assert(offsetof(FM1PlayerAnimationSettingItem, TeleportStart) == 0x000000, "Member 'FM1PlayerAnimationSettingItem::TeleportStart' has a wrong offset!");
static_assert(offsetof(FM1PlayerAnimationSettingItem, TeleportEnd) == 0x000030, "Member 'FM1PlayerAnimationSettingItem::TeleportEnd' has a wrong offset!");
static_assert(offsetof(FM1PlayerAnimationSettingItem, DBNODead) == 0x000060, "Member 'FM1PlayerAnimationSettingItem::DBNODead' has a wrong offset!");
static_assert(offsetof(FM1PlayerAnimationSettingItem, StandDead) == 0x000090, "Member 'FM1PlayerAnimationSettingItem::StandDead' has a wrong offset!");
static_assert(offsetof(FM1PlayerAnimationSettingItem, DBNORevive) == 0x0000C0, "Member 'FM1PlayerAnimationSettingItem::DBNORevive' has a wrong offset!");

// ScriptStruct M1.M1PlayerInteractionAnimSet
// 0x0060 (0x0060 - 0x0000)
struct FM1PlayerInteractionAnimSet final
{
public:
	TSoftObjectPtr<class UAnimMontage>            Female;                                            // 0x0000(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Male;                                              // 0x0030(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PlayerInteractionAnimSet) == 0x000008, "Wrong alignment on FM1PlayerInteractionAnimSet");
static_assert(sizeof(FM1PlayerInteractionAnimSet) == 0x000060, "Wrong size on FM1PlayerInteractionAnimSet");
static_assert(offsetof(FM1PlayerInteractionAnimSet, Female) == 0x000000, "Member 'FM1PlayerInteractionAnimSet::Female' has a wrong offset!");
static_assert(offsetof(FM1PlayerInteractionAnimSet, Male) == 0x000030, "Member 'FM1PlayerInteractionAnimSet::Male' has a wrong offset!");

// ScriptStruct M1.M1WeaponCameraOffsetSetting
// 0x0018 (0x0018 - 0x0000)
struct FM1WeaponCameraOffsetSetting final
{
public:
	struct FVector                                SocketOffset;                                      // 0x0000(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffset;                                      // 0x000C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponCameraOffsetSetting) == 0x000004, "Wrong alignment on FM1WeaponCameraOffsetSetting");
static_assert(sizeof(FM1WeaponCameraOffsetSetting) == 0x000018, "Wrong size on FM1WeaponCameraOffsetSetting");
static_assert(offsetof(FM1WeaponCameraOffsetSetting, SocketOffset) == 0x000000, "Member 'FM1WeaponCameraOffsetSetting::SocketOffset' has a wrong offset!");
static_assert(offsetof(FM1WeaponCameraOffsetSetting, TargetOffset) == 0x00000C, "Member 'FM1WeaponCameraOffsetSetting::TargetOffset' has a wrong offset!");

// ScriptStruct M1.M1CommonDBNOSetting
// 0x0178 (0x0178 - 0x0000)
struct FM1CommonDBNOSetting final
{
public:
	class FName                                   DBNOHitDecalSocketName;                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          DBNORescueStartAnim;                               // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          DBNORescueEndAnim;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         DBNORescueDrone;                                   // 0x0018(0x0020)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1DataVisualFX_Material               DBNORescueTargetEffectMaterial;                    // 0x0038(0x0130)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector                                DBNOUIOffset;                                      // 0x0168(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDBNOHiddenCurrentWeapon;                          // 0x0174(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_175[0x3];                                      // 0x0175(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CommonDBNOSetting) == 0x000008, "Wrong alignment on FM1CommonDBNOSetting");
static_assert(sizeof(FM1CommonDBNOSetting) == 0x000178, "Wrong size on FM1CommonDBNOSetting");
static_assert(offsetof(FM1CommonDBNOSetting, DBNOHitDecalSocketName) == 0x000000, "Member 'FM1CommonDBNOSetting::DBNOHitDecalSocketName' has a wrong offset!");
static_assert(offsetof(FM1CommonDBNOSetting, DBNORescueStartAnim) == 0x000008, "Member 'FM1CommonDBNOSetting::DBNORescueStartAnim' has a wrong offset!");
static_assert(offsetof(FM1CommonDBNOSetting, DBNORescueEndAnim) == 0x000010, "Member 'FM1CommonDBNOSetting::DBNORescueEndAnim' has a wrong offset!");
static_assert(offsetof(FM1CommonDBNOSetting, DBNORescueDrone) == 0x000018, "Member 'FM1CommonDBNOSetting::DBNORescueDrone' has a wrong offset!");
static_assert(offsetof(FM1CommonDBNOSetting, DBNORescueTargetEffectMaterial) == 0x000038, "Member 'FM1CommonDBNOSetting::DBNORescueTargetEffectMaterial' has a wrong offset!");
static_assert(offsetof(FM1CommonDBNOSetting, DBNOUIOffset) == 0x000168, "Member 'FM1CommonDBNOSetting::DBNOUIOffset' has a wrong offset!");
static_assert(offsetof(FM1CommonDBNOSetting, bDBNOHiddenCurrentWeapon) == 0x000174, "Member 'FM1CommonDBNOSetting::bDBNOHiddenCurrentWeapon' has a wrong offset!");

// ScriptStruct M1.M1ContentsDBNOSetting
// 0x0024 (0x0024 - 0x0000)
struct FM1ContentsDBNOSetting final
{
public:
	float                                         DBNOMaxMoveSpeed;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DBNOLifeTime;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DBNOReduceWeightByCount;                           // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DBNOReduceTimeOnDamage;                            // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DBNORescueInteractionTime;                         // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DBNOGiveUpRescueInteractionTime;                   // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DBNORescueInteractionDistance;                     // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DBNOReviveRecoverHPRate;                           // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DBNORespawnTime;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ContentsDBNOSetting) == 0x000004, "Wrong alignment on FM1ContentsDBNOSetting");
static_assert(sizeof(FM1ContentsDBNOSetting) == 0x000024, "Wrong size on FM1ContentsDBNOSetting");
static_assert(offsetof(FM1ContentsDBNOSetting, DBNOMaxMoveSpeed) == 0x000000, "Member 'FM1ContentsDBNOSetting::DBNOMaxMoveSpeed' has a wrong offset!");
static_assert(offsetof(FM1ContentsDBNOSetting, DBNOLifeTime) == 0x000004, "Member 'FM1ContentsDBNOSetting::DBNOLifeTime' has a wrong offset!");
static_assert(offsetof(FM1ContentsDBNOSetting, DBNOReduceWeightByCount) == 0x000008, "Member 'FM1ContentsDBNOSetting::DBNOReduceWeightByCount' has a wrong offset!");
static_assert(offsetof(FM1ContentsDBNOSetting, DBNOReduceTimeOnDamage) == 0x00000C, "Member 'FM1ContentsDBNOSetting::DBNOReduceTimeOnDamage' has a wrong offset!");
static_assert(offsetof(FM1ContentsDBNOSetting, DBNORescueInteractionTime) == 0x000010, "Member 'FM1ContentsDBNOSetting::DBNORescueInteractionTime' has a wrong offset!");
static_assert(offsetof(FM1ContentsDBNOSetting, DBNOGiveUpRescueInteractionTime) == 0x000014, "Member 'FM1ContentsDBNOSetting::DBNOGiveUpRescueInteractionTime' has a wrong offset!");
static_assert(offsetof(FM1ContentsDBNOSetting, DBNORescueInteractionDistance) == 0x000018, "Member 'FM1ContentsDBNOSetting::DBNORescueInteractionDistance' has a wrong offset!");
static_assert(offsetof(FM1ContentsDBNOSetting, DBNOReviveRecoverHPRate) == 0x00001C, "Member 'FM1ContentsDBNOSetting::DBNOReviveRecoverHPRate' has a wrong offset!");
static_assert(offsetof(FM1ContentsDBNOSetting, DBNORespawnTime) == 0x000020, "Member 'FM1ContentsDBNOSetting::DBNORespawnTime' has a wrong offset!");

// ScriptStruct M1.M1CommonSkillInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1CommonSkillInfo final
{
public:
	struct FDataTableRowHandle                    DataRow;                                           // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   DataRowName;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1SkillActiveType                            ActiveType;                                        // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1BattleKey                                  BattleKey;                                         // 0x0019(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CommonSkillInfo) == 0x000008, "Wrong alignment on FM1CommonSkillInfo");
static_assert(sizeof(FM1CommonSkillInfo) == 0x000020, "Wrong size on FM1CommonSkillInfo");
static_assert(offsetof(FM1CommonSkillInfo, DataRow) == 0x000000, "Member 'FM1CommonSkillInfo::DataRow' has a wrong offset!");
static_assert(offsetof(FM1CommonSkillInfo, DataRowName) == 0x000010, "Member 'FM1CommonSkillInfo::DataRowName' has a wrong offset!");
static_assert(offsetof(FM1CommonSkillInfo, ActiveType) == 0x000018, "Member 'FM1CommonSkillInfo::ActiveType' has a wrong offset!");
static_assert(offsetof(FM1CommonSkillInfo, BattleKey) == 0x000019, "Member 'FM1CommonSkillInfo::BattleKey' has a wrong offset!");

// ScriptStruct M1.M1AsyncProbeContext
// 0x0050 (0x0050 - 0x0000)
struct FM1AsyncProbeContext final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EM1PlayerAsyncProbeType                       ProbeType;                                         // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     Hits;                                              // 0x0010(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     SecondaryHits;                                     // 0x0020(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1AsyncProbeContext) == 0x000008, "Wrong alignment on FM1AsyncProbeContext");
static_assert(sizeof(FM1AsyncProbeContext) == 0x000050, "Wrong size on FM1AsyncProbeContext");
static_assert(offsetof(FM1AsyncProbeContext, ProbeType) == 0x000008, "Member 'FM1AsyncProbeContext::ProbeType' has a wrong offset!");
static_assert(offsetof(FM1AsyncProbeContext, Hits) == 0x000010, "Member 'FM1AsyncProbeContext::Hits' has a wrong offset!");
static_assert(offsetof(FM1AsyncProbeContext, SecondaryHits) == 0x000020, "Member 'FM1AsyncProbeContext::SecondaryHits' has a wrong offset!");

// ScriptStruct M1.M1LoggedInAccountInfo
// 0x0028 (0x0028 - 0x0000)
struct FM1LoggedInAccountInfo final
{
public:
	class FString                                 LoginId;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerToken;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         PlayerAccountId;                                   // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1LoggedInAccountInfo) == 0x000008, "Wrong alignment on FM1LoggedInAccountInfo");
static_assert(sizeof(FM1LoggedInAccountInfo) == 0x000028, "Wrong size on FM1LoggedInAccountInfo");
static_assert(offsetof(FM1LoggedInAccountInfo, LoginId) == 0x000000, "Member 'FM1LoggedInAccountInfo::LoginId' has a wrong offset!");
static_assert(offsetof(FM1LoggedInAccountInfo, PlayerToken) == 0x000010, "Member 'FM1LoggedInAccountInfo::PlayerToken' has a wrong offset!");
static_assert(offsetof(FM1LoggedInAccountInfo, PlayerAccountId) == 0x000020, "Member 'FM1LoggedInAccountInfo::PlayerAccountId' has a wrong offset!");

// ScriptStruct M1.M1ShopUIClickRecrods
// 0x00F0 (0x00F0 - 0x0000)
struct alignas(0x08) FM1ShopUIClickRecrods final
{
public:
	uint8                                         Pad_0[0xF0];                                       // 0x0000(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ShopUIClickRecrods) == 0x000008, "Wrong alignment on FM1ShopUIClickRecrods");
static_assert(sizeof(FM1ShopUIClickRecrods) == 0x0000F0, "Wrong size on FM1ShopUIClickRecrods");

// ScriptStruct M1.M1CustomizeEtcSkinData
// 0x0008 (0x0008 - 0x0000)
struct FM1CustomizeEtcSkinData final
{
public:
	struct FM1TemplateId                          CustomizingTemplateId;                             // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitialSetup;                                     // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CustomizeEtcSkinData) == 0x000004, "Wrong alignment on FM1CustomizeEtcSkinData");
static_assert(sizeof(FM1CustomizeEtcSkinData) == 0x000008, "Wrong size on FM1CustomizeEtcSkinData");
static_assert(offsetof(FM1CustomizeEtcSkinData, CustomizingTemplateId) == 0x000000, "Member 'FM1CustomizeEtcSkinData::CustomizingTemplateId' has a wrong offset!");
static_assert(offsetof(FM1CustomizeEtcSkinData, bInitialSetup) == 0x000004, "Member 'FM1CustomizeEtcSkinData::bInitialSetup' has a wrong offset!");

// ScriptStruct M1.M1CustomizeCharacterSkinData
// 0x0018 (0x0018 - 0x0000)
struct FM1CustomizeCharacterSkinData final
{
public:
	TArray<struct FM1CustomizeSkinInfo>           CustomizeSkinInfoArray;                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bInitialSetup;                                     // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CustomizeCharacterSkinData) == 0x000008, "Wrong alignment on FM1CustomizeCharacterSkinData");
static_assert(sizeof(FM1CustomizeCharacterSkinData) == 0x000018, "Wrong size on FM1CustomizeCharacterSkinData");
static_assert(offsetof(FM1CustomizeCharacterSkinData, CustomizeSkinInfoArray) == 0x000000, "Member 'FM1CustomizeCharacterSkinData::CustomizeSkinInfoArray' has a wrong offset!");
static_assert(offsetof(FM1CustomizeCharacterSkinData, bInitialSetup) == 0x000010, "Member 'FM1CustomizeCharacterSkinData::bInitialSetup' has a wrong offset!");

// ScriptStruct M1.M1CustomizeWeaponSkinData
// 0x0028 (0x0028 - 0x0000)
struct FM1CustomizeWeaponSkinData final
{
public:
	struct FM1CustomizeSkinInfo                   CustomizeSkinInfo;                                 // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	bool                                          bInitialSetup;                                     // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CustomizeWeaponSkinData) == 0x000008, "Wrong alignment on FM1CustomizeWeaponSkinData");
static_assert(sizeof(FM1CustomizeWeaponSkinData) == 0x000028, "Wrong size on FM1CustomizeWeaponSkinData");
static_assert(offsetof(FM1CustomizeWeaponSkinData, CustomizeSkinInfo) == 0x000000, "Member 'FM1CustomizeWeaponSkinData::CustomizeSkinInfo' has a wrong offset!");
static_assert(offsetof(FM1CustomizeWeaponSkinData, bInitialSetup) == 0x000020, "Member 'FM1CustomizeWeaponSkinData::bInitialSetup' has a wrong offset!");

// ScriptStruct M1.M1VFXDataForCustomize
// 0x0080 (0x0080 - 0x0000)
struct FM1VFXDataForCustomize final
{
public:
	bool                                          bAttachToOwner;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachAbsoluteRotation;                           // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1FXSpawnParam                        FXSpawnParam;                                      // 0x0010(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTransform                             Offset;                                            // 0x0050(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1VFXDataForCustomize) == 0x000010, "Wrong alignment on FM1VFXDataForCustomize");
static_assert(sizeof(FM1VFXDataForCustomize) == 0x000080, "Wrong size on FM1VFXDataForCustomize");
static_assert(offsetof(FM1VFXDataForCustomize, bAttachToOwner) == 0x000000, "Member 'FM1VFXDataForCustomize::bAttachToOwner' has a wrong offset!");
static_assert(offsetof(FM1VFXDataForCustomize, bAttachAbsoluteRotation) == 0x000001, "Member 'FM1VFXDataForCustomize::bAttachAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(FM1VFXDataForCustomize, BoneName) == 0x000004, "Member 'FM1VFXDataForCustomize::BoneName' has a wrong offset!");
static_assert(offsetof(FM1VFXDataForCustomize, FXSpawnParam) == 0x000010, "Member 'FM1VFXDataForCustomize::FXSpawnParam' has a wrong offset!");
static_assert(offsetof(FM1VFXDataForCustomize, Offset) == 0x000050, "Member 'FM1VFXDataForCustomize::Offset' has a wrong offset!");

// ScriptStruct M1.M1CustomizeEffectFXSpawnParams
// 0x0020 (0x0020 - 0x0000)
struct FM1CustomizeEffectFXSpawnParams final
{
public:
	TArray<struct FM1VFXDataForCustomize>         NiagaraVFXs;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1DataVisualFX_Material>       MaterialVFXs;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizeEffectFXSpawnParams) == 0x000008, "Wrong alignment on FM1CustomizeEffectFXSpawnParams");
static_assert(sizeof(FM1CustomizeEffectFXSpawnParams) == 0x000020, "Wrong size on FM1CustomizeEffectFXSpawnParams");
static_assert(offsetof(FM1CustomizeEffectFXSpawnParams, NiagaraVFXs) == 0x000000, "Member 'FM1CustomizeEffectFXSpawnParams::NiagaraVFXs' has a wrong offset!");
static_assert(offsetof(FM1CustomizeEffectFXSpawnParams, MaterialVFXs) == 0x000010, "Member 'FM1CustomizeEffectFXSpawnParams::MaterialVFXs' has a wrong offset!");

// ScriptStruct M1.M1NpcCustomizingEvolutionInfo
// 0x000C (0x000C - 0x0000)
struct FM1NpcCustomizingEvolutionInfo final
{
public:
	int32                                         HeadSkinEvolutionIndex;                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BodySkinEvolutionIndex;                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponSkinEvolutionIndex;                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NpcCustomizingEvolutionInfo) == 0x000004, "Wrong alignment on FM1NpcCustomizingEvolutionInfo");
static_assert(sizeof(FM1NpcCustomizingEvolutionInfo) == 0x00000C, "Wrong size on FM1NpcCustomizingEvolutionInfo");
static_assert(offsetof(FM1NpcCustomizingEvolutionInfo, HeadSkinEvolutionIndex) == 0x000000, "Member 'FM1NpcCustomizingEvolutionInfo::HeadSkinEvolutionIndex' has a wrong offset!");
static_assert(offsetof(FM1NpcCustomizingEvolutionInfo, BodySkinEvolutionIndex) == 0x000004, "Member 'FM1NpcCustomizingEvolutionInfo::BodySkinEvolutionIndex' has a wrong offset!");
static_assert(offsetof(FM1NpcCustomizingEvolutionInfo, WeaponSkinEvolutionIndex) == 0x000008, "Member 'FM1NpcCustomizingEvolutionInfo::WeaponSkinEvolutionIndex' has a wrong offset!");

// ScriptStruct M1.M1NpcCustomizingInfo
// 0x003C (0x003C - 0x0000)
struct FM1NpcCustomizingInfo final
{
public:
	class FName                                   HeadSkinId;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FaceSkinId;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodySkinId;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChestAttachmentId;                                 // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BackAttachmentId;                                  // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponSkinId;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NpcCustomizingEvolutionInfo         EvolutionInfo;                                     // 0x0030(0x000C)(Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NpcCustomizingInfo) == 0x000004, "Wrong alignment on FM1NpcCustomizingInfo");
static_assert(sizeof(FM1NpcCustomizingInfo) == 0x00003C, "Wrong size on FM1NpcCustomizingInfo");
static_assert(offsetof(FM1NpcCustomizingInfo, HeadSkinId) == 0x000000, "Member 'FM1NpcCustomizingInfo::HeadSkinId' has a wrong offset!");
static_assert(offsetof(FM1NpcCustomizingInfo, FaceSkinId) == 0x000008, "Member 'FM1NpcCustomizingInfo::FaceSkinId' has a wrong offset!");
static_assert(offsetof(FM1NpcCustomizingInfo, BodySkinId) == 0x000010, "Member 'FM1NpcCustomizingInfo::BodySkinId' has a wrong offset!");
static_assert(offsetof(FM1NpcCustomizingInfo, ChestAttachmentId) == 0x000018, "Member 'FM1NpcCustomizingInfo::ChestAttachmentId' has a wrong offset!");
static_assert(offsetof(FM1NpcCustomizingInfo, BackAttachmentId) == 0x000020, "Member 'FM1NpcCustomizingInfo::BackAttachmentId' has a wrong offset!");
static_assert(offsetof(FM1NpcCustomizingInfo, WeaponSkinId) == 0x000028, "Member 'FM1NpcCustomizingInfo::WeaponSkinId' has a wrong offset!");
static_assert(offsetof(FM1NpcCustomizingInfo, EvolutionInfo) == 0x000030, "Member 'FM1NpcCustomizingInfo::EvolutionInfo' has a wrong offset!");

// ScriptStruct M1.M1PlayerPartsSlot
// 0x0028 (0x0028 - 0x0000)
struct FM1PlayerPartsSlot final
{
public:
	struct FM1EquippedPartsItemInfo               EquippedPartsItemInfo;                             // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	EM1EquipmentSlotType                          SlotType;                                          // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PlayerPartsSlot) == 0x000008, "Wrong alignment on FM1PlayerPartsSlot");
static_assert(sizeof(FM1PlayerPartsSlot) == 0x000028, "Wrong size on FM1PlayerPartsSlot");
static_assert(offsetof(FM1PlayerPartsSlot, EquippedPartsItemInfo) == 0x000000, "Member 'FM1PlayerPartsSlot::EquippedPartsItemInfo' has a wrong offset!");
static_assert(offsetof(FM1PlayerPartsSlot, SlotType) == 0x000020, "Member 'FM1PlayerPartsSlot::SlotType' has a wrong offset!");

// ScriptStruct M1.M1PlayerRespawnVolumeTimerHandlePair
// 0x0018 (0x0018 - 0x0000)
struct FM1PlayerRespawnVolumeTimerHandlePair final
{
public:
	struct FTimerHandle                           TimerHandle;                                       // 0x0000(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AM1Character>>    WeakCharacters;                                    // 0x0008(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PlayerRespawnVolumeTimerHandlePair) == 0x000008, "Wrong alignment on FM1PlayerRespawnVolumeTimerHandlePair");
static_assert(sizeof(FM1PlayerRespawnVolumeTimerHandlePair) == 0x000018, "Wrong size on FM1PlayerRespawnVolumeTimerHandlePair");
static_assert(offsetof(FM1PlayerRespawnVolumeTimerHandlePair, TimerHandle) == 0x000000, "Member 'FM1PlayerRespawnVolumeTimerHandlePair::TimerHandle' has a wrong offset!");
static_assert(offsetof(FM1PlayerRespawnVolumeTimerHandlePair, WeakCharacters) == 0x000008, "Member 'FM1PlayerRespawnVolumeTimerHandlePair::WeakCharacters' has a wrong offset!");

// ScriptStruct M1.M1SlidingState
// 0x0010 (0x0010 - 0x0000)
struct FM1SlidingState final
{
public:
	bool                                          bSliding;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SlidingFloorNormal;                                // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SlidingState) == 0x000004, "Wrong alignment on FM1SlidingState");
static_assert(sizeof(FM1SlidingState) == 0x000010, "Wrong size on FM1SlidingState");
static_assert(offsetof(FM1SlidingState, bSliding) == 0x000000, "Member 'FM1SlidingState::bSliding' has a wrong offset!");
static_assert(offsetof(FM1SlidingState, SlidingFloorNormal) == 0x000004, "Member 'FM1SlidingState::SlidingFloorNormal' has a wrong offset!");

// ScriptStruct M1.M1PlayerPlatformInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1PlayerPlatformInfo final
{
public:
	EM1LoginPlatformTypes                         PlatformType;                                      // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        PlatformUid;                                       // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PlayerPlatformInfo) == 0x000008, "Wrong alignment on FM1PlayerPlatformInfo");
static_assert(sizeof(FM1PlayerPlatformInfo) == 0x000010, "Wrong size on FM1PlayerPlatformInfo");
static_assert(offsetof(FM1PlayerPlatformInfo, PlatformType) == 0x000000, "Member 'FM1PlayerPlatformInfo::PlatformType' has a wrong offset!");
static_assert(offsetof(FM1PlayerPlatformInfo, PlatformUid) == 0x000008, "Member 'FM1PlayerPlatformInfo::PlatformUid' has a wrong offset!");

// ScriptStruct M1.M1PlayerTitle
// 0x000C (0x000C - 0x0000)
struct FM1PlayerTitle final
{
public:
	struct FM1TemplateId                          PrefixTitle;                                       // 0x0000(0x0004)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          SuffixTitle;                                       // 0x0004(0x0004)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1CharacterGender                            AnimPresetType;                                    // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PlayerTitle) == 0x000004, "Wrong alignment on FM1PlayerTitle");
static_assert(sizeof(FM1PlayerTitle) == 0x00000C, "Wrong size on FM1PlayerTitle");
static_assert(offsetof(FM1PlayerTitle, PrefixTitle) == 0x000000, "Member 'FM1PlayerTitle::PrefixTitle' has a wrong offset!");
static_assert(offsetof(FM1PlayerTitle, SuffixTitle) == 0x000004, "Member 'FM1PlayerTitle::SuffixTitle' has a wrong offset!");
static_assert(offsetof(FM1PlayerTitle, AnimPresetType) == 0x000008, "Member 'FM1PlayerTitle::AnimPresetType' has a wrong offset!");

// ScriptStruct M1.M1PostProcessMaterialParamInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1PostProcessMaterialParamInfo final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveBase*                             Curve;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PostProcessMaterialParamInfo) == 0x000008, "Wrong alignment on FM1PostProcessMaterialParamInfo");
static_assert(sizeof(FM1PostProcessMaterialParamInfo) == 0x000010, "Wrong size on FM1PostProcessMaterialParamInfo");
static_assert(offsetof(FM1PostProcessMaterialParamInfo, ParamName) == 0x000000, "Member 'FM1PostProcessMaterialParamInfo::ParamName' has a wrong offset!");
static_assert(offsetof(FM1PostProcessMaterialParamInfo, Curve) == 0x000008, "Member 'FM1PostProcessMaterialParamInfo::Curve' has a wrong offset!");

// ScriptStruct M1.M1PostProcessMaterialEffect
// 0x0040 (0x0040 - 0x0000)
struct FM1PostProcessMaterialEffect final
{
public:
	class UM1DataPostProcessMaterialEffect*       Data;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UCameraComponent>        CameraComp;                                        // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UM1AkComponent>          AkComp;                                            // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               InstanceDynamic;                                   // 0x0018(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ElapsedTime;                                       // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EM1PostProcessState                           State;                                             // 0x0024(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeativatedElapsedTime;                             // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTimerHandle>                   RepeatSoundTimerHandles;                           // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1PostProcessMaterialEffect) == 0x000008, "Wrong alignment on FM1PostProcessMaterialEffect");
static_assert(sizeof(FM1PostProcessMaterialEffect) == 0x000040, "Wrong size on FM1PostProcessMaterialEffect");
static_assert(offsetof(FM1PostProcessMaterialEffect, Data) == 0x000000, "Member 'FM1PostProcessMaterialEffect::Data' has a wrong offset!");
static_assert(offsetof(FM1PostProcessMaterialEffect, CameraComp) == 0x000008, "Member 'FM1PostProcessMaterialEffect::CameraComp' has a wrong offset!");
static_assert(offsetof(FM1PostProcessMaterialEffect, AkComp) == 0x000010, "Member 'FM1PostProcessMaterialEffect::AkComp' has a wrong offset!");
static_assert(offsetof(FM1PostProcessMaterialEffect, InstanceDynamic) == 0x000018, "Member 'FM1PostProcessMaterialEffect::InstanceDynamic' has a wrong offset!");
static_assert(offsetof(FM1PostProcessMaterialEffect, ElapsedTime) == 0x000020, "Member 'FM1PostProcessMaterialEffect::ElapsedTime' has a wrong offset!");
static_assert(offsetof(FM1PostProcessMaterialEffect, State) == 0x000024, "Member 'FM1PostProcessMaterialEffect::State' has a wrong offset!");
static_assert(offsetof(FM1PostProcessMaterialEffect, DeativatedElapsedTime) == 0x000028, "Member 'FM1PostProcessMaterialEffect::DeativatedElapsedTime' has a wrong offset!");
static_assert(offsetof(FM1PostProcessMaterialEffect, RepeatSoundTimerHandles) == 0x000030, "Member 'FM1PostProcessMaterialEffect::RepeatSoundTimerHandles' has a wrong offset!");

// ScriptStruct M1.M1PostProcessMaterialEffectsPlayer
// 0x0018 (0x0018 - 0x0000)
struct FM1PostProcessMaterialEffectsPlayer final
{
public:
	TArray<struct FM1PostProcessMaterialEffect>   PPMaterialEffects;                                 // 0x0000(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class AM1Player*                              PlayerOwner;                                       // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1PostProcessMaterialEffectsPlayer) == 0x000008, "Wrong alignment on FM1PostProcessMaterialEffectsPlayer");
static_assert(sizeof(FM1PostProcessMaterialEffectsPlayer) == 0x000018, "Wrong size on FM1PostProcessMaterialEffectsPlayer");
static_assert(offsetof(FM1PostProcessMaterialEffectsPlayer, PPMaterialEffects) == 0x000000, "Member 'FM1PostProcessMaterialEffectsPlayer::PPMaterialEffects' has a wrong offset!");
static_assert(offsetof(FM1PostProcessMaterialEffectsPlayer, PlayerOwner) == 0x000010, "Member 'FM1PostProcessMaterialEffectsPlayer::PlayerOwner' has a wrong offset!");

// ScriptStruct M1.M1CharacterPreviewAnim
// 0x0010 (0x0018 - 0x0008)
struct FM1CharacterPreviewAnim final : public FTableRowBase
{
public:
	int64                                         CharacterId;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UM1PreviewAnimInstance>     PreviewAnim;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CharacterPreviewAnim) == 0x000008, "Wrong alignment on FM1CharacterPreviewAnim");
static_assert(sizeof(FM1CharacterPreviewAnim) == 0x000018, "Wrong size on FM1CharacterPreviewAnim");
static_assert(offsetof(FM1CharacterPreviewAnim, CharacterId) == 0x000008, "Member 'FM1CharacterPreviewAnim::CharacterId' has a wrong offset!");
static_assert(offsetof(FM1CharacterPreviewAnim, PreviewAnim) == 0x000010, "Member 'FM1CharacterPreviewAnim::PreviewAnim' has a wrong offset!");

// ScriptStruct M1.M1TestEquipmentSaveData
// 0x0008 (0x0008 - 0x0000)
struct FM1TestEquipmentSaveData final
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipmentSlot;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TestEquipmentSaveData) == 0x000004, "Wrong alignment on FM1TestEquipmentSaveData");
static_assert(sizeof(FM1TestEquipmentSaveData) == 0x000008, "Wrong size on FM1TestEquipmentSaveData");
static_assert(offsetof(FM1TestEquipmentSaveData, TemplateId) == 0x000000, "Member 'FM1TestEquipmentSaveData::TemplateId' has a wrong offset!");
static_assert(offsetof(FM1TestEquipmentSaveData, EquipmentSlot) == 0x000004, "Member 'FM1TestEquipmentSaveData::EquipmentSlot' has a wrong offset!");

// ScriptStruct M1.M1UIEvent_ChangedWeaponChargeLevel
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FM1UIEvent_ChangedWeaponChargeLevel final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_ChangedWeaponChargeLevel) == 0x000004, "Wrong alignment on FM1UIEvent_ChangedWeaponChargeLevel");
static_assert(sizeof(FM1UIEvent_ChangedWeaponChargeLevel) == 0x000008, "Wrong size on FM1UIEvent_ChangedWeaponChargeLevel");

// ScriptStruct M1.M1TestCustomizingSaveData
// 0x02D0 (0x02D0 - 0x0000)
struct FM1TestCustomizingSaveData final
{
public:
	TMap<struct FM1TemplateId, struct FM1CustomizeCharacterInfo> Characters;                                        // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	TMap<struct FM1TemplateId, struct FM1CustomizeWeaponInfo> Weapons;                                           // 0x0050(0x0050)(NativeAccessSpecifierPublic)
	TMap<struct FM1TemplateId, struct FM1CustomizePaintInfo> Paints;                                            // 0x00A0(0x0050)(NativeAccessSpecifierPublic)
	TMap<struct FM1TemplateId, struct FM1CustomizeEvolutionInfo> Evolutions;                                        // 0x00F0(0x0050)(NativeAccessSpecifierPublic)
	TMap<int32, struct FM1TemplateId>             EmotionSlots;                                      // 0x0140(0x0050)(NativeAccessSpecifierPublic)
	TMap<EM1CustomizingItemCategoryType, struct FM1TemplateId> Etc;                                               // 0x0190(0x0050)(NativeAccessSpecifierPublic)
	TMap<struct FM1TemplateId, struct FM1CustomizeBoundedItems> BoundedToCharacter;                                // 0x01E0(0x0050)(NativeAccessSpecifierPublic)
	TMap<struct FM1TemplateId, struct FM1CustomizeBoundedItems> BoundedToWeapon;                                   // 0x0230(0x0050)(NativeAccessSpecifierPublic)
	TMap<struct FM1TemplateId, struct FM1CustomizeBoundedItems> BoundedToSkin;                                     // 0x0280(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TestCustomizingSaveData) == 0x000008, "Wrong alignment on FM1TestCustomizingSaveData");
static_assert(sizeof(FM1TestCustomizingSaveData) == 0x0002D0, "Wrong size on FM1TestCustomizingSaveData");
static_assert(offsetof(FM1TestCustomizingSaveData, Characters) == 0x000000, "Member 'FM1TestCustomizingSaveData::Characters' has a wrong offset!");
static_assert(offsetof(FM1TestCustomizingSaveData, Weapons) == 0x000050, "Member 'FM1TestCustomizingSaveData::Weapons' has a wrong offset!");
static_assert(offsetof(FM1TestCustomizingSaveData, Paints) == 0x0000A0, "Member 'FM1TestCustomizingSaveData::Paints' has a wrong offset!");
static_assert(offsetof(FM1TestCustomizingSaveData, Evolutions) == 0x0000F0, "Member 'FM1TestCustomizingSaveData::Evolutions' has a wrong offset!");
static_assert(offsetof(FM1TestCustomizingSaveData, EmotionSlots) == 0x000140, "Member 'FM1TestCustomizingSaveData::EmotionSlots' has a wrong offset!");
static_assert(offsetof(FM1TestCustomizingSaveData, Etc) == 0x000190, "Member 'FM1TestCustomizingSaveData::Etc' has a wrong offset!");
static_assert(offsetof(FM1TestCustomizingSaveData, BoundedToCharacter) == 0x0001E0, "Member 'FM1TestCustomizingSaveData::BoundedToCharacter' has a wrong offset!");
static_assert(offsetof(FM1TestCustomizingSaveData, BoundedToWeapon) == 0x000230, "Member 'FM1TestCustomizingSaveData::BoundedToWeapon' has a wrong offset!");
static_assert(offsetof(FM1TestCustomizingSaveData, BoundedToSkin) == 0x000280, "Member 'FM1TestCustomizingSaveData::BoundedToSkin' has a wrong offset!");

// ScriptStruct M1.ProceduralKeyTimeEvent
// 0x0014 (0x0014 - 0x0000)
struct FProceduralKeyTimeEvent final
{
public:
	class FName                                   FootBone;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1ProceduralKeyTimeType                      KeyTimeType;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EventStartTime;                                    // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EventEndTime;                                      // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralKeyTimeEvent) == 0x000004, "Wrong alignment on FProceduralKeyTimeEvent");
static_assert(sizeof(FProceduralKeyTimeEvent) == 0x000014, "Wrong size on FProceduralKeyTimeEvent");
static_assert(offsetof(FProceduralKeyTimeEvent, FootBone) == 0x000000, "Member 'FProceduralKeyTimeEvent::FootBone' has a wrong offset!");
static_assert(offsetof(FProceduralKeyTimeEvent, KeyTimeType) == 0x000008, "Member 'FProceduralKeyTimeEvent::KeyTimeType' has a wrong offset!");
static_assert(offsetof(FProceduralKeyTimeEvent, EventStartTime) == 0x00000C, "Member 'FProceduralKeyTimeEvent::EventStartTime' has a wrong offset!");
static_assert(offsetof(FProceduralKeyTimeEvent, EventEndTime) == 0x000010, "Member 'FProceduralKeyTimeEvent::EventEndTime' has a wrong offset!");

// ScriptStruct M1.M1PrologueSequenceTrackData
// 0x0008 (0x0040 - 0x0038)
struct FM1PrologueSequenceTrackData final : public FM1SequenceTrackData
{
public:
	EM1PrologueSequenceTrackType                  SequenceType;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1PrologueSequenceTrackType                  NextSequenceType;                                  // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldClearPreviousSubtitles;                     // 0x003A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PrologueSequenceTrackData) == 0x000008, "Wrong alignment on FM1PrologueSequenceTrackData");
static_assert(sizeof(FM1PrologueSequenceTrackData) == 0x000040, "Wrong size on FM1PrologueSequenceTrackData");
static_assert(offsetof(FM1PrologueSequenceTrackData, SequenceType) == 0x000038, "Member 'FM1PrologueSequenceTrackData::SequenceType' has a wrong offset!");
static_assert(offsetof(FM1PrologueSequenceTrackData, NextSequenceType) == 0x000039, "Member 'FM1PrologueSequenceTrackData::NextSequenceType' has a wrong offset!");
static_assert(offsetof(FM1PrologueSequenceTrackData, bShouldClearPreviousSubtitles) == 0x00003A, "Member 'FM1PrologueSequenceTrackData::bShouldClearPreviousSubtitles' has a wrong offset!");

// ScriptStruct M1.M1UIEvent_ChangedWeaponSkin
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FM1UIEvent_ChangedWeaponSkin final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_ChangedWeaponSkin) == 0x000004, "Wrong alignment on FM1UIEvent_ChangedWeaponSkin");
static_assert(sizeof(FM1UIEvent_ChangedWeaponSkin) == 0x000008, "Wrong size on FM1UIEvent_ChangedWeaponSkin");

// ScriptStruct M1.M1PushAwayInfo
// 0x000C (0x000C - 0x0000)
struct FM1PushAwayInfo final
{
public:
	bool                                          bPushAway;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepPushAway;                                     // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PushAwayInfo) == 0x000004, "Wrong alignment on FM1PushAwayInfo");
static_assert(sizeof(FM1PushAwayInfo) == 0x00000C, "Wrong size on FM1PushAwayInfo");
static_assert(offsetof(FM1PushAwayInfo, bPushAway) == 0x000000, "Member 'FM1PushAwayInfo::bPushAway' has a wrong offset!");
static_assert(offsetof(FM1PushAwayInfo, Duration) == 0x000004, "Member 'FM1PushAwayInfo::Duration' has a wrong offset!");
static_assert(offsetof(FM1PushAwayInfo, bKeepPushAway) == 0x000008, "Member 'FM1PushAwayInfo::bKeepPushAway' has a wrong offset!");

// ScriptStruct M1.M1GameplayTagVariantBlueprintPropertyMapping
// 0x0058 (0x0058 - 0x0000)
struct FM1GameplayTagVariantBlueprintPropertyMapping final
{
public:
	struct FGameplayTag                           TagToMap;                                          // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VariantName;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TFieldPath<struct FProperty>                  PropertyToEdit;                                    // 0x0010(0x0020)(Edit, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  PropertyGuid;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1GameplayTagVariantBlueprintPropertyMapping) == 0x000008, "Wrong alignment on FM1GameplayTagVariantBlueprintPropertyMapping");
static_assert(sizeof(FM1GameplayTagVariantBlueprintPropertyMapping) == 0x000058, "Wrong size on FM1GameplayTagVariantBlueprintPropertyMapping");
static_assert(offsetof(FM1GameplayTagVariantBlueprintPropertyMapping, TagToMap) == 0x000000, "Member 'FM1GameplayTagVariantBlueprintPropertyMapping::TagToMap' has a wrong offset!");
static_assert(offsetof(FM1GameplayTagVariantBlueprintPropertyMapping, VariantName) == 0x000008, "Member 'FM1GameplayTagVariantBlueprintPropertyMapping::VariantName' has a wrong offset!");
static_assert(offsetof(FM1GameplayTagVariantBlueprintPropertyMapping, PropertyToEdit) == 0x000010, "Member 'FM1GameplayTagVariantBlueprintPropertyMapping::PropertyToEdit' has a wrong offset!");
static_assert(offsetof(FM1GameplayTagVariantBlueprintPropertyMapping, PropertyName) == 0x000030, "Member 'FM1GameplayTagVariantBlueprintPropertyMapping::PropertyName' has a wrong offset!");
static_assert(offsetof(FM1GameplayTagVariantBlueprintPropertyMapping, PropertyGuid) == 0x000038, "Member 'FM1GameplayTagVariantBlueprintPropertyMapping::PropertyGuid' has a wrong offset!");

// ScriptStruct M1.M1GameplayTagVariantBlueprintPropertyMap
// 0x0028 (0x0028 - 0x0000)
struct FM1GameplayTagVariantBlueprintPropertyMap final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1GameplayTagVariantBlueprintPropertyMapping> PropertyMappings;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FM1GameplayTagVariantBlueprintPropertyMap) == 0x000008, "Wrong alignment on FM1GameplayTagVariantBlueprintPropertyMap");
static_assert(sizeof(FM1GameplayTagVariantBlueprintPropertyMap) == 0x000028, "Wrong size on FM1GameplayTagVariantBlueprintPropertyMap");
static_assert(offsetof(FM1GameplayTagVariantBlueprintPropertyMap, PropertyMappings) == 0x000018, "Member 'FM1GameplayTagVariantBlueprintPropertyMap::PropertyMappings' has a wrong offset!");

// ScriptStruct M1.M1QueryTableMetaStruct
// 0x0020 (0x0028 - 0x0008)
struct FM1QueryTableMetaStruct final : public FTableRowBase
{
public:
	TArray<class FName>                           EntryBlacklist;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ActiveBlacklist;                                   // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1QueryTableMetaStruct) == 0x000008, "Wrong alignment on FM1QueryTableMetaStruct");
static_assert(sizeof(FM1QueryTableMetaStruct) == 0x000028, "Wrong size on FM1QueryTableMetaStruct");
static_assert(offsetof(FM1QueryTableMetaStruct, EntryBlacklist) == 0x000008, "Member 'FM1QueryTableMetaStruct::EntryBlacklist' has a wrong offset!");
static_assert(offsetof(FM1QueryTableMetaStruct, ActiveBlacklist) == 0x000018, "Member 'FM1QueryTableMetaStruct::ActiveBlacklist' has a wrong offset!");

// ScriptStruct M1.M1UIEvent_ChangedDBNOState
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FM1UIEvent_ChangedDBNOState final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_ChangedDBNOState) == 0x000004, "Wrong alignment on FM1UIEvent_ChangedDBNOState");
static_assert(sizeof(FM1UIEvent_ChangedDBNOState) == 0x00000C, "Wrong size on FM1UIEvent_ChangedDBNOState");

// ScriptStruct M1.M1NpcServiceList
// 0x0010 (0x0010 - 0x0000)
struct FM1NpcServiceList final
{
public:
	TArray<EM1NpcServiceType>                     NpcServices;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NpcServiceList) == 0x000008, "Wrong alignment on FM1NpcServiceList");
static_assert(sizeof(FM1NpcServiceList) == 0x000010, "Wrong size on FM1NpcServiceList");
static_assert(offsetof(FM1NpcServiceList, NpcServices) == 0x000000, "Member 'FM1NpcServiceList::NpcServices' has a wrong offset!");

// ScriptStruct M1.M1QuestIncreaseCountRPC
// 0x000C (0x000C - 0x0000)
struct FM1QuestIncreaseCountRPC final
{
public:
	struct FM1TemplateId                          QuestTemplateId;                                   // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConditionIndex;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IncreaseCount;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1QuestIncreaseCountRPC) == 0x000004, "Wrong alignment on FM1QuestIncreaseCountRPC");
static_assert(sizeof(FM1QuestIncreaseCountRPC) == 0x00000C, "Wrong size on FM1QuestIncreaseCountRPC");
static_assert(offsetof(FM1QuestIncreaseCountRPC, QuestTemplateId) == 0x000000, "Member 'FM1QuestIncreaseCountRPC::QuestTemplateId' has a wrong offset!");
static_assert(offsetof(FM1QuestIncreaseCountRPC, ConditionIndex) == 0x000004, "Member 'FM1QuestIncreaseCountRPC::ConditionIndex' has a wrong offset!");
static_assert(offsetof(FM1QuestIncreaseCountRPC, IncreaseCount) == 0x000008, "Member 'FM1QuestIncreaseCountRPC::IncreaseCount' has a wrong offset!");

// ScriptStruct M1.M1QueuedItemsParams
// 0x00D0 (0x00D0 - 0x0000)
struct FM1QueuedItemsParams final
{
public:
	struct FM1JustLoggedInValues                  JustLoggedInValues;                                // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	TArray<struct FM1CharacterInfoWrapper>        Characters;                                        // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1RuneInfoWrapper>             Runes;                                             // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1EquipmentInfoWrapper>        Equipments;                                        // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1EquipmentRandomOptionInfo>   RandomOptions;                                     // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1PerkInfo>                    Perks;                                             // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1ReactorEnchantInfo>          ReactorEnchantInfo;                                // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1ConsumableInfoWrapper>       Consumables;                                       // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1CurrencyInfo>                Currencies;                                        // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1SocialMotionInfoWrapper>     SocialMotions;                                     // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1WeaponProficiencyInfo>       Proficiencies;                                     // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1CustomizingInfoWrapper>      Customizings;                                      // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1QueuedItemsParams) == 0x000008, "Wrong alignment on FM1QueuedItemsParams");
static_assert(sizeof(FM1QueuedItemsParams) == 0x0000D0, "Wrong size on FM1QueuedItemsParams");
static_assert(offsetof(FM1QueuedItemsParams, JustLoggedInValues) == 0x000000, "Member 'FM1QueuedItemsParams::JustLoggedInValues' has a wrong offset!");
static_assert(offsetof(FM1QueuedItemsParams, Characters) == 0x000020, "Member 'FM1QueuedItemsParams::Characters' has a wrong offset!");
static_assert(offsetof(FM1QueuedItemsParams, Runes) == 0x000030, "Member 'FM1QueuedItemsParams::Runes' has a wrong offset!");
static_assert(offsetof(FM1QueuedItemsParams, Equipments) == 0x000040, "Member 'FM1QueuedItemsParams::Equipments' has a wrong offset!");
static_assert(offsetof(FM1QueuedItemsParams, RandomOptions) == 0x000050, "Member 'FM1QueuedItemsParams::RandomOptions' has a wrong offset!");
static_assert(offsetof(FM1QueuedItemsParams, Perks) == 0x000060, "Member 'FM1QueuedItemsParams::Perks' has a wrong offset!");
static_assert(offsetof(FM1QueuedItemsParams, ReactorEnchantInfo) == 0x000070, "Member 'FM1QueuedItemsParams::ReactorEnchantInfo' has a wrong offset!");
static_assert(offsetof(FM1QueuedItemsParams, Consumables) == 0x000080, "Member 'FM1QueuedItemsParams::Consumables' has a wrong offset!");
static_assert(offsetof(FM1QueuedItemsParams, Currencies) == 0x000090, "Member 'FM1QueuedItemsParams::Currencies' has a wrong offset!");
static_assert(offsetof(FM1QueuedItemsParams, SocialMotions) == 0x0000A0, "Member 'FM1QueuedItemsParams::SocialMotions' has a wrong offset!");
static_assert(offsetof(FM1QueuedItemsParams, Proficiencies) == 0x0000B0, "Member 'FM1QueuedItemsParams::Proficiencies' has a wrong offset!");
static_assert(offsetof(FM1QueuedItemsParams, Customizings) == 0x0000C0, "Member 'FM1QueuedItemsParams::Customizings' has a wrong offset!");

// ScriptStruct M1.M1UIEvent_ChangedProgressAtQuest
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FM1UIEvent_ChangedProgressAtQuest final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_ChangedProgressAtQuest) == 0x000004, "Wrong alignment on FM1UIEvent_ChangedProgressAtQuest");
static_assert(sizeof(FM1UIEvent_ChangedProgressAtQuest) == 0x000010, "Wrong size on FM1UIEvent_ChangedProgressAtQuest");

// ScriptStruct M1.M1QueuedItems
// 0x0001 (0x0001 - 0x0000)
struct FM1QueuedItems final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1QueuedItems) == 0x000001, "Wrong alignment on FM1QueuedItems");
static_assert(sizeof(FM1QueuedItems) == 0x000001, "Wrong size on FM1QueuedItems");

// ScriptStruct M1.M1RallyPointConstructionInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1RallyPointConstructionInfo final
{
public:
	int32                                         RallyPointCount;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceMove;                                        // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AM1RallyPoint*>                  RallyPointActors;                                  // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	class AM1RallyPoint*                          RandomRallyPoint;                                  // 0x0018(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RallyPointConstructionInfo) == 0x000008, "Wrong alignment on FM1RallyPointConstructionInfo");
static_assert(sizeof(FM1RallyPointConstructionInfo) == 0x000020, "Wrong size on FM1RallyPointConstructionInfo");
static_assert(offsetof(FM1RallyPointConstructionInfo, RallyPointCount) == 0x000000, "Member 'FM1RallyPointConstructionInfo::RallyPointCount' has a wrong offset!");
static_assert(offsetof(FM1RallyPointConstructionInfo, bForceMove) == 0x000004, "Member 'FM1RallyPointConstructionInfo::bForceMove' has a wrong offset!");
static_assert(offsetof(FM1RallyPointConstructionInfo, RallyPointActors) == 0x000008, "Member 'FM1RallyPointConstructionInfo::RallyPointActors' has a wrong offset!");
static_assert(offsetof(FM1RallyPointConstructionInfo, RandomRallyPoint) == 0x000018, "Member 'FM1RallyPointConstructionInfo::RandomRallyPoint' has a wrong offset!");

// ScriptStruct M1.M1DynamicNavPolyCostSettings
// 0x000C (0x000C - 0x0000)
struct FM1DynamicNavPolyCostSettings final
{
public:
	bool                                          bDynamicLinkPolyCost;                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdditionalLinkPolyCostPerAgent;                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisualizeCost;                                    // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1DynamicNavPolyCostSettings) == 0x000004, "Wrong alignment on FM1DynamicNavPolyCostSettings");
static_assert(sizeof(FM1DynamicNavPolyCostSettings) == 0x00000C, "Wrong size on FM1DynamicNavPolyCostSettings");
static_assert(offsetof(FM1DynamicNavPolyCostSettings, bDynamicLinkPolyCost) == 0x000000, "Member 'FM1DynamicNavPolyCostSettings::bDynamicLinkPolyCost' has a wrong offset!");
static_assert(offsetof(FM1DynamicNavPolyCostSettings, AdditionalLinkPolyCostPerAgent) == 0x000004, "Member 'FM1DynamicNavPolyCostSettings::AdditionalLinkPolyCostPerAgent' has a wrong offset!");
static_assert(offsetof(FM1DynamicNavPolyCostSettings, bVisualizeCost) == 0x000008, "Member 'FM1DynamicNavPolyCostSettings::bVisualizeCost' has a wrong offset!");

// ScriptStruct M1.M1ConnectionAlwaysRelevantNodePair
// 0x0010 (0x0010 - 0x0000)
struct FM1ConnectionAlwaysRelevantNodePair final
{
public:
	class UNetConnection*                         NetConnection;                                     // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReplicationGraphNode_AlwaysRelevant_ForConnection* Node;                                              // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ConnectionAlwaysRelevantNodePair) == 0x000008, "Wrong alignment on FM1ConnectionAlwaysRelevantNodePair");
static_assert(sizeof(FM1ConnectionAlwaysRelevantNodePair) == 0x000010, "Wrong size on FM1ConnectionAlwaysRelevantNodePair");
static_assert(offsetof(FM1ConnectionAlwaysRelevantNodePair, NetConnection) == 0x000000, "Member 'FM1ConnectionAlwaysRelevantNodePair::NetConnection' has a wrong offset!");
static_assert(offsetof(FM1ConnectionAlwaysRelevantNodePair, Node) == 0x000008, "Member 'FM1ConnectionAlwaysRelevantNodePair::Node' has a wrong offset!");

// ScriptStruct M1.M1WeaponChargeGaugeUIColors
// 0x0030 (0x0030 - 0x0000)
struct FM1WeaponChargeGaugeUIColors final
{
public:
	struct FLinearColor                           BaseColor;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MultiplyColor;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FillColor;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponChargeGaugeUIColors) == 0x000004, "Wrong alignment on FM1WeaponChargeGaugeUIColors");
static_assert(sizeof(FM1WeaponChargeGaugeUIColors) == 0x000030, "Wrong size on FM1WeaponChargeGaugeUIColors");
static_assert(offsetof(FM1WeaponChargeGaugeUIColors, BaseColor) == 0x000000, "Member 'FM1WeaponChargeGaugeUIColors::BaseColor' has a wrong offset!");
static_assert(offsetof(FM1WeaponChargeGaugeUIColors, MultiplyColor) == 0x000010, "Member 'FM1WeaponChargeGaugeUIColors::MultiplyColor' has a wrong offset!");
static_assert(offsetof(FM1WeaponChargeGaugeUIColors, FillColor) == 0x000020, "Member 'FM1WeaponChargeGaugeUIColors::FillColor' has a wrong offset!");

// ScriptStruct M1.M1FeaturedResearch
// 0x0020 (0x0020 - 0x0000)
struct FM1FeaturedResearch final
{
public:
	TArray<class UM1Research*>                    ShuffledResearches;                                // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UM1Research*>                    RecommandResearches;                               // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FeaturedResearch) == 0x000008, "Wrong alignment on FM1FeaturedResearch");
static_assert(sizeof(FM1FeaturedResearch) == 0x000020, "Wrong size on FM1FeaturedResearch");
static_assert(offsetof(FM1FeaturedResearch, ShuffledResearches) == 0x000000, "Member 'FM1FeaturedResearch::ShuffledResearches' has a wrong offset!");
static_assert(offsetof(FM1FeaturedResearch, RecommandResearches) == 0x000010, "Member 'FM1FeaturedResearch::RecommandResearches' has a wrong offset!");

// ScriptStruct M1.M1RewardParam
// 0x0020 (0x0020 - 0x0000)
struct FM1RewardParam final
{
public:
	struct FVector                                TargetLocation;                                    // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         CharacterExp;                                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ProficiencyExp;                                    // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RewardParam) == 0x000008, "Wrong alignment on FM1RewardParam");
static_assert(sizeof(FM1RewardParam) == 0x000020, "Wrong size on FM1RewardParam");
static_assert(offsetof(FM1RewardParam, TargetLocation) == 0x000000, "Member 'FM1RewardParam::TargetLocation' has a wrong offset!");
static_assert(offsetof(FM1RewardParam, CharacterExp) == 0x000010, "Member 'FM1RewardParam::CharacterExp' has a wrong offset!");
static_assert(offsetof(FM1RewardParam, ProficiencyExp) == 0x000018, "Member 'FM1RewardParam::ProficiencyExp' has a wrong offset!");

// ScriptStruct M1.M1ReceivedProficiencyExp
// 0x0008 (0x0028 - 0x0020)
struct FM1ReceivedProficiencyExp final : public FM1ReceivedRewardExp
{
public:
	struct FM1TemplateId                          TemplateId;                                        // 0x0020(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ReceivedProficiencyExp) == 0x000008, "Wrong alignment on FM1ReceivedProficiencyExp");
static_assert(sizeof(FM1ReceivedProficiencyExp) == 0x000028, "Wrong size on FM1ReceivedProficiencyExp");
static_assert(offsetof(FM1ReceivedProficiencyExp, TemplateId) == 0x000020, "Member 'FM1ReceivedProficiencyExp::TemplateId' has a wrong offset!");

// ScriptStruct M1.M1ActivatedWeaponSlot
// 0x0040 (0x0040 - 0x0000)
struct FM1ActivatedWeaponSlot final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1WeaponSlot                          WeaponSlot;                                        // 0x0008(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x20];                                      // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ActivatedWeaponSlot) == 0x000008, "Wrong alignment on FM1ActivatedWeaponSlot");
static_assert(sizeof(FM1ActivatedWeaponSlot) == 0x000040, "Wrong size on FM1ActivatedWeaponSlot");
static_assert(offsetof(FM1ActivatedWeaponSlot, WeaponSlot) == 0x000008, "Member 'FM1ActivatedWeaponSlot::WeaponSlot' has a wrong offset!");

// ScriptStruct M1.M1RichTextBlockLinkStytleRow
// 0x06E8 (0x06F0 - 0x0008)
struct FM1RichTextBlockLinkStytleRow final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHyperlinkStyle                        LinkTextStyle;                                     // 0x0010(0x06E0)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RichTextBlockLinkStytleRow) == 0x000010, "Wrong alignment on FM1RichTextBlockLinkStytleRow");
static_assert(sizeof(FM1RichTextBlockLinkStytleRow) == 0x0006F0, "Wrong size on FM1RichTextBlockLinkStytleRow");
static_assert(offsetof(FM1RichTextBlockLinkStytleRow, LinkTextStyle) == 0x000010, "Member 'FM1RichTextBlockLinkStytleRow::LinkTextStyle' has a wrong offset!");

// ScriptStruct M1.M1StatusEffectRPC
// 0x0018 (0x0018 - 0x0000)
struct FM1StatusEffectRPC final
{
public:
	TWeakObjectPtr<class UM1StatusEffectComponent> StatusEffectComponent;                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UM1StatusEffect>         StatusEffect;                                      // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StatusEffectDataRowName;                           // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1StatusEffectRPC) == 0x000004, "Wrong alignment on FM1StatusEffectRPC");
static_assert(sizeof(FM1StatusEffectRPC) == 0x000018, "Wrong size on FM1StatusEffectRPC");
static_assert(offsetof(FM1StatusEffectRPC, StatusEffectComponent) == 0x000000, "Member 'FM1StatusEffectRPC::StatusEffectComponent' has a wrong offset!");
static_assert(offsetof(FM1StatusEffectRPC, StatusEffect) == 0x000008, "Member 'FM1StatusEffectRPC::StatusEffect' has a wrong offset!");
static_assert(offsetof(FM1StatusEffectRPC, StatusEffectDataRowName) == 0x000010, "Member 'FM1StatusEffectRPC::StatusEffectDataRowName' has a wrong offset!");

// ScriptStruct M1.M1InstantHitShellHitResults
// 0x0018 (0x0018 - 0x0000)
struct FM1InstantHitShellHitResults final
{
public:
	TArray<struct FHitResult>                     HitResults;                                        // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bHitMultiEnemy;                                    // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1InstantHitShellHitResults) == 0x000008, "Wrong alignment on FM1InstantHitShellHitResults");
static_assert(sizeof(FM1InstantHitShellHitResults) == 0x000018, "Wrong size on FM1InstantHitShellHitResults");
static_assert(offsetof(FM1InstantHitShellHitResults, HitResults) == 0x000000, "Member 'FM1InstantHitShellHitResults::HitResults' has a wrong offset!");
static_assert(offsetof(FM1InstantHitShellHitResults, bHitMultiEnemy) == 0x000010, "Member 'FM1InstantHitShellHitResults::bHitMultiEnemy' has a wrong offset!");

// ScriptStruct M1.M1NXRequestRuneRecommendation
// 0x0038 (0x0038 - 0x0000)
struct FM1NXRequestRuneRecommendation final
{
public:
	int64                                         Npsn;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Character_id;                                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weapon_id;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1NXRecRuneInfo>               Module_hold;                                       // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Module_capacity;                                   // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Model_type;                                        // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1NXRecRuneSlotInfo>           Module_slots;                                      // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NXRequestRuneRecommendation) == 0x000008, "Wrong alignment on FM1NXRequestRuneRecommendation");
static_assert(sizeof(FM1NXRequestRuneRecommendation) == 0x000038, "Wrong size on FM1NXRequestRuneRecommendation");
static_assert(offsetof(FM1NXRequestRuneRecommendation, Npsn) == 0x000000, "Member 'FM1NXRequestRuneRecommendation::Npsn' has a wrong offset!");
static_assert(offsetof(FM1NXRequestRuneRecommendation, Character_id) == 0x000008, "Member 'FM1NXRequestRuneRecommendation::Character_id' has a wrong offset!");
static_assert(offsetof(FM1NXRequestRuneRecommendation, Weapon_id) == 0x00000C, "Member 'FM1NXRequestRuneRecommendation::Weapon_id' has a wrong offset!");
static_assert(offsetof(FM1NXRequestRuneRecommendation, Module_hold) == 0x000010, "Member 'FM1NXRequestRuneRecommendation::Module_hold' has a wrong offset!");
static_assert(offsetof(FM1NXRequestRuneRecommendation, Module_capacity) == 0x000020, "Member 'FM1NXRequestRuneRecommendation::Module_capacity' has a wrong offset!");
static_assert(offsetof(FM1NXRequestRuneRecommendation, Model_type) == 0x000024, "Member 'FM1NXRequestRuneRecommendation::Model_type' has a wrong offset!");
static_assert(offsetof(FM1NXRequestRuneRecommendation, Module_slots) == 0x000028, "Member 'FM1NXRequestRuneRecommendation::Module_slots' has a wrong offset!");

// ScriptStruct M1.M1NXRecommendation
// 0x0030 (0x0030 - 0x0000)
struct FM1NXRecommendation final
{
public:
	TArray<struct FM1NXRunePak>                   Items;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Context;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Sub_context;                                       // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NXRecommendation) == 0x000008, "Wrong alignment on FM1NXRecommendation");
static_assert(sizeof(FM1NXRecommendation) == 0x000030, "Wrong size on FM1NXRecommendation");
static_assert(offsetof(FM1NXRecommendation, Items) == 0x000000, "Member 'FM1NXRecommendation::Items' has a wrong offset!");
static_assert(offsetof(FM1NXRecommendation, Context) == 0x000010, "Member 'FM1NXRecommendation::Context' has a wrong offset!");
static_assert(offsetof(FM1NXRecommendation, Sub_context) == 0x000020, "Member 'FM1NXRecommendation::Sub_context' has a wrong offset!");

// ScriptStruct M1.M1WeaponMagazineRecord
// 0x0010 (0x0010 - 0x0000)
struct FM1WeaponMagazineRecord final
{
public:
	double                                        Timestamp;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundsPerMagazine;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1WeaponMagazineRecord) == 0x000008, "Wrong alignment on FM1WeaponMagazineRecord");
static_assert(sizeof(FM1WeaponMagazineRecord) == 0x000010, "Wrong size on FM1WeaponMagazineRecord");
static_assert(offsetof(FM1WeaponMagazineRecord, Timestamp) == 0x000000, "Member 'FM1WeaponMagazineRecord::Timestamp' has a wrong offset!");
static_assert(offsetof(FM1WeaponMagazineRecord, RoundsPerMagazine) == 0x000008, "Member 'FM1WeaponMagazineRecord::RoundsPerMagazine' has a wrong offset!");

// ScriptStruct M1.M1NXReceiveRuneRecommendation
// 0x0040 (0x0040 - 0x0000)
struct FM1NXReceiveRuneRecommendation final
{
public:
	class FString                                 Model_id;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NXRecommendation                    Recommendation;                                    // 0x0010(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NXReceiveRuneRecommendation) == 0x000008, "Wrong alignment on FM1NXReceiveRuneRecommendation");
static_assert(sizeof(FM1NXReceiveRuneRecommendation) == 0x000040, "Wrong size on FM1NXReceiveRuneRecommendation");
static_assert(offsetof(FM1NXReceiveRuneRecommendation, Model_id) == 0x000000, "Member 'FM1NXReceiveRuneRecommendation::Model_id' has a wrong offset!");
static_assert(offsetof(FM1NXReceiveRuneRecommendation, Recommendation) == 0x000010, "Member 'FM1NXReceiveRuneRecommendation::Recommendation' has a wrong offset!");

// ScriptStruct M1.M1RuneQuantitySet
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FM1RuneQuantitySet final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RuneQuantitySet) == 0x000008, "Wrong alignment on FM1RuneQuantitySet");
static_assert(sizeof(FM1RuneQuantitySet) == 0x000050, "Wrong size on FM1RuneQuantitySet");

// ScriptStruct M1.M1SeasonReinforce
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FM1SeasonReinforce final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SeasonReinforce) == 0x000008, "Wrong alignment on FM1SeasonReinforce");
static_assert(sizeof(FM1SeasonReinforce) == 0x000010, "Wrong size on FM1SeasonReinforce");

// ScriptStruct M1.M1ServerStreamingEnabled
// 0x0008 (0x0008 - 0x0000)
struct FM1ServerStreamingEnabled final
{
public:
	bool                                          bIsEnabled;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        UpdateCounter;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ServerStreamingEnabled) == 0x000004, "Wrong alignment on FM1ServerStreamingEnabled");
static_assert(sizeof(FM1ServerStreamingEnabled) == 0x000008, "Wrong size on FM1ServerStreamingEnabled");
static_assert(offsetof(FM1ServerStreamingEnabled, bIsEnabled) == 0x000000, "Member 'FM1ServerStreamingEnabled::bIsEnabled' has a wrong offset!");
static_assert(offsetof(FM1ServerStreamingEnabled, UpdateCounter) == 0x000004, "Member 'FM1ServerStreamingEnabled::UpdateCounter' has a wrong offset!");

// ScriptStruct M1.M1MasteryLevelBenefitDetailInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FM1MasteryLevelBenefitDetailInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MasteryLevelBenefitDetailInfo) == 0x000008, "Wrong alignment on FM1MasteryLevelBenefitDetailInfo");
static_assert(sizeof(FM1MasteryLevelBenefitDetailInfo) == 0x000018, "Wrong size on FM1MasteryLevelBenefitDetailInfo");

// ScriptStruct M1.M1SetOptionInfo
// 0x0060 (0x0060 - 0x0000)
struct FM1SetOptionInfo final
{
public:
	TArray<class UM1InventoryItemAccessory*>      EquippedAccessories;                               // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, struct FM1AbilityId>              ActiveAbilityIds;                                  // 0x0010(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SetOptionInfo) == 0x000008, "Wrong alignment on FM1SetOptionInfo");
static_assert(sizeof(FM1SetOptionInfo) == 0x000060, "Wrong size on FM1SetOptionInfo");
static_assert(offsetof(FM1SetOptionInfo, EquippedAccessories) == 0x000000, "Member 'FM1SetOptionInfo::EquippedAccessories' has a wrong offset!");
static_assert(offsetof(FM1SetOptionInfo, ActiveAbilityIds) == 0x000010, "Member 'FM1SetOptionInfo::ActiveAbilityIds' has a wrong offset!");

// ScriptStruct M1.M1Skill
// 0x00A0 (0x00A0 - 0x0000)
struct FM1Skill final
{
public:
	class FName                                   DefaultSkillDataRowName;                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SkillDataRowName;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FM1AbilityId>                   AbilityIdByLevels;                                 // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FM1AbilityId                           ActiveHandle;                                      // 0x0020(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FM1AlarmId                             CooltimeAlarmId;                                   // 0x0030(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FM1AlarmId                             StackChargingTimeAlarmId;                          // 0x0040(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         StackChargingCount;                                // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1AlarmId                             ActiveDurationAlarmId;                             // 0x0058(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EM1BattleKey                                  BattleKey;                                         // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EM1SkillActiveType                            ActiveType;                                        // 0x0069(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A[0x2E];                                      // 0x006A(0x002E)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnerActor;                                        // 0x0098(0x0008)(ZeroConstructor, Transient, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1Skill) == 0x000008, "Wrong alignment on FM1Skill");
static_assert(sizeof(FM1Skill) == 0x0000A0, "Wrong size on FM1Skill");
static_assert(offsetof(FM1Skill, DefaultSkillDataRowName) == 0x000000, "Member 'FM1Skill::DefaultSkillDataRowName' has a wrong offset!");
static_assert(offsetof(FM1Skill, SkillDataRowName) == 0x000008, "Member 'FM1Skill::SkillDataRowName' has a wrong offset!");
static_assert(offsetof(FM1Skill, AbilityIdByLevels) == 0x000010, "Member 'FM1Skill::AbilityIdByLevels' has a wrong offset!");
static_assert(offsetof(FM1Skill, ActiveHandle) == 0x000020, "Member 'FM1Skill::ActiveHandle' has a wrong offset!");
static_assert(offsetof(FM1Skill, CooltimeAlarmId) == 0x000030, "Member 'FM1Skill::CooltimeAlarmId' has a wrong offset!");
static_assert(offsetof(FM1Skill, StackChargingTimeAlarmId) == 0x000040, "Member 'FM1Skill::StackChargingTimeAlarmId' has a wrong offset!");
static_assert(offsetof(FM1Skill, StackChargingCount) == 0x000050, "Member 'FM1Skill::StackChargingCount' has a wrong offset!");
static_assert(offsetof(FM1Skill, ActiveDurationAlarmId) == 0x000058, "Member 'FM1Skill::ActiveDurationAlarmId' has a wrong offset!");
static_assert(offsetof(FM1Skill, BattleKey) == 0x000068, "Member 'FM1Skill::BattleKey' has a wrong offset!");
static_assert(offsetof(FM1Skill, ActiveType) == 0x000069, "Member 'FM1Skill::ActiveType' has a wrong offset!");
static_assert(offsetof(FM1Skill, OwnerActor) == 0x000098, "Member 'FM1Skill::OwnerActor' has a wrong offset!");

// ScriptStruct M1.M1OwningToolTipType
// 0x0020 (0x0020 - 0x0000)
struct FM1OwningToolTipType final
{
public:
	EM1TooltipAttachOption                        AttachOption;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1TooltipAttachDirection                     AttachDirection;                                   // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UM1UIWidget>                ToolTipClass;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TooltipUIKey;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1OwningToolTipType) == 0x000008, "Wrong alignment on FM1OwningToolTipType");
static_assert(sizeof(FM1OwningToolTipType) == 0x000020, "Wrong size on FM1OwningToolTipType");
static_assert(offsetof(FM1OwningToolTipType, AttachOption) == 0x000000, "Member 'FM1OwningToolTipType::AttachOption' has a wrong offset!");
static_assert(offsetof(FM1OwningToolTipType, AttachDirection) == 0x000001, "Member 'FM1OwningToolTipType::AttachDirection' has a wrong offset!");
static_assert(offsetof(FM1OwningToolTipType, ToolTipClass) == 0x000008, "Member 'FM1OwningToolTipType::ToolTipClass' has a wrong offset!");
static_assert(offsetof(FM1OwningToolTipType, TooltipUIKey) == 0x000010, "Member 'FM1OwningToolTipType::TooltipUIKey' has a wrong offset!");

// ScriptStruct M1.M1NXGameInfo
// 0x0078 (0x0078 - 0x0000)
struct FM1NXGameInfo final
{
public:
	int32                                         ServiceId;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServiceName;                                       // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServiceSupportUrl;                                 // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServiceSupportUrlForGuest;                         // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1NXCreatorGradeInfo                  GradeInfo;                                         // 0x0038(0x0040)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NXGameInfo) == 0x000008, "Wrong alignment on FM1NXGameInfo");
static_assert(sizeof(FM1NXGameInfo) == 0x000078, "Wrong size on FM1NXGameInfo");
static_assert(offsetof(FM1NXGameInfo, ServiceId) == 0x000000, "Member 'FM1NXGameInfo::ServiceId' has a wrong offset!");
static_assert(offsetof(FM1NXGameInfo, ServiceName) == 0x000008, "Member 'FM1NXGameInfo::ServiceName' has a wrong offset!");
static_assert(offsetof(FM1NXGameInfo, ServiceSupportUrl) == 0x000018, "Member 'FM1NXGameInfo::ServiceSupportUrl' has a wrong offset!");
static_assert(offsetof(FM1NXGameInfo, ServiceSupportUrlForGuest) == 0x000028, "Member 'FM1NXGameInfo::ServiceSupportUrlForGuest' has a wrong offset!");
static_assert(offsetof(FM1NXGameInfo, GradeInfo) == 0x000038, "Member 'FM1NXGameInfo::GradeInfo' has a wrong offset!");

// ScriptStruct M1.M1NXReceiveCSPInfoWrapper
// 0x0080 (0x0080 - 0x0000)
struct FM1NXReceiveCSPInfoWrapper final
{
public:
	int32                                         Code;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1NXGameInfo                          Data;                                              // 0x0008(0x0078)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NXReceiveCSPInfoWrapper) == 0x000008, "Wrong alignment on FM1NXReceiveCSPInfoWrapper");
static_assert(sizeof(FM1NXReceiveCSPInfoWrapper) == 0x000080, "Wrong size on FM1NXReceiveCSPInfoWrapper");
static_assert(offsetof(FM1NXReceiveCSPInfoWrapper, Code) == 0x000000, "Member 'FM1NXReceiveCSPInfoWrapper::Code' has a wrong offset!");
static_assert(offsetof(FM1NXReceiveCSPInfoWrapper, Data) == 0x000008, "Member 'FM1NXReceiveCSPInfoWrapper::Data' has a wrong offset!");

// ScriptStruct M1.M1TabItem
// 0x0050 (0x0050 - 0x0000)
struct FM1TabItem final
{
public:
	TSoftObjectPtr<class UTexture2D>              IconImage;                                         // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StringId;                                          // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           IconImageColor;                                    // 0x0040(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TabItem) == 0x000008, "Wrong alignment on FM1TabItem");
static_assert(sizeof(FM1TabItem) == 0x000050, "Wrong size on FM1TabItem");
static_assert(offsetof(FM1TabItem, IconImage) == 0x000000, "Member 'FM1TabItem::IconImage' has a wrong offset!");
static_assert(offsetof(FM1TabItem, StringId) == 0x000030, "Member 'FM1TabItem::StringId' has a wrong offset!");
static_assert(offsetof(FM1TabItem, IconImageColor) == 0x000040, "Member 'FM1TabItem::IconImageColor' has a wrong offset!");

// ScriptStruct M1.M1NXReceiveUserCSPInfo
// 0x00B8 (0x00B8 - 0x0000)
struct FM1NXReceiveUserCSPInfo final
{
public:
	struct FM1NXCreatorInfo                       CreatorInfo;                                       // 0x0000(0x00B8)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NXReceiveUserCSPInfo) == 0x000008, "Wrong alignment on FM1NXReceiveUserCSPInfo");
static_assert(sizeof(FM1NXReceiveUserCSPInfo) == 0x0000B8, "Wrong size on FM1NXReceiveUserCSPInfo");
static_assert(offsetof(FM1NXReceiveUserCSPInfo, CreatorInfo) == 0x000000, "Member 'FM1NXReceiveUserCSPInfo::CreatorInfo' has a wrong offset!");

// ScriptStruct M1.M1NXReceiveUserCSPInfoWrapper
// 0x00C0 (0x00C0 - 0x0000)
struct FM1NXReceiveUserCSPInfoWrapper final
{
public:
	int32                                         Code;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1NXReceiveUserCSPInfo                Data;                                              // 0x0008(0x00B8)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NXReceiveUserCSPInfoWrapper) == 0x000008, "Wrong alignment on FM1NXReceiveUserCSPInfoWrapper");
static_assert(sizeof(FM1NXReceiveUserCSPInfoWrapper) == 0x0000C0, "Wrong size on FM1NXReceiveUserCSPInfoWrapper");
static_assert(offsetof(FM1NXReceiveUserCSPInfoWrapper, Code) == 0x000000, "Member 'FM1NXReceiveUserCSPInfoWrapper::Code' has a wrong offset!");
static_assert(offsetof(FM1NXReceiveUserCSPInfoWrapper, Data) == 0x000008, "Member 'FM1NXReceiveUserCSPInfoWrapper::Data' has a wrong offset!");

// ScriptStruct M1.M1NXRequestCSP
// 0x0010 (0x0010 - 0x0000)
struct FM1NXRequestCSP final
{
public:
	class FString                                 Game_token;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NXRequestCSP) == 0x000008, "Wrong alignment on FM1NXRequestCSP");
static_assert(sizeof(FM1NXRequestCSP) == 0x000010, "Wrong size on FM1NXRequestCSP");
static_assert(offsetof(FM1NXRequestCSP, Game_token) == 0x000000, "Member 'FM1NXRequestCSP::Game_token' has a wrong offset!");

// ScriptStruct M1.M1NXRequestUserCSP
// 0x0020 (0x0020 - 0x0000)
struct FM1NXRequestUserCSP final
{
public:
	class FString                                 Game_token;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Guid;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1NXRequestUserCSP) == 0x000008, "Wrong alignment on FM1NXRequestUserCSP");
static_assert(sizeof(FM1NXRequestUserCSP) == 0x000020, "Wrong size on FM1NXRequestUserCSP");
static_assert(offsetof(FM1NXRequestUserCSP, Game_token) == 0x000000, "Member 'FM1NXRequestUserCSP::Game_token' has a wrong offset!");
static_assert(offsetof(FM1NXRequestUserCSP, Guid) == 0x000010, "Member 'FM1NXRequestUserCSP::Guid' has a wrong offset!");

// ScriptStruct M1.M1CollectionInfoUI
// 0x0018 (0x0018 - 0x0000)
struct FM1CollectionInfoUI final
{
public:
	class FString                                 CollectiblesStringId;                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentCount;                                      // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetCount;                                       // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CollectionInfoUI) == 0x000008, "Wrong alignment on FM1CollectionInfoUI");
static_assert(sizeof(FM1CollectionInfoUI) == 0x000018, "Wrong size on FM1CollectionInfoUI");
static_assert(offsetof(FM1CollectionInfoUI, CollectiblesStringId) == 0x000000, "Member 'FM1CollectionInfoUI::CollectiblesStringId' has a wrong offset!");
static_assert(offsetof(FM1CollectionInfoUI, CurrentCount) == 0x000010, "Member 'FM1CollectionInfoUI::CurrentCount' has a wrong offset!");
static_assert(offsetof(FM1CollectionInfoUI, TargetCount) == 0x000014, "Member 'FM1CollectionInfoUI::TargetCount' has a wrong offset!");

// ScriptStruct M1.M1CanCommunicateMap
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FM1CanCommunicateMap final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CanCommunicateMap) == 0x000008, "Wrong alignment on FM1CanCommunicateMap");
static_assert(sizeof(FM1CanCommunicateMap) == 0x000050, "Wrong size on FM1CanCommunicateMap");

// ScriptStruct M1.M1SocialBlockDataMap
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FM1SocialBlockDataMap final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SocialBlockDataMap) == 0x000008, "Wrong alignment on FM1SocialBlockDataMap");
static_assert(sizeof(FM1SocialBlockDataMap) == 0x000050, "Wrong size on FM1SocialBlockDataMap");

// ScriptStruct M1.M1PlayerPlatformCommPermissionInfo
// 0x0068 (0x0068 - 0x0000)
struct FM1PlayerPlatformCommPermissionInfo final
{
public:
	class FString                                 AccountName;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        PlatformUid;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EM1CommunicationType, EM1CommunicateCheckResult> PermissionMap;                                     // 0x0018(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PlayerPlatformCommPermissionInfo) == 0x000008, "Wrong alignment on FM1PlayerPlatformCommPermissionInfo");
static_assert(sizeof(FM1PlayerPlatformCommPermissionInfo) == 0x000068, "Wrong size on FM1PlayerPlatformCommPermissionInfo");
static_assert(offsetof(FM1PlayerPlatformCommPermissionInfo, AccountName) == 0x000000, "Member 'FM1PlayerPlatformCommPermissionInfo::AccountName' has a wrong offset!");
static_assert(offsetof(FM1PlayerPlatformCommPermissionInfo, PlatformUid) == 0x000010, "Member 'FM1PlayerPlatformCommPermissionInfo::PlatformUid' has a wrong offset!");
static_assert(offsetof(FM1PlayerPlatformCommPermissionInfo, PermissionMap) == 0x000018, "Member 'FM1PlayerPlatformCommPermissionInfo::PermissionMap' has a wrong offset!");

// ScriptStruct M1.M1PackageElement
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FM1PackageElement final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PackageElement) == 0x000008, "Wrong alignment on FM1PackageElement");
static_assert(sizeof(FM1PackageElement) == 0x000018, "Wrong size on FM1PackageElement");

// ScriptStruct M1.M1PlayerPlatformCommPermissionList
// 0x00A0 (0x00A0 - 0x0000)
struct alignas(0x08) FM1PlayerPlatformCommPermissionList final
{
public:
	uint8                                         Pad_0[0xA0];                                       // 0x0000(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PlayerPlatformCommPermissionList) == 0x000008, "Wrong alignment on FM1PlayerPlatformCommPermissionList");
static_assert(sizeof(FM1PlayerPlatformCommPermissionList) == 0x0000A0, "Wrong size on FM1PlayerPlatformCommPermissionList");

// ScriptStruct M1.M1SessionMemberCommState
// 0x0060 (0x0060 - 0x0000)
struct FM1SessionMemberCommState final
{
public:
	class FString                                 AccountName;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EM1CommunicationType, bool>              CommMap;                                           // 0x0010(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SessionMemberCommState) == 0x000008, "Wrong alignment on FM1SessionMemberCommState");
static_assert(sizeof(FM1SessionMemberCommState) == 0x000060, "Wrong size on FM1SessionMemberCommState");
static_assert(offsetof(FM1SessionMemberCommState, AccountName) == 0x000000, "Member 'FM1SessionMemberCommState::AccountName' has a wrong offset!");
static_assert(offsetof(FM1SessionMemberCommState, CommMap) == 0x000010, "Member 'FM1SessionMemberCommState::CommMap' has a wrong offset!");

// ScriptStruct M1.M1SessionMemberCommStateList
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FM1SessionMemberCommStateList final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SessionMemberCommStateList) == 0x000008, "Wrong alignment on FM1SessionMemberCommStateList");
static_assert(sizeof(FM1SessionMemberCommStateList) == 0x000050, "Wrong size on FM1SessionMemberCommStateList");

// ScriptStruct M1.M1SpawnLocationEffectFXForMesh
// 0x0050 (0x0050 - 0x0000)
struct FM1SpawnLocationEffectFXForMesh final
{
public:
	bool                                          bAttachToOwner;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1FXSpawnParam                        FXSpawnParam;                                      // 0x0010(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SpawnLocationEffectFXForMesh) == 0x000008, "Wrong alignment on FM1SpawnLocationEffectFXForMesh");
static_assert(sizeof(FM1SpawnLocationEffectFXForMesh) == 0x000050, "Wrong size on FM1SpawnLocationEffectFXForMesh");
static_assert(offsetof(FM1SpawnLocationEffectFXForMesh, bAttachToOwner) == 0x000000, "Member 'FM1SpawnLocationEffectFXForMesh::bAttachToOwner' has a wrong offset!");
static_assert(offsetof(FM1SpawnLocationEffectFXForMesh, BoneName) == 0x000004, "Member 'FM1SpawnLocationEffectFXForMesh::BoneName' has a wrong offset!");
static_assert(offsetof(FM1SpawnLocationEffectFXForMesh, FXSpawnParam) == 0x000010, "Member 'FM1SpawnLocationEffectFXForMesh::FXSpawnParam' has a wrong offset!");

// ScriptStruct M1.M1SelectorSpawnLocation
// 0x0014 (0x0014 - 0x0000)
struct FM1SelectorSpawnLocation final
{
public:
	struct FVector                                SpawnLocation;                                     // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeSpawned;                                      // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnOrder;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SelectorSpawnLocation) == 0x000004, "Wrong alignment on FM1SelectorSpawnLocation");
static_assert(sizeof(FM1SelectorSpawnLocation) == 0x000014, "Wrong size on FM1SelectorSpawnLocation");
static_assert(offsetof(FM1SelectorSpawnLocation, SpawnLocation) == 0x000000, "Member 'FM1SelectorSpawnLocation::SpawnLocation' has a wrong offset!");
static_assert(offsetof(FM1SelectorSpawnLocation, CanBeSpawned) == 0x00000C, "Member 'FM1SelectorSpawnLocation::CanBeSpawned' has a wrong offset!");
static_assert(offsetof(FM1SelectorSpawnLocation, SpawnOrder) == 0x000010, "Member 'FM1SelectorSpawnLocation::SpawnOrder' has a wrong offset!");

// ScriptStruct M1.M1CarryingCharacterLaunchInfo
// 0x0008 (0x0008 - 0x0000)
struct FM1CarryingCharacterLaunchInfo final
{
public:
	float                                         MinDelayToLaunch;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDelayToLaunch;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CarryingCharacterLaunchInfo) == 0x000004, "Wrong alignment on FM1CarryingCharacterLaunchInfo");
static_assert(sizeof(FM1CarryingCharacterLaunchInfo) == 0x000008, "Wrong size on FM1CarryingCharacterLaunchInfo");
static_assert(offsetof(FM1CarryingCharacterLaunchInfo, MinDelayToLaunch) == 0x000000, "Member 'FM1CarryingCharacterLaunchInfo::MinDelayToLaunch' has a wrong offset!");
static_assert(offsetof(FM1CarryingCharacterLaunchInfo, MaxDelayToLaunch) == 0x000004, "Member 'FM1CarryingCharacterLaunchInfo::MaxDelayToLaunch' has a wrong offset!");

// ScriptStruct M1.M1UIEvent_StopReload
// 0x0002 (0x0002 - 0x0000)
struct FM1UIEvent_StopReload final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_StopReload) == 0x000001, "Wrong alignment on FM1UIEvent_StopReload");
static_assert(sizeof(FM1UIEvent_StopReload) == 0x000002, "Wrong size on FM1UIEvent_StopReload");

// ScriptStruct M1.M1MonsterSpawnGroups
// 0x0038 (0x0038 - 0x0000)
struct FM1MonsterSpawnGroups final
{
public:
	class FName                                   MonsterSpawnGroupName;                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ratio;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         LocationTargets;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x18];                                      // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MonsterSpawnGroups) == 0x000008, "Wrong alignment on FM1MonsterSpawnGroups");
static_assert(sizeof(FM1MonsterSpawnGroups) == 0x000038, "Wrong size on FM1MonsterSpawnGroups");
static_assert(offsetof(FM1MonsterSpawnGroups, MonsterSpawnGroupName) == 0x000000, "Member 'FM1MonsterSpawnGroups::MonsterSpawnGroupName' has a wrong offset!");
static_assert(offsetof(FM1MonsterSpawnGroups, Ratio) == 0x000008, "Member 'FM1MonsterSpawnGroups::Ratio' has a wrong offset!");
static_assert(offsetof(FM1MonsterSpawnGroups, LocationTargets) == 0x000010, "Member 'FM1MonsterSpawnGroups::LocationTargets' has a wrong offset!");

// ScriptStruct M1.M1SprayInfo
// 0x0050 (0x0050 - 0x0000)
struct FM1SprayInfo final
{
public:
	struct FM1TemplateId                          SprayTid;                                          // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshLocalYaw;                                      // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnFloor;                                          // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0xB];                                       // 0x0045(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SprayInfo) == 0x000010, "Wrong alignment on FM1SprayInfo");
static_assert(sizeof(FM1SprayInfo) == 0x000050, "Wrong size on FM1SprayInfo");
static_assert(offsetof(FM1SprayInfo, SprayTid) == 0x000000, "Member 'FM1SprayInfo::SprayTid' has a wrong offset!");
static_assert(offsetof(FM1SprayInfo, SpawnTransform) == 0x000010, "Member 'FM1SprayInfo::SpawnTransform' has a wrong offset!");
static_assert(offsetof(FM1SprayInfo, MeshLocalYaw) == 0x000040, "Member 'FM1SprayInfo::MeshLocalYaw' has a wrong offset!");
static_assert(offsetof(FM1SprayInfo, bOnFloor) == 0x000044, "Member 'FM1SprayInfo::bOnFloor' has a wrong offset!");

// ScriptStruct M1.DefaultLaggingInfo
// 0x0014 (0x0014 - 0x0000)
struct FDefaultLaggingInfo final
{
public:
	float                                         Speed;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMaxDistance;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetSpeed;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Accel;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDefaultLaggingInfo) == 0x000004, "Wrong alignment on FDefaultLaggingInfo");
static_assert(sizeof(FDefaultLaggingInfo) == 0x000014, "Wrong size on FDefaultLaggingInfo");
static_assert(offsetof(FDefaultLaggingInfo, Speed) == 0x000000, "Member 'FDefaultLaggingInfo::Speed' has a wrong offset!");
static_assert(offsetof(FDefaultLaggingInfo, MaxDistance) == 0x000004, "Member 'FDefaultLaggingInfo::MaxDistance' has a wrong offset!");
static_assert(offsetof(FDefaultLaggingInfo, TargetMaxDistance) == 0x000008, "Member 'FDefaultLaggingInfo::TargetMaxDistance' has a wrong offset!");
static_assert(offsetof(FDefaultLaggingInfo, TargetSpeed) == 0x00000C, "Member 'FDefaultLaggingInfo::TargetSpeed' has a wrong offset!");
static_assert(offsetof(FDefaultLaggingInfo, Accel) == 0x000010, "Member 'FDefaultLaggingInfo::Accel' has a wrong offset!");

// ScriptStruct M1.HowGameCleared
// 0x0008 (0x0028 - 0x0020)
struct FHowGameCleared final : public FM1Statistics
{
public:
	int32                                         PlayerCount;                                       // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DestroyedObjectCount;                              // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHowGameCleared) == 0x000008, "Wrong alignment on FHowGameCleared");
static_assert(sizeof(FHowGameCleared) == 0x000028, "Wrong size on FHowGameCleared");
static_assert(offsetof(FHowGameCleared, PlayerCount) == 0x000020, "Member 'FHowGameCleared::PlayerCount' has a wrong offset!");
static_assert(offsetof(FHowGameCleared, DestroyedObjectCount) == 0x000024, "Member 'FHowGameCleared::DestroyedObjectCount' has a wrong offset!");

// ScriptStruct M1.M1PCBattlePattern
// 0x0030 (0x0050 - 0x0020)
struct FM1PCBattlePattern final : public FM1Statistics
{
public:
	int64                                         WeaponId;                                          // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PCLocation;                                        // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHit;                                              // 0x0034(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 HitCharacterIDs;                                   // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         TotalDamage;                                       // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitCharacterLength;                                // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PCBattlePattern) == 0x000008, "Wrong alignment on FM1PCBattlePattern");
static_assert(sizeof(FM1PCBattlePattern) == 0x000050, "Wrong size on FM1PCBattlePattern");
static_assert(offsetof(FM1PCBattlePattern, WeaponId) == 0x000020, "Member 'FM1PCBattlePattern::WeaponId' has a wrong offset!");
static_assert(offsetof(FM1PCBattlePattern, PCLocation) == 0x000028, "Member 'FM1PCBattlePattern::PCLocation' has a wrong offset!");
static_assert(offsetof(FM1PCBattlePattern, bHit) == 0x000034, "Member 'FM1PCBattlePattern::bHit' has a wrong offset!");
static_assert(offsetof(FM1PCBattlePattern, HitCharacterIDs) == 0x000038, "Member 'FM1PCBattlePattern::HitCharacterIDs' has a wrong offset!");
static_assert(offsetof(FM1PCBattlePattern, TotalDamage) == 0x000048, "Member 'FM1PCBattlePattern::TotalDamage' has a wrong offset!");
static_assert(offsetof(FM1PCBattlePattern, HitCharacterLength) == 0x00004C, "Member 'FM1PCBattlePattern::HitCharacterLength' has a wrong offset!");

// ScriptStruct M1.M1WeaponBottomHudInfo
// 0x0048 (0x0048 - 0x0000)
struct FM1WeaponBottomHudInfo final
{
public:
	bool                                          bHidden;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           CustomColor;                                       // 0x0004(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              CustomIcon;                                        // 0x0018(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponBottomHudInfo) == 0x000008, "Wrong alignment on FM1WeaponBottomHudInfo");
static_assert(sizeof(FM1WeaponBottomHudInfo) == 0x000048, "Wrong size on FM1WeaponBottomHudInfo");
static_assert(offsetof(FM1WeaponBottomHudInfo, bHidden) == 0x000000, "Member 'FM1WeaponBottomHudInfo::bHidden' has a wrong offset!");
static_assert(offsetof(FM1WeaponBottomHudInfo, CustomColor) == 0x000004, "Member 'FM1WeaponBottomHudInfo::CustomColor' has a wrong offset!");
static_assert(offsetof(FM1WeaponBottomHudInfo, CustomIcon) == 0x000018, "Member 'FM1WeaponBottomHudInfo::CustomIcon' has a wrong offset!");

// ScriptStruct M1.M1DropItemCreated
// 0x0008 (0x0028 - 0x0020)
struct FM1DropItemCreated final : public FM1Statistics
{
public:
	int64                                         ItemId;                                            // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DropItemCreated) == 0x000008, "Wrong alignment on FM1DropItemCreated");
static_assert(sizeof(FM1DropItemCreated) == 0x000028, "Wrong size on FM1DropItemCreated");
static_assert(offsetof(FM1DropItemCreated, ItemId) == 0x000020, "Member 'FM1DropItemCreated::ItemId' has a wrong offset!");

// ScriptStruct M1.M1DropItemAcquired
// 0x0008 (0x0028 - 0x0020)
struct FM1DropItemAcquired final : public FM1Statistics
{
public:
	int64                                         ItemId;                                            // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DropItemAcquired) == 0x000008, "Wrong alignment on FM1DropItemAcquired");
static_assert(sizeof(FM1DropItemAcquired) == 0x000028, "Wrong size on FM1DropItemAcquired");
static_assert(offsetof(FM1DropItemAcquired, ItemId) == 0x000020, "Member 'FM1DropItemAcquired::ItemId' has a wrong offset!");

// ScriptStruct M1.M1PlayerDBNOTriggered
// 0x0000 (0x0020 - 0x0020)
struct FM1PlayerDBNOTriggered final : public FM1Statistics
{
};
static_assert(alignof(FM1PlayerDBNOTriggered) == 0x000008, "Wrong alignment on FM1PlayerDBNOTriggered");
static_assert(sizeof(FM1PlayerDBNOTriggered) == 0x000020, "Wrong size on FM1PlayerDBNOTriggered");

// ScriptStruct M1.M1PlayerJumped
// 0x0008 (0x0028 - 0x0020)
struct FM1PlayerJumped final : public FM1Statistics
{
public:
	bool                                          bDoubleJump;                                       // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PlayerJumped) == 0x000008, "Wrong alignment on FM1PlayerJumped");
static_assert(sizeof(FM1PlayerJumped) == 0x000028, "Wrong size on FM1PlayerJumped");
static_assert(offsetof(FM1PlayerJumped, bDoubleJump) == 0x000020, "Member 'FM1PlayerJumped::bDoubleJump' has a wrong offset!");

// ScriptStruct M1.M1PlayerFiredWire
// 0x0008 (0x0028 - 0x0020)
struct FM1PlayerFiredWire final : public FM1Statistics
{
public:
	bool                                          bHooked;                                           // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Distance;                                          // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PlayerFiredWire) == 0x000008, "Wrong alignment on FM1PlayerFiredWire");
static_assert(sizeof(FM1PlayerFiredWire) == 0x000028, "Wrong size on FM1PlayerFiredWire");
static_assert(offsetof(FM1PlayerFiredWire, bHooked) == 0x000020, "Member 'FM1PlayerFiredWire::bHooked' has a wrong offset!");
static_assert(offsetof(FM1PlayerFiredWire, Distance) == 0x000024, "Member 'FM1PlayerFiredWire::Distance' has a wrong offset!");

// ScriptStruct M1.M1WeaponZoomHidePlayerSetting
// 0x000C (0x000C - 0x0000)
struct FM1WeaponZoomHidePlayerSetting final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HideToCameraFOVTransitionRate;                     // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShowToCameraFOVTransitionRate;                     // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponZoomHidePlayerSetting) == 0x000004, "Wrong alignment on FM1WeaponZoomHidePlayerSetting");
static_assert(sizeof(FM1WeaponZoomHidePlayerSetting) == 0x00000C, "Wrong size on FM1WeaponZoomHidePlayerSetting");
static_assert(offsetof(FM1WeaponZoomHidePlayerSetting, bEnable) == 0x000000, "Member 'FM1WeaponZoomHidePlayerSetting::bEnable' has a wrong offset!");
static_assert(offsetof(FM1WeaponZoomHidePlayerSetting, HideToCameraFOVTransitionRate) == 0x000004, "Member 'FM1WeaponZoomHidePlayerSetting::HideToCameraFOVTransitionRate' has a wrong offset!");
static_assert(offsetof(FM1WeaponZoomHidePlayerSetting, ShowToCameraFOVTransitionRate) == 0x000008, "Member 'FM1WeaponZoomHidePlayerSetting::ShowToCameraFOVTransitionRate' has a wrong offset!");

// ScriptStruct M1.M1SelectedCharacterID
// 0x0018 (0x0038 - 0x0020)
struct FM1SelectedCharacterID final : public FM1Statistics
{
public:
	class FString                                 UserName;                                          // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         CharacterId;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SelectedCharacterID) == 0x000008, "Wrong alignment on FM1SelectedCharacterID");
static_assert(sizeof(FM1SelectedCharacterID) == 0x000038, "Wrong size on FM1SelectedCharacterID");
static_assert(offsetof(FM1SelectedCharacterID, UserName) == 0x000020, "Member 'FM1SelectedCharacterID::UserName' has a wrong offset!");
static_assert(offsetof(FM1SelectedCharacterID, CharacterId) == 0x000030, "Member 'FM1SelectedCharacterID::CharacterId' has a wrong offset!");

// ScriptStruct M1.M1EpicPartsDestroy
// 0x0020 (0x0040 - 0x0020)
struct FM1EpicPartsDestroy : public FM1Statistics
{
public:
	class FString                                 PartsId;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 State;                                             // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EpicPartsDestroy) == 0x000008, "Wrong alignment on FM1EpicPartsDestroy");
static_assert(sizeof(FM1EpicPartsDestroy) == 0x000040, "Wrong size on FM1EpicPartsDestroy");
static_assert(offsetof(FM1EpicPartsDestroy, PartsId) == 0x000020, "Member 'FM1EpicPartsDestroy::PartsId' has a wrong offset!");
static_assert(offsetof(FM1EpicPartsDestroy, State) == 0x000030, "Member 'FM1EpicPartsDestroy::State' has a wrong offset!");

// ScriptStruct M1.M1EpicDeboneSuccess
// 0x0010 (0x0050 - 0x0040)
struct FM1EpicDeboneSuccess final : public FM1EpicPartsDestroy
{
public:
	class FString                                 Cause;                                             // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EpicDeboneSuccess) == 0x000008, "Wrong alignment on FM1EpicDeboneSuccess");
static_assert(sizeof(FM1EpicDeboneSuccess) == 0x000050, "Wrong size on FM1EpicDeboneSuccess");
static_assert(offsetof(FM1EpicDeboneSuccess, Cause) == 0x000040, "Member 'FM1EpicDeboneSuccess::Cause' has a wrong offset!");

// ScriptStruct M1.M1ClientStatModifiers
// 0x0020 (0x0020 - 0x0000)
struct FM1ClientStatModifiers final
{
public:
	EM1StatType                                   StatType;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ScaledInteger                       BaseValue;                                         // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1StatTypeOpValue>             Modifiers;                                         // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ClientStatModifiers) == 0x000008, "Wrong alignment on FM1ClientStatModifiers");
static_assert(sizeof(FM1ClientStatModifiers) == 0x000020, "Wrong size on FM1ClientStatModifiers");
static_assert(offsetof(FM1ClientStatModifiers, StatType) == 0x000000, "Member 'FM1ClientStatModifiers::StatType' has a wrong offset!");
static_assert(offsetof(FM1ClientStatModifiers, BaseValue) == 0x000008, "Member 'FM1ClientStatModifiers::BaseValue' has a wrong offset!");
static_assert(offsetof(FM1ClientStatModifiers, Modifiers) == 0x000010, "Member 'FM1ClientStatModifiers::Modifiers' has a wrong offset!");

// ScriptStruct M1.M1TeleportInfo
// 0x0030 (0x0030 - 0x0000)
struct FM1TeleportInfo final
{
public:
	EM1TeleportState                              State;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bTeleportAtSequence;                               // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Context;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TeleportInfo) == 0x000008, "Wrong alignment on FM1TeleportInfo");
static_assert(sizeof(FM1TeleportInfo) == 0x000030, "Wrong size on FM1TeleportInfo");
static_assert(offsetof(FM1TeleportInfo, State) == 0x000000, "Member 'FM1TeleportInfo::State' has a wrong offset!");
static_assert(offsetof(FM1TeleportInfo, Location) == 0x000004, "Member 'FM1TeleportInfo::Location' has a wrong offset!");
static_assert(offsetof(FM1TeleportInfo, Rotation) == 0x000010, "Member 'FM1TeleportInfo::Rotation' has a wrong offset!");
static_assert(offsetof(FM1TeleportInfo, bTeleportAtSequence) == 0x00001C, "Member 'FM1TeleportInfo::bTeleportAtSequence' has a wrong offset!");
static_assert(offsetof(FM1TeleportInfo, Context) == 0x000020, "Member 'FM1TeleportInfo::Context' has a wrong offset!");

// ScriptStruct M1.M1RequestedTeleportInfo
// 0x0030 (0x0030 - 0x0000)
struct FM1RequestedTeleportInfo final
{
public:
	bool                                          bMapEnter;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1TeleportExecuteType                        ExecuteType;                                       // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Context;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1RequestedTeleportInfo) == 0x000008, "Wrong alignment on FM1RequestedTeleportInfo");
static_assert(sizeof(FM1RequestedTeleportInfo) == 0x000030, "Wrong size on FM1RequestedTeleportInfo");
static_assert(offsetof(FM1RequestedTeleportInfo, bMapEnter) == 0x000000, "Member 'FM1RequestedTeleportInfo::bMapEnter' has a wrong offset!");
static_assert(offsetof(FM1RequestedTeleportInfo, ExecuteType) == 0x000001, "Member 'FM1RequestedTeleportInfo::ExecuteType' has a wrong offset!");
static_assert(offsetof(FM1RequestedTeleportInfo, Location) == 0x000004, "Member 'FM1RequestedTeleportInfo::Location' has a wrong offset!");
static_assert(offsetof(FM1RequestedTeleportInfo, Rotation) == 0x000010, "Member 'FM1RequestedTeleportInfo::Rotation' has a wrong offset!");
static_assert(offsetof(FM1RequestedTeleportInfo, Context) == 0x000020, "Member 'FM1RequestedTeleportInfo::Context' has a wrong offset!");

// ScriptStruct M1.M1UIStringKey
// 0x0018 (0x0018 - 0x0000)
struct FM1UIStringKey final
{
public:
	class FString                                 UIKey;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1UITextType                                 UIKeyType;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIStringKey) == 0x000008, "Wrong alignment on FM1UIStringKey");
static_assert(sizeof(FM1UIStringKey) == 0x000018, "Wrong size on FM1UIStringKey");
static_assert(offsetof(FM1UIStringKey, UIKey) == 0x000000, "Member 'FM1UIStringKey::UIKey' has a wrong offset!");
static_assert(offsetof(FM1UIStringKey, UIKeyType) == 0x000010, "Member 'FM1UIStringKey::UIKeyType' has a wrong offset!");

// ScriptStruct M1.M1TickableDelegateScriptContext
// 0x0010 (0x0028 - 0x0018)
struct FM1TickableDelegateScriptContext final : public FM1TickableDelegateBaseContext
{
public:
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1TickableDelegateScriptContext) == 0x000008, "Wrong alignment on FM1TickableDelegateScriptContext");
static_assert(sizeof(FM1TickableDelegateScriptContext) == 0x000028, "Wrong size on FM1TickableDelegateScriptContext");

// ScriptStruct M1.M1TickableDelegateOuterActorTickFunction
// 0x0010 (0x0040 - 0x0030)
struct FM1TickableDelegateOuterActorTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1TickableDelegateOuterActorTickFunction) == 0x000008, "Wrong alignment on FM1TickableDelegateOuterActorTickFunction");
static_assert(sizeof(FM1TickableDelegateOuterActorTickFunction) == 0x000040, "Wrong size on FM1TickableDelegateOuterActorTickFunction");

// ScriptStruct M1.M1Timespan
// 0x0000 (0x0008 - 0x0008)
struct FM1Timespan final : public FTimespan
{
};
static_assert(alignof(FM1Timespan) == 0x000008, "Wrong alignment on FM1Timespan");
static_assert(sizeof(FM1Timespan) == 0x000008, "Wrong size on FM1Timespan");

// ScriptStruct M1.M1ToyServiceInfo
// 0x0030 (0x0030 - 0x0000)
struct FM1ToyServiceInfo final
{
public:
	class FString                                 PackageName;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServiceId;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServiceKey;                                        // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ToyServiceInfo) == 0x000008, "Wrong alignment on FM1ToyServiceInfo");
static_assert(sizeof(FM1ToyServiceInfo) == 0x000030, "Wrong size on FM1ToyServiceInfo");
static_assert(offsetof(FM1ToyServiceInfo, PackageName) == 0x000000, "Member 'FM1ToyServiceInfo::PackageName' has a wrong offset!");
static_assert(offsetof(FM1ToyServiceInfo, ServiceId) == 0x000010, "Member 'FM1ToyServiceInfo::ServiceId' has a wrong offset!");
static_assert(offsetof(FM1ToyServiceInfo, ServiceKey) == 0x000020, "Member 'FM1ToyServiceInfo::ServiceKey' has a wrong offset!");

// ScriptStruct M1.M1ToyFriend
// 0x0038 (0x0038 - 0x0000)
struct FM1ToyFriend final
{
public:
	EM1LoginPlatformTypes                         PlatformType;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         PlatformUserId;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Guid;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInGameOnline;                                    // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlatformOnline;                                  // 0x0031(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ToyFriend) == 0x000008, "Wrong alignment on FM1ToyFriend");
static_assert(sizeof(FM1ToyFriend) == 0x000038, "Wrong size on FM1ToyFriend");
static_assert(offsetof(FM1ToyFriend, PlatformType) == 0x000000, "Member 'FM1ToyFriend::PlatformType' has a wrong offset!");
static_assert(offsetof(FM1ToyFriend, PlatformUserId) == 0x000008, "Member 'FM1ToyFriend::PlatformUserId' has a wrong offset!");
static_assert(offsetof(FM1ToyFriend, Guid) == 0x000010, "Member 'FM1ToyFriend::Guid' has a wrong offset!");
static_assert(offsetof(FM1ToyFriend, DisplayName) == 0x000020, "Member 'FM1ToyFriend::DisplayName' has a wrong offset!");
static_assert(offsetof(FM1ToyFriend, IsInGameOnline) == 0x000030, "Member 'FM1ToyFriend::IsInGameOnline' has a wrong offset!");
static_assert(offsetof(FM1ToyFriend, IsPlatformOnline) == 0x000031, "Member 'FM1ToyFriend::IsPlatformOnline' has a wrong offset!");

// ScriptStruct M1.M1WidgetAudioData
// 0x0050 (0x0050 - 0x0000)
struct FM1WidgetAudioData final
{
public:
	TMap<EM1WidgetAudioType, class FName>         AudioNamesForEvent;                                // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FM1WidgetAudioData) == 0x000008, "Wrong alignment on FM1WidgetAudioData");
static_assert(sizeof(FM1WidgetAudioData) == 0x000050, "Wrong size on FM1WidgetAudioData");
static_assert(offsetof(FM1WidgetAudioData, AudioNamesForEvent) == 0x000000, "Member 'FM1WidgetAudioData::AudioNamesForEvent' has a wrong offset!");

// ScriptStruct M1.M1ToyProduct
// 0x0088 (0x0088 - 0x0000)
struct FM1ToyProduct final
{
public:
	class FString                                 PlatformProductId;                                 // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LocalizedTitle;                                    // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LocalizedDescription;                              // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LocalizedPrice;                                    // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         PriceAmountMicros;                                 // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PriceCurrencyCode;                                 // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LocalizedBasePrice;                                // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         BasePriceAmountMicros;                             // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BasePriceCurrencyCode;                             // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MultiQuantityEnabled;                              // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ToyProduct) == 0x000008, "Wrong alignment on FM1ToyProduct");
static_assert(sizeof(FM1ToyProduct) == 0x000088, "Wrong size on FM1ToyProduct");
static_assert(offsetof(FM1ToyProduct, PlatformProductId) == 0x000000, "Member 'FM1ToyProduct::PlatformProductId' has a wrong offset!");
static_assert(offsetof(FM1ToyProduct, LocalizedTitle) == 0x000010, "Member 'FM1ToyProduct::LocalizedTitle' has a wrong offset!");
static_assert(offsetof(FM1ToyProduct, LocalizedDescription) == 0x000020, "Member 'FM1ToyProduct::LocalizedDescription' has a wrong offset!");
static_assert(offsetof(FM1ToyProduct, LocalizedPrice) == 0x000030, "Member 'FM1ToyProduct::LocalizedPrice' has a wrong offset!");
static_assert(offsetof(FM1ToyProduct, PriceAmountMicros) == 0x000040, "Member 'FM1ToyProduct::PriceAmountMicros' has a wrong offset!");
static_assert(offsetof(FM1ToyProduct, PriceCurrencyCode) == 0x000048, "Member 'FM1ToyProduct::PriceCurrencyCode' has a wrong offset!");
static_assert(offsetof(FM1ToyProduct, LocalizedBasePrice) == 0x000058, "Member 'FM1ToyProduct::LocalizedBasePrice' has a wrong offset!");
static_assert(offsetof(FM1ToyProduct, BasePriceAmountMicros) == 0x000068, "Member 'FM1ToyProduct::BasePriceAmountMicros' has a wrong offset!");
static_assert(offsetof(FM1ToyProduct, BasePriceCurrencyCode) == 0x000070, "Member 'FM1ToyProduct::BasePriceCurrencyCode' has a wrong offset!");
static_assert(offsetof(FM1ToyProduct, MultiQuantityEnabled) == 0x000080, "Member 'FM1ToyProduct::MultiQuantityEnabled' has a wrong offset!");

// ScriptStruct M1.M1TrapServerMovement
// 0x0018 (0x0018 - 0x0000)
struct FM1TrapServerMovement final
{
public:
	class FName                                   MovementComponentName;                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Time;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Direction;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1TrapServerMovement) == 0x000008, "Wrong alignment on FM1TrapServerMovement");
static_assert(sizeof(FM1TrapServerMovement) == 0x000018, "Wrong size on FM1TrapServerMovement");
static_assert(offsetof(FM1TrapServerMovement, MovementComponentName) == 0x000000, "Member 'FM1TrapServerMovement::MovementComponentName' has a wrong offset!");
static_assert(offsetof(FM1TrapServerMovement, Time) == 0x000008, "Member 'FM1TrapServerMovement::Time' has a wrong offset!");
static_assert(offsetof(FM1TrapServerMovement, Direction) == 0x000010, "Member 'FM1TrapServerMovement::Direction' has a wrong offset!");

// ScriptStruct M1.M1TrapVFXOption
// 0x0070 (0x0070 - 0x0000)
struct FM1TrapVFXOption final
{
public:
	struct FM1FXSpawnParam                        VFXParam;                                          // 0x0000(0x0040)(Edit, NativeAccessSpecifierPublic)
	struct FTransform                             RelativeTransform;                                 // 0x0040(0x0030)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TrapVFXOption) == 0x000010, "Wrong alignment on FM1TrapVFXOption");
static_assert(sizeof(FM1TrapVFXOption) == 0x000070, "Wrong size on FM1TrapVFXOption");
static_assert(offsetof(FM1TrapVFXOption, VFXParam) == 0x000000, "Member 'FM1TrapVFXOption::VFXParam' has a wrong offset!");
static_assert(offsetof(FM1TrapVFXOption, RelativeTransform) == 0x000040, "Member 'FM1TrapVFXOption::RelativeTransform' has a wrong offset!");

// ScriptStruct M1.M1FieldTargetInfo
// 0x0030 (0x0030 - 0x0000)
struct FM1FieldTargetInfo final
{
public:
	class FString                                 TargetId;                                          // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetStringId;                                    // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1MapTargetType                              TargetType;                                        // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetSubType;                                     // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressValue;                                     // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEssential;                                        // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1FieldProgressTargetState                   ProgressState;                                     // 0x002D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1FieldTargetInfo) == 0x000008, "Wrong alignment on FM1FieldTargetInfo");
static_assert(sizeof(FM1FieldTargetInfo) == 0x000030, "Wrong size on FM1FieldTargetInfo");
static_assert(offsetof(FM1FieldTargetInfo, TargetId) == 0x000000, "Member 'FM1FieldTargetInfo::TargetId' has a wrong offset!");
static_assert(offsetof(FM1FieldTargetInfo, TargetStringId) == 0x000010, "Member 'FM1FieldTargetInfo::TargetStringId' has a wrong offset!");
static_assert(offsetof(FM1FieldTargetInfo, TargetType) == 0x000020, "Member 'FM1FieldTargetInfo::TargetType' has a wrong offset!");
static_assert(offsetof(FM1FieldTargetInfo, TargetSubType) == 0x000024, "Member 'FM1FieldTargetInfo::TargetSubType' has a wrong offset!");
static_assert(offsetof(FM1FieldTargetInfo, ProgressValue) == 0x000028, "Member 'FM1FieldTargetInfo::ProgressValue' has a wrong offset!");
static_assert(offsetof(FM1FieldTargetInfo, bEssential) == 0x00002C, "Member 'FM1FieldTargetInfo::bEssential' has a wrong offset!");
static_assert(offsetof(FM1FieldTargetInfo, ProgressState) == 0x00002D, "Member 'FM1FieldTargetInfo::ProgressState' has a wrong offset!");

// ScriptStruct M1.M1TrapAOEOption
// 0x0090 (0x0090 - 0x0000)
struct FM1TrapAOEOption final
{
public:
	TArray<class FName>                           AttachSockets;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bGenerateToPairMesh;                               // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SweepExtent;                                       // 0x0014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TrapVFXOption                       AOEVFXOption;                                      // 0x0020(0x0070)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TrapAOEOption) == 0x000010, "Wrong alignment on FM1TrapAOEOption");
static_assert(sizeof(FM1TrapAOEOption) == 0x000090, "Wrong size on FM1TrapAOEOption");
static_assert(offsetof(FM1TrapAOEOption, AttachSockets) == 0x000000, "Member 'FM1TrapAOEOption::AttachSockets' has a wrong offset!");
static_assert(offsetof(FM1TrapAOEOption, bGenerateToPairMesh) == 0x000010, "Member 'FM1TrapAOEOption::bGenerateToPairMesh' has a wrong offset!");
static_assert(offsetof(FM1TrapAOEOption, SweepExtent) == 0x000014, "Member 'FM1TrapAOEOption::SweepExtent' has a wrong offset!");
static_assert(offsetof(FM1TrapAOEOption, AOEVFXOption) == 0x000020, "Member 'FM1TrapAOEOption::AOEVFXOption' has a wrong offset!");

// ScriptStruct M1.M1TrapNonAOEVFXOption
// 0x0080 (0x0080 - 0x0000)
struct FM1TrapNonAOEVFXOption final
{
public:
	bool                                          bAttachParent;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Socket;                                            // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1TrapVFXOption                       VFX;                                               // 0x0010(0x0070)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TrapNonAOEVFXOption) == 0x000010, "Wrong alignment on FM1TrapNonAOEVFXOption");
static_assert(sizeof(FM1TrapNonAOEVFXOption) == 0x000080, "Wrong size on FM1TrapNonAOEVFXOption");
static_assert(offsetof(FM1TrapNonAOEVFXOption, bAttachParent) == 0x000000, "Member 'FM1TrapNonAOEVFXOption::bAttachParent' has a wrong offset!");
static_assert(offsetof(FM1TrapNonAOEVFXOption, Socket) == 0x000004, "Member 'FM1TrapNonAOEVFXOption::Socket' has a wrong offset!");
static_assert(offsetof(FM1TrapNonAOEVFXOption, VFX) == 0x000010, "Member 'FM1TrapNonAOEVFXOption::VFX' has a wrong offset!");

// ScriptStruct M1.M1TrapAbilityOption
// 0x0018 (0x0018 - 0x0000)
struct FM1TrapAbilityOption final
{
public:
	class FName                                   AbilityName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1AbilityParamData>            AbilityParams;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TrapAbilityOption) == 0x000008, "Wrong alignment on FM1TrapAbilityOption");
static_assert(sizeof(FM1TrapAbilityOption) == 0x000018, "Wrong size on FM1TrapAbilityOption");
static_assert(offsetof(FM1TrapAbilityOption, AbilityName) == 0x000000, "Member 'FM1TrapAbilityOption::AbilityName' has a wrong offset!");
static_assert(offsetof(FM1TrapAbilityOption, AbilityParams) == 0x000008, "Member 'FM1TrapAbilityOption::AbilityParams' has a wrong offset!");

// ScriptStruct M1.M1BoostNoticeInfo
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FM1BoostNoticeInfo final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1BoostNoticeInfo) == 0x000008, "Wrong alignment on FM1BoostNoticeInfo");
static_assert(sizeof(FM1BoostNoticeInfo) == 0x000050, "Wrong size on FM1BoostNoticeInfo");

// ScriptStruct M1.M1ShopPageInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1ShopPageInfo final
{
public:
	int32                                         SubItemIndex;                                      // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PageIndex;                                         // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UM1UIData*                              PageUIData;                                        // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ShopPageInfo) == 0x000008, "Wrong alignment on FM1ShopPageInfo");
static_assert(sizeof(FM1ShopPageInfo) == 0x000010, "Wrong size on FM1ShopPageInfo");
static_assert(offsetof(FM1ShopPageInfo, SubItemIndex) == 0x000000, "Member 'FM1ShopPageInfo::SubItemIndex' has a wrong offset!");
static_assert(offsetof(FM1ShopPageInfo, PageIndex) == 0x000004, "Member 'FM1ShopPageInfo::PageIndex' has a wrong offset!");
static_assert(offsetof(FM1ShopPageInfo, PageUIData) == 0x000008, "Member 'FM1ShopPageInfo::PageUIData' has a wrong offset!");

// ScriptStruct M1.M1PlayerStatGraph
// 0x0010 (0x0018 - 0x0008)
struct FM1PlayerStatGraph final : public FTableRowBase
{
public:
	EM1StatType                                   StatType;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinValue;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PlayerStatGraph) == 0x000008, "Wrong alignment on FM1PlayerStatGraph");
static_assert(sizeof(FM1PlayerStatGraph) == 0x000018, "Wrong size on FM1PlayerStatGraph");
static_assert(offsetof(FM1PlayerStatGraph, StatType) == 0x000008, "Member 'FM1PlayerStatGraph::StatType' has a wrong offset!");
static_assert(offsetof(FM1PlayerStatGraph, MinValue) == 0x00000C, "Member 'FM1PlayerStatGraph::MinValue' has a wrong offset!");
static_assert(offsetof(FM1PlayerStatGraph, MaxValue) == 0x000010, "Member 'FM1PlayerStatGraph::MaxValue' has a wrong offset!");

// ScriptStruct M1.UIDataInitParamTest
// 0x0008 (0x0018 - 0x0010)
struct FUIDataInitParamTest final : public FUIDataInitParam
{
public:
	class UM1TestGameObject*                      TestObject;                                        // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIDataInitParamTest) == 0x000008, "Wrong alignment on FUIDataInitParamTest");
static_assert(sizeof(FUIDataInitParamTest) == 0x000018, "Wrong size on FUIDataInitParamTest");
static_assert(offsetof(FUIDataInitParamTest, TestObject) == 0x000010, "Member 'FUIDataInitParamTest::TestObject' has a wrong offset!");

// ScriptStruct M1.M1ContextButtonSet
// 0x0018 (0x0018 - 0x0000)
struct FM1ContextButtonSet final
{
public:
	EM1SystemKey                                  Key;                                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UIKey;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ContextButtonSet) == 0x000008, "Wrong alignment on FM1ContextButtonSet");
static_assert(sizeof(FM1ContextButtonSet) == 0x000018, "Wrong size on FM1ContextButtonSet");
static_assert(offsetof(FM1ContextButtonSet, Key) == 0x000000, "Member 'FM1ContextButtonSet::Key' has a wrong offset!");
static_assert(offsetof(FM1ContextButtonSet, UIKey) == 0x000008, "Member 'FM1ContextButtonSet::UIKey' has a wrong offset!");

// ScriptStruct M1.M1CurrencyInternalPair
// 0x0010 (0x0010 - 0x0000)
struct FM1CurrencyInternalPair final
{
public:
	int64                                         FreeAmount;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         PaidAmount;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CurrencyInternalPair) == 0x000008, "Wrong alignment on FM1CurrencyInternalPair");
static_assert(sizeof(FM1CurrencyInternalPair) == 0x000010, "Wrong size on FM1CurrencyInternalPair");
static_assert(offsetof(FM1CurrencyInternalPair, FreeAmount) == 0x000000, "Member 'FM1CurrencyInternalPair::FreeAmount' has a wrong offset!");
static_assert(offsetof(FM1CurrencyInternalPair, PaidAmount) == 0x000008, "Member 'FM1CurrencyInternalPair::PaidAmount' has a wrong offset!");

// ScriptStruct M1.M1CustomizePageInfo
// 0x0010 (0x0010 - 0x0000)
struct FM1CustomizePageInfo final
{
public:
	EM1CustomizePageType                          PageType;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UM1UIData*                              UIData;                                            // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CustomizePageInfo) == 0x000008, "Wrong alignment on FM1CustomizePageInfo");
static_assert(sizeof(FM1CustomizePageInfo) == 0x000010, "Wrong size on FM1CustomizePageInfo");
static_assert(offsetof(FM1CustomizePageInfo, PageType) == 0x000000, "Member 'FM1CustomizePageInfo::PageType' has a wrong offset!");
static_assert(offsetof(FM1CustomizePageInfo, UIData) == 0x000008, "Member 'FM1CustomizePageInfo::UIData' has a wrong offset!");

// ScriptStruct M1.M1CustomizePartsLineInfo
// 0x0038 (0x0038 - 0x0000)
struct FM1CustomizePartsLineInfo final
{
public:
	class FName                                   LineStartBoneName;                                 // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Point_Start_0;                                     // 0x0008(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Point_Start_1;                                     // 0x0010(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Point_End;                                         // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Point_End_Offset;                                  // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CustomizePartsLineInfo) == 0x000008, "Wrong alignment on FM1CustomizePartsLineInfo");
static_assert(sizeof(FM1CustomizePartsLineInfo) == 0x000038, "Wrong size on FM1CustomizePartsLineInfo");
static_assert(offsetof(FM1CustomizePartsLineInfo, LineStartBoneName) == 0x000000, "Member 'FM1CustomizePartsLineInfo::LineStartBoneName' has a wrong offset!");
static_assert(offsetof(FM1CustomizePartsLineInfo, Point_Start_0) == 0x000008, "Member 'FM1CustomizePartsLineInfo::Point_Start_0' has a wrong offset!");
static_assert(offsetof(FM1CustomizePartsLineInfo, Point_Start_1) == 0x000010, "Member 'FM1CustomizePartsLineInfo::Point_Start_1' has a wrong offset!");
static_assert(offsetof(FM1CustomizePartsLineInfo, Point_End) == 0x000018, "Member 'FM1CustomizePartsLineInfo::Point_End' has a wrong offset!");
static_assert(offsetof(FM1CustomizePartsLineInfo, Point_End_Offset) == 0x000020, "Member 'FM1CustomizePartsLineInfo::Point_End_Offset' has a wrong offset!");

// ScriptStruct M1.M1FocusInformation
// 0x000C (0x000C - 0x0000)
struct FM1FocusInformation final
{
public:
	bool                                          bFocusReceived;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFocusEvent                            FocusEvent;                                        // 0x0004(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1FocusInformation) == 0x000004, "Wrong alignment on FM1FocusInformation");
static_assert(sizeof(FM1FocusInformation) == 0x00000C, "Wrong size on FM1FocusInformation");
static_assert(offsetof(FM1FocusInformation, bFocusReceived) == 0x000000, "Member 'FM1FocusInformation::bFocusReceived' has a wrong offset!");
static_assert(offsetof(FM1FocusInformation, FocusEvent) == 0x000004, "Member 'FM1FocusInformation::FocusEvent' has a wrong offset!");

// ScriptStruct M1.M1UIDamagedEffectInfo
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FM1UIDamagedEffectInfo final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIDamagedEffectInfo) == 0x000004, "Wrong alignment on FM1UIDamagedEffectInfo");
static_assert(sizeof(FM1UIDamagedEffectInfo) == 0x00000C, "Wrong size on FM1UIDamagedEffectInfo");

// ScriptStruct M1.UIDataInitParamNumeric
// 0x0008 (0x0018 - 0x0010)
struct FUIDataInitParamNumeric final : public FUIDataInitParam
{
public:
	int32                                         Value;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIDataInitParamNumeric) == 0x000008, "Wrong alignment on FUIDataInitParamNumeric");
static_assert(sizeof(FUIDataInitParamNumeric) == 0x000018, "Wrong size on FUIDataInitParamNumeric");
static_assert(offsetof(FUIDataInitParamNumeric, Value) == 0x000010, "Member 'FUIDataInitParamNumeric::Value' has a wrong offset!");

// ScriptStruct M1.M1SimpleAccountInfo
// 0x0070 (0x0070 - 0x0000)
struct FM1SimpleAccountInfo final
{
public:
	class FString                                 AccountName;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          CharacterTid;                                      // 0x0010(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterLevel;                                    // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MasteryRank;                                       // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         PartyUID;                                          // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1TemplateId                          MapTemplateId;                                     // 0x0028(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaxCharacterLevel;                                // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaxMasteryRank;                                   // 0x002D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1LoginPlatformTypes                         PlatformType;                                      // 0x002E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F[0x1];                                       // 0x002F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         PlatformUid;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlatformOnlineId;                                  // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInGameOnline;                                   // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlatformOnline;                                 // 0x0049(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreator;                                          // 0x004A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x5];                                       // 0x004B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Npsn;                                              // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   PlayerTitle;                                       // 0x0058(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1SimpleAccountInfo) == 0x000008, "Wrong alignment on FM1SimpleAccountInfo");
static_assert(sizeof(FM1SimpleAccountInfo) == 0x000070, "Wrong size on FM1SimpleAccountInfo");
static_assert(offsetof(FM1SimpleAccountInfo, AccountName) == 0x000000, "Member 'FM1SimpleAccountInfo::AccountName' has a wrong offset!");
static_assert(offsetof(FM1SimpleAccountInfo, CharacterTid) == 0x000010, "Member 'FM1SimpleAccountInfo::CharacterTid' has a wrong offset!");
static_assert(offsetof(FM1SimpleAccountInfo, CharacterLevel) == 0x000014, "Member 'FM1SimpleAccountInfo::CharacterLevel' has a wrong offset!");
static_assert(offsetof(FM1SimpleAccountInfo, MasteryRank) == 0x000018, "Member 'FM1SimpleAccountInfo::MasteryRank' has a wrong offset!");
static_assert(offsetof(FM1SimpleAccountInfo, PartyUID) == 0x000020, "Member 'FM1SimpleAccountInfo::PartyUID' has a wrong offset!");
static_assert(offsetof(FM1SimpleAccountInfo, MapTemplateId) == 0x000028, "Member 'FM1SimpleAccountInfo::MapTemplateId' has a wrong offset!");
static_assert(offsetof(FM1SimpleAccountInfo, bMaxCharacterLevel) == 0x00002C, "Member 'FM1SimpleAccountInfo::bMaxCharacterLevel' has a wrong offset!");
static_assert(offsetof(FM1SimpleAccountInfo, bMaxMasteryRank) == 0x00002D, "Member 'FM1SimpleAccountInfo::bMaxMasteryRank' has a wrong offset!");
static_assert(offsetof(FM1SimpleAccountInfo, PlatformType) == 0x00002E, "Member 'FM1SimpleAccountInfo::PlatformType' has a wrong offset!");
static_assert(offsetof(FM1SimpleAccountInfo, PlatformUid) == 0x000030, "Member 'FM1SimpleAccountInfo::PlatformUid' has a wrong offset!");
static_assert(offsetof(FM1SimpleAccountInfo, PlatformOnlineId) == 0x000038, "Member 'FM1SimpleAccountInfo::PlatformOnlineId' has a wrong offset!");
static_assert(offsetof(FM1SimpleAccountInfo, bIsInGameOnline) == 0x000048, "Member 'FM1SimpleAccountInfo::bIsInGameOnline' has a wrong offset!");
static_assert(offsetof(FM1SimpleAccountInfo, bIsPlatformOnline) == 0x000049, "Member 'FM1SimpleAccountInfo::bIsPlatformOnline' has a wrong offset!");
static_assert(offsetof(FM1SimpleAccountInfo, bCreator) == 0x00004A, "Member 'FM1SimpleAccountInfo::bCreator' has a wrong offset!");
static_assert(offsetof(FM1SimpleAccountInfo, Npsn) == 0x000050, "Member 'FM1SimpleAccountInfo::Npsn' has a wrong offset!");
static_assert(offsetof(FM1SimpleAccountInfo, PlayerTitle) == 0x000058, "Member 'FM1SimpleAccountInfo::PlayerTitle' has a wrong offset!");

// ScriptStruct M1.M1VariantAbilityParamData
// 0x0028 (0x0028 - 0x0000)
struct FM1VariantAbilityParamData final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1AbilityParamType                           Type;                                              // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1VariantData                         Value;                                             // 0x0010(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1VariantAbilityParamData) == 0x000008, "Wrong alignment on FM1VariantAbilityParamData");
static_assert(sizeof(FM1VariantAbilityParamData) == 0x000028, "Wrong size on FM1VariantAbilityParamData");
static_assert(offsetof(FM1VariantAbilityParamData, Name) == 0x000000, "Member 'FM1VariantAbilityParamData::Name' has a wrong offset!");
static_assert(offsetof(FM1VariantAbilityParamData, Type) == 0x000008, "Member 'FM1VariantAbilityParamData::Type' has a wrong offset!");
static_assert(offsetof(FM1VariantAbilityParamData, Value) == 0x000010, "Member 'FM1VariantAbilityParamData::Value' has a wrong offset!");

// ScriptStruct M1.M1ElementalFloaterSetting
// 0x0008 (0x0008 - 0x0000)
struct FM1ElementalFloaterSetting final
{
public:
	float                                         MinRadius;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRadius;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ElementalFloaterSetting) == 0x000004, "Wrong alignment on FM1ElementalFloaterSetting");
static_assert(sizeof(FM1ElementalFloaterSetting) == 0x000008, "Wrong size on FM1ElementalFloaterSetting");
static_assert(offsetof(FM1ElementalFloaterSetting, MinRadius) == 0x000000, "Member 'FM1ElementalFloaterSetting::MinRadius' has a wrong offset!");
static_assert(offsetof(FM1ElementalFloaterSetting, MaxRadius) == 0x000004, "Member 'FM1ElementalFloaterSetting::MaxRadius' has a wrong offset!");

// ScriptStruct M1.M1SkillTooltipCalcParam
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FM1SkillTooltipCalcParam final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SkillTooltipCalcParam) == 0x000004, "Wrong alignment on FM1SkillTooltipCalcParam");
static_assert(sizeof(FM1SkillTooltipCalcParam) == 0x000008, "Wrong size on FM1SkillTooltipCalcParam");

// ScriptStruct M1.M1MonsterKillInfoUI
// 0x0020 (0x0020 - 0x0000)
struct FM1MonsterKillInfoUI final
{
public:
	class FString                                 MonsterStringId;                                   // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AppearanceCount;                                   // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillCount;                                         // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetKillCount;                                   // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MonsterKillInfoUI) == 0x000008, "Wrong alignment on FM1MonsterKillInfoUI");
static_assert(sizeof(FM1MonsterKillInfoUI) == 0x000020, "Wrong size on FM1MonsterKillInfoUI");
static_assert(offsetof(FM1MonsterKillInfoUI, MonsterStringId) == 0x000000, "Member 'FM1MonsterKillInfoUI::MonsterStringId' has a wrong offset!");
static_assert(offsetof(FM1MonsterKillInfoUI, AppearanceCount) == 0x000010, "Member 'FM1MonsterKillInfoUI::AppearanceCount' has a wrong offset!");
static_assert(offsetof(FM1MonsterKillInfoUI, KillCount) == 0x000014, "Member 'FM1MonsterKillInfoUI::KillCount' has a wrong offset!");
static_assert(offsetof(FM1MonsterKillInfoUI, TargetKillCount) == 0x000018, "Member 'FM1MonsterKillInfoUI::TargetKillCount' has a wrong offset!");

// ScriptStruct M1.M1EnumStringRow
// 0x0008 (0x0010 - 0x0008)
struct FM1EnumStringRow final : public FTableRowBase
{
public:
	class FName                                   StringId;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1EnumStringRow) == 0x000008, "Wrong alignment on FM1EnumStringRow");
static_assert(sizeof(FM1EnumStringRow) == 0x000010, "Wrong size on FM1EnumStringRow");
static_assert(offsetof(FM1EnumStringRow, StringId) == 0x000008, "Member 'FM1EnumStringRow::StringId' has a wrong offset!");

// ScriptStruct M1.M1ItemProbabilityInfo
// 0x000C (0x000C - 0x0000)
struct FM1ItemProbabilityInfo final
{
public:
	int32                                         DefaultProbability;                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinProbability;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxProbability;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1ItemProbabilityInfo) == 0x000004, "Wrong alignment on FM1ItemProbabilityInfo");
static_assert(sizeof(FM1ItemProbabilityInfo) == 0x00000C, "Wrong size on FM1ItemProbabilityInfo");
static_assert(offsetof(FM1ItemProbabilityInfo, DefaultProbability) == 0x000000, "Member 'FM1ItemProbabilityInfo::DefaultProbability' has a wrong offset!");
static_assert(offsetof(FM1ItemProbabilityInfo, MinProbability) == 0x000004, "Member 'FM1ItemProbabilityInfo::MinProbability' has a wrong offset!");
static_assert(offsetof(FM1ItemProbabilityInfo, MaxProbability) == 0x000008, "Member 'FM1ItemProbabilityInfo::MaxProbability' has a wrong offset!");

// ScriptStruct M1.M1ItemStatForUI
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FM1ItemStatForUI final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ItemStatForUI) == 0x000008, "Wrong alignment on FM1ItemStatForUI");
static_assert(sizeof(FM1ItemStatForUI) == 0x000038, "Wrong size on FM1ItemStatForUI");

// ScriptStruct M1.M1CurrencyRewardWrapper
// 0x0010 (0x0010 - 0x0000)
struct FM1CurrencyRewardWrapper final
{
public:
	class UM1UIDataItemInfo*                      MinValue;                                          // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MaxValue;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CurrencyRewardWrapper) == 0x000008, "Wrong alignment on FM1CurrencyRewardWrapper");
static_assert(sizeof(FM1CurrencyRewardWrapper) == 0x000010, "Wrong size on FM1CurrencyRewardWrapper");
static_assert(offsetof(FM1CurrencyRewardWrapper, MinValue) == 0x000000, "Member 'FM1CurrencyRewardWrapper::MinValue' has a wrong offset!");
static_assert(offsetof(FM1CurrencyRewardWrapper, MaxValue) == 0x000008, "Member 'FM1CurrencyRewardWrapper::MaxValue' has a wrong offset!");

// ScriptStruct M1.M1MissionRewardItemWrapper
// 0x0050 (0x0050 - 0x0000)
struct FM1MissionRewardItemWrapper final
{
public:
	struct FM1ItemDef                             ItemDef;                                           // 0x0000(0x0048)(NativeAccessSpecifierPublic)
	int32                                         MinProbability;                                    // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxProbability;                                    // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionRewardItemWrapper) == 0x000008, "Wrong alignment on FM1MissionRewardItemWrapper");
static_assert(sizeof(FM1MissionRewardItemWrapper) == 0x000050, "Wrong size on FM1MissionRewardItemWrapper");
static_assert(offsetof(FM1MissionRewardItemWrapper, ItemDef) == 0x000000, "Member 'FM1MissionRewardItemWrapper::ItemDef' has a wrong offset!");
static_assert(offsetof(FM1MissionRewardItemWrapper, MinProbability) == 0x000048, "Member 'FM1MissionRewardItemWrapper::MinProbability' has a wrong offset!");
static_assert(offsetof(FM1MissionRewardItemWrapper, MaxProbability) == 0x00004C, "Member 'FM1MissionRewardItemWrapper::MaxProbability' has a wrong offset!");

// ScriptStruct M1.M1MissionRewardItemUIDataWrapper
// 0x0010 (0x0010 - 0x0000)
struct FM1MissionRewardItemUIDataWrapper final
{
public:
	TArray<class UM1UIDataItemInfo*>              UIDatas;                                           // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MissionRewardItemUIDataWrapper) == 0x000008, "Wrong alignment on FM1MissionRewardItemUIDataWrapper");
static_assert(sizeof(FM1MissionRewardItemUIDataWrapper) == 0x000010, "Wrong size on FM1MissionRewardItemUIDataWrapper");
static_assert(offsetof(FM1MissionRewardItemUIDataWrapper, UIDatas) == 0x000000, "Member 'FM1MissionRewardItemUIDataWrapper::UIDatas' has a wrong offset!");

// ScriptStruct M1.M1DestructionCountInfoUI
// 0x0018 (0x0018 - 0x0000)
struct FM1DestructionCountInfoUI final
{
public:
	class FString                                 DestructionTargetStringId;                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentDestructionCount;                           // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetDestructionCount;                            // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DestructionCountInfoUI) == 0x000008, "Wrong alignment on FM1DestructionCountInfoUI");
static_assert(sizeof(FM1DestructionCountInfoUI) == 0x000018, "Wrong size on FM1DestructionCountInfoUI");
static_assert(offsetof(FM1DestructionCountInfoUI, DestructionTargetStringId) == 0x000000, "Member 'FM1DestructionCountInfoUI::DestructionTargetStringId' has a wrong offset!");
static_assert(offsetof(FM1DestructionCountInfoUI, CurrentDestructionCount) == 0x000010, "Member 'FM1DestructionCountInfoUI::CurrentDestructionCount' has a wrong offset!");
static_assert(offsetof(FM1DestructionCountInfoUI, TargetDestructionCount) == 0x000014, "Member 'FM1DestructionCountInfoUI::TargetDestructionCount' has a wrong offset!");

// ScriptStruct M1.M1DestructionTargetInfoUI
// 0x0018 (0x0018 - 0x0000)
struct FM1DestructionTargetInfoUI final
{
public:
	class FString                                 DestructionTargetStringId;                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetHP;                                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1DestructionTargetInfoUI) == 0x000008, "Wrong alignment on FM1DestructionTargetInfoUI");
static_assert(sizeof(FM1DestructionTargetInfoUI) == 0x000018, "Wrong size on FM1DestructionTargetInfoUI");
static_assert(offsetof(FM1DestructionTargetInfoUI, DestructionTargetStringId) == 0x000000, "Member 'FM1DestructionTargetInfoUI::DestructionTargetStringId' has a wrong offset!");
static_assert(offsetof(FM1DestructionTargetInfoUI, TargetHP) == 0x000010, "Member 'FM1DestructionTargetInfoUI::TargetHP' has a wrong offset!");

// ScriptStruct M1.M1DefenseTargetInfoUI
// 0x0018 (0x0018 - 0x0000)
struct FM1DefenseTargetInfoUI final
{
public:
	class FString                                 MissionTargetStringId;                             // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentShieldRatio;                                // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentHPRatio;                                    // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1DefenseTargetInfoUI) == 0x000008, "Wrong alignment on FM1DefenseTargetInfoUI");
static_assert(sizeof(FM1DefenseTargetInfoUI) == 0x000018, "Wrong size on FM1DefenseTargetInfoUI");
static_assert(offsetof(FM1DefenseTargetInfoUI, MissionTargetStringId) == 0x000000, "Member 'FM1DefenseTargetInfoUI::MissionTargetStringId' has a wrong offset!");
static_assert(offsetof(FM1DefenseTargetInfoUI, CurrentShieldRatio) == 0x000010, "Member 'FM1DefenseTargetInfoUI::CurrentShieldRatio' has a wrong offset!");
static_assert(offsetof(FM1DefenseTargetInfoUI, CurrentHPRatio) == 0x000014, "Member 'FM1DefenseTargetInfoUI::CurrentHPRatio' has a wrong offset!");

// ScriptStruct M1.M1SupplyInfoUI
// 0x0010 (0x0010 - 0x0000)
struct FM1SupplyInfoUI final
{
public:
	int32                                         CurrentRate;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetRate;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AlertRate;                                         // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDecreaseSupply;                                   // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1SupplyInfoUI) == 0x000004, "Wrong alignment on FM1SupplyInfoUI");
static_assert(sizeof(FM1SupplyInfoUI) == 0x000010, "Wrong size on FM1SupplyInfoUI");
static_assert(offsetof(FM1SupplyInfoUI, CurrentRate) == 0x000000, "Member 'FM1SupplyInfoUI::CurrentRate' has a wrong offset!");
static_assert(offsetof(FM1SupplyInfoUI, TargetRate) == 0x000004, "Member 'FM1SupplyInfoUI::TargetRate' has a wrong offset!");
static_assert(offsetof(FM1SupplyInfoUI, AlertRate) == 0x000008, "Member 'FM1SupplyInfoUI::AlertRate' has a wrong offset!");
static_assert(offsetof(FM1SupplyInfoUI, bDecreaseSupply) == 0x00000C, "Member 'FM1SupplyInfoUI::bDecreaseSupply' has a wrong offset!");

// ScriptStruct M1.M1RuneDetailStatKey
// 0x0002 (0x0002 - 0x0000)
struct FM1RuneDetailStatKey final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1RuneDetailStatKey) == 0x000001, "Wrong alignment on FM1RuneDetailStatKey");
static_assert(sizeof(FM1RuneDetailStatKey) == 0x000002, "Wrong size on FM1RuneDetailStatKey");

// ScriptStruct M1.M1VoidBattleStartConditions
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FM1VoidBattleStartConditions final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1VoidBattleStartConditions) == 0x000008, "Wrong alignment on FM1VoidBattleStartConditions");
static_assert(sizeof(FM1VoidBattleStartConditions) == 0x000010, "Wrong size on FM1VoidBattleStartConditions");

// ScriptStruct M1.M1UIEvent_ChangedWeaponSpread
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FM1UIEvent_ChangedWeaponSpread final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_ChangedWeaponSpread) == 0x000004, "Wrong alignment on FM1UIEvent_ChangedWeaponSpread");
static_assert(sizeof(FM1UIEvent_ChangedWeaponSpread) == 0x000004, "Wrong size on FM1UIEvent_ChangedWeaponSpread");

// ScriptStruct M1.M1UIEvent_ChangedWeaponChargeGaugeDelta
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FM1UIEvent_ChangedWeaponChargeGaugeDelta final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_ChangedWeaponChargeGaugeDelta) == 0x000004, "Wrong alignment on FM1UIEvent_ChangedWeaponChargeGaugeDelta");
static_assert(sizeof(FM1UIEvent_ChangedWeaponChargeGaugeDelta) == 0x000008, "Wrong size on FM1UIEvent_ChangedWeaponChargeGaugeDelta");

// ScriptStruct M1.M1UIEvent_ChangedWeaponChargeGaugeHold
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FM1UIEvent_ChangedWeaponChargeGaugeHold final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_ChangedWeaponChargeGaugeHold) == 0x000004, "Wrong alignment on FM1UIEvent_ChangedWeaponChargeGaugeHold");
static_assert(sizeof(FM1UIEvent_ChangedWeaponChargeGaugeHold) == 0x000008, "Wrong size on FM1UIEvent_ChangedWeaponChargeGaugeHold");

// ScriptStruct M1.M1UIEvent_AcquiredRounds
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FM1UIEvent_AcquiredRounds final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_AcquiredRounds) == 0x000004, "Wrong alignment on FM1UIEvent_AcquiredRounds");
static_assert(sizeof(FM1UIEvent_AcquiredRounds) == 0x000018, "Wrong size on FM1UIEvent_AcquiredRounds");

// ScriptStruct M1.M1UIEvent_RepReactorEquipped
// 0x0001 (0x0001 - 0x0000)
struct FM1UIEvent_RepReactorEquipped final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_RepReactorEquipped) == 0x000001, "Wrong alignment on FM1UIEvent_RepReactorEquipped");
static_assert(sizeof(FM1UIEvent_RepReactorEquipped) == 0x000001, "Wrong size on FM1UIEvent_RepReactorEquipped");

// ScriptStruct M1.M1UIEvent_FadeEffect
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FM1UIEvent_FadeEffect final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_FadeEffect) == 0x000004, "Wrong alignment on FM1UIEvent_FadeEffect");
static_assert(sizeof(FM1UIEvent_FadeEffect) == 0x00000C, "Wrong size on FM1UIEvent_FadeEffect");

// ScriptStruct M1.M1UIEvent_WeaponPerkEquipped
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FM1UIEvent_WeaponPerkEquipped final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_WeaponPerkEquipped) == 0x000004, "Wrong alignment on FM1UIEvent_WeaponPerkEquipped");
static_assert(sizeof(FM1UIEvent_WeaponPerkEquipped) == 0x00000C, "Wrong size on FM1UIEvent_WeaponPerkEquipped");

// ScriptStruct M1.M1UIEvent_WeaponPerkActivated
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FM1UIEvent_WeaponPerkActivated final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_WeaponPerkActivated) == 0x000004, "Wrong alignment on FM1UIEvent_WeaponPerkActivated");
static_assert(sizeof(FM1UIEvent_WeaponPerkActivated) == 0x000014, "Wrong size on FM1UIEvent_WeaponPerkActivated");

// ScriptStruct M1.M1UIEvent_CheckEnchantRuneReceived
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FM1UIEvent_CheckEnchantRuneReceived final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UIEvent_CheckEnchantRuneReceived) == 0x000008, "Wrong alignment on FM1UIEvent_CheckEnchantRuneReceived");
static_assert(sizeof(FM1UIEvent_CheckEnchantRuneReceived) == 0x000010, "Wrong size on FM1UIEvent_CheckEnchantRuneReceived");

// ScriptStruct M1.M1PlayerMaxEnergyShieldRatio
// 0x0018 (0x0020 - 0x0008)
struct FM1PlayerMaxEnergyShieldRatio final : public FTableRowBase
{
public:
	int32                                         NumOfSections;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FM1ScaledInteger                       MinValue;                                          // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1ScaledInteger                       MaxValue;                                          // 0x0018(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1PlayerMaxEnergyShieldRatio) == 0x000008, "Wrong alignment on FM1PlayerMaxEnergyShieldRatio");
static_assert(sizeof(FM1PlayerMaxEnergyShieldRatio) == 0x000020, "Wrong size on FM1PlayerMaxEnergyShieldRatio");
static_assert(offsetof(FM1PlayerMaxEnergyShieldRatio, NumOfSections) == 0x000008, "Member 'FM1PlayerMaxEnergyShieldRatio::NumOfSections' has a wrong offset!");
static_assert(offsetof(FM1PlayerMaxEnergyShieldRatio, MinValue) == 0x000010, "Member 'FM1PlayerMaxEnergyShieldRatio::MinValue' has a wrong offset!");
static_assert(offsetof(FM1PlayerMaxEnergyShieldRatio, MaxValue) == 0x000018, "Member 'FM1PlayerMaxEnergyShieldRatio::MaxValue' has a wrong offset!");

// ScriptStruct M1.M1ContentOpenInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1ContentOpenInfo final
{
public:
	int32                                         ContentTabIndex;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ContentSubTabType;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ContentSubTabIndex;                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UM1UIData*                              UIData;                                            // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offset;                                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ContentOpenInfo) == 0x000008, "Wrong alignment on FM1ContentOpenInfo");
static_assert(sizeof(FM1ContentOpenInfo) == 0x000020, "Wrong size on FM1ContentOpenInfo");
static_assert(offsetof(FM1ContentOpenInfo, ContentTabIndex) == 0x000000, "Member 'FM1ContentOpenInfo::ContentTabIndex' has a wrong offset!");
static_assert(offsetof(FM1ContentOpenInfo, ContentSubTabType) == 0x000004, "Member 'FM1ContentOpenInfo::ContentSubTabType' has a wrong offset!");
static_assert(offsetof(FM1ContentOpenInfo, ContentSubTabIndex) == 0x000008, "Member 'FM1ContentOpenInfo::ContentSubTabIndex' has a wrong offset!");
static_assert(offsetof(FM1ContentOpenInfo, UIData) == 0x000010, "Member 'FM1ContentOpenInfo::UIData' has a wrong offset!");
static_assert(offsetof(FM1ContentOpenInfo, Offset) == 0x000018, "Member 'FM1ContentOpenInfo::Offset' has a wrong offset!");

// ScriptStruct M1.M1LevelUpInfo
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FM1LevelUpInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1LevelUpInfo) == 0x000004, "Wrong alignment on FM1LevelUpInfo");
static_assert(sizeof(FM1LevelUpInfo) == 0x000008, "Wrong size on FM1LevelUpInfo");

// ScriptStruct M1.M1InventoryPageInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1InventoryPageInfo final
{
public:
	EM1InventoryTab                               PageType;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UM1UIData*                              UIData;                                            // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScrollOffset;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TabIndex;                                          // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InventoryPageInfo) == 0x000008, "Wrong alignment on FM1InventoryPageInfo");
static_assert(sizeof(FM1InventoryPageInfo) == 0x000018, "Wrong size on FM1InventoryPageInfo");
static_assert(offsetof(FM1InventoryPageInfo, PageType) == 0x000000, "Member 'FM1InventoryPageInfo::PageType' has a wrong offset!");
static_assert(offsetof(FM1InventoryPageInfo, UIData) == 0x000008, "Member 'FM1InventoryPageInfo::UIData' has a wrong offset!");
static_assert(offsetof(FM1InventoryPageInfo, ScrollOffset) == 0x000010, "Member 'FM1InventoryPageInfo::ScrollOffset' has a wrong offset!");
static_assert(offsetof(FM1InventoryPageInfo, TabIndex) == 0x000014, "Member 'FM1InventoryPageInfo::TabIndex' has a wrong offset!");

// ScriptStruct M1.M1BattleZoneRelatedData
// 0x0028 (0x0028 - 0x0000)
struct FM1BattleZoneRelatedData final
{
public:
	struct FM1TemplateId                          BattleZoneId;                                      // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UM1UIWidget*>                    MissionWidgets;                                    // 0x0008(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UM1UIWidget*>                    CampWidgets;                                       // 0x0018(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1BattleZoneRelatedData) == 0x000008, "Wrong alignment on FM1BattleZoneRelatedData");
static_assert(sizeof(FM1BattleZoneRelatedData) == 0x000028, "Wrong size on FM1BattleZoneRelatedData");
static_assert(offsetof(FM1BattleZoneRelatedData, BattleZoneId) == 0x000000, "Member 'FM1BattleZoneRelatedData::BattleZoneId' has a wrong offset!");
static_assert(offsetof(FM1BattleZoneRelatedData, MissionWidgets) == 0x000008, "Member 'FM1BattleZoneRelatedData::MissionWidgets' has a wrong offset!");
static_assert(offsetof(FM1BattleZoneRelatedData, CampWidgets) == 0x000018, "Member 'FM1BattleZoneRelatedData::CampWidgets' has a wrong offset!");

// ScriptStruct M1.M1LiveMapEntity
// 0x0018 (0x0018 - 0x0000)
struct FM1LiveMapEntity final
{
public:
	class UM1UIWidget*                            IconWidget;                                        // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  LiveActor;                                         // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncRotation;                                     // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1LiveMapEntity) == 0x000008, "Wrong alignment on FM1LiveMapEntity");
static_assert(sizeof(FM1LiveMapEntity) == 0x000018, "Wrong size on FM1LiveMapEntity");
static_assert(offsetof(FM1LiveMapEntity, IconWidget) == 0x000000, "Member 'FM1LiveMapEntity::IconWidget' has a wrong offset!");
static_assert(offsetof(FM1LiveMapEntity, LiveActor) == 0x000008, "Member 'FM1LiveMapEntity::LiveActor' has a wrong offset!");
static_assert(offsetof(FM1LiveMapEntity, bSyncRotation) == 0x000010, "Member 'FM1LiveMapEntity::bSyncRotation' has a wrong offset!");

// ScriptStruct M1.M1MiniGameTimingRingParams
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FM1MiniGameTimingRingParams final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1MiniGameTimingRingParams) == 0x000008, "Wrong alignment on FM1MiniGameTimingRingParams");
static_assert(sizeof(FM1MiniGameTimingRingParams) == 0x000050, "Wrong size on FM1MiniGameTimingRingParams");

// ScriptStruct M1.M1MultiConditionFilterCreateParam
// 0x0018 (0x0018 - 0x0000)
struct FM1MultiConditionFilterCreateParam final
{
public:
	EM1FilterOption                               FilterOption;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1MultiConditionDropDownInfo>  Infos;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MultiConditionFilterCreateParam) == 0x000008, "Wrong alignment on FM1MultiConditionFilterCreateParam");
static_assert(sizeof(FM1MultiConditionFilterCreateParam) == 0x000018, "Wrong size on FM1MultiConditionFilterCreateParam");
static_assert(offsetof(FM1MultiConditionFilterCreateParam, FilterOption) == 0x000000, "Member 'FM1MultiConditionFilterCreateParam::FilterOption' has a wrong offset!");
static_assert(offsetof(FM1MultiConditionFilterCreateParam, Infos) == 0x000008, "Member 'FM1MultiConditionFilterCreateParam::Infos' has a wrong offset!");

// ScriptStruct M1.M1MultiConditionCreateParam
// 0x0088 (0x0088 - 0x0000)
struct FM1MultiConditionCreateParam final
{
public:
	bool                                          bUseSorter;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFilter;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSearch;                                        // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowKeyBtnOnlyConsole;                            // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFilterToolTip;                                 // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EM1SaveSortAndFilterScope                     SaveScope;                                         // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1MultiConditionSorterCreateParam> SorterParams;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1MultiConditionFilterCreateParam> FilterParams;                                      // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EM1SearchKeywordType>                  KeywordTypes;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FM1MultiConditionDropDownInfo>  KeywordParams;                                     // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FM1OwningToolTipType                   FilterToolTipType;                                 // 0x0048(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FVector2D                              SorterWidgetSizeOverride;                          // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FilterWidgetSizeOverride;                          // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SearchWidgetSizeOverride;                          // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UM1UIMultiConditionDropDown_Filter> FilterClass;                                       // 0x0080(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1MultiConditionCreateParam) == 0x000008, "Wrong alignment on FM1MultiConditionCreateParam");
static_assert(sizeof(FM1MultiConditionCreateParam) == 0x000088, "Wrong size on FM1MultiConditionCreateParam");
static_assert(offsetof(FM1MultiConditionCreateParam, bUseSorter) == 0x000000, "Member 'FM1MultiConditionCreateParam::bUseSorter' has a wrong offset!");
static_assert(offsetof(FM1MultiConditionCreateParam, bUseFilter) == 0x000001, "Member 'FM1MultiConditionCreateParam::bUseFilter' has a wrong offset!");
static_assert(offsetof(FM1MultiConditionCreateParam, bUseSearch) == 0x000002, "Member 'FM1MultiConditionCreateParam::bUseSearch' has a wrong offset!");
static_assert(offsetof(FM1MultiConditionCreateParam, bShowKeyBtnOnlyConsole) == 0x000003, "Member 'FM1MultiConditionCreateParam::bShowKeyBtnOnlyConsole' has a wrong offset!");
static_assert(offsetof(FM1MultiConditionCreateParam, bUseFilterToolTip) == 0x000004, "Member 'FM1MultiConditionCreateParam::bUseFilterToolTip' has a wrong offset!");
static_assert(offsetof(FM1MultiConditionCreateParam, SaveScope) == 0x000005, "Member 'FM1MultiConditionCreateParam::SaveScope' has a wrong offset!");
static_assert(offsetof(FM1MultiConditionCreateParam, SorterParams) == 0x000008, "Member 'FM1MultiConditionCreateParam::SorterParams' has a wrong offset!");
static_assert(offsetof(FM1MultiConditionCreateParam, FilterParams) == 0x000018, "Member 'FM1MultiConditionCreateParam::FilterParams' has a wrong offset!");
static_assert(offsetof(FM1MultiConditionCreateParam, KeywordTypes) == 0x000028, "Member 'FM1MultiConditionCreateParam::KeywordTypes' has a wrong offset!");
static_assert(offsetof(FM1MultiConditionCreateParam, KeywordParams) == 0x000038, "Member 'FM1MultiConditionCreateParam::KeywordParams' has a wrong offset!");
static_assert(offsetof(FM1MultiConditionCreateParam, FilterToolTipType) == 0x000048, "Member 'FM1MultiConditionCreateParam::FilterToolTipType' has a wrong offset!");
static_assert(offsetof(FM1MultiConditionCreateParam, SorterWidgetSizeOverride) == 0x000068, "Member 'FM1MultiConditionCreateParam::SorterWidgetSizeOverride' has a wrong offset!");
static_assert(offsetof(FM1MultiConditionCreateParam, FilterWidgetSizeOverride) == 0x000070, "Member 'FM1MultiConditionCreateParam::FilterWidgetSizeOverride' has a wrong offset!");
static_assert(offsetof(FM1MultiConditionCreateParam, SearchWidgetSizeOverride) == 0x000078, "Member 'FM1MultiConditionCreateParam::SearchWidgetSizeOverride' has a wrong offset!");
static_assert(offsetof(FM1MultiConditionCreateParam, FilterClass) == 0x000080, "Member 'FM1MultiConditionCreateParam::FilterClass' has a wrong offset!");

// ScriptStruct M1.M1PopupData
// 0x0088 (0x0090 - 0x0008)
struct FM1PopupData final : public FTableRowBase
{
public:
	struct FSoftClassPath                         PopupBlueprintClass;                               // 0x0008(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         ContentBlueprintClass;                             // 0x0028(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Desc;                                              // 0x0058(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Buttons;                                           // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EM1SystemKey>                          SystemKeys;                                        // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ConfirmHoldingDuration;                            // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1PopupData) == 0x000008, "Wrong alignment on FM1PopupData");
static_assert(sizeof(FM1PopupData) == 0x000090, "Wrong size on FM1PopupData");
static_assert(offsetof(FM1PopupData, PopupBlueprintClass) == 0x000008, "Member 'FM1PopupData::PopupBlueprintClass' has a wrong offset!");
static_assert(offsetof(FM1PopupData, ContentBlueprintClass) == 0x000028, "Member 'FM1PopupData::ContentBlueprintClass' has a wrong offset!");
static_assert(offsetof(FM1PopupData, Title) == 0x000048, "Member 'FM1PopupData::Title' has a wrong offset!");
static_assert(offsetof(FM1PopupData, Desc) == 0x000058, "Member 'FM1PopupData::Desc' has a wrong offset!");
static_assert(offsetof(FM1PopupData, Buttons) == 0x000068, "Member 'FM1PopupData::Buttons' has a wrong offset!");
static_assert(offsetof(FM1PopupData, SystemKeys) == 0x000078, "Member 'FM1PopupData::SystemKeys' has a wrong offset!");
static_assert(offsetof(FM1PopupData, ConfirmHoldingDuration) == 0x000088, "Member 'FM1PopupData::ConfirmHoldingDuration' has a wrong offset!");

// ScriptStruct M1.M1ButtonToastSpecificData
// 0x0018 (0x0020 - 0x0008)
struct FM1ButtonToastSpecificData final : public FTableRowBase
{
public:
	class FString                                 ButtonStringKey;                                   // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ButtonToastSpecificData) == 0x000008, "Wrong alignment on FM1ButtonToastSpecificData");
static_assert(sizeof(FM1ButtonToastSpecificData) == 0x000020, "Wrong size on FM1ButtonToastSpecificData");
static_assert(offsetof(FM1ButtonToastSpecificData, ButtonStringKey) == 0x000008, "Member 'FM1ButtonToastSpecificData::ButtonStringKey' has a wrong offset!");
static_assert(offsetof(FM1ButtonToastSpecificData, Duration) == 0x000018, "Member 'FM1ButtonToastSpecificData::Duration' has a wrong offset!");

// ScriptStruct M1.M1UserReportData
// 0x0010 (0x0018 - 0x0008)
struct FM1UserReportData final : public FTableRowBase
{
public:
	EM1ReportReasonType                           ReportType;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringId;                                          // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1UserReportData) == 0x000008, "Wrong alignment on FM1UserReportData");
static_assert(sizeof(FM1UserReportData) == 0x000018, "Wrong size on FM1UserReportData");
static_assert(offsetof(FM1UserReportData, ReportType) == 0x000008, "Member 'FM1UserReportData::ReportType' has a wrong offset!");
static_assert(offsetof(FM1UserReportData, StringId) == 0x00000C, "Member 'FM1UserReportData::StringId' has a wrong offset!");

// ScriptStruct M1.M1KeyEventTargets
// 0x0010 (0x0010 - 0x0000)
struct FM1KeyEventTargets final
{
public:
	TArray<class UM1UIWidget*>                    Widgets;                                           // 0x0000(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1KeyEventTargets) == 0x000008, "Wrong alignment on FM1KeyEventTargets");
static_assert(sizeof(FM1KeyEventTargets) == 0x000010, "Wrong size on FM1KeyEventTargets");
static_assert(offsetof(FM1KeyEventTargets, Widgets) == 0x000000, "Member 'FM1KeyEventTargets::Widgets' has a wrong offset!");

// ScriptStruct M1.M1TaggedVariantAbilityParamData
// 0x0018 (0x0018 - 0x0000)
struct FM1TaggedVariantAbilityParamData final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FM1VariantAbilityParamData>     Params;                                            // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1TaggedVariantAbilityParamData) == 0x000008, "Wrong alignment on FM1TaggedVariantAbilityParamData");
static_assert(sizeof(FM1TaggedVariantAbilityParamData) == 0x000018, "Wrong size on FM1TaggedVariantAbilityParamData");
static_assert(offsetof(FM1TaggedVariantAbilityParamData, Tag) == 0x000000, "Member 'FM1TaggedVariantAbilityParamData::Tag' has a wrong offset!");
static_assert(offsetof(FM1TaggedVariantAbilityParamData, Params) == 0x000008, "Member 'FM1TaggedVariantAbilityParamData::Params' has a wrong offset!");

// ScriptStruct M1.M1VariantParamSet
// 0x0050 (0x0050 - 0x0000)
struct FM1VariantParamSet final
{
public:
	TMap<class FName, struct FM1VariantData>      NamedParams;                                       // 0x0000(0x0050)(RepSkip, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1VariantParamSet) == 0x000008, "Wrong alignment on FM1VariantParamSet");
static_assert(sizeof(FM1VariantParamSet) == 0x000050, "Wrong size on FM1VariantParamSet");
static_assert(offsetof(FM1VariantParamSet, NamedParams) == 0x000000, "Member 'FM1VariantParamSet::NamedParams' has a wrong offset!");

// ScriptStruct M1.M1WeaponAimTraceResult
// 0x0018 (0x0018 - 0x0000)
struct FM1WeaponAimTraceResult final
{
public:
	bool                                          bHit;                                              // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     HitResults;                                        // 0x0008(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponAimTraceResult) == 0x000008, "Wrong alignment on FM1WeaponAimTraceResult");
static_assert(sizeof(FM1WeaponAimTraceResult) == 0x000018, "Wrong size on FM1WeaponAimTraceResult");
static_assert(offsetof(FM1WeaponAimTraceResult, bHit) == 0x000000, "Member 'FM1WeaponAimTraceResult::bHit' has a wrong offset!");
static_assert(offsetof(FM1WeaponAimTraceResult, HitResults) == 0x000008, "Member 'FM1WeaponAimTraceResult::HitResults' has a wrong offset!");

// ScriptStruct M1.M1WeaponFireParams
// 0x0010 (0x0010 - 0x0000)
struct FM1WeaponFireParams final
{
public:
	float                                         Fireinterval;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FM1WeaponBurstFireParams               BurstFire;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FM1WeaponFireAnimParams                Anim;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponFireParams) == 0x000004, "Wrong alignment on FM1WeaponFireParams");
static_assert(sizeof(FM1WeaponFireParams) == 0x000010, "Wrong size on FM1WeaponFireParams");
static_assert(offsetof(FM1WeaponFireParams, Fireinterval) == 0x000000, "Member 'FM1WeaponFireParams::Fireinterval' has a wrong offset!");
static_assert(offsetof(FM1WeaponFireParams, BurstFire) == 0x000004, "Member 'FM1WeaponFireParams::BurstFire' has a wrong offset!");
static_assert(offsetof(FM1WeaponFireParams, Anim) == 0x000008, "Member 'FM1WeaponFireParams::Anim' has a wrong offset!");

// ScriptStruct M1.M1CharacterBasedWeaponAttachData
// 0x0058 (0x0058 - 0x0000)
struct FM1CharacterBasedWeaponAttachData final
{
public:
	class FName                                   TargetBone;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FTransform>          AttachTransforms;                                  // 0x0008(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1CharacterBasedWeaponAttachData) == 0x000008, "Wrong alignment on FM1CharacterBasedWeaponAttachData");
static_assert(sizeof(FM1CharacterBasedWeaponAttachData) == 0x000058, "Wrong size on FM1CharacterBasedWeaponAttachData");
static_assert(offsetof(FM1CharacterBasedWeaponAttachData, TargetBone) == 0x000000, "Member 'FM1CharacterBasedWeaponAttachData::TargetBone' has a wrong offset!");
static_assert(offsetof(FM1CharacterBasedWeaponAttachData, AttachTransforms) == 0x000008, "Member 'FM1CharacterBasedWeaponAttachData::AttachTransforms' has a wrong offset!");

// ScriptStruct M1.M1WeaponChangeAnimationSettings
// 0x00E0 (0x00E0 - 0x0000)
struct FM1WeaponChangeAnimationSettings final
{
public:
	TMap<EM1EquipItemClassType, struct FM1WeaponChangeAnimationSetting> WeaponSettings;                                    // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FM1WeaponChangeAnimationSetting        BareHandSettings;                                  // 0x0050(0x0040)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TMap<struct FM1TemplateId, struct FM1WeaponChangeAnimationSetting> AltWeaponSettings;                                 // 0x0090(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponChangeAnimationSettings) == 0x000008, "Wrong alignment on FM1WeaponChangeAnimationSettings");
static_assert(sizeof(FM1WeaponChangeAnimationSettings) == 0x0000E0, "Wrong size on FM1WeaponChangeAnimationSettings");
static_assert(offsetof(FM1WeaponChangeAnimationSettings, WeaponSettings) == 0x000000, "Member 'FM1WeaponChangeAnimationSettings::WeaponSettings' has a wrong offset!");
static_assert(offsetof(FM1WeaponChangeAnimationSettings, BareHandSettings) == 0x000050, "Member 'FM1WeaponChangeAnimationSettings::BareHandSettings' has a wrong offset!");
static_assert(offsetof(FM1WeaponChangeAnimationSettings, AltWeaponSettings) == 0x000090, "Member 'FM1WeaponChangeAnimationSettings::AltWeaponSettings' has a wrong offset!");

// ScriptStruct M1.M1WeaponRoundsInitialization
// 0x0008 (0x0008 - 0x0000)
struct FM1WeaponRoundsInitialization final
{
public:
	bool                                          bNeedToRoundsInitialization;                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentRounds;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponRoundsInitialization) == 0x000004, "Wrong alignment on FM1WeaponRoundsInitialization");
static_assert(sizeof(FM1WeaponRoundsInitialization) == 0x000008, "Wrong size on FM1WeaponRoundsInitialization");
static_assert(offsetof(FM1WeaponRoundsInitialization, bNeedToRoundsInitialization) == 0x000000, "Member 'FM1WeaponRoundsInitialization::bNeedToRoundsInitialization' has a wrong offset!");
static_assert(offsetof(FM1WeaponRoundsInitialization, CurrentRounds) == 0x000004, "Member 'FM1WeaponRoundsInitialization::CurrentRounds' has a wrong offset!");

// ScriptStruct M1.M1ChangingWeaponAnimData
// 0x0018 (0x0018 - 0x0000)
struct FM1ChangingWeaponAnimData final
{
public:
	class UAnimMontage*                           UnEquipMontage;                                    // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EquipMontage;                                      // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1ChangingWeaponAnimData) == 0x000008, "Wrong alignment on FM1ChangingWeaponAnimData");
static_assert(sizeof(FM1ChangingWeaponAnimData) == 0x000018, "Wrong size on FM1ChangingWeaponAnimData");
static_assert(offsetof(FM1ChangingWeaponAnimData, UnEquipMontage) == 0x000000, "Member 'FM1ChangingWeaponAnimData::UnEquipMontage' has a wrong offset!");
static_assert(offsetof(FM1ChangingWeaponAnimData, EquipMontage) == 0x000008, "Member 'FM1ChangingWeaponAnimData::EquipMontage' has a wrong offset!");

// ScriptStruct M1.M1InstantHitInfo
// 0x0018 (0x0018 - 0x0000)
struct FM1InstantHitInfo final
{
public:
	struct FVector_NetQuantize                    FireLoc;                                           // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              FireDir;                                           // 0x000C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1InstantHitInfo) == 0x000004, "Wrong alignment on FM1InstantHitInfo");
static_assert(sizeof(FM1InstantHitInfo) == 0x000018, "Wrong size on FM1InstantHitInfo");
static_assert(offsetof(FM1InstantHitInfo, FireLoc) == 0x000000, "Member 'FM1InstantHitInfo::FireLoc' has a wrong offset!");
static_assert(offsetof(FM1InstantHitInfo, FireDir) == 0x00000C, "Member 'FM1InstantHitInfo::FireDir' has a wrong offset!");

// ScriptStruct M1.M1InstantHitShellInfo
// 0x0020 (0x0020 - 0x0000)
struct FM1InstantHitShellInfo final
{
public:
	int32                                         ShellCount;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FM1InstantHitShellHitResults>   HitResultsPerShell;                                // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bShellsAllHitEnemies;                              // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShellsAllHitOneEnemy;                             // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1InstantHitShellInfo) == 0x000008, "Wrong alignment on FM1InstantHitShellInfo");
static_assert(sizeof(FM1InstantHitShellInfo) == 0x000020, "Wrong size on FM1InstantHitShellInfo");
static_assert(offsetof(FM1InstantHitShellInfo, ShellCount) == 0x000000, "Member 'FM1InstantHitShellInfo::ShellCount' has a wrong offset!");
static_assert(offsetof(FM1InstantHitShellInfo, HitResultsPerShell) == 0x000008, "Member 'FM1InstantHitShellInfo::HitResultsPerShell' has a wrong offset!");
static_assert(offsetof(FM1InstantHitShellInfo, bShellsAllHitEnemies) == 0x000018, "Member 'FM1InstantHitShellInfo::bShellsAllHitEnemies' has a wrong offset!");
static_assert(offsetof(FM1InstantHitShellInfo, bShellsAllHitOneEnemy) == 0x000019, "Member 'FM1InstantHitShellInfo::bShellsAllHitOneEnemy' has a wrong offset!");

// ScriptStruct M1.M1WeaponFXSpawnParams
// 0x0034 (0x0034 - 0x0000)
struct FM1WeaponFXSpawnParams final
{
public:
	struct FVector                                LocationOffset;                                    // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0018(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Attached : 1;                                      // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAttachToCharacter;                                // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x002C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FM1WeaponFXSpawnParams) == 0x000004, "Wrong alignment on FM1WeaponFXSpawnParams");
static_assert(sizeof(FM1WeaponFXSpawnParams) == 0x000034, "Wrong size on FM1WeaponFXSpawnParams");
static_assert(offsetof(FM1WeaponFXSpawnParams, LocationOffset) == 0x000000, "Member 'FM1WeaponFXSpawnParams::LocationOffset' has a wrong offset!");
static_assert(offsetof(FM1WeaponFXSpawnParams, RotationOffset) == 0x00000C, "Member 'FM1WeaponFXSpawnParams::RotationOffset' has a wrong offset!");
static_assert(offsetof(FM1WeaponFXSpawnParams, Scale) == 0x000018, "Member 'FM1WeaponFXSpawnParams::Scale' has a wrong offset!");
static_assert(offsetof(FM1WeaponFXSpawnParams, bAttachToCharacter) == 0x000028, "Member 'FM1WeaponFXSpawnParams::bAttachToCharacter' has a wrong offset!");
static_assert(offsetof(FM1WeaponFXSpawnParams, SocketName) == 0x00002C, "Member 'FM1WeaponFXSpawnParams::SocketName' has a wrong offset!");

// ScriptStruct M1.M1WidgetAnimSectionTemplate
// 0x0010 (0x0030 - 0x0020)
struct FM1WidgetAnimSectionTemplate final : public FMovieSceneEvalTemplate
{
public:
	class FName                                   AnimName;                                          // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFrameNumber                           SectionStartFrame;                                 // 0x0028(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFrameNumber                           SectionEndFrame;                                   // 0x002C(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FM1WidgetAnimSectionTemplate) == 0x000008, "Wrong alignment on FM1WidgetAnimSectionTemplate");
static_assert(sizeof(FM1WidgetAnimSectionTemplate) == 0x000030, "Wrong size on FM1WidgetAnimSectionTemplate");
static_assert(offsetof(FM1WidgetAnimSectionTemplate, AnimName) == 0x000020, "Member 'FM1WidgetAnimSectionTemplate::AnimName' has a wrong offset!");
static_assert(offsetof(FM1WidgetAnimSectionTemplate, SectionStartFrame) == 0x000028, "Member 'FM1WidgetAnimSectionTemplate::SectionStartFrame' has a wrong offset!");
static_assert(offsetof(FM1WidgetAnimSectionTemplate, SectionEndFrame) == 0x00002C, "Member 'FM1WidgetAnimSectionTemplate::SectionEndFrame' has a wrong offset!");

// ScriptStruct M1.M1CustomizeWireCasterSkinInfo
// 0x0008 (0x0008 - 0x0000)
struct FM1CustomizeWireCasterSkinInfo final
{
public:
	struct FM1TemplateId                          SkinTid;                                           // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitialSetup;                                     // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FM1CustomizeWireCasterSkinInfo) == 0x000004, "Wrong alignment on FM1CustomizeWireCasterSkinInfo");
static_assert(sizeof(FM1CustomizeWireCasterSkinInfo) == 0x000008, "Wrong size on FM1CustomizeWireCasterSkinInfo");
static_assert(offsetof(FM1CustomizeWireCasterSkinInfo, SkinTid) == 0x000000, "Member 'FM1CustomizeWireCasterSkinInfo::SkinTid' has a wrong offset!");
static_assert(offsetof(FM1CustomizeWireCasterSkinInfo, bInitialSetup) == 0x000004, "Member 'FM1CustomizeWireCasterSkinInfo::bInitialSetup' has a wrong offset!");

}

